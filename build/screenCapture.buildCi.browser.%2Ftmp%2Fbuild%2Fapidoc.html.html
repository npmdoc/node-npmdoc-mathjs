<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="http://mathjs.org">mathjs (v3.12.0)</a>
</h1>
<h4>Math.js is an extensive math library for JavaScript and Node.js. It features a flexible expression parser with support for symbolic computation, comes with a large set of built-in functions and constants, and offers an integrated solution to work with dif</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs">module mathjs</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">mathjs.</span>false</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">mathjs.</span>true</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.abs">
            function <span class="apidocSignatureSpan">mathjs.</span>abs
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.acos">
            function <span class="apidocSignatureSpan">mathjs.</span>acos
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.acosh">
            function <span class="apidocSignatureSpan">mathjs.</span>acosh
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.acot">
            function <span class="apidocSignatureSpan">mathjs.</span>acot
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.acoth">
            function <span class="apidocSignatureSpan">mathjs.</span>acoth
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.acsc">
            function <span class="apidocSignatureSpan">mathjs.</span>acsc
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.acsch">
            function <span class="apidocSignatureSpan">mathjs.</span>acsch
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.add">
            function <span class="apidocSignatureSpan">mathjs.</span>add
            <span class="apidocSignatureSpan">(arg0, arg1, arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.and">
            function <span class="apidocSignatureSpan">mathjs.</span>and
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.arg">
            function <span class="apidocSignatureSpan">mathjs.</span>arg
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.asec">
            function <span class="apidocSignatureSpan">mathjs.</span>asec
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.asech">
            function <span class="apidocSignatureSpan">mathjs.</span>asech
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.asin">
            function <span class="apidocSignatureSpan">mathjs.</span>asin
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.asinh">
            function <span class="apidocSignatureSpan">mathjs.</span>asinh
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.atan">
            function <span class="apidocSignatureSpan">mathjs.</span>atan
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.atan2">
            function <span class="apidocSignatureSpan">mathjs.</span>atan2
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.atanh">
            function <span class="apidocSignatureSpan">mathjs.</span>atanh
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.bellNumbers">
            function <span class="apidocSignatureSpan">mathjs.</span>bellNumbers
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.bignumber">
            function <span class="apidocSignatureSpan">mathjs.</span>bignumber
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.bitAnd">
            function <span class="apidocSignatureSpan">mathjs.</span>bitAnd
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.bitNot">
            function <span class="apidocSignatureSpan">mathjs.</span>bitNot
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.bitOr">
            function <span class="apidocSignatureSpan">mathjs.</span>bitOr
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.bitXor">
            function <span class="apidocSignatureSpan">mathjs.</span>bitXor
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.boolean">
            function <span class="apidocSignatureSpan">mathjs.</span>boolean
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.catalan">
            function <span class="apidocSignatureSpan">mathjs.</span>catalan
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.cbrt">
            function <span class="apidocSignatureSpan">mathjs.</span>cbrt
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.ceil">
            function <span class="apidocSignatureSpan">mathjs.</span>ceil
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.chain">
            function <span class="apidocSignatureSpan">mathjs.</span>chain
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.clone">
            function <span class="apidocSignatureSpan">mathjs.</span>clone
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.combinations">
            function <span class="apidocSignatureSpan">mathjs.</span>combinations
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.compare">
            function <span class="apidocSignatureSpan">mathjs.</span>compare
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.compile">
            function <span class="apidocSignatureSpan">mathjs.</span>compile
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.complex">
            function <span class="apidocSignatureSpan">mathjs.</span>complex
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.composition">
            function <span class="apidocSignatureSpan">mathjs.</span>composition
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.concat">
            function <span class="apidocSignatureSpan">mathjs.</span>concat
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.config">
            function <span class="apidocSignatureSpan">mathjs.</span>config
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.conj">
            function <span class="apidocSignatureSpan">mathjs.</span>conj
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.cos">
            function <span class="apidocSignatureSpan">mathjs.</span>cos
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.cosh">
            function <span class="apidocSignatureSpan">mathjs.</span>cosh
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.cot">
            function <span class="apidocSignatureSpan">mathjs.</span>cot
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.coth">
            function <span class="apidocSignatureSpan">mathjs.</span>coth
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.create">
            function <span class="apidocSignatureSpan">mathjs.</span>create
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.createUnit">
            function <span class="apidocSignatureSpan">mathjs.</span>createUnit
            <span class="apidocSignatureSpan">(arg0, arg1, arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.cross">
            function <span class="apidocSignatureSpan">mathjs.</span>cross
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.csc">
            function <span class="apidocSignatureSpan">mathjs.</span>csc
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.csch">
            function <span class="apidocSignatureSpan">mathjs.</span>csch
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.cube">
            function <span class="apidocSignatureSpan">mathjs.</span>cube
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.deepEqual">
            function <span class="apidocSignatureSpan">mathjs.</span>deepEqual
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.derivative">
            function <span class="apidocSignatureSpan">mathjs.</span>derivative
            <span class="apidocSignatureSpan">(arg0, arg1, arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.det">
            function <span class="apidocSignatureSpan">mathjs.</span>det
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.diag">
            function <span class="apidocSignatureSpan">mathjs.</span>diag
            <span class="apidocSignatureSpan">(arg0, arg1, arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.distance">
            function <span class="apidocSignatureSpan">mathjs.</span>distance
            <span class="apidocSignatureSpan">(arg0, arg1, arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.divide">
            function <span class="apidocSignatureSpan">mathjs.</span>divide
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.dot">
            function <span class="apidocSignatureSpan">mathjs.</span>dot
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.dotDivide">
            function <span class="apidocSignatureSpan">mathjs.</span>dotDivide
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.dotMultiply">
            function <span class="apidocSignatureSpan">mathjs.</span>dotMultiply
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.dotPow">
            function <span class="apidocSignatureSpan">mathjs.</span>dotPow
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.emit">
            function <span class="apidocSignatureSpan">mathjs.</span>emit
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.equal">
            function <span class="apidocSignatureSpan">mathjs.</span>equal
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.erf">
            function <span class="apidocSignatureSpan">mathjs.</span>erf
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.error.ArgumentsError">
            function <span class="apidocSignatureSpan">mathjs.</span>error.ArgumentsError
            <span class="apidocSignatureSpan">(fn, count, min, max)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.error.ArgumentsError.prototype.constructor">
            function <span class="apidocSignatureSpan">mathjs.</span>error.ArgumentsError.prototype.constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.error.DimensionError">
            function <span class="apidocSignatureSpan">mathjs.</span>error.DimensionError
            <span class="apidocSignatureSpan">(actual, expected, relation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.error.IndexError">
            function <span class="apidocSignatureSpan">mathjs.</span>error.IndexError
            <span class="apidocSignatureSpan">(index, min, max)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.eval">
            function <span class="apidocSignatureSpan">mathjs.</span>eval
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.exp">
            function <span class="apidocSignatureSpan">mathjs.</span>exp
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.Parser">
            function <span class="apidocSignatureSpan">mathjs.</span>expression.Parser
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.parse">
            function <span class="apidocSignatureSpan">mathjs.</span>expression.parse
            <span class="apidocSignatureSpan">(expr, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.eye">
            function <span class="apidocSignatureSpan">mathjs.</span>eye
            <span class="apidocSignatureSpan">(arg0, arg1, arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.factorial">
            function <span class="apidocSignatureSpan">mathjs.</span>factorial
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.filter">
            function <span class="apidocSignatureSpan">mathjs.</span>filter
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.fix">
            function <span class="apidocSignatureSpan">mathjs.</span>fix
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.flatten">
            function <span class="apidocSignatureSpan">mathjs.</span>flatten
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.floor">
            function <span class="apidocSignatureSpan">mathjs.</span>floor
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.forEach">
            function <span class="apidocSignatureSpan">mathjs.</span>forEach
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.format">
            function <span class="apidocSignatureSpan">mathjs.</span>format
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.fraction">
            function <span class="apidocSignatureSpan">mathjs.</span>fraction
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.gamma">
            function <span class="apidocSignatureSpan">mathjs.</span>gamma
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.gcd">
            function <span class="apidocSignatureSpan">mathjs.</span>gcd
            <span class="apidocSignatureSpan">(arg0, arg1, arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.help">
            function <span class="apidocSignatureSpan">mathjs.</span>help
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.hypot">
            function <span class="apidocSignatureSpan">mathjs.</span>hypot
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.im">
            function <span class="apidocSignatureSpan">mathjs.</span>im
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.import">
            function <span class="apidocSignatureSpan">mathjs.</span>import
            <span class="apidocSignatureSpan">(object, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.index">
            function <span class="apidocSignatureSpan">mathjs.</span>index
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.intersect">
            function <span class="apidocSignatureSpan">mathjs.</span>intersect
            <span class="apidocSignatureSpan">(arg0, arg1, arg2, arg3)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.inv">
            function <span class="apidocSignatureSpan">mathjs.</span>inv
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.isInteger">
            function <span class="apidocSignatureSpan">mathjs.</span>isInteger
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.isNaN">
            function <span class="apidocSignatureSpan">mathjs.</span>isNaN
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.isNegative">
            function <span class="apidocSignatureSpan">mathjs.</span>isNegative
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.isNumeric">
            function <span class="apidocSignatureSpan">mathjs.</span>isNumeric
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.isPositive">
            function <span class="apidocSignatureSpan">mathjs.</span>isPositive
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.isPrime">
            function <span class="apidocSignatureSpan">mathjs.</span>isPrime
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.isZero">
            function <span class="apidocSignatureSpan">mathjs.</span>isZero
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.kldivergence">
            function <span class="apidocSignatureSpan">mathjs.</span>kldivergence
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.kron">
            function <span class="apidocSignatureSpan">mathjs.</span>kron
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.larger">
            function <span class="apidocSignatureSpan">mathjs.</span>larger
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.largerEq">
            function <span class="apidocSignatureSpan">mathjs.</span>largerEq
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.lcm">
            function <span class="apidocSignatureSpan">mathjs.</span>lcm
            <span class="apidocSignatureSpan">(arg0, arg1, arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.leftShift">
            function <span class="apidocSignatureSpan">mathjs.</span>leftShift
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.log">
            function <span class="apidocSignatureSpan">mathjs.</span>log
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.log10">
            function <span class="apidocSignatureSpan">mathjs.</span>log10
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.lsolve">
            function <span class="apidocSignatureSpan">mathjs.</span>lsolve
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.lup">
            function <span class="apidocSignatureSpan">mathjs.</span>lup
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.lusolve">
            function <span class="apidocSignatureSpan">mathjs.</span>lusolve
            <span class="apidocSignatureSpan">(arg0, arg1, arg2, arg3)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.mad">
            function <span class="apidocSignatureSpan">mathjs.</span>mad
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.map">
            function <span class="apidocSignatureSpan">mathjs.</span>map
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.matrix">
            function <span class="apidocSignatureSpan">mathjs.</span>matrix
            <span class="apidocSignatureSpan">(arg0, arg1, arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.max">
            function <span class="apidocSignatureSpan">mathjs.</span>max
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.mean">
            function <span class="apidocSignatureSpan">mathjs.</span>mean
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.median">
            function <span class="apidocSignatureSpan">mathjs.</span>median
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.min">
            function <span class="apidocSignatureSpan">mathjs.</span>min
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.mod">
            function <span class="apidocSignatureSpan">mathjs.</span>mod
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.mode">
            function <span class="apidocSignatureSpan">mathjs.</span>mode
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.multinomial">
            function <span class="apidocSignatureSpan">mathjs.</span>multinomial
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.multiply">
            function <span class="apidocSignatureSpan">mathjs.</span>multiply
            <span class="apidocSignatureSpan">(arg0, arg1, arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.norm">
            function <span class="apidocSignatureSpan">mathjs.</span>norm
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.not">
            function <span class="apidocSignatureSpan">mathjs.</span>not
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.nthRoot">
            function <span class="apidocSignatureSpan">mathjs.</span>nthRoot
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.number">
            function <span class="apidocSignatureSpan">mathjs.</span>number
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.off">
            function <span class="apidocSignatureSpan">mathjs.</span>off
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.on">
            function <span class="apidocSignatureSpan">mathjs.</span>on
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.once">
            function <span class="apidocSignatureSpan">mathjs.</span>once
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.ones">
            function <span class="apidocSignatureSpan">mathjs.</span>ones
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.or">
            function <span class="apidocSignatureSpan">mathjs.</span>or
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.parse">
            function <span class="apidocSignatureSpan">mathjs.</span>parse
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.parser">
            function <span class="apidocSignatureSpan">mathjs.</span>parser
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.partitionSelect">
            function <span class="apidocSignatureSpan">mathjs.</span>partitionSelect
            <span class="apidocSignatureSpan">(arg0, arg1, arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.permutations">
            function <span class="apidocSignatureSpan">mathjs.</span>permutations
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.pow">
            function <span class="apidocSignatureSpan">mathjs.</span>pow
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.print">
            function <span class="apidocSignatureSpan">mathjs.</span>print
            <span class="apidocSignatureSpan">(arg0, arg1, arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.prod">
            function <span class="apidocSignatureSpan">mathjs.</span>prod
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.qr">
            function <span class="apidocSignatureSpan">mathjs.</span>qr
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.quantileSeq">
            function <span class="apidocSignatureSpan">mathjs.</span>quantileSeq
            <span class="apidocSignatureSpan">(data, probOrN, sorted)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.range">
            function <span class="apidocSignatureSpan">mathjs.</span>range
            <span class="apidocSignatureSpan">(arg0, arg1, arg2, arg3)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.re">
            function <span class="apidocSignatureSpan">mathjs.</span>re
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.reshape">
            function <span class="apidocSignatureSpan">mathjs.</span>reshape
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.resize">
            function <span class="apidocSignatureSpan">mathjs.</span>resize
            <span class="apidocSignatureSpan">(x, size, defaultValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.rightArithShift">
            function <span class="apidocSignatureSpan">mathjs.</span>rightArithShift
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.rightLogShift">
            function <span class="apidocSignatureSpan">mathjs.</span>rightLogShift
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.round">
            function <span class="apidocSignatureSpan">mathjs.</span>round
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.sec">
            function <span class="apidocSignatureSpan">mathjs.</span>sec
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.sech">
            function <span class="apidocSignatureSpan">mathjs.</span>sech
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.sign">
            function <span class="apidocSignatureSpan">mathjs.</span>sign
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.simplify">
            function <span class="apidocSignatureSpan">mathjs.</span>simplify
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.sin">
            function <span class="apidocSignatureSpan">mathjs.</span>sin
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.sinh">
            function <span class="apidocSignatureSpan">mathjs.</span>sinh
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.size">
            function <span class="apidocSignatureSpan">mathjs.</span>size
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.slu">
            function <span class="apidocSignatureSpan">mathjs.</span>slu
            <span class="apidocSignatureSpan">(arg0, arg1, arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.smaller">
            function <span class="apidocSignatureSpan">mathjs.</span>smaller
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.smallerEq">
            function <span class="apidocSignatureSpan">mathjs.</span>smallerEq
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.sort">
            function <span class="apidocSignatureSpan">mathjs.</span>sort
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.sparse">
            function <span class="apidocSignatureSpan">mathjs.</span>sparse
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.splitUnit">
            function <span class="apidocSignatureSpan">mathjs.</span>splitUnit
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.sqrt">
            function <span class="apidocSignatureSpan">mathjs.</span>sqrt
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.square">
            function <span class="apidocSignatureSpan">mathjs.</span>square
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.squeeze">
            function <span class="apidocSignatureSpan">mathjs.</span>squeeze
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.std">
            function <span class="apidocSignatureSpan">mathjs.</span>std
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.stirlingS2">
            function <span class="apidocSignatureSpan">mathjs.</span>stirlingS2
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.string">
            function <span class="apidocSignatureSpan">mathjs.</span>string
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.subset">
            function <span class="apidocSignatureSpan">mathjs.</span>subset
            <span class="apidocSignatureSpan">(arg0, arg1, arg2, arg3)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.subtract">
            function <span class="apidocSignatureSpan">mathjs.</span>subtract
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.sum">
            function <span class="apidocSignatureSpan">mathjs.</span>sum
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.tan">
            function <span class="apidocSignatureSpan">mathjs.</span>tan
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.tanh">
            function <span class="apidocSignatureSpan">mathjs.</span>tanh
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.to">
            function <span class="apidocSignatureSpan">mathjs.</span>to
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.trace">
            function <span class="apidocSignatureSpan">mathjs.</span>trace
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.transpose">
            function <span class="apidocSignatureSpan">mathjs.</span>transpose
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber">
            function <span class="apidocSignatureSpan">mathjs.</span>type.BigNumber
            <span class="apidocSignatureSpan">(v)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain">
            function <span class="apidocSignatureSpan">mathjs.</span>type.Chain
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Complex">
            function <span class="apidocSignatureSpan">mathjs.</span>type.Complex
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.DenseMatrix">
            function <span class="apidocSignatureSpan">mathjs.</span>type.DenseMatrix
            <span class="apidocSignatureSpan">(data, datatype)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.FibonacciHeap">
            function <span class="apidocSignatureSpan">mathjs.</span>type.FibonacciHeap
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Fraction">
            function <span class="apidocSignatureSpan">mathjs.</span>type.Fraction
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Help">
            function <span class="apidocSignatureSpan">mathjs.</span>type.Help
            <span class="apidocSignatureSpan">(doc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.ImmutableDenseMatrix">
            function <span class="apidocSignatureSpan">mathjs.</span>type.ImmutableDenseMatrix
            <span class="apidocSignatureSpan">(data, datatype)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Index">
            function <span class="apidocSignatureSpan">mathjs.</span>type.Index
            <span class="apidocSignatureSpan">(ranges)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Matrix">
            function <span class="apidocSignatureSpan">mathjs.</span>type.Matrix
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Range">
            function <span class="apidocSignatureSpan">mathjs.</span>type.Range
            <span class="apidocSignatureSpan">(start, end, step)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.ResultSet">
            function <span class="apidocSignatureSpan">mathjs.</span>type.ResultSet
            <span class="apidocSignatureSpan">(entries)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Spa">
            function <span class="apidocSignatureSpan">mathjs.</span>type.Spa
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.SparseMatrix">
            function <span class="apidocSignatureSpan">mathjs.</span>type.SparseMatrix
            <span class="apidocSignatureSpan">(data, datatype)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Unit">
            function <span class="apidocSignatureSpan">mathjs.</span>type.Unit
            <span class="apidocSignatureSpan">(value, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.typed">
            function <span class="apidocSignatureSpan">mathjs.</span>typed
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.typeof">
            function <span class="apidocSignatureSpan">mathjs.</span>typeof
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.unaryMinus">
            function <span class="apidocSignatureSpan">mathjs.</span>unaryMinus
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.unaryPlus">
            function <span class="apidocSignatureSpan">mathjs.</span>unaryPlus
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.unequal">
            function <span class="apidocSignatureSpan">mathjs.</span>unequal
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.unit">
            function <span class="apidocSignatureSpan">mathjs.</span>unit
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.usolve">
            function <span class="apidocSignatureSpan">mathjs.</span>usolve
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.var">
            function <span class="apidocSignatureSpan">mathjs.</span>var
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.xgcd">
            function <span class="apidocSignatureSpan">mathjs.</span>xgcd
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.xor">
            function <span class="apidocSignatureSpan">mathjs.</span>xor
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.zeros">
            function <span class="apidocSignatureSpan">mathjs.</span>zeros
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mathjs.</span>E</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mathjs.</span>Infinity</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mathjs.</span>LN10</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mathjs.</span>LN2</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mathjs.</span>LOG10E</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mathjs.</span>LOG2E</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mathjs.</span>NaN</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mathjs.</span>PI</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mathjs.</span>SQRT1_2</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mathjs.</span>SQRT2</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mathjs.</span>e</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mathjs.</span>efimovFactor</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mathjs.</span>fineStructure</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mathjs.</span>phi</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mathjs.</span>pi</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mathjs.</span>sackurTetrode</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mathjs.</span>tau</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mathjs.</span>weakMixingAngle</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>AccessorNode</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>ArrayNode</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>AssignmentNode</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>BigNumber</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>BlockNode</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>Chain</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>Complex</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>ConditionalNode</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>ConstantNode</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>DenseMatrix</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>FibonacciHeap</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>Fraction</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>FunctionAssignmentNode</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>FunctionNode</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>Help</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>ImmutableDenseMatrix</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>IndexNode</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>Matrix</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>MatrixIndex</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>Node</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>ObjectNode</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>OperatorNode</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>ParenthesisNode</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>Parser</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>Range</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>RangeNode</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>ResultSet</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>Spa</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>SparseMatrix</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>SymbolNode</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>Unit</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>UpdateNode</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>addScalar</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>array</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>atomicMass</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>avogadro</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>bohrMagneton</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>bohrRadius</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>boltzmann</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>classicalElectronRadius</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>concat_transform</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>conductanceQuantum</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>constants</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>core</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>coulomb</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>derivative.signatures</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>deuteronMass</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>distribution</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>divideScalar</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>electricConstant</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>electronMass</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>elementaryCharge</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>emitter</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>equalScalar</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>error</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>error.ArgumentsError.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>error.DimensionError.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>error.IndexError.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>error_transform</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>expression</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>expression.Parser.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>expression.mathWithTransform</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>expression.mathWithTransform.AccessorNode.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>expression.mathWithTransform.ArrayNode.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>expression.mathWithTransform.AssignmentNode.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>expression.mathWithTransform.BlockNode.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>expression.mathWithTransform.ConditionalNode.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>expression.mathWithTransform.ConstantNode.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>expression.mathWithTransform.FunctionAssignmentNode.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>expression.mathWithTransform.FunctionNode.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>expression.mathWithTransform.IndexNode.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>expression.mathWithTransform.Node.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>expression.mathWithTransform.ObjectNode.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>expression.mathWithTransform.OperatorNode.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>expression.mathWithTransform.ParenthesisNode.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>expression.mathWithTransform.RangeNode.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>expression.mathWithTransform.SymbolNode.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>expression.node</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>expression.transform</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>faraday</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>fermiCoupling</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>filter_transform</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>firstRadiation</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>forEach_transform</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>formatter</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>function</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>gasConstant</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>gravitationConstant</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>gravity</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>hartreeEnergy</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>i</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>index_transform</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>inverseConductanceQuantum</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>json</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>klitzing</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>latex</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>loschmidt</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>magneticConstant</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>magneticFluxQuantum</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>map_transform</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>max_transform</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>mean_transform</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>molarMass</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>molarMassC12</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>molarPlanckConstant</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>molarVolume</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>multiplyScalar</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>neutronMass</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>nuclearMagneton</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>null</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>object</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>operators</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>physicalConstants</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>pickRandom</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>planckCharge</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>planckConstant</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>planckLength</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>planckMass</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>planckTemperature</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>planckTime</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>protonMass</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>quantumOfCirculation</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>random</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>randomInt</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>range_transform</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>reducedPlanckConstant</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>reviver</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>rydberg</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>secondRadiation</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>speedOfLight</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>stefanBoltzmann</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>subset_transform</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>thomsonCrossSection</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>type</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>type.BigNumber.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>type.Chain.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>type.Complex.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>type.DenseMatrix.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>type.FibonacciHeap.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>type.Fraction.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>type.Help.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>type.ImmutableDenseMatrix.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>type.Index.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>type.Matrix.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>type.Range.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>type.ResultSet.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>type.Spa.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>type.SparseMatrix.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>type.Unit.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>typed.signatures</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>types</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>uninitialized</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>vacuumImpedance</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.</span>wienDisplacement</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.AccessorNode">module mathjs.AccessorNode</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.AccessorNode.factory">
            function <span class="apidocSignatureSpan">mathjs.AccessorNode.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.AccessorNode.</span>name</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.AccessorNode.</span>path</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.ArrayNode">module mathjs.ArrayNode</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.ArrayNode.factory">
            function <span class="apidocSignatureSpan">mathjs.ArrayNode.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.ArrayNode.</span>name</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.ArrayNode.</span>path</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.AssignmentNode">module mathjs.AssignmentNode</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.AssignmentNode.factory">
            function <span class="apidocSignatureSpan">mathjs.AssignmentNode.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.AssignmentNode.</span>name</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.AssignmentNode.</span>path</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.BigNumber">module mathjs.BigNumber</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">mathjs.BigNumber.</span>math</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.BigNumber.factory">
            function <span class="apidocSignatureSpan">mathjs.BigNumber.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed, math)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.BigNumber.</span>name</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.BigNumber.</span>path</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.BlockNode">module mathjs.BlockNode</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.BlockNode.factory">
            function <span class="apidocSignatureSpan">mathjs.BlockNode.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.BlockNode.</span>name</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.BlockNode.</span>path</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.Chain">module mathjs.Chain</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">mathjs.Chain.</span>lazy</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">mathjs.Chain.</span>math</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.Chain.factory">
            function <span class="apidocSignatureSpan">mathjs.Chain.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed, math)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.Chain.</span>name</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.Chain.</span>path</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.Complex">module mathjs.Complex</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">mathjs.Complex.</span>math</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.Complex.factory">
            function <span class="apidocSignatureSpan">mathjs.Complex.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed, math)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.Complex.</span>name</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.Complex.</span>path</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.ConditionalNode">module mathjs.ConditionalNode</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.ConditionalNode.factory">
            function <span class="apidocSignatureSpan">mathjs.ConditionalNode.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.ConditionalNode.</span>name</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.ConditionalNode.</span>path</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.ConstantNode">module mathjs.ConstantNode</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.ConstantNode.factory">
            function <span class="apidocSignatureSpan">mathjs.ConstantNode.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.ConstantNode.</span>name</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.ConstantNode.</span>path</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.DenseMatrix">module mathjs.DenseMatrix</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">mathjs.DenseMatrix.</span>lazy</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.DenseMatrix.factory">
            function <span class="apidocSignatureSpan">mathjs.DenseMatrix.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.DenseMatrix.</span>name</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.DenseMatrix.</span>path</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.FibonacciHeap">module mathjs.FibonacciHeap</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.FibonacciHeap.factory">
            function <span class="apidocSignatureSpan">mathjs.FibonacciHeap.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.FibonacciHeap.</span>name</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.FibonacciHeap.</span>path</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.Fraction">module mathjs.Fraction</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.Fraction.factory">
            function <span class="apidocSignatureSpan">mathjs.Fraction.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.Fraction.</span>name</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.Fraction.</span>path</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.FunctionAssignmentNode">module mathjs.FunctionAssignmentNode</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.FunctionAssignmentNode.factory">
            function <span class="apidocSignatureSpan">mathjs.FunctionAssignmentNode.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.FunctionAssignmentNode.</span>name</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.FunctionAssignmentNode.</span>path</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.FunctionNode">module mathjs.FunctionNode</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">mathjs.FunctionNode.</span>math</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.FunctionNode.factory">
            function <span class="apidocSignatureSpan">mathjs.FunctionNode.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed, math)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.FunctionNode.</span>name</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.FunctionNode.</span>path</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.Help">module mathjs.Help</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.Help.factory">
            function <span class="apidocSignatureSpan">mathjs.Help.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.Help.</span>name</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.Help.</span>path</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.ImmutableDenseMatrix">module mathjs.ImmutableDenseMatrix</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.ImmutableDenseMatrix.factory">
            function <span class="apidocSignatureSpan">mathjs.ImmutableDenseMatrix.</span>factory
            <span class="apidocSignatureSpan">(type, config, load)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.ImmutableDenseMatrix.</span>name</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.ImmutableDenseMatrix.</span>path</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.IndexNode">module mathjs.IndexNode</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.IndexNode.factory">
            function <span class="apidocSignatureSpan">mathjs.IndexNode.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.IndexNode.</span>name</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.IndexNode.</span>path</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.Matrix">module mathjs.Matrix</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.Matrix.factory">
            function <span class="apidocSignatureSpan">mathjs.Matrix.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.Matrix.</span>name</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.Matrix.</span>path</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.MatrixIndex">module mathjs.MatrixIndex</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.MatrixIndex.factory">
            function <span class="apidocSignatureSpan">mathjs.MatrixIndex.</span>factory
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.MatrixIndex.</span>name</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.MatrixIndex.</span>path</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.Node">module mathjs.Node</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">mathjs.Node.</span>math</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.Node.factory">
            function <span class="apidocSignatureSpan">mathjs.Node.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed, math)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.Node.</span>name</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.Node.</span>path</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.ObjectNode">module mathjs.ObjectNode</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.ObjectNode.factory">
            function <span class="apidocSignatureSpan">mathjs.ObjectNode.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.ObjectNode.</span>name</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.ObjectNode.</span>path</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.OperatorNode">module mathjs.OperatorNode</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">mathjs.OperatorNode.</span>math</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.OperatorNode.factory">
            function <span class="apidocSignatureSpan">mathjs.OperatorNode.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed, math)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.OperatorNode.</span>name</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.OperatorNode.</span>path</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.ParenthesisNode">module mathjs.ParenthesisNode</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.ParenthesisNode.factory">
            function <span class="apidocSignatureSpan">mathjs.ParenthesisNode.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.ParenthesisNode.</span>name</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.ParenthesisNode.</span>path</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.Parser">module mathjs.Parser</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">mathjs.Parser.</span>math</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.Parser.factory">
            function <span class="apidocSignatureSpan">mathjs.Parser.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed, math)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.Parser.</span>name</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.Parser.</span>path</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.Range">module mathjs.Range</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.Range.factory">
            function <span class="apidocSignatureSpan">mathjs.Range.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.Range.</span>name</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.Range.</span>path</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.RangeNode">module mathjs.RangeNode</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.RangeNode.factory">
            function <span class="apidocSignatureSpan">mathjs.RangeNode.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.RangeNode.</span>name</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.RangeNode.</span>path</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.ResultSet">module mathjs.ResultSet</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.ResultSet.factory">
            function <span class="apidocSignatureSpan">mathjs.ResultSet.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.ResultSet.</span>name</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.ResultSet.</span>path</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.Spa">module mathjs.Spa</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.Spa.factory">
            function <span class="apidocSignatureSpan">mathjs.Spa.</span>factory
            <span class="apidocSignatureSpan">(type, config, load)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.Spa.</span>name</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.Spa.</span>path</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.SparseMatrix">module mathjs.SparseMatrix</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">mathjs.SparseMatrix.</span>lazy</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.SparseMatrix.factory">
            function <span class="apidocSignatureSpan">mathjs.SparseMatrix.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.SparseMatrix.</span>name</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.SparseMatrix.</span>path</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.SymbolNode">module mathjs.SymbolNode</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">mathjs.SymbolNode.</span>math</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.SymbolNode.factory">
            function <span class="apidocSignatureSpan">mathjs.SymbolNode.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed, math)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.SymbolNode.</span>name</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.SymbolNode.</span>path</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.Unit">module mathjs.Unit</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">mathjs.Unit.</span>math</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.Unit.factory">
            function <span class="apidocSignatureSpan">mathjs.Unit.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed, math)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.Unit.</span>name</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.Unit.</span>path</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.UpdateNode">module mathjs.UpdateNode</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.UpdateNode.factory">
            function <span class="apidocSignatureSpan">mathjs.UpdateNode.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.UpdateNode.</span>name</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.UpdateNode.</span>path</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.abs">module mathjs.abs</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.abs.factory">
            function <span class="apidocSignatureSpan">mathjs.abs.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.abs.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.acos">module mathjs.acos</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.acos.factory">
            function <span class="apidocSignatureSpan">mathjs.acos.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.acos.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.acosh">module mathjs.acosh</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.acosh.factory">
            function <span class="apidocSignatureSpan">mathjs.acosh.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.acosh.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.acot">module mathjs.acot</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.acot.factory">
            function <span class="apidocSignatureSpan">mathjs.acot.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.acot.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.acoth">module mathjs.acoth</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.acoth.factory">
            function <span class="apidocSignatureSpan">mathjs.acoth.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.acoth.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.acsc">module mathjs.acsc</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.acsc.factory">
            function <span class="apidocSignatureSpan">mathjs.acsc.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.acsc.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.acsch">module mathjs.acsch</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.acsch.factory">
            function <span class="apidocSignatureSpan">mathjs.acsch.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.acsch.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.add">module mathjs.add</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.add.factory">
            function <span class="apidocSignatureSpan">mathjs.add.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.add.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.addScalar">module mathjs.addScalar</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.addScalar.factory">
            function <span class="apidocSignatureSpan">mathjs.addScalar.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.and">module mathjs.and</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.and.factory">
            function <span class="apidocSignatureSpan">mathjs.and.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.and.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.arg">module mathjs.arg</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.arg.factory">
            function <span class="apidocSignatureSpan">mathjs.arg.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.arg.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.array">module mathjs.array</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.array.flatten">
            function <span class="apidocSignatureSpan">mathjs.array.</span>flatten
            <span class="apidocSignatureSpan">(array)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.array.isArray">
            function <span class="apidocSignatureSpan">mathjs.array.</span>isArray
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.array.reshape">
            function <span class="apidocSignatureSpan">mathjs.array.</span>reshape
            <span class="apidocSignatureSpan">(array, sizes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.array.resize">
            function <span class="apidocSignatureSpan">mathjs.array.</span>resize
            <span class="apidocSignatureSpan">(array, size, defaultValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.array.size">
            function <span class="apidocSignatureSpan">mathjs.array.</span>size
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.array.squeeze">
            function <span class="apidocSignatureSpan">mathjs.array.</span>squeeze
            <span class="apidocSignatureSpan">(array, size)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.array.unsqueeze">
            function <span class="apidocSignatureSpan">mathjs.array.</span>unsqueeze
            <span class="apidocSignatureSpan">(array, dims, outer, size)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.array.validate">
            function <span class="apidocSignatureSpan">mathjs.array.</span>validate
            <span class="apidocSignatureSpan">(array, size)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.array.validateIndex">
            function <span class="apidocSignatureSpan">mathjs.array.</span>validateIndex
            <span class="apidocSignatureSpan">(index, length)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.array.</span>UNINITIALIZED</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.asec">module mathjs.asec</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.asec.factory">
            function <span class="apidocSignatureSpan">mathjs.asec.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.asec.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.asech">module mathjs.asech</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.asech.factory">
            function <span class="apidocSignatureSpan">mathjs.asech.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.asech.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.asin">module mathjs.asin</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.asin.factory">
            function <span class="apidocSignatureSpan">mathjs.asin.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.asin.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.asinh">module mathjs.asinh</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.asinh.factory">
            function <span class="apidocSignatureSpan">mathjs.asinh.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.asinh.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.atan">module mathjs.atan</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.atan.factory">
            function <span class="apidocSignatureSpan">mathjs.atan.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.atan.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.atan2">module mathjs.atan2</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.atan2.factory">
            function <span class="apidocSignatureSpan">mathjs.atan2.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.atan2.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.atanh">module mathjs.atanh</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.atanh.factory">
            function <span class="apidocSignatureSpan">mathjs.atanh.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.atanh.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.bellNumbers">module mathjs.bellNumbers</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.bellNumbers.factory">
            function <span class="apidocSignatureSpan">mathjs.bellNumbers.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.bellNumbers.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.bitAnd">module mathjs.bitAnd</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.bitAnd.factory">
            function <span class="apidocSignatureSpan">mathjs.bitAnd.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.bitAnd.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.bitNot">module mathjs.bitNot</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.bitNot.factory">
            function <span class="apidocSignatureSpan">mathjs.bitNot.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.bitNot.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.bitOr">module mathjs.bitOr</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.bitOr.factory">
            function <span class="apidocSignatureSpan">mathjs.bitOr.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.bitOr.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.bitXor">module mathjs.bitXor</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.bitXor.factory">
            function <span class="apidocSignatureSpan">mathjs.bitXor.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.bitXor.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.boolean">module mathjs.boolean</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.boolean.factory">
            function <span class="apidocSignatureSpan">mathjs.boolean.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.boolean.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.catalan">module mathjs.catalan</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.catalan.factory">
            function <span class="apidocSignatureSpan">mathjs.catalan.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.catalan.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.cbrt">module mathjs.cbrt</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.cbrt.factory">
            function <span class="apidocSignatureSpan">mathjs.cbrt.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.cbrt.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.ceil">module mathjs.ceil</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.ceil.factory">
            function <span class="apidocSignatureSpan">mathjs.ceil.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.ceil.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.clone">module mathjs.clone</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.clone.factory">
            function <span class="apidocSignatureSpan">mathjs.clone.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.clone.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.combinations">module mathjs.combinations</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.combinations.factory">
            function <span class="apidocSignatureSpan">mathjs.combinations.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.combinations.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.compare">module mathjs.compare</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.compare.factory">
            function <span class="apidocSignatureSpan">mathjs.compare.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.compare.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.compile">module mathjs.compile</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.compile.factory">
            function <span class="apidocSignatureSpan">mathjs.compile.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.compile.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.composition">module mathjs.composition</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.composition.factory">
            function <span class="apidocSignatureSpan">mathjs.composition.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.composition.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.concat">module mathjs.concat</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.concat.factory">
            function <span class="apidocSignatureSpan">mathjs.concat.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.concat.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.concat_transform">module mathjs.concat_transform</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.concat_transform.factory">
            function <span class="apidocSignatureSpan">mathjs.concat_transform.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.concat_transform.</span>name</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.concat_transform.</span>path</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.config">module mathjs.config</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">mathjs.config.</span>math</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.config.factory">
            function <span class="apidocSignatureSpan">mathjs.config.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed, math)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.config.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.conj">module mathjs.conj</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.conj.factory">
            function <span class="apidocSignatureSpan">mathjs.conj.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.conj.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.constants">module mathjs.constants</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">mathjs.constants.</span>lazy</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">mathjs.constants.</span>math</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.constants.factory">
            function <span class="apidocSignatureSpan">mathjs.constants.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed, math)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.core">module mathjs.core</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.core.create">
            function <span class="apidocSignatureSpan">mathjs.core.</span>create
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.cos">module mathjs.cos</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.cos.factory">
            function <span class="apidocSignatureSpan">mathjs.cos.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.cos.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.cosh">module mathjs.cosh</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.cosh.factory">
            function <span class="apidocSignatureSpan">mathjs.cosh.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.cosh.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.cot">module mathjs.cot</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.cot.factory">
            function <span class="apidocSignatureSpan">mathjs.cot.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.cot.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.coth">module mathjs.coth</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.coth.factory">
            function <span class="apidocSignatureSpan">mathjs.coth.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.coth.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.cross">module mathjs.cross</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.cross.factory">
            function <span class="apidocSignatureSpan">mathjs.cross.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.cross.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.csc">module mathjs.csc</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.csc.factory">
            function <span class="apidocSignatureSpan">mathjs.csc.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.csc.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.csch">module mathjs.csch</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.csch.factory">
            function <span class="apidocSignatureSpan">mathjs.csch.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.csch.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.cube">module mathjs.cube</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.cube.factory">
            function <span class="apidocSignatureSpan">mathjs.cube.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.cube.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.deepEqual">module mathjs.deepEqual</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.deepEqual.factory">
            function <span class="apidocSignatureSpan">mathjs.deepEqual.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.deepEqual.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.derivative">module mathjs.derivative</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">mathjs.derivative.</span>_simplify</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.derivative.derivative">
            function <span class="apidocSignatureSpan">mathjs.</span>derivative
            <span class="apidocSignatureSpan">(arg0, arg1, arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.derivative.toTex">
            function <span class="apidocSignatureSpan">mathjs.derivative.</span>toTex
            <span class="apidocSignatureSpan">(deriv)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.derivative.</span>signatures</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.derivative.signatures">module mathjs.derivative.signatures</a><ol>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.det">module mathjs.det</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.det.factory">
            function <span class="apidocSignatureSpan">mathjs.det.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.det.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.diag">module mathjs.diag</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.diag.factory">
            function <span class="apidocSignatureSpan">mathjs.diag.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.diag.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.distance">module mathjs.distance</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.distance.factory">
            function <span class="apidocSignatureSpan">mathjs.distance.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.distance.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.distribution">module mathjs.distribution</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.distribution.factory">
            function <span class="apidocSignatureSpan">mathjs.distribution.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed, math)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.distribution.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.divide">module mathjs.divide</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.divide.factory">
            function <span class="apidocSignatureSpan">mathjs.divide.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.divide.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.divideScalar">module mathjs.divideScalar</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.divideScalar.factory">
            function <span class="apidocSignatureSpan">mathjs.divideScalar.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.dot">module mathjs.dot</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.dot.factory">
            function <span class="apidocSignatureSpan">mathjs.dot.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.dot.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.dotDivide">module mathjs.dotDivide</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.dotDivide.factory">
            function <span class="apidocSignatureSpan">mathjs.dotDivide.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.dotDivide.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.dotMultiply">module mathjs.dotMultiply</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.dotMultiply.factory">
            function <span class="apidocSignatureSpan">mathjs.dotMultiply.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.dotMultiply.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.dotPow">module mathjs.dotPow</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.dotPow.factory">
            function <span class="apidocSignatureSpan">mathjs.dotPow.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.dotPow.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.emitter">module mathjs.emitter</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.emitter.mixin">
            function <span class="apidocSignatureSpan">mathjs.emitter.</span>mixin
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.equal">module mathjs.equal</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.equal.factory">
            function <span class="apidocSignatureSpan">mathjs.equal.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.equal.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.equalScalar">module mathjs.equalScalar</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.equalScalar.factory">
            function <span class="apidocSignatureSpan">mathjs.equalScalar.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.erf">module mathjs.erf</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.erf.factory">
            function <span class="apidocSignatureSpan">mathjs.erf.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.erf.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.error">module mathjs.error</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.error.ArgumentsError">
            function <span class="apidocSignatureSpan">mathjs.error.</span>ArgumentsError
            <span class="apidocSignatureSpan">(fn, count, min, max)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.error.DimensionError">
            function <span class="apidocSignatureSpan">mathjs.error.</span>DimensionError
            <span class="apidocSignatureSpan">(actual, expected, relation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.error.IndexError">
            function <span class="apidocSignatureSpan">mathjs.error.</span>IndexError
            <span class="apidocSignatureSpan">(index, min, max)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.error.ArgumentsError">module mathjs.error.ArgumentsError</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.error.ArgumentsError.ArgumentsError">
            function <span class="apidocSignatureSpan">mathjs.error.</span>ArgumentsError
            <span class="apidocSignatureSpan">(fn, count, min, max)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.error.ArgumentsError.prototype">module mathjs.error.ArgumentsError.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">mathjs.error.ArgumentsError.prototype.</span>isArgumentsError</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.error.ArgumentsError.prototype.constructor">
            function <span class="apidocSignatureSpan">mathjs.error.ArgumentsError.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.error.ArgumentsError.prototype.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.error.ArgumentsError.prototype.constructor">module mathjs.error.ArgumentsError.prototype.constructor</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.error.ArgumentsError.prototype.constructor.constructor">
            function <span class="apidocSignatureSpan">mathjs.error.ArgumentsError.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.error.ArgumentsError.prototype.constructor.captureStackTrace">
            function <span class="apidocSignatureSpan">mathjs.error.ArgumentsError.prototype.constructor.</span>captureStackTrace
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mathjs.error.ArgumentsError.prototype.constructor.</span>stackTraceLimit</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.error.DimensionError">module mathjs.error.DimensionError</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.error.DimensionError.DimensionError">
            function <span class="apidocSignatureSpan">mathjs.error.</span>DimensionError
            <span class="apidocSignatureSpan">(actual, expected, relation)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.error.DimensionError.prototype">module mathjs.error.DimensionError.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">mathjs.error.DimensionError.prototype.</span>isDimensionError</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.error.DimensionError.prototype.constructor">
            function <span class="apidocSignatureSpan">mathjs.error.DimensionError.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.error.DimensionError.prototype.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.error.IndexError">module mathjs.error.IndexError</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.error.IndexError.IndexError">
            function <span class="apidocSignatureSpan">mathjs.error.</span>IndexError
            <span class="apidocSignatureSpan">(index, min, max)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.error.IndexError.prototype">module mathjs.error.IndexError.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">mathjs.error.IndexError.prototype.</span>isIndexError</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.error.IndexError.prototype.constructor">
            function <span class="apidocSignatureSpan">mathjs.error.IndexError.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.error.IndexError.prototype.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.error_transform">module mathjs.error_transform</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.error_transform.transform">
            function <span class="apidocSignatureSpan">mathjs.error_transform.</span>transform
            <span class="apidocSignatureSpan">(err)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.eval">module mathjs.eval</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.eval.factory">
            function <span class="apidocSignatureSpan">mathjs.eval.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.eval.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.exp">module mathjs.exp</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.exp.factory">
            function <span class="apidocSignatureSpan">mathjs.exp.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.exp.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.expression">module mathjs.expression</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.Parser">
            function <span class="apidocSignatureSpan">mathjs.expression.</span>Parser
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.parse">
            function <span class="apidocSignatureSpan">mathjs.expression.</span>parse
            <span class="apidocSignatureSpan">(expr, options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.expression.</span>docs</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.expression.</span>mathWithTransform</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.expression.</span>node</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.expression.</span>transform</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.expression.Parser">module mathjs.expression.Parser</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.Parser.Parser">
            function <span class="apidocSignatureSpan">mathjs.expression.</span>Parser
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.expression.Parser.prototype">module mathjs.expression.Parser.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">mathjs.expression.Parser.prototype.</span>isParser</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.Parser.prototype.clear">
            function <span class="apidocSignatureSpan">mathjs.expression.Parser.prototype.</span>clear
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.Parser.prototype.compile">
            function <span class="apidocSignatureSpan">mathjs.expression.Parser.prototype.</span>compile
            <span class="apidocSignatureSpan">(expr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.Parser.prototype.eval">
            function <span class="apidocSignatureSpan">mathjs.expression.Parser.prototype.</span>eval
            <span class="apidocSignatureSpan">(expr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.Parser.prototype.get">
            function <span class="apidocSignatureSpan">mathjs.expression.Parser.prototype.</span>get
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.Parser.prototype.getAll">
            function <span class="apidocSignatureSpan">mathjs.expression.Parser.prototype.</span>getAll
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.Parser.prototype.parse">
            function <span class="apidocSignatureSpan">mathjs.expression.Parser.prototype.</span>parse
            <span class="apidocSignatureSpan">(expr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.Parser.prototype.remove">
            function <span class="apidocSignatureSpan">mathjs.expression.Parser.prototype.</span>remove
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.Parser.prototype.set">
            function <span class="apidocSignatureSpan">mathjs.expression.Parser.prototype.</span>set
            <span class="apidocSignatureSpan">(name, value)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.expression.Parser.prototype.</span>type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.expression.mathWithTransform">module mathjs.expression.mathWithTransform</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>false</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>true</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.AccessorNode">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>AccessorNode
            <span class="apidocSignatureSpan">(object, index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.ArgumentsError">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>ArgumentsError
            <span class="apidocSignatureSpan">(fn, count, min, max)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.ArrayNode">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>ArrayNode
            <span class="apidocSignatureSpan">(items)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.AssignmentNode">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>AssignmentNode
            <span class="apidocSignatureSpan">(object, index, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.BigNumber">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>BigNumber
            <span class="apidocSignatureSpan">(v)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.BlockNode">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>BlockNode
            <span class="apidocSignatureSpan">(blocks)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.Chain">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>Chain
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.Complex">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>Complex
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.ConditionalNode">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>ConditionalNode
            <span class="apidocSignatureSpan">(condition, trueExpr, falseExpr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.ConstantNode">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>ConstantNode
            <span class="apidocSignatureSpan">(value, valueType)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.DenseMatrix">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>DenseMatrix
            <span class="apidocSignatureSpan">(data, datatype)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.DimensionError">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>DimensionError
            <span class="apidocSignatureSpan">(actual, expected, relation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.FibonacciHeap">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>FibonacciHeap
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.Fraction">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>Fraction
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.FunctionAssignmentNode">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>FunctionAssignmentNode
            <span class="apidocSignatureSpan">(name, params, expr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.FunctionNode">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>FunctionNode
            <span class="apidocSignatureSpan">(fn, args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.Help">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>Help
            <span class="apidocSignatureSpan">(doc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.ImmutableDenseMatrix">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>ImmutableDenseMatrix
            <span class="apidocSignatureSpan">(data, datatype)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.Index">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>Index
            <span class="apidocSignatureSpan">(ranges)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.IndexError">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>IndexError
            <span class="apidocSignatureSpan">(index, min, max)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.IndexNode">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>IndexNode
            <span class="apidocSignatureSpan">(dimensions, dotNotation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.Matrix">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>Matrix
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.Node">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>Node
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.ObjectNode">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>ObjectNode
            <span class="apidocSignatureSpan">(properties)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.OperatorNode">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>OperatorNode
            <span class="apidocSignatureSpan">(op, fn, args, implicit)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.ParenthesisNode">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>ParenthesisNode
            <span class="apidocSignatureSpan">(content)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.Parser">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>Parser
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.Range">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>Range
            <span class="apidocSignatureSpan">(start, end, step)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.RangeNode">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>RangeNode
            <span class="apidocSignatureSpan">(start, end, step)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.ResultSet">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>ResultSet
            <span class="apidocSignatureSpan">(entries)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.Spa">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>Spa
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.SparseMatrix">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>SparseMatrix
            <span class="apidocSignatureSpan">(data, datatype)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.SymbolNode">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>SymbolNode
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.Unit">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>Unit
            <span class="apidocSignatureSpan">(value, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.UpdateNode">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>UpdateNode
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.abs">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>abs
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.acos">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>acos
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.acosh">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>acosh
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.acot">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>acot
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.acoth">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>acoth
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.acsc">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>acsc
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.acsch">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>acsch
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.add">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>add
            <span class="apidocSignatureSpan">(arg0, arg1, arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.and">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>and
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.arg">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>arg
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.asec">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>asec
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.asech">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>asech
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.asin">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>asin
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.asinh">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>asinh
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.atan">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>atan
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.atan2">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>atan2
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.atanh">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>atanh
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.bellNumbers">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>bellNumbers
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.bignumber">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>bignumber
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.bitAnd">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>bitAnd
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.bitNot">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>bitNot
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.bitOr">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>bitOr
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.bitXor">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>bitXor
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.boolean">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>boolean
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.catalan">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>catalan
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.cbrt">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>cbrt
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.ceil">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>ceil
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.chain">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>chain
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.clone">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>clone
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.combinations">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>combinations
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.compare">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>compare
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.compile">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>compile
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.complex">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>complex
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.composition">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>composition
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.concat">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>concat
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.config">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>config
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.conj">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>conj
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.cos">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>cos
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.cosh">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>cosh
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.cot">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>cot
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.coth">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>coth
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.createUnit">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>createUnit
            <span class="apidocSignatureSpan">(arg0, arg1, arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.cross">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>cross
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.csc">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>csc
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.csch">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>csch
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.cube">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>cube
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.deepEqual">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>deepEqual
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.derivative">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>derivative
            <span class="apidocSignatureSpan">(arg0, arg1, arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.det">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>det
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.diag">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>diag
            <span class="apidocSignatureSpan">(arg0, arg1, arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.distance">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>distance
            <span class="apidocSignatureSpan">(arg0, arg1, arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.divide">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>divide
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.dot">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>dot
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.dotDivide">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>dotDivide
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.dotMultiply">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>dotMultiply
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.dotPow">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>dotPow
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.equal">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>equal
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.erf">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>erf
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.eval">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>eval
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.exp">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>exp
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.eye">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>eye
            <span class="apidocSignatureSpan">(arg0, arg1, arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.factorial">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>factorial
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.filter">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>filter
            <span class="apidocSignatureSpan">(args, math, scope)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.fix">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>fix
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.flatten">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>flatten
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.floor">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>floor
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.forEach">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>forEach
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.format">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>format
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.fraction">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>fraction
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.gamma">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>gamma
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.gcd">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>gcd
            <span class="apidocSignatureSpan">(arg0, arg1, arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.help">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>help
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.hypot">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>hypot
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.im">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>im
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.index">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>index
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.intersect">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>intersect
            <span class="apidocSignatureSpan">(arg0, arg1, arg2, arg3)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.inv">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>inv
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.isInteger">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>isInteger
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.isNaN">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>isNaN
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.isNegative">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>isNegative
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.isNumeric">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>isNumeric
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.isPositive">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>isPositive
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.isPrime">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>isPrime
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.isZero">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>isZero
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.kldivergence">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>kldivergence
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.kron">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>kron
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.larger">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>larger
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.largerEq">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>largerEq
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.lcm">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>lcm
            <span class="apidocSignatureSpan">(arg0, arg1, arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.leftShift">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>leftShift
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.log">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>log
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.log10">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>log10
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.lsolve">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>lsolve
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.lup">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>lup
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.lusolve">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>lusolve
            <span class="apidocSignatureSpan">(arg0, arg1, arg2, arg3)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.mad">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>mad
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.map">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>map
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.matrix">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>matrix
            <span class="apidocSignatureSpan">(arg0, arg1, arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.max">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>max
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.mean">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>mean
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.median">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>median
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.min">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>min
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.mod">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>mod
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.mode">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>mode
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.multinomial">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>multinomial
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.multiply">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>multiply
            <span class="apidocSignatureSpan">(arg0, arg1, arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.norm">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>norm
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.not">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>not
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.nthRoot">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>nthRoot
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.number">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>number
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.ones">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>ones
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.or">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>or
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.parse">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>parse
            <span class="apidocSignatureSpan">(expr, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.parser">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>parser
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.partitionSelect">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>partitionSelect
            <span class="apidocSignatureSpan">(arg0, arg1, arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.permutations">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>permutations
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.pow">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>pow
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.print">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>print
            <span class="apidocSignatureSpan">(arg0, arg1, arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.prod">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>prod
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.qr">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>qr
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.quantileSeq">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>quantileSeq
            <span class="apidocSignatureSpan">(data, probOrN, sorted)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.range">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>range
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.re">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>re
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.reshape">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>reshape
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.resize">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>resize
            <span class="apidocSignatureSpan">(x, size, defaultValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.reviver">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>reviver
            <span class="apidocSignatureSpan">(key, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.rightArithShift">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>rightArithShift
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.rightLogShift">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>rightLogShift
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.round">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>round
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.sec">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>sec
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.sech">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>sech
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.sign">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>sign
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.simplify">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>simplify
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.sin">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>sin
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.sinh">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>sinh
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.size">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>size
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.slu">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>slu
            <span class="apidocSignatureSpan">(arg0, arg1, arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.smaller">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>smaller
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.smallerEq">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>smallerEq
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.sort">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>sort
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.sparse">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>sparse
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.splitUnit">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>splitUnit
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.sqrt">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>sqrt
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.square">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>square
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.squeeze">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>squeeze
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.std">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>std
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.stirlingS2">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>stirlingS2
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.string">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>string
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.subset">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>subset
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.subtract">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>subtract
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.sum">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>sum
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.tan">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>tan
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.tanh">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>tanh
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.to">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>to
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.trace">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>trace
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.transpose">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>transpose
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.typeof">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>typeof
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.unaryMinus">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>unaryMinus
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.unaryPlus">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>unaryPlus
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.unequal">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>unequal
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.unit">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>unit
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.usolve">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>usolve
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.var">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>var
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.xgcd">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>xgcd
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.xor">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>xor
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.zeros">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>zeros
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>E</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>Infinity</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>LN10</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>LN2</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>LOG10E</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>LOG2E</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>NaN</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>PI</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>SQRT1_2</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>SQRT2</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>e</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>phi</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>pi</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>tau</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>docs</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>i</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>null</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>uninitialized</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.expression.mathWithTransform.AccessorNode.prototype">module mathjs.expression.mathWithTransform.AccessorNode.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.AccessorNode.prototype.</span>isAccessorNode</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.AccessorNode.prototype._compile">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.AccessorNode.prototype.</span>_compile
            <span class="apidocSignatureSpan">(defs, args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.AccessorNode.prototype._toString">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.AccessorNode.prototype.</span>_toString
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.AccessorNode.prototype._toTex">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.AccessorNode.prototype.</span>_toTex
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.AccessorNode.prototype.clone">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.AccessorNode.prototype.</span>clone
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.AccessorNode.prototype.forEach">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.AccessorNode.prototype.</span>forEach
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.AccessorNode.prototype.map">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.AccessorNode.prototype.</span>map
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.AccessorNode.prototype.</span>type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.expression.mathWithTransform.ArrayNode.prototype">module mathjs.expression.mathWithTransform.ArrayNode.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.ArrayNode.prototype.</span>isArrayNode</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.ArrayNode.prototype._compile">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.ArrayNode.prototype.</span>_compile
            <span class="apidocSignatureSpan">(defs, args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.ArrayNode.prototype._toString">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.ArrayNode.prototype.</span>_toString
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.ArrayNode.prototype._toTex">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.ArrayNode.prototype.</span>_toTex
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.ArrayNode.prototype.clone">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.ArrayNode.prototype.</span>clone
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.ArrayNode.prototype.forEach">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.ArrayNode.prototype.</span>forEach
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.ArrayNode.prototype.map">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.ArrayNode.prototype.</span>map
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.ArrayNode.prototype.</span>type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.expression.mathWithTransform.AssignmentNode.prototype">module mathjs.expression.mathWithTransform.AssignmentNode.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.AssignmentNode.prototype.</span>isAssignmentNode</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.AssignmentNode.prototype._compile">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.AssignmentNode.prototype.</span>_compile
            <span class="apidocSignatureSpan">(defs, args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.AssignmentNode.prototype._toString">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.AssignmentNode.prototype.</span>_toString
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.AssignmentNode.prototype._toTex">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.AssignmentNode.prototype.</span>_toTex
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.AssignmentNode.prototype.clone">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.AssignmentNode.prototype.</span>clone
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.AssignmentNode.prototype.forEach">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.AssignmentNode.prototype.</span>forEach
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.AssignmentNode.prototype.map">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.AssignmentNode.prototype.</span>map
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.AssignmentNode.prototype.</span>type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.expression.mathWithTransform.BlockNode.prototype">module mathjs.expression.mathWithTransform.BlockNode.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.BlockNode.prototype.</span>isBlockNode</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.BlockNode.prototype._compile">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.BlockNode.prototype.</span>_compile
            <span class="apidocSignatureSpan">(defs, args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.BlockNode.prototype._toString">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.BlockNode.prototype.</span>_toString
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.BlockNode.prototype._toTex">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.BlockNode.prototype.</span>_toTex
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.BlockNode.prototype.clone">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.BlockNode.prototype.</span>clone
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.BlockNode.prototype.forEach">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.BlockNode.prototype.</span>forEach
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.BlockNode.prototype.map">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.BlockNode.prototype.</span>map
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.BlockNode.prototype.</span>type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.expression.mathWithTransform.ConditionalNode.prototype">module mathjs.expression.mathWithTransform.ConditionalNode.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.ConditionalNode.prototype.</span>isConditionalNode</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.ConditionalNode.prototype._compile">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.ConditionalNode.prototype.</span>_compile
            <span class="apidocSignatureSpan">(defs, args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.ConditionalNode.prototype._toString">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.ConditionalNode.prototype.</span>_toString
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.ConditionalNode.prototype._toTex">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.ConditionalNode.prototype.</span>_toTex
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.ConditionalNode.prototype.clone">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.ConditionalNode.prototype.</span>clone
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.ConditionalNode.prototype.forEach">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.ConditionalNode.prototype.</span>forEach
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.ConditionalNode.prototype.map">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.ConditionalNode.prototype.</span>map
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.ConditionalNode.prototype.</span>type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.expression.mathWithTransform.ConstantNode.prototype">module mathjs.expression.mathWithTransform.ConstantNode.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.ConstantNode.prototype.</span>isConstantNode</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.ConstantNode.prototype._compile">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.ConstantNode.prototype.</span>_compile
            <span class="apidocSignatureSpan">(defs, args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.ConstantNode.prototype._toString">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.ConstantNode.prototype.</span>_toString
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.ConstantNode.prototype._toTex">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.ConstantNode.prototype.</span>_toTex
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.ConstantNode.prototype.clone">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.ConstantNode.prototype.</span>clone
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.ConstantNode.prototype.forEach">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.ConstantNode.prototype.</span>forEach
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.ConstantNode.prototype.map">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.ConstantNode.prototype.</span>map
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.ConstantNode.prototype.</span>type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.expression.mathWithTransform.FunctionAssignmentNode.prototype">module mathjs.expression.mathWithTransform.FunctionAssignmentNode.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.FunctionAssignmentNode.prototype.</span>isFunctionAssignmentNode</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.FunctionAssignmentNode.prototype._compile">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.FunctionAssignmentNode.prototype.</span>_compile
            <span class="apidocSignatureSpan">(defs, args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.FunctionAssignmentNode.prototype._toString">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.FunctionAssignmentNode.prototype.</span>_toString
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.FunctionAssignmentNode.prototype._toTex">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.FunctionAssignmentNode.prototype.</span>_toTex
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.FunctionAssignmentNode.prototype.clone">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.FunctionAssignmentNode.prototype.</span>clone
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.FunctionAssignmentNode.prototype.forEach">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.FunctionAssignmentNode.prototype.</span>forEach
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.FunctionAssignmentNode.prototype.map">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.FunctionAssignmentNode.prototype.</span>map
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.FunctionAssignmentNode.prototype.</span>type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.expression.mathWithTransform.FunctionNode.prototype">module mathjs.expression.mathWithTransform.FunctionNode.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.FunctionNode.prototype.</span>isFunctionNode</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.FunctionNode.prototype._compile">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.FunctionNode.prototype.</span>_compile
            <span class="apidocSignatureSpan">(defs, args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.FunctionNode.prototype._compileScope">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.FunctionNode.prototype.</span>_compileScope
            <span class="apidocSignatureSpan">(defs, args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.FunctionNode.prototype._getUniqueArgumentsName">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.FunctionNode.prototype.</span>_getUniqueArgumentsName
            <span class="apidocSignatureSpan">(defs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.FunctionNode.prototype._toString">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.FunctionNode.prototype.</span>_toString
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.FunctionNode.prototype._toTex">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.FunctionNode.prototype.</span>_toTex
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.FunctionNode.prototype.clone">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.FunctionNode.prototype.</span>clone
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.FunctionNode.prototype.forEach">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.FunctionNode.prototype.</span>forEach
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.FunctionNode.prototype.getIdentifier">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.FunctionNode.prototype.</span>getIdentifier
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.FunctionNode.prototype.map">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.FunctionNode.prototype.</span>map
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.FunctionNode.prototype.toString">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.FunctionNode.prototype.</span>toString
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.FunctionNode.prototype.toTex">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.FunctionNode.prototype.</span>toTex
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.FunctionNode.prototype.</span>type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.expression.mathWithTransform.IndexNode.prototype">module mathjs.expression.mathWithTransform.IndexNode.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.IndexNode.prototype.</span>isIndexNode</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.IndexNode.prototype._compile">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.IndexNode.prototype.</span>_compile
            <span class="apidocSignatureSpan">(defs, args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.IndexNode.prototype._toString">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.IndexNode.prototype.</span>_toString
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.IndexNode.prototype._toTex">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.IndexNode.prototype.</span>_toTex
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.IndexNode.prototype.clone">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.IndexNode.prototype.</span>clone
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.IndexNode.prototype.forEach">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.IndexNode.prototype.</span>forEach
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.IndexNode.prototype.getObjectProperty">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.IndexNode.prototype.</span>getObjectProperty
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.IndexNode.prototype.isObjectProperty">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.IndexNode.prototype.</span>isObjectProperty
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.IndexNode.prototype.map">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.IndexNode.prototype.</span>map
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.IndexNode.prototype.needsSize">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.IndexNode.prototype.</span>needsSize
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.IndexNode.prototype.</span>type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.expression.mathWithTransform.Node.prototype">module mathjs.expression.mathWithTransform.Node.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.Node.prototype.</span>isNode</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.Node.prototype._compile">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.Node.prototype.</span>_compile
            <span class="apidocSignatureSpan">(defs, args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.Node.prototype._ifNode">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.Node.prototype.</span>_ifNode
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.Node.prototype._toString">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.Node.prototype.</span>_toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.Node.prototype._toTex">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.Node.prototype.</span>_toTex
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.Node.prototype.clone">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.Node.prototype.</span>clone
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.Node.prototype.cloneDeep">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.Node.prototype.</span>cloneDeep
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.Node.prototype.compile">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.Node.prototype.</span>compile
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.Node.prototype.equals">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.Node.prototype.</span>equals
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.Node.prototype.eval">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.Node.prototype.</span>eval
            <span class="apidocSignatureSpan">(scope)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.Node.prototype.filter">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.Node.prototype.</span>filter
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.Node.prototype.find">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.Node.prototype.</span>find
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.Node.prototype.forEach">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.Node.prototype.</span>forEach
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.Node.prototype.getContent">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.Node.prototype.</span>getContent
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.Node.prototype.getIdentifier">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.Node.prototype.</span>getIdentifier
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.Node.prototype.map">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.Node.prototype.</span>map
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.Node.prototype.match">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.Node.prototype.</span>match
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.Node.prototype.toString">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.Node.prototype.</span>toString
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.Node.prototype.toTex">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.Node.prototype.</span>toTex
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.Node.prototype.transform">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.Node.prototype.</span>transform
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.Node.prototype.traverse">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.Node.prototype.</span>traverse
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.Node.prototype.</span>comment</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.Node.prototype.</span>type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.expression.mathWithTransform.ObjectNode.prototype">module mathjs.expression.mathWithTransform.ObjectNode.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.ObjectNode.prototype.</span>isObjectNode</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.ObjectNode.prototype._compile">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.ObjectNode.prototype.</span>_compile
            <span class="apidocSignatureSpan">(defs, args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.ObjectNode.prototype._toString">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.ObjectNode.prototype.</span>_toString
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.ObjectNode.prototype._toTex">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.ObjectNode.prototype.</span>_toTex
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.ObjectNode.prototype.clone">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.ObjectNode.prototype.</span>clone
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.ObjectNode.prototype.forEach">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.ObjectNode.prototype.</span>forEach
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.ObjectNode.prototype.map">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.ObjectNode.prototype.</span>map
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.ObjectNode.prototype.</span>type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.expression.mathWithTransform.OperatorNode.prototype">module mathjs.expression.mathWithTransform.OperatorNode.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.OperatorNode.prototype.</span>isOperatorNode</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.OperatorNode.prototype._compile">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.OperatorNode.prototype.</span>_compile
            <span class="apidocSignatureSpan">(defs, args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.OperatorNode.prototype._toString">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.OperatorNode.prototype.</span>_toString
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.OperatorNode.prototype._toTex">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.OperatorNode.prototype.</span>_toTex
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.OperatorNode.prototype.clone">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.OperatorNode.prototype.</span>clone
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.OperatorNode.prototype.forEach">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.OperatorNode.prototype.</span>forEach
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.OperatorNode.prototype.getIdentifier">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.OperatorNode.prototype.</span>getIdentifier
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.OperatorNode.prototype.map">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.OperatorNode.prototype.</span>map
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.OperatorNode.prototype.</span>type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.expression.mathWithTransform.ParenthesisNode.prototype">module mathjs.expression.mathWithTransform.ParenthesisNode.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.ParenthesisNode.prototype.</span>isParenthesisNode</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.ParenthesisNode.prototype._compile">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.ParenthesisNode.prototype.</span>_compile
            <span class="apidocSignatureSpan">(defs, args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.ParenthesisNode.prototype._toString">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.ParenthesisNode.prototype.</span>_toString
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.ParenthesisNode.prototype._toTex">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.ParenthesisNode.prototype.</span>_toTex
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.ParenthesisNode.prototype.clone">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.ParenthesisNode.prototype.</span>clone
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.ParenthesisNode.prototype.forEach">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.ParenthesisNode.prototype.</span>forEach
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.ParenthesisNode.prototype.getContent">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.ParenthesisNode.prototype.</span>getContent
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.ParenthesisNode.prototype.map">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.ParenthesisNode.prototype.</span>map
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.ParenthesisNode.prototype.</span>type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.expression.mathWithTransform.RangeNode.prototype">module mathjs.expression.mathWithTransform.RangeNode.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.RangeNode.prototype.</span>isRangeNode</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.RangeNode.prototype._compile">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.RangeNode.prototype.</span>_compile
            <span class="apidocSignatureSpan">(defs, args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.RangeNode.prototype._toString">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.RangeNode.prototype.</span>_toString
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.RangeNode.prototype._toTex">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.RangeNode.prototype.</span>_toTex
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.RangeNode.prototype.clone">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.RangeNode.prototype.</span>clone
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.RangeNode.prototype.forEach">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.RangeNode.prototype.</span>forEach
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.RangeNode.prototype.map">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.RangeNode.prototype.</span>map
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.RangeNode.prototype.needsEnd">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.RangeNode.prototype.</span>needsEnd
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.RangeNode.prototype.</span>type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.expression.mathWithTransform.SymbolNode.prototype">module mathjs.expression.mathWithTransform.SymbolNode.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.SymbolNode.prototype.</span>isSymbolNode</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.SymbolNode.prototype._compile">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.SymbolNode.prototype.</span>_compile
            <span class="apidocSignatureSpan">(defs, args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.SymbolNode.prototype._toString">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.SymbolNode.prototype.</span>_toString
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.SymbolNode.prototype._toTex">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.SymbolNode.prototype.</span>_toTex
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.SymbolNode.prototype.clone">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.SymbolNode.prototype.</span>clone
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.SymbolNode.prototype.forEach">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.SymbolNode.prototype.</span>forEach
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.mathWithTransform.SymbolNode.prototype.map">
            function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.SymbolNode.prototype.</span>map
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.SymbolNode.prototype.</span>type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.expression.node">module mathjs.expression.node</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.node.AccessorNode">
            function <span class="apidocSignatureSpan">mathjs.expression.node.</span>AccessorNode
            <span class="apidocSignatureSpan">(object, index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.node.ArrayNode">
            function <span class="apidocSignatureSpan">mathjs.expression.node.</span>ArrayNode
            <span class="apidocSignatureSpan">(items)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.node.AssignmentNode">
            function <span class="apidocSignatureSpan">mathjs.expression.node.</span>AssignmentNode
            <span class="apidocSignatureSpan">(object, index, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.node.BlockNode">
            function <span class="apidocSignatureSpan">mathjs.expression.node.</span>BlockNode
            <span class="apidocSignatureSpan">(blocks)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.node.ConditionalNode">
            function <span class="apidocSignatureSpan">mathjs.expression.node.</span>ConditionalNode
            <span class="apidocSignatureSpan">(condition, trueExpr, falseExpr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.node.ConstantNode">
            function <span class="apidocSignatureSpan">mathjs.expression.node.</span>ConstantNode
            <span class="apidocSignatureSpan">(value, valueType)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.node.FunctionAssignmentNode">
            function <span class="apidocSignatureSpan">mathjs.expression.node.</span>FunctionAssignmentNode
            <span class="apidocSignatureSpan">(name, params, expr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.node.FunctionNode">
            function <span class="apidocSignatureSpan">mathjs.expression.node.</span>FunctionNode
            <span class="apidocSignatureSpan">(fn, args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.node.IndexNode">
            function <span class="apidocSignatureSpan">mathjs.expression.node.</span>IndexNode
            <span class="apidocSignatureSpan">(dimensions, dotNotation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.node.Node">
            function <span class="apidocSignatureSpan">mathjs.expression.node.</span>Node
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.node.ObjectNode">
            function <span class="apidocSignatureSpan">mathjs.expression.node.</span>ObjectNode
            <span class="apidocSignatureSpan">(properties)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.node.OperatorNode">
            function <span class="apidocSignatureSpan">mathjs.expression.node.</span>OperatorNode
            <span class="apidocSignatureSpan">(op, fn, args, implicit)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.node.ParenthesisNode">
            function <span class="apidocSignatureSpan">mathjs.expression.node.</span>ParenthesisNode
            <span class="apidocSignatureSpan">(content)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.node.RangeNode">
            function <span class="apidocSignatureSpan">mathjs.expression.node.</span>RangeNode
            <span class="apidocSignatureSpan">(start, end, step)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.node.SymbolNode">
            function <span class="apidocSignatureSpan">mathjs.expression.node.</span>SymbolNode
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.node.UpdateNode">
            function <span class="apidocSignatureSpan">mathjs.expression.node.</span>UpdateNode
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.expression.parse">module mathjs.expression.parse</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.parse.parse">
            function <span class="apidocSignatureSpan">mathjs.expression.</span>parse
            <span class="apidocSignatureSpan">(expr, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.parse.isAlpha">
            function <span class="apidocSignatureSpan">mathjs.expression.parse.</span>isAlpha
            <span class="apidocSignatureSpan">(c, cPrev, cNext)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.parse.isDecimalMark">
            function <span class="apidocSignatureSpan">mathjs.expression.parse.</span>isDecimalMark
            <span class="apidocSignatureSpan">(c, cNext)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.parse.isDigit">
            function <span class="apidocSignatureSpan">mathjs.expression.parse.</span>isDigit
            <span class="apidocSignatureSpan">(c)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.parse.isDigitDot">
            function <span class="apidocSignatureSpan">mathjs.expression.parse.</span>isDigitDot
            <span class="apidocSignatureSpan">(c)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.parse.isValidLatinOrGreek">
            function <span class="apidocSignatureSpan">mathjs.expression.parse.</span>isValidLatinOrGreek
            <span class="apidocSignatureSpan">(c)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.parse.isValidMathSymbol">
            function <span class="apidocSignatureSpan">mathjs.expression.parse.</span>isValidMathSymbol
            <span class="apidocSignatureSpan">(high, low)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.parse.isWhitespace">
            function <span class="apidocSignatureSpan">mathjs.expression.parse.</span>isWhitespace
            <span class="apidocSignatureSpan">(c, nestingLevel)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.expression.transform">module mathjs.expression.transform</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.transform.concat">
            function <span class="apidocSignatureSpan">mathjs.expression.transform.</span>concat
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.transform.filter">
            function <span class="apidocSignatureSpan">mathjs.expression.transform.</span>filter
            <span class="apidocSignatureSpan">(args, math, scope)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.transform.forEach">
            function <span class="apidocSignatureSpan">mathjs.expression.transform.</span>forEach
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.transform.index">
            function <span class="apidocSignatureSpan">mathjs.expression.transform.</span>index
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.transform.map">
            function <span class="apidocSignatureSpan">mathjs.expression.transform.</span>map
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.transform.max">
            function <span class="apidocSignatureSpan">mathjs.expression.transform.</span>max
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.transform.mean">
            function <span class="apidocSignatureSpan">mathjs.expression.transform.</span>mean
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.transform.min">
            function <span class="apidocSignatureSpan">mathjs.expression.transform.</span>min
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.transform.range">
            function <span class="apidocSignatureSpan">mathjs.expression.transform.</span>range
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.expression.transform.subset">
            function <span class="apidocSignatureSpan">mathjs.expression.transform.</span>subset
            <span class="apidocSignatureSpan">(arg0)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.eye">module mathjs.eye</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.eye.factory">
            function <span class="apidocSignatureSpan">mathjs.eye.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.eye.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.factorial">module mathjs.factorial</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.factorial.factory">
            function <span class="apidocSignatureSpan">mathjs.factorial.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.factorial.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.filter">module mathjs.filter</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.filter.factory">
            function <span class="apidocSignatureSpan">mathjs.filter.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.filter.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.filter_transform">module mathjs.filter_transform</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.filter_transform.factory">
            function <span class="apidocSignatureSpan">mathjs.filter_transform.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.filter_transform.</span>name</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.filter_transform.</span>path</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.fix">module mathjs.fix</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.fix.factory">
            function <span class="apidocSignatureSpan">mathjs.fix.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.fix.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.flatten">module mathjs.flatten</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.flatten.factory">
            function <span class="apidocSignatureSpan">mathjs.flatten.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.flatten.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.floor">module mathjs.floor</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.floor.factory">
            function <span class="apidocSignatureSpan">mathjs.floor.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.floor.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.forEach">module mathjs.forEach</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.forEach.factory">
            function <span class="apidocSignatureSpan">mathjs.forEach.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.forEach.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.forEach_transform">module mathjs.forEach_transform</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.forEach_transform.factory">
            function <span class="apidocSignatureSpan">mathjs.forEach_transform.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.forEach_transform.</span>name</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.forEach_transform.</span>path</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.format">module mathjs.format</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.format.factory">
            function <span class="apidocSignatureSpan">mathjs.format.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.format.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.formatter">module mathjs.formatter</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.formatter.format">
            function <span class="apidocSignatureSpan">mathjs.formatter.</span>format
            <span class="apidocSignatureSpan">(value, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.formatter.toExponential">
            function <span class="apidocSignatureSpan">mathjs.formatter.</span>toExponential
            <span class="apidocSignatureSpan">(value, precision)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.formatter.toFixed">
            function <span class="apidocSignatureSpan">mathjs.formatter.</span>toFixed
            <span class="apidocSignatureSpan">(value, precision)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.function">module mathjs.function</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.function.maxArgumentCount">
            function <span class="apidocSignatureSpan">mathjs.function.</span>maxArgumentCount
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.function.memoize">
            function <span class="apidocSignatureSpan">mathjs.function.</span>memoize
            <span class="apidocSignatureSpan">(fn, hasher)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.gamma">module mathjs.gamma</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.gamma.factory">
            function <span class="apidocSignatureSpan">mathjs.gamma.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.gamma.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.gcd">module mathjs.gcd</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.gcd.factory">
            function <span class="apidocSignatureSpan">mathjs.gcd.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.gcd.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.hypot">module mathjs.hypot</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.hypot.factory">
            function <span class="apidocSignatureSpan">mathjs.hypot.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.hypot.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.im">module mathjs.im</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.im.factory">
            function <span class="apidocSignatureSpan">mathjs.im.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.im.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.import">module mathjs.import</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">mathjs.import.</span>lazy</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">mathjs.import.</span>math</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.import.factory">
            function <span class="apidocSignatureSpan">mathjs.import.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed, math)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.import.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.index_transform">module mathjs.index_transform</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.index_transform.factory">
            function <span class="apidocSignatureSpan">mathjs.index_transform.</span>factory
            <span class="apidocSignatureSpan">(type, config, load)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.index_transform.</span>name</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.index_transform.</span>path</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.intersect">module mathjs.intersect</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.intersect.factory">
            function <span class="apidocSignatureSpan">mathjs.intersect.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.intersect.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.inv">module mathjs.inv</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.inv.factory">
            function <span class="apidocSignatureSpan">mathjs.inv.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.inv.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.isInteger">module mathjs.isInteger</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.isInteger.factory">
            function <span class="apidocSignatureSpan">mathjs.isInteger.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.isInteger.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.isNaN">module mathjs.isNaN</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.isNaN.factory">
            function <span class="apidocSignatureSpan">mathjs.isNaN.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.isNaN.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.isNegative">module mathjs.isNegative</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.isNegative.factory">
            function <span class="apidocSignatureSpan">mathjs.isNegative.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.isNegative.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.isNumeric">module mathjs.isNumeric</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.isNumeric.factory">
            function <span class="apidocSignatureSpan">mathjs.isNumeric.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.isNumeric.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.isPositive">module mathjs.isPositive</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.isPositive.factory">
            function <span class="apidocSignatureSpan">mathjs.isPositive.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.isPositive.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.isPrime">module mathjs.isPrime</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.isPrime.factory">
            function <span class="apidocSignatureSpan">mathjs.isPrime.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.isPrime.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.isZero">module mathjs.isZero</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.isZero.factory">
            function <span class="apidocSignatureSpan">mathjs.isZero.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.isZero.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.json">module mathjs.json</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.json.reviver">
            function <span class="apidocSignatureSpan">mathjs.json.</span>reviver
            <span class="apidocSignatureSpan">(key, value)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.kldivergence">module mathjs.kldivergence</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.kldivergence.factory">
            function <span class="apidocSignatureSpan">mathjs.kldivergence.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.kldivergence.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.kron">module mathjs.kron</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.kron.factory">
            function <span class="apidocSignatureSpan">mathjs.kron.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.kron.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.larger">module mathjs.larger</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.larger.factory">
            function <span class="apidocSignatureSpan">mathjs.larger.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.larger.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.largerEq">module mathjs.largerEq</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.largerEq.factory">
            function <span class="apidocSignatureSpan">mathjs.largerEq.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.largerEq.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.latex">module mathjs.latex</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.latex.toSymbol">
            function <span class="apidocSignatureSpan">mathjs.latex.</span>toSymbol
            <span class="apidocSignatureSpan">(name, isUnit)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.latex.</span>operators</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.latex.</span>symbols</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.latex.</span>defaultTemplate</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.lcm">module mathjs.lcm</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.lcm.factory">
            function <span class="apidocSignatureSpan">mathjs.lcm.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.lcm.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.leftShift">module mathjs.leftShift</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.leftShift.factory">
            function <span class="apidocSignatureSpan">mathjs.leftShift.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.leftShift.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.log10">module mathjs.log10</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.log10.factory">
            function <span class="apidocSignatureSpan">mathjs.log10.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.log10.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.mad">module mathjs.mad</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.mad.factory">
            function <span class="apidocSignatureSpan">mathjs.mad.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.mad.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.map">module mathjs.map</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.map.factory">
            function <span class="apidocSignatureSpan">mathjs.map.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.map.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.map_transform">module mathjs.map_transform</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.map_transform.factory">
            function <span class="apidocSignatureSpan">mathjs.map_transform.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.map_transform.</span>name</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.map_transform.</span>path</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.max">module mathjs.max</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.max.factory">
            function <span class="apidocSignatureSpan">mathjs.max.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.max.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.max_transform">module mathjs.max_transform</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.max_transform.factory">
            function <span class="apidocSignatureSpan">mathjs.max_transform.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.max_transform.</span>name</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.max_transform.</span>path</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.mean">module mathjs.mean</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.mean.factory">
            function <span class="apidocSignatureSpan">mathjs.mean.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.mean.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.mean_transform">module mathjs.mean_transform</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.mean_transform.factory">
            function <span class="apidocSignatureSpan">mathjs.mean_transform.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.mean_transform.</span>name</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.mean_transform.</span>path</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.median">module mathjs.median</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.median.factory">
            function <span class="apidocSignatureSpan">mathjs.median.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.median.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.mod">module mathjs.mod</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.mod.factory">
            function <span class="apidocSignatureSpan">mathjs.mod.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.mod.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.mode">module mathjs.mode</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.mode.factory">
            function <span class="apidocSignatureSpan">mathjs.mode.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.mode.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.multinomial">module mathjs.multinomial</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.multinomial.factory">
            function <span class="apidocSignatureSpan">mathjs.multinomial.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.multinomial.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.multiply">module mathjs.multiply</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.multiply.factory">
            function <span class="apidocSignatureSpan">mathjs.multiply.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.multiply.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.multiplyScalar">module mathjs.multiplyScalar</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.multiplyScalar.factory">
            function <span class="apidocSignatureSpan">mathjs.multiplyScalar.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.norm">module mathjs.norm</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.norm.factory">
            function <span class="apidocSignatureSpan">mathjs.norm.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.norm.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.not">module mathjs.not</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.not.factory">
            function <span class="apidocSignatureSpan">mathjs.not.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.not.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.nthRoot">module mathjs.nthRoot</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.nthRoot.factory">
            function <span class="apidocSignatureSpan">mathjs.nthRoot.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.nthRoot.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.number">module mathjs.number</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.number.factory">
            function <span class="apidocSignatureSpan">mathjs.number.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.number.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.object">module mathjs.object</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.object.canDefineProperty">
            function <span class="apidocSignatureSpan">mathjs.object.</span>canDefineProperty
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.object.clone">
            function <span class="apidocSignatureSpan">mathjs.object.</span>clone
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.object.deepEqual">
            function <span class="apidocSignatureSpan">mathjs.object.</span>deepEqual
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.object.deepExtend">
            function <span class="apidocSignatureSpan">mathjs.object.</span>deepExtend
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.object.extend">
            function <span class="apidocSignatureSpan">mathjs.object.</span>extend
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.object.isFactory">
            function <span class="apidocSignatureSpan">mathjs.object.</span>isFactory
            <span class="apidocSignatureSpan">(object)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.object.lazy">
            function <span class="apidocSignatureSpan">mathjs.object.</span>lazy
            <span class="apidocSignatureSpan">(object, prop, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.object.traverse">
            function <span class="apidocSignatureSpan">mathjs.object.</span>traverse
            <span class="apidocSignatureSpan">(object, path)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.ones">module mathjs.ones</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.ones.factory">
            function <span class="apidocSignatureSpan">mathjs.ones.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.ones.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.operators">module mathjs.operators</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.operators.getAssociativity">
            function <span class="apidocSignatureSpan">mathjs.operators.</span>getAssociativity
            <span class="apidocSignatureSpan">(_node, parenthesis)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.operators.getPrecedence">
            function <span class="apidocSignatureSpan">mathjs.operators.</span>getPrecedence
            <span class="apidocSignatureSpan">(_node, parenthesis)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.operators.isAssociativeWith">
            function <span class="apidocSignatureSpan">mathjs.operators.</span>isAssociativeWith
            <span class="apidocSignatureSpan">(nodeA, nodeB, parenthesis)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.operators.</span>properties</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.or">module mathjs.or</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.or.factory">
            function <span class="apidocSignatureSpan">mathjs.or.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.or.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.parse">module mathjs.parse</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.parse.factory">
            function <span class="apidocSignatureSpan">mathjs.parse.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.parse.</span>name</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.parse.</span>path</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.partitionSelect">module mathjs.partitionSelect</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.partitionSelect.factory">
            function <span class="apidocSignatureSpan">mathjs.partitionSelect.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.partitionSelect.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.permutations">module mathjs.permutations</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.permutations.factory">
            function <span class="apidocSignatureSpan">mathjs.permutations.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.permutations.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.physicalConstants">module mathjs.physicalConstants</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">mathjs.physicalConstants.</span>lazy</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">mathjs.physicalConstants.</span>math</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.physicalConstants.factory">
            function <span class="apidocSignatureSpan">mathjs.physicalConstants.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed, math)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.pickRandom">module mathjs.pickRandom</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.pickRandom.factory">
            function <span class="apidocSignatureSpan">mathjs.pickRandom.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.pickRandom.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.pow">module mathjs.pow</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.pow.factory">
            function <span class="apidocSignatureSpan">mathjs.pow.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.pow.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.print">module mathjs.print</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.print.factory">
            function <span class="apidocSignatureSpan">mathjs.print.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.print.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.prod">module mathjs.prod</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.prod.factory">
            function <span class="apidocSignatureSpan">mathjs.prod.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.prod.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.quantileSeq">module mathjs.quantileSeq</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.quantileSeq.factory">
            function <span class="apidocSignatureSpan">mathjs.quantileSeq.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.quantileSeq.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.random">module mathjs.random</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.random.factory">
            function <span class="apidocSignatureSpan">mathjs.random.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.random.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.randomInt">module mathjs.randomInt</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.randomInt.factory">
            function <span class="apidocSignatureSpan">mathjs.randomInt.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.randomInt.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.range">module mathjs.range</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.range.factory">
            function <span class="apidocSignatureSpan">mathjs.range.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.range.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.range_transform">module mathjs.range_transform</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.range_transform.factory">
            function <span class="apidocSignatureSpan">mathjs.range_transform.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.range_transform.</span>name</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.range_transform.</span>path</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.re">module mathjs.re</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.re.factory">
            function <span class="apidocSignatureSpan">mathjs.re.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.re.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.reshape">module mathjs.reshape</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.reshape.factory">
            function <span class="apidocSignatureSpan">mathjs.reshape.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.reshape.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.resize">module mathjs.resize</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.resize.factory">
            function <span class="apidocSignatureSpan">mathjs.resize.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.resize.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.reviver">module mathjs.reviver</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.reviver.factory">
            function <span class="apidocSignatureSpan">mathjs.reviver.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.reviver.</span>name</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.reviver.</span>path</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.rightArithShift">module mathjs.rightArithShift</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.rightArithShift.factory">
            function <span class="apidocSignatureSpan">mathjs.rightArithShift.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.rightArithShift.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.rightLogShift">module mathjs.rightLogShift</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.rightLogShift.factory">
            function <span class="apidocSignatureSpan">mathjs.rightLogShift.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.rightLogShift.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.round">module mathjs.round</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.round.factory">
            function <span class="apidocSignatureSpan">mathjs.round.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.round.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.sec">module mathjs.sec</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.sec.factory">
            function <span class="apidocSignatureSpan">mathjs.sec.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.sec.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.sech">module mathjs.sech</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.sech.factory">
            function <span class="apidocSignatureSpan">mathjs.sech.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.sech.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.sign">module mathjs.sign</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.sign.factory">
            function <span class="apidocSignatureSpan">mathjs.sign.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.sign.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.simplify">module mathjs.simplify</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.simplify.factory">
            function <span class="apidocSignatureSpan">mathjs.simplify.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.simplify.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.sin">module mathjs.sin</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.sin.factory">
            function <span class="apidocSignatureSpan">mathjs.sin.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.sin.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.sinh">module mathjs.sinh</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.sinh.factory">
            function <span class="apidocSignatureSpan">mathjs.sinh.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.sinh.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.size">module mathjs.size</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.size.factory">
            function <span class="apidocSignatureSpan">mathjs.size.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.size.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.smaller">module mathjs.smaller</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.smaller.factory">
            function <span class="apidocSignatureSpan">mathjs.smaller.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.smaller.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.smallerEq">module mathjs.smallerEq</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.smallerEq.factory">
            function <span class="apidocSignatureSpan">mathjs.smallerEq.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.smallerEq.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.sort">module mathjs.sort</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.sort.factory">
            function <span class="apidocSignatureSpan">mathjs.sort.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.sort.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.sqrt">module mathjs.sqrt</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.sqrt.factory">
            function <span class="apidocSignatureSpan">mathjs.sqrt.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.sqrt.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.square">module mathjs.square</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.square.factory">
            function <span class="apidocSignatureSpan">mathjs.square.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.square.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.squeeze">module mathjs.squeeze</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.squeeze.factory">
            function <span class="apidocSignatureSpan">mathjs.squeeze.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.squeeze.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.std">module mathjs.std</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.std.factory">
            function <span class="apidocSignatureSpan">mathjs.std.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.std.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.stirlingS2">module mathjs.stirlingS2</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.stirlingS2.factory">
            function <span class="apidocSignatureSpan">mathjs.stirlingS2.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.stirlingS2.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.string">module mathjs.string</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.string.factory">
            function <span class="apidocSignatureSpan">mathjs.string.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.string.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.subset">module mathjs.subset</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.subset.factory">
            function <span class="apidocSignatureSpan">mathjs.subset.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.subset.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.subset_transform">module mathjs.subset_transform</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.subset_transform.factory">
            function <span class="apidocSignatureSpan">mathjs.subset_transform.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.subset_transform.</span>name</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.subset_transform.</span>path</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.subtract">module mathjs.subtract</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.subtract.factory">
            function <span class="apidocSignatureSpan">mathjs.subtract.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.subtract.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.sum">module mathjs.sum</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.sum.factory">
            function <span class="apidocSignatureSpan">mathjs.sum.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.sum.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.tan">module mathjs.tan</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.tan.factory">
            function <span class="apidocSignatureSpan">mathjs.tan.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.tan.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.tanh">module mathjs.tanh</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.tanh.factory">
            function <span class="apidocSignatureSpan">mathjs.tanh.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.tanh.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.to">module mathjs.to</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.to.factory">
            function <span class="apidocSignatureSpan">mathjs.to.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.to.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.trace">module mathjs.trace</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.trace.factory">
            function <span class="apidocSignatureSpan">mathjs.trace.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.trace.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.transpose">module mathjs.transpose</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.transpose.factory">
            function <span class="apidocSignatureSpan">mathjs.transpose.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.transpose.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.type">module mathjs.type</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber">
            function <span class="apidocSignatureSpan">mathjs.type.</span>BigNumber
            <span class="apidocSignatureSpan">(v)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain">
            function <span class="apidocSignatureSpan">mathjs.type.</span>Chain
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Complex">
            function <span class="apidocSignatureSpan">mathjs.type.</span>Complex
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.DenseMatrix">
            function <span class="apidocSignatureSpan">mathjs.type.</span>DenseMatrix
            <span class="apidocSignatureSpan">(data, datatype)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.FibonacciHeap">
            function <span class="apidocSignatureSpan">mathjs.type.</span>FibonacciHeap
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Fraction">
            function <span class="apidocSignatureSpan">mathjs.type.</span>Fraction
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Help">
            function <span class="apidocSignatureSpan">mathjs.type.</span>Help
            <span class="apidocSignatureSpan">(doc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.ImmutableDenseMatrix">
            function <span class="apidocSignatureSpan">mathjs.type.</span>ImmutableDenseMatrix
            <span class="apidocSignatureSpan">(data, datatype)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Index">
            function <span class="apidocSignatureSpan">mathjs.type.</span>Index
            <span class="apidocSignatureSpan">(ranges)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Matrix">
            function <span class="apidocSignatureSpan">mathjs.type.</span>Matrix
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Range">
            function <span class="apidocSignatureSpan">mathjs.type.</span>Range
            <span class="apidocSignatureSpan">(start, end, step)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.ResultSet">
            function <span class="apidocSignatureSpan">mathjs.type.</span>ResultSet
            <span class="apidocSignatureSpan">(entries)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Spa">
            function <span class="apidocSignatureSpan">mathjs.type.</span>Spa
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.SparseMatrix">
            function <span class="apidocSignatureSpan">mathjs.type.</span>SparseMatrix
            <span class="apidocSignatureSpan">(data, datatype)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Unit">
            function <span class="apidocSignatureSpan">mathjs.type.</span>Unit
            <span class="apidocSignatureSpan">(value, name)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.type.BigNumber">module mathjs.type.BigNumber</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>crypto</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.BigNumber">
            function <span class="apidocSignatureSpan">mathjs.type.</span>BigNumber
            <span class="apidocSignatureSpan">(v)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.abs">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>abs
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.acos">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>acos
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.acosh">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>acosh
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.add">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>add
            <span class="apidocSignatureSpan">(x, y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.asin">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>asin
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.asinh">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>asinh
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.atan">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>atan
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.atan2">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>atan2
            <span class="apidocSignatureSpan">(y, x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.atanh">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>atanh
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.cbrt">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>cbrt
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.ceil">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>ceil
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.clone">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>clone
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.config">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>config
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.cos">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>cos
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.cosh">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>cosh
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.div">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>div
            <span class="apidocSignatureSpan">(x, y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.exp">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>exp
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.floor">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>floor
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.fromJSON">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>fromJSON
            <span class="apidocSignatureSpan">(json)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.hypot">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>hypot
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.ln">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>ln
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.log">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>log
            <span class="apidocSignatureSpan">(x, y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.log10">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>log10
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.log2">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>log2
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.max">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>max
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.min">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>min
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.mod">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>mod
            <span class="apidocSignatureSpan">(x, y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.mul">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>mul
            <span class="apidocSignatureSpan">(x, y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.pow">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>pow
            <span class="apidocSignatureSpan">(x, y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.random">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>random
            <span class="apidocSignatureSpan">(sd)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.round">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>round
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.set">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>set
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.sign">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>sign
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.sin">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>sin
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.sinh">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>sinh
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.sqrt">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>sqrt
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.sub">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>sub
            <span class="apidocSignatureSpan">(x, y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.tan">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>tan
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.tanh">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>tanh
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.trunc">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>trunc
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>EUCLID</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>ROUND_CEIL</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>ROUND_DOWN</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>ROUND_FLOOR</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>ROUND_HALF_CEIL</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>ROUND_HALF_DOWN</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>ROUND_HALF_EVEN</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>ROUND_HALF_FLOOR</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>ROUND_HALF_UP</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>ROUND_UP</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>maxE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>minE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>modulo</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>precision</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>rounding</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>toExpNeg</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>toExpPos</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.type.BigNumber.prototype">module mathjs.type.BigNumber.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>isBigNumber</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.abs">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>abs
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.absoluteValue">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>absoluteValue
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.acos">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>acos
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.acosh">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>acosh
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.add">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>add
            <span class="apidocSignatureSpan">(y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.asin">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>asin
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.asinh">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>asinh
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.atan">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>atan
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.atanh">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>atanh
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.cbrt">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>cbrt
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.ceil">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>ceil
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.cmp">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>cmp
            <span class="apidocSignatureSpan">(y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.comparedTo">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>comparedTo
            <span class="apidocSignatureSpan">(y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.cos">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>cos
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.cosh">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>cosh
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.cosine">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>cosine
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.cubeRoot">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>cubeRoot
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.decimalPlaces">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>decimalPlaces
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.div">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>div
            <span class="apidocSignatureSpan">(y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.divToInt">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>divToInt
            <span class="apidocSignatureSpan">(y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.dividedBy">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>dividedBy
            <span class="apidocSignatureSpan">(y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.dividedToIntegerBy">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>dividedToIntegerBy
            <span class="apidocSignatureSpan">(y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.dp">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>dp
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.eq">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>eq
            <span class="apidocSignatureSpan">(y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.equals">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>equals
            <span class="apidocSignatureSpan">(y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.exp">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>exp
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.floor">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>floor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.greaterThan">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>greaterThan
            <span class="apidocSignatureSpan">(y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.greaterThanOrEqualTo">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>greaterThanOrEqualTo
            <span class="apidocSignatureSpan">(y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.gt">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>gt
            <span class="apidocSignatureSpan">(y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.gte">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>gte
            <span class="apidocSignatureSpan">(y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.hyperbolicCosine">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>hyperbolicCosine
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.hyperbolicSine">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>hyperbolicSine
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.hyperbolicTangent">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>hyperbolicTangent
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.inverseCosine">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>inverseCosine
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.inverseHyperbolicCosine">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>inverseHyperbolicCosine
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.inverseHyperbolicSine">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>inverseHyperbolicSine
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.inverseHyperbolicTangent">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>inverseHyperbolicTangent
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.inverseSine">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>inverseSine
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.inverseTangent">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>inverseTangent
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.isFinite">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>isFinite
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.isInt">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>isInt
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.isInteger">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>isInteger
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.isNaN">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>isNaN
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.isNeg">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>isNeg
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.isNegative">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>isNegative
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.isPos">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>isPos
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.isPositive">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>isPositive
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.isZero">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>isZero
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.lessThan">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>lessThan
            <span class="apidocSignatureSpan">(y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.lessThanOrEqualTo">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>lessThanOrEqualTo
            <span class="apidocSignatureSpan">(y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.ln">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>ln
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.log">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>log
            <span class="apidocSignatureSpan">(base)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.logarithm">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>logarithm
            <span class="apidocSignatureSpan">(base)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.lt">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>lt
            <span class="apidocSignatureSpan">(y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.lte">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>lte
            <span class="apidocSignatureSpan">(y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.minus">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>minus
            <span class="apidocSignatureSpan">(y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.mod">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>mod
            <span class="apidocSignatureSpan">(y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.modulo">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>modulo
            <span class="apidocSignatureSpan">(y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.mul">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>mul
            <span class="apidocSignatureSpan">(y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.naturalExponential">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>naturalExponential
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.naturalLogarithm">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>naturalLogarithm
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.neg">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>neg
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.negated">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>negated
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.plus">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>plus
            <span class="apidocSignatureSpan">(y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.pow">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>pow
            <span class="apidocSignatureSpan">(y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.precision">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>precision
            <span class="apidocSignatureSpan">(z)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.round">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>round
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.sd">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>sd
            <span class="apidocSignatureSpan">(z)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.sin">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>sin
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.sine">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>sine
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.sinh">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>sinh
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.sqrt">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>sqrt
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.squareRoot">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>squareRoot
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.sub">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>sub
            <span class="apidocSignatureSpan">(y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.tan">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>tan
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.tangent">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>tangent
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.tanh">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>tanh
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.times">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>times
            <span class="apidocSignatureSpan">(y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.toBinary">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>toBinary
            <span class="apidocSignatureSpan">(sd, rm)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.toDP">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>toDP
            <span class="apidocSignatureSpan">(dp, rm)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.toDecimalPlaces">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>toDecimalPlaces
            <span class="apidocSignatureSpan">(dp, rm)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.toExponential">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>toExponential
            <span class="apidocSignatureSpan">(dp, rm)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.toFixed">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>toFixed
            <span class="apidocSignatureSpan">(dp, rm)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.toFraction">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>toFraction
            <span class="apidocSignatureSpan">(maxD)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.toHex">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>toHex
            <span class="apidocSignatureSpan">(sd, rm)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.toHexadecimal">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>toHexadecimal
            <span class="apidocSignatureSpan">(sd, rm)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.toJSON">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.toNearest">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>toNearest
            <span class="apidocSignatureSpan">(y, rm)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.toNumber">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>toNumber
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.toOctal">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>toOctal
            <span class="apidocSignatureSpan">(sd, rm)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.toPower">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>toPower
            <span class="apidocSignatureSpan">(y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.toPrecision">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>toPrecision
            <span class="apidocSignatureSpan">(sd, rm)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.toSD">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>toSD
            <span class="apidocSignatureSpan">(sd, rm)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.toSignificantDigits">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>toSignificantDigits
            <span class="apidocSignatureSpan">(sd, rm)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.toString">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.trunc">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>trunc
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.truncated">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>truncated
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.BigNumber.prototype.valueOf">
            function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>valueOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.type.Chain">module mathjs.type.Chain</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.Chain">
            function <span class="apidocSignatureSpan">mathjs.type.</span>Chain
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.createProxy">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.</span>createProxy
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.type.Chain.prototype">module mathjs.type.Chain.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>isChain</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.abs">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>abs
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.acos">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>acos
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.acosh">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>acosh
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.acot">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>acot
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.acoth">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>acoth
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.acsc">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>acsc
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.acsch">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>acsch
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.add">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>add
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.and">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>and
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.arg">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>arg
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.asec">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>asec
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.asech">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>asech
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.asin">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>asin
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.asinh">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>asinh
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.atan">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>atan
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.atan2">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>atan2
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.atanh">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>atanh
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.bellNumbers">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>bellNumbers
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.bignumber">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>bignumber
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.bitAnd">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>bitAnd
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.bitNot">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>bitNot
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.bitOr">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>bitOr
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.bitXor">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>bitXor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.boolean">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>boolean
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.catalan">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>catalan
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.cbrt">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>cbrt
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.ceil">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>ceil
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.chain">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>chain
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.clone">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>clone
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.combinations">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>combinations
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.compare">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>compare
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.compile">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>compile
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.complex">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>complex
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.composition">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>composition
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.concat">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>concat
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.config">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>config
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.conj">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>conj
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.cos">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>cos
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.cosh">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>cosh
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.cot">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>cot
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.coth">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>coth
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.create">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>create
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.createUnit">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>createUnit
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.cross">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>cross
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.csc">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>csc
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.csch">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>csch
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.cube">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>cube
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.deepEqual">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>deepEqual
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.derivative">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>derivative
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.det">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>det
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.diag">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>diag
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.distance">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>distance
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.divide">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>divide
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.done">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>done
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.dot">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>dot
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.dotDivide">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>dotDivide
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.dotMultiply">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>dotMultiply
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.dotPow">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>dotPow
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.emit">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>emit
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.equal">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>equal
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.erf">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>erf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.eval">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>eval
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.exp">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>exp
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.eye">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>eye
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.factorial">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>factorial
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.filter">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>filter
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.fix">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>fix
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.flatten">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>flatten
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.floor">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>floor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.forEach">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>forEach
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.format">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>format
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.fraction">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>fraction
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.gamma">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>gamma
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.gcd">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>gcd
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.help">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>help
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.hypot">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>hypot
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.im">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>im
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.import">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>import
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.index">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>index
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.intersect">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>intersect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.inv">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>inv
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.isInteger">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>isInteger
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.isNaN">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>isNaN
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.isNegative">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>isNegative
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.isNumeric">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>isNumeric
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.isPositive">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>isPositive
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.isPrime">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>isPrime
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.isZero">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>isZero
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.kldivergence">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>kldivergence
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.kron">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>kron
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.larger">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>larger
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.largerEq">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>largerEq
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.lcm">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>lcm
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.leftShift">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>leftShift
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.log">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>log
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.log10">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>log10
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.lsolve">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>lsolve
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.lup">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>lup
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.lusolve">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>lusolve
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.mad">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>mad
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.map">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>map
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.matrix">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>matrix
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.max">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>max
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.mean">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>mean
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.median">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>median
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.min">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>min
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.mod">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>mod
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.mode">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>mode
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.multinomial">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>multinomial
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.multiply">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>multiply
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.norm">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>norm
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.not">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>not
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.nthRoot">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>nthRoot
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.number">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>number
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.off">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>off
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.on">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>on
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.once">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>once
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.ones">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>ones
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.or">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>or
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.parse">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>parse
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.parser">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>parser
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.partitionSelect">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>partitionSelect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.permutations">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>permutations
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.pow">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>pow
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.print">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>print
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.prod">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>prod
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.qr">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>qr
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.quantileSeq">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>quantileSeq
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.range">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>range
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.re">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>re
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.reshape">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>reshape
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.resize">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>resize
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.rightArithShift">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>rightArithShift
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.rightLogShift">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>rightLogShift
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.round">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>round
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.sec">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>sec
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.sech">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>sech
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.sign">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>sign
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.simplify">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>simplify
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.sin">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>sin
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.sinh">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>sinh
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.size">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>size
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.slu">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>slu
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.smaller">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>smaller
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.smallerEq">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>smallerEq
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.sort">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>sort
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.sparse">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>sparse
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.splitUnit">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>splitUnit
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.sqrt">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>sqrt
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.square">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>square
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.squeeze">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>squeeze
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.std">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>std
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.stirlingS2">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>stirlingS2
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.string">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>string
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.subset">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>subset
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.subtract">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>subtract
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.sum">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>sum
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.tan">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>tan
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.tanh">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>tanh
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.to">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>to
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.toString">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.trace">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>trace
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.transpose">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>transpose
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.typed">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>typed
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.typeof">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>typeof
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.unaryMinus">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>unaryMinus
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.unaryPlus">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>unaryPlus
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.unequal">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>unequal
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.unit">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>unit
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.usolve">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>usolve
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.valueOf">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>valueOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.var">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>var
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.xgcd">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>xgcd
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.xor">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>xor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Chain.prototype.zeros">
            function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>zeros
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.type.Complex">module mathjs.type.Complex</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Complex.Complex">
            function <span class="apidocSignatureSpan">mathjs.type.</span>Complex
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Complex.fromJSON">
            function <span class="apidocSignatureSpan">mathjs.type.Complex.</span>fromJSON
            <span class="apidocSignatureSpan">(json)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Complex.fromPolar">
            function <span class="apidocSignatureSpan">mathjs.type.Complex.</span>fromPolar
            <span class="apidocSignatureSpan">(args)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mathjs.type.Complex.</span>EPSILON</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.type.Complex.</span>E</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.type.Complex.</span>I</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.type.Complex.</span>ONE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.type.Complex.</span>PI</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.type.Complex.</span>ZERO</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.type.Complex.prototype">module mathjs.type.Complex.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>isComplex</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Complex.prototype.abs">
            function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>abs
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Complex.prototype.acos">
            function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>acos
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Complex.prototype.acosh">
            function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>acosh
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Complex.prototype.acot">
            function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>acot
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Complex.prototype.acoth">
            function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>acoth
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Complex.prototype.acsc">
            function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>acsc
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Complex.prototype.acsch">
            function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>acsch
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Complex.prototype.add">
            function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>add
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Complex.prototype.arg">
            function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>arg
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Complex.prototype.asec">
            function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>asec
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Complex.prototype.asech">
            function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>asech
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Complex.prototype.asin">
            function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>asin
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Complex.prototype.asinh">
            function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>asinh
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Complex.prototype.atan">
            function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>atan
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Complex.prototype.atanh">
            function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>atanh
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Complex.prototype.ceil">
            function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>ceil
            <span class="apidocSignatureSpan">(places)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Complex.prototype.clone">
            function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>clone
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Complex.prototype.conjugate">
            function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>conjugate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Complex.prototype.cos">
            function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>cos
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Complex.prototype.cosh">
            function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>cosh
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Complex.prototype.cot">
            function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>cot
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Complex.prototype.coth">
            function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>coth
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Complex.prototype.csc">
            function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>csc
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Complex.prototype.csch">
            function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>csch
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Complex.prototype.div">
            function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>div
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Complex.prototype.equals">
            function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>equals
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Complex.prototype.exp">
            function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>exp
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Complex.prototype.floor">
            function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>floor
            <span class="apidocSignatureSpan">(places)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Complex.prototype.format">
            function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>format
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Complex.prototype.inverse">
            function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>inverse
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Complex.prototype.isNaN">
            function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>isNaN
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Complex.prototype.log">
            function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>log
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Complex.prototype.mul">
            function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>mul
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Complex.prototype.neg">
            function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>neg
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Complex.prototype.pow">
            function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>pow
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Complex.prototype.round">
            function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>round
            <span class="apidocSignatureSpan">(places)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Complex.prototype.sec">
            function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>sec
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Complex.prototype.sech">
            function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>sech
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Complex.prototype.sign">
            function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>sign
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Complex.prototype.sin">
            function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>sin
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Complex.prototype.sinh">
            function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>sinh
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Complex.prototype.sqrt">
            function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>sqrt
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Complex.prototype.sub">
            function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>sub
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Complex.prototype.tan">
            function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>tan
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Complex.prototype.tanh">
            function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>tanh
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Complex.prototype.toJSON">
            function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Complex.prototype.toPolar">
            function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>toPolar
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Complex.prototype.toString">
            function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Complex.prototype.toVector">
            function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>toVector
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Complex.prototype.valueOf">
            function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>valueOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>im</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>re</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.type.DenseMatrix">module mathjs.type.DenseMatrix</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.DenseMatrix.DenseMatrix">
            function <span class="apidocSignatureSpan">mathjs.type.</span>DenseMatrix
            <span class="apidocSignatureSpan">(data, datatype)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.DenseMatrix._swapRows">
            function <span class="apidocSignatureSpan">mathjs.type.DenseMatrix.</span>_swapRows
            <span class="apidocSignatureSpan">(i, j, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.DenseMatrix.diagonal">
            function <span class="apidocSignatureSpan">mathjs.type.DenseMatrix.</span>diagonal
            <span class="apidocSignatureSpan">(size, value, k, defaultValue, datatype)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.DenseMatrix.fromJSON">
            function <span class="apidocSignatureSpan">mathjs.type.DenseMatrix.</span>fromJSON
            <span class="apidocSignatureSpan">(json)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.type.DenseMatrix.prototype">module mathjs.type.DenseMatrix.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">mathjs.type.DenseMatrix.prototype.</span>isDenseMatrix</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.DenseMatrix.prototype.clone">
            function <span class="apidocSignatureSpan">mathjs.type.DenseMatrix.prototype.</span>clone
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.DenseMatrix.prototype.create">
            function <span class="apidocSignatureSpan">mathjs.type.DenseMatrix.prototype.</span>create
            <span class="apidocSignatureSpan">(data, datatype)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.DenseMatrix.prototype.datatype">
            function <span class="apidocSignatureSpan">mathjs.type.DenseMatrix.prototype.</span>datatype
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.DenseMatrix.prototype.diagonal">
            function <span class="apidocSignatureSpan">mathjs.type.DenseMatrix.prototype.</span>diagonal
            <span class="apidocSignatureSpan">(k)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.DenseMatrix.prototype.forEach">
            function <span class="apidocSignatureSpan">mathjs.type.DenseMatrix.prototype.</span>forEach
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.DenseMatrix.prototype.format">
            function <span class="apidocSignatureSpan">mathjs.type.DenseMatrix.prototype.</span>format
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.DenseMatrix.prototype.get">
            function <span class="apidocSignatureSpan">mathjs.type.DenseMatrix.prototype.</span>get
            <span class="apidocSignatureSpan">(index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.DenseMatrix.prototype.map">
            function <span class="apidocSignatureSpan">mathjs.type.DenseMatrix.prototype.</span>map
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.DenseMatrix.prototype.reshape">
            function <span class="apidocSignatureSpan">mathjs.type.DenseMatrix.prototype.</span>reshape
            <span class="apidocSignatureSpan">(size, copy)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.DenseMatrix.prototype.resize">
            function <span class="apidocSignatureSpan">mathjs.type.DenseMatrix.prototype.</span>resize
            <span class="apidocSignatureSpan">(size, defaultValue, copy)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.DenseMatrix.prototype.set">
            function <span class="apidocSignatureSpan">mathjs.type.DenseMatrix.prototype.</span>set
            <span class="apidocSignatureSpan">(index, value, defaultValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.DenseMatrix.prototype.size">
            function <span class="apidocSignatureSpan">mathjs.type.DenseMatrix.prototype.</span>size
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.DenseMatrix.prototype.storage">
            function <span class="apidocSignatureSpan">mathjs.type.DenseMatrix.prototype.</span>storage
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.DenseMatrix.prototype.subset">
            function <span class="apidocSignatureSpan">mathjs.type.DenseMatrix.prototype.</span>subset
            <span class="apidocSignatureSpan">(index, replacement, defaultValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.DenseMatrix.prototype.swapRows">
            function <span class="apidocSignatureSpan">mathjs.type.DenseMatrix.prototype.</span>swapRows
            <span class="apidocSignatureSpan">(i, j)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.DenseMatrix.prototype.toArray">
            function <span class="apidocSignatureSpan">mathjs.type.DenseMatrix.prototype.</span>toArray
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.DenseMatrix.prototype.toJSON">
            function <span class="apidocSignatureSpan">mathjs.type.DenseMatrix.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.DenseMatrix.prototype.toString">
            function <span class="apidocSignatureSpan">mathjs.type.DenseMatrix.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.DenseMatrix.prototype.valueOf">
            function <span class="apidocSignatureSpan">mathjs.type.DenseMatrix.prototype.</span>valueOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.type.DenseMatrix.prototype.</span>type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.type.FibonacciHeap">module mathjs.type.FibonacciHeap</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.FibonacciHeap.FibonacciHeap">
            function <span class="apidocSignatureSpan">mathjs.type.</span>FibonacciHeap
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.type.FibonacciHeap.prototype">module mathjs.type.FibonacciHeap.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">mathjs.type.FibonacciHeap.prototype.</span>isFibonacciHeap</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.FibonacciHeap.prototype.clear">
            function <span class="apidocSignatureSpan">mathjs.type.FibonacciHeap.prototype.</span>clear
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.FibonacciHeap.prototype.extractMinimum">
            function <span class="apidocSignatureSpan">mathjs.type.FibonacciHeap.prototype.</span>extractMinimum
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.FibonacciHeap.prototype.insert">
            function <span class="apidocSignatureSpan">mathjs.type.FibonacciHeap.prototype.</span>insert
            <span class="apidocSignatureSpan">(key, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.FibonacciHeap.prototype.isEmpty">
            function <span class="apidocSignatureSpan">mathjs.type.FibonacciHeap.prototype.</span>isEmpty
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.FibonacciHeap.prototype.remove">
            function <span class="apidocSignatureSpan">mathjs.type.FibonacciHeap.prototype.</span>remove
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.FibonacciHeap.prototype.size">
            function <span class="apidocSignatureSpan">mathjs.type.FibonacciHeap.prototype.</span>size
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.type.FibonacciHeap.prototype.</span>type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.type.Fraction">module mathjs.type.Fraction</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Fraction.Fraction">
            function <span class="apidocSignatureSpan">mathjs.type.</span>Fraction
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Fraction.DivisionByZero">
            function <span class="apidocSignatureSpan">mathjs.type.Fraction.</span>DivisionByZero
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Fraction.InvalidParameter">
            function <span class="apidocSignatureSpan">mathjs.type.Fraction.</span>InvalidParameter
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Fraction.fromJSON">
            function <span class="apidocSignatureSpan">mathjs.type.Fraction.</span>fromJSON
            <span class="apidocSignatureSpan">(json)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mathjs.type.Fraction.</span>REDUCE</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.type.Fraction.prototype">module mathjs.type.Fraction.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">mathjs.type.Fraction.prototype.</span>isFraction</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Fraction.prototype.abs">
            function <span class="apidocSignatureSpan">mathjs.type.Fraction.prototype.</span>abs
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Fraction.prototype.add">
            function <span class="apidocSignatureSpan">mathjs.type.Fraction.prototype.</span>add
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Fraction.prototype.ceil">
            function <span class="apidocSignatureSpan">mathjs.type.Fraction.prototype.</span>ceil
            <span class="apidocSignatureSpan">(places)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Fraction.prototype.clone">
            function <span class="apidocSignatureSpan">mathjs.type.Fraction.prototype.</span>clone
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Fraction.prototype.compare">
            function <span class="apidocSignatureSpan">mathjs.type.Fraction.prototype.</span>compare
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Fraction.prototype.div">
            function <span class="apidocSignatureSpan">mathjs.type.Fraction.prototype.</span>div
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Fraction.prototype.divisible">
            function <span class="apidocSignatureSpan">mathjs.type.Fraction.prototype.</span>divisible
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Fraction.prototype.equals">
            function <span class="apidocSignatureSpan">mathjs.type.Fraction.prototype.</span>equals
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Fraction.prototype.floor">
            function <span class="apidocSignatureSpan">mathjs.type.Fraction.prototype.</span>floor
            <span class="apidocSignatureSpan">(places)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Fraction.prototype.gcd">
            function <span class="apidocSignatureSpan">mathjs.type.Fraction.prototype.</span>gcd
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Fraction.prototype.inverse">
            function <span class="apidocSignatureSpan">mathjs.type.Fraction.prototype.</span>inverse
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Fraction.prototype.lcm">
            function <span class="apidocSignatureSpan">mathjs.type.Fraction.prototype.</span>lcm
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Fraction.prototype.mod">
            function <span class="apidocSignatureSpan">mathjs.type.Fraction.prototype.</span>mod
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Fraction.prototype.mul">
            function <span class="apidocSignatureSpan">mathjs.type.Fraction.prototype.</span>mul
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Fraction.prototype.neg">
            function <span class="apidocSignatureSpan">mathjs.type.Fraction.prototype.</span>neg
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Fraction.prototype.pow">
            function <span class="apidocSignatureSpan">mathjs.type.Fraction.prototype.</span>pow
            <span class="apidocSignatureSpan">(m)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Fraction.prototype.round">
            function <span class="apidocSignatureSpan">mathjs.type.Fraction.prototype.</span>round
            <span class="apidocSignatureSpan">(places)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Fraction.prototype.sub">
            function <span class="apidocSignatureSpan">mathjs.type.Fraction.prototype.</span>sub
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Fraction.prototype.toContinued">
            function <span class="apidocSignatureSpan">mathjs.type.Fraction.prototype.</span>toContinued
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Fraction.prototype.toFraction">
            function <span class="apidocSignatureSpan">mathjs.type.Fraction.prototype.</span>toFraction
            <span class="apidocSignatureSpan">(excludeWhole)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Fraction.prototype.toJSON">
            function <span class="apidocSignatureSpan">mathjs.type.Fraction.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Fraction.prototype.toLatex">
            function <span class="apidocSignatureSpan">mathjs.type.Fraction.prototype.</span>toLatex
            <span class="apidocSignatureSpan">(excludeWhole)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Fraction.prototype.toString">
            function <span class="apidocSignatureSpan">mathjs.type.Fraction.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Fraction.prototype.valueOf">
            function <span class="apidocSignatureSpan">mathjs.type.Fraction.prototype.</span>valueOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mathjs.type.Fraction.prototype.</span>d</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mathjs.type.Fraction.prototype.</span>n</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">mathjs.type.Fraction.prototype.</span>s</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.type.Fraction.prototype.</span>type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.type.Help">module mathjs.type.Help</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Help.Help">
            function <span class="apidocSignatureSpan">mathjs.type.</span>Help
            <span class="apidocSignatureSpan">(doc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Help.fromJSON">
            function <span class="apidocSignatureSpan">mathjs.type.Help.</span>fromJSON
            <span class="apidocSignatureSpan">(json)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.type.Help.prototype">module mathjs.type.Help.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">mathjs.type.Help.prototype.</span>isHelp</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Help.prototype.toJSON">
            function <span class="apidocSignatureSpan">mathjs.type.Help.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Help.prototype.toString">
            function <span class="apidocSignatureSpan">mathjs.type.Help.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Help.prototype.valueOf">
            function <span class="apidocSignatureSpan">mathjs.type.Help.prototype.</span>valueOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.type.Help.prototype.</span>type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.type.ImmutableDenseMatrix">module mathjs.type.ImmutableDenseMatrix</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.ImmutableDenseMatrix.ImmutableDenseMatrix">
            function <span class="apidocSignatureSpan">mathjs.type.</span>ImmutableDenseMatrix
            <span class="apidocSignatureSpan">(data, datatype)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.ImmutableDenseMatrix.fromJSON">
            function <span class="apidocSignatureSpan">mathjs.type.ImmutableDenseMatrix.</span>fromJSON
            <span class="apidocSignatureSpan">(json)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.type.ImmutableDenseMatrix.prototype">module mathjs.type.ImmutableDenseMatrix.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">mathjs.type.ImmutableDenseMatrix.prototype.</span>isImmutableDenseMatrix</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.ImmutableDenseMatrix.prototype.clone">
            function <span class="apidocSignatureSpan">mathjs.type.ImmutableDenseMatrix.prototype.</span>clone
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.ImmutableDenseMatrix.prototype.max">
            function <span class="apidocSignatureSpan">mathjs.type.ImmutableDenseMatrix.prototype.</span>max
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.ImmutableDenseMatrix.prototype.min">
            function <span class="apidocSignatureSpan">mathjs.type.ImmutableDenseMatrix.prototype.</span>min
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.ImmutableDenseMatrix.prototype.reshape">
            function <span class="apidocSignatureSpan">mathjs.type.ImmutableDenseMatrix.prototype.</span>reshape
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.ImmutableDenseMatrix.prototype.resize">
            function <span class="apidocSignatureSpan">mathjs.type.ImmutableDenseMatrix.prototype.</span>resize
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.ImmutableDenseMatrix.prototype.set">
            function <span class="apidocSignatureSpan">mathjs.type.ImmutableDenseMatrix.prototype.</span>set
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.ImmutableDenseMatrix.prototype.subset">
            function <span class="apidocSignatureSpan">mathjs.type.ImmutableDenseMatrix.prototype.</span>subset
            <span class="apidocSignatureSpan">(index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.ImmutableDenseMatrix.prototype.swapRows">
            function <span class="apidocSignatureSpan">mathjs.type.ImmutableDenseMatrix.prototype.</span>swapRows
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.ImmutableDenseMatrix.prototype.toJSON">
            function <span class="apidocSignatureSpan">mathjs.type.ImmutableDenseMatrix.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.type.ImmutableDenseMatrix.prototype.</span>_data</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.type.ImmutableDenseMatrix.prototype.</span>_size</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.type.ImmutableDenseMatrix.prototype.</span>type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.type.Index">module mathjs.type.Index</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Index.Index">
            function <span class="apidocSignatureSpan">mathjs.type.</span>Index
            <span class="apidocSignatureSpan">(ranges)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Index.create">
            function <span class="apidocSignatureSpan">mathjs.type.Index.</span>create
            <span class="apidocSignatureSpan">(ranges)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Index.fromJSON">
            function <span class="apidocSignatureSpan">mathjs.type.Index.</span>fromJSON
            <span class="apidocSignatureSpan">(json)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.type.Index.prototype">module mathjs.type.Index.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">mathjs.type.Index.prototype.</span>isIndex</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Index.prototype.clone">
            function <span class="apidocSignatureSpan">mathjs.type.Index.prototype.</span>clone
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Index.prototype.dimension">
            function <span class="apidocSignatureSpan">mathjs.type.Index.prototype.</span>dimension
            <span class="apidocSignatureSpan">(dim)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Index.prototype.forEach">
            function <span class="apidocSignatureSpan">mathjs.type.Index.prototype.</span>forEach
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Index.prototype.getObjectProperty">
            function <span class="apidocSignatureSpan">mathjs.type.Index.prototype.</span>getObjectProperty
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Index.prototype.isObjectProperty">
            function <span class="apidocSignatureSpan">mathjs.type.Index.prototype.</span>isObjectProperty
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Index.prototype.isScalar">
            function <span class="apidocSignatureSpan">mathjs.type.Index.prototype.</span>isScalar
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Index.prototype.max">
            function <span class="apidocSignatureSpan">mathjs.type.Index.prototype.</span>max
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Index.prototype.min">
            function <span class="apidocSignatureSpan">mathjs.type.Index.prototype.</span>min
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Index.prototype.size">
            function <span class="apidocSignatureSpan">mathjs.type.Index.prototype.</span>size
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Index.prototype.toArray">
            function <span class="apidocSignatureSpan">mathjs.type.Index.prototype.</span>toArray
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Index.prototype.toJSON">
            function <span class="apidocSignatureSpan">mathjs.type.Index.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Index.prototype.toString">
            function <span class="apidocSignatureSpan">mathjs.type.Index.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Index.prototype.valueOf">
            function <span class="apidocSignatureSpan">mathjs.type.Index.prototype.</span>valueOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.type.Index.prototype.</span>type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.type.Matrix">module mathjs.type.Matrix</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Matrix.Matrix">
            function <span class="apidocSignatureSpan">mathjs.type.</span>Matrix
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Matrix.storage">
            function <span class="apidocSignatureSpan">mathjs.type.Matrix.</span>storage
            <span class="apidocSignatureSpan">(format)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.type.Matrix.</span>_storage</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.type.Matrix.prototype">module mathjs.type.Matrix.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">mathjs.type.Matrix.prototype.</span>isMatrix</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Matrix.prototype.clone">
            function <span class="apidocSignatureSpan">mathjs.type.Matrix.prototype.</span>clone
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Matrix.prototype.create">
            function <span class="apidocSignatureSpan">mathjs.type.Matrix.prototype.</span>create
            <span class="apidocSignatureSpan">(data, datatype)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Matrix.prototype.datatype">
            function <span class="apidocSignatureSpan">mathjs.type.Matrix.prototype.</span>datatype
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Matrix.prototype.forEach">
            function <span class="apidocSignatureSpan">mathjs.type.Matrix.prototype.</span>forEach
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Matrix.prototype.format">
            function <span class="apidocSignatureSpan">mathjs.type.Matrix.prototype.</span>format
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Matrix.prototype.get">
            function <span class="apidocSignatureSpan">mathjs.type.Matrix.prototype.</span>get
            <span class="apidocSignatureSpan">(index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Matrix.prototype.map">
            function <span class="apidocSignatureSpan">mathjs.type.Matrix.prototype.</span>map
            <span class="apidocSignatureSpan">(callback, skipZeros)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Matrix.prototype.reshape">
            function <span class="apidocSignatureSpan">mathjs.type.Matrix.prototype.</span>reshape
            <span class="apidocSignatureSpan">(size, defaultValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Matrix.prototype.resize">
            function <span class="apidocSignatureSpan">mathjs.type.Matrix.prototype.</span>resize
            <span class="apidocSignatureSpan">(size, defaultValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Matrix.prototype.set">
            function <span class="apidocSignatureSpan">mathjs.type.Matrix.prototype.</span>set
            <span class="apidocSignatureSpan">(index, value, defaultValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Matrix.prototype.size">
            function <span class="apidocSignatureSpan">mathjs.type.Matrix.prototype.</span>size
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Matrix.prototype.storage">
            function <span class="apidocSignatureSpan">mathjs.type.Matrix.prototype.</span>storage
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Matrix.prototype.subset">
            function <span class="apidocSignatureSpan">mathjs.type.Matrix.prototype.</span>subset
            <span class="apidocSignatureSpan">(index, replacement, defaultValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Matrix.prototype.toArray">
            function <span class="apidocSignatureSpan">mathjs.type.Matrix.prototype.</span>toArray
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Matrix.prototype.toString">
            function <span class="apidocSignatureSpan">mathjs.type.Matrix.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Matrix.prototype.valueOf">
            function <span class="apidocSignatureSpan">mathjs.type.Matrix.prototype.</span>valueOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.type.Matrix.prototype.</span>type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.type.Range">module mathjs.type.Range</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Range.Range">
            function <span class="apidocSignatureSpan">mathjs.type.</span>Range
            <span class="apidocSignatureSpan">(start, end, step)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Range.fromJSON">
            function <span class="apidocSignatureSpan">mathjs.type.Range.</span>fromJSON
            <span class="apidocSignatureSpan">(json)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Range.parse">
            function <span class="apidocSignatureSpan">mathjs.type.Range.</span>parse
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.type.Range.prototype">module mathjs.type.Range.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">mathjs.type.Range.prototype.</span>isRange</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Range.prototype.clone">
            function <span class="apidocSignatureSpan">mathjs.type.Range.prototype.</span>clone
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Range.prototype.forEach">
            function <span class="apidocSignatureSpan">mathjs.type.Range.prototype.</span>forEach
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Range.prototype.format">
            function <span class="apidocSignatureSpan">mathjs.type.Range.prototype.</span>format
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Range.prototype.map">
            function <span class="apidocSignatureSpan">mathjs.type.Range.prototype.</span>map
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Range.prototype.max">
            function <span class="apidocSignatureSpan">mathjs.type.Range.prototype.</span>max
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Range.prototype.min">
            function <span class="apidocSignatureSpan">mathjs.type.Range.prototype.</span>min
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Range.prototype.size">
            function <span class="apidocSignatureSpan">mathjs.type.Range.prototype.</span>size
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Range.prototype.toArray">
            function <span class="apidocSignatureSpan">mathjs.type.Range.prototype.</span>toArray
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Range.prototype.toJSON">
            function <span class="apidocSignatureSpan">mathjs.type.Range.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Range.prototype.toString">
            function <span class="apidocSignatureSpan">mathjs.type.Range.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Range.prototype.valueOf">
            function <span class="apidocSignatureSpan">mathjs.type.Range.prototype.</span>valueOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.type.Range.prototype.</span>type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.type.ResultSet">module mathjs.type.ResultSet</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.ResultSet.ResultSet">
            function <span class="apidocSignatureSpan">mathjs.type.</span>ResultSet
            <span class="apidocSignatureSpan">(entries)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.ResultSet.fromJSON">
            function <span class="apidocSignatureSpan">mathjs.type.ResultSet.</span>fromJSON
            <span class="apidocSignatureSpan">(json)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.type.ResultSet.prototype">module mathjs.type.ResultSet.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">mathjs.type.ResultSet.prototype.</span>isResultSet</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.ResultSet.prototype.toJSON">
            function <span class="apidocSignatureSpan">mathjs.type.ResultSet.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.ResultSet.prototype.toString">
            function <span class="apidocSignatureSpan">mathjs.type.ResultSet.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.ResultSet.prototype.valueOf">
            function <span class="apidocSignatureSpan">mathjs.type.ResultSet.prototype.</span>valueOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.type.ResultSet.prototype.</span>type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.type.Spa">module mathjs.type.Spa</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Spa.Spa">
            function <span class="apidocSignatureSpan">mathjs.type.</span>Spa
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.type.Spa.prototype">module mathjs.type.Spa.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">mathjs.type.Spa.prototype.</span>isSpa</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Spa.prototype.accumulate">
            function <span class="apidocSignatureSpan">mathjs.type.Spa.prototype.</span>accumulate
            <span class="apidocSignatureSpan">(i, v)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Spa.prototype.forEach">
            function <span class="apidocSignatureSpan">mathjs.type.Spa.prototype.</span>forEach
            <span class="apidocSignatureSpan">(from, to, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Spa.prototype.get">
            function <span class="apidocSignatureSpan">mathjs.type.Spa.prototype.</span>get
            <span class="apidocSignatureSpan">(i)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Spa.prototype.set">
            function <span class="apidocSignatureSpan">mathjs.type.Spa.prototype.</span>set
            <span class="apidocSignatureSpan">(i, v)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Spa.prototype.swap">
            function <span class="apidocSignatureSpan">mathjs.type.Spa.prototype.</span>swap
            <span class="apidocSignatureSpan">(i, j)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.type.Spa.prototype.</span>type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.type.SparseMatrix">module mathjs.type.SparseMatrix</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.SparseMatrix.SparseMatrix">
            function <span class="apidocSignatureSpan">mathjs.type.</span>SparseMatrix
            <span class="apidocSignatureSpan">(data, datatype)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.SparseMatrix._forEachRow">
            function <span class="apidocSignatureSpan">mathjs.type.SparseMatrix.</span>_forEachRow
            <span class="apidocSignatureSpan">(j, values, index, ptr, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.SparseMatrix._swapRows">
            function <span class="apidocSignatureSpan">mathjs.type.SparseMatrix.</span>_swapRows
            <span class="apidocSignatureSpan">(x, y, columns, values, index, ptr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.SparseMatrix.diagonal">
            function <span class="apidocSignatureSpan">mathjs.type.SparseMatrix.</span>diagonal
            <span class="apidocSignatureSpan">(size, value, k, defaultValue, datatype)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.SparseMatrix.fromJSON">
            function <span class="apidocSignatureSpan">mathjs.type.SparseMatrix.</span>fromJSON
            <span class="apidocSignatureSpan">(json)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.type.SparseMatrix.prototype">module mathjs.type.SparseMatrix.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">mathjs.type.SparseMatrix.prototype.</span>isSparseMatrix</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.SparseMatrix.prototype.clone">
            function <span class="apidocSignatureSpan">mathjs.type.SparseMatrix.prototype.</span>clone
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.SparseMatrix.prototype.create">
            function <span class="apidocSignatureSpan">mathjs.type.SparseMatrix.prototype.</span>create
            <span class="apidocSignatureSpan">(data, datatype)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.SparseMatrix.prototype.datatype">
            function <span class="apidocSignatureSpan">mathjs.type.SparseMatrix.prototype.</span>datatype
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.SparseMatrix.prototype.density">
            function <span class="apidocSignatureSpan">mathjs.type.SparseMatrix.prototype.</span>density
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.SparseMatrix.prototype.diagonal">
            function <span class="apidocSignatureSpan">mathjs.type.SparseMatrix.prototype.</span>diagonal
            <span class="apidocSignatureSpan">(k)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.SparseMatrix.prototype.forEach">
            function <span class="apidocSignatureSpan">mathjs.type.SparseMatrix.prototype.</span>forEach
            <span class="apidocSignatureSpan">(callback, skipZeros)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.SparseMatrix.prototype.format">
            function <span class="apidocSignatureSpan">mathjs.type.SparseMatrix.prototype.</span>format
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.SparseMatrix.prototype.get">
            function <span class="apidocSignatureSpan">mathjs.type.SparseMatrix.prototype.</span>get
            <span class="apidocSignatureSpan">(index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.SparseMatrix.prototype.map">
            function <span class="apidocSignatureSpan">mathjs.type.SparseMatrix.prototype.</span>map
            <span class="apidocSignatureSpan">(callback, skipZeros)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.SparseMatrix.prototype.reshape">
            function <span class="apidocSignatureSpan">mathjs.type.SparseMatrix.prototype.</span>reshape
            <span class="apidocSignatureSpan">(size, copy)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.SparseMatrix.prototype.resize">
            function <span class="apidocSignatureSpan">mathjs.type.SparseMatrix.prototype.</span>resize
            <span class="apidocSignatureSpan">(size, defaultValue, copy)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.SparseMatrix.prototype.set">
            function <span class="apidocSignatureSpan">mathjs.type.SparseMatrix.prototype.</span>set
            <span class="apidocSignatureSpan">(index, v, defaultValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.SparseMatrix.prototype.size">
            function <span class="apidocSignatureSpan">mathjs.type.SparseMatrix.prototype.</span>size
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.SparseMatrix.prototype.storage">
            function <span class="apidocSignatureSpan">mathjs.type.SparseMatrix.prototype.</span>storage
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.SparseMatrix.prototype.subset">
            function <span class="apidocSignatureSpan">mathjs.type.SparseMatrix.prototype.</span>subset
            <span class="apidocSignatureSpan">(index, replacement, defaultValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.SparseMatrix.prototype.swapRows">
            function <span class="apidocSignatureSpan">mathjs.type.SparseMatrix.prototype.</span>swapRows
            <span class="apidocSignatureSpan">(i, j)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.SparseMatrix.prototype.toArray">
            function <span class="apidocSignatureSpan">mathjs.type.SparseMatrix.prototype.</span>toArray
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.SparseMatrix.prototype.toJSON">
            function <span class="apidocSignatureSpan">mathjs.type.SparseMatrix.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.SparseMatrix.prototype.toString">
            function <span class="apidocSignatureSpan">mathjs.type.SparseMatrix.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.SparseMatrix.prototype.valueOf">
            function <span class="apidocSignatureSpan">mathjs.type.SparseMatrix.prototype.</span>valueOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.type.SparseMatrix.prototype.</span>type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.type.Unit">module mathjs.type.Unit</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Unit.Unit">
            function <span class="apidocSignatureSpan">mathjs.type.</span>Unit
            <span class="apidocSignatureSpan">(value, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Unit._getNumberConverter">
            function <span class="apidocSignatureSpan">mathjs.type.Unit.</span>_getNumberConverter
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Unit.createUnit">
            function <span class="apidocSignatureSpan">mathjs.type.Unit.</span>createUnit
            <span class="apidocSignatureSpan">(obj, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Unit.createUnitSingle">
            function <span class="apidocSignatureSpan">mathjs.type.Unit.</span>createUnitSingle
            <span class="apidocSignatureSpan">(name, obj, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Unit.deleteUnit">
            function <span class="apidocSignatureSpan">mathjs.type.Unit.</span>deleteUnit
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Unit.fromJSON">
            function <span class="apidocSignatureSpan">mathjs.type.Unit.</span>fromJSON
            <span class="apidocSignatureSpan">(json)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Unit.getUnitSystem">
            function <span class="apidocSignatureSpan">mathjs.type.Unit.</span>getUnitSystem
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Unit.isValuelessUnit">
            function <span class="apidocSignatureSpan">mathjs.type.Unit.</span>isValuelessUnit
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Unit.parse">
            function <span class="apidocSignatureSpan">mathjs.type.Unit.</span>parse
            <span class="apidocSignatureSpan">(str, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Unit.setUnitSystem">
            function <span class="apidocSignatureSpan">mathjs.type.Unit.</span>setUnitSystem
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.type.Unit.</span>BASE_UNITS</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.type.Unit.</span>PREFIXES</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.type.Unit.</span>UNITS</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.type.Unit.</span>UNIT_SYSTEMS</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.type.Unit.</span>typeConverters</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.type.Unit.prototype">module mathjs.type.Unit.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">mathjs.type.Unit.prototype.</span>isUnit</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Unit.prototype._bestPrefix">
            function <span class="apidocSignatureSpan">mathjs.type.Unit.prototype.</span>_bestPrefix
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Unit.prototype._denormalize">
            function <span class="apidocSignatureSpan">mathjs.type.Unit.prototype.</span>_denormalize
            <span class="apidocSignatureSpan">(value, prefixValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Unit.prototype._isDerived">
            function <span class="apidocSignatureSpan">mathjs.type.Unit.prototype.</span>_isDerived
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Unit.prototype._normalize">
            function <span class="apidocSignatureSpan">mathjs.type.Unit.prototype.</span>_normalize
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Unit.prototype.abs">
            function <span class="apidocSignatureSpan">mathjs.type.Unit.prototype.</span>abs
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Unit.prototype.clone">
            function <span class="apidocSignatureSpan">mathjs.type.Unit.prototype.</span>clone
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Unit.prototype.divide">
            function <span class="apidocSignatureSpan">mathjs.type.Unit.prototype.</span>divide
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Unit.prototype.equalBase">
            function <span class="apidocSignatureSpan">mathjs.type.Unit.prototype.</span>equalBase
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Unit.prototype.equals">
            function <span class="apidocSignatureSpan">mathjs.type.Unit.prototype.</span>equals
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Unit.prototype.format">
            function <span class="apidocSignatureSpan">mathjs.type.Unit.prototype.</span>format
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Unit.prototype.formatUnits">
            function <span class="apidocSignatureSpan">mathjs.type.Unit.prototype.</span>formatUnits
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Unit.prototype.hasBase">
            function <span class="apidocSignatureSpan">mathjs.type.Unit.prototype.</span>hasBase
            <span class="apidocSignatureSpan">(base)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Unit.prototype.multiply">
            function <span class="apidocSignatureSpan">mathjs.type.Unit.prototype.</span>multiply
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Unit.prototype.pow">
            function <span class="apidocSignatureSpan">mathjs.type.Unit.prototype.</span>pow
            <span class="apidocSignatureSpan">(p)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Unit.prototype.simplifyUnitListLazy">
            function <span class="apidocSignatureSpan">mathjs.type.Unit.prototype.</span>simplifyUnitListLazy
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Unit.prototype.splitUnit">
            function <span class="apidocSignatureSpan">mathjs.type.Unit.prototype.</span>splitUnit
            <span class="apidocSignatureSpan">(parts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Unit.prototype.to">
            function <span class="apidocSignatureSpan">mathjs.type.Unit.prototype.</span>to
            <span class="apidocSignatureSpan">(valuelessUnit)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Unit.prototype.toJSON">
            function <span class="apidocSignatureSpan">mathjs.type.Unit.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Unit.prototype.toNumber">
            function <span class="apidocSignatureSpan">mathjs.type.Unit.prototype.</span>toNumber
            <span class="apidocSignatureSpan">(valuelessUnit)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Unit.prototype.toNumeric">
            function <span class="apidocSignatureSpan">mathjs.type.Unit.prototype.</span>toNumeric
            <span class="apidocSignatureSpan">(valuelessUnit)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Unit.prototype.toSI">
            function <span class="apidocSignatureSpan">mathjs.type.Unit.prototype.</span>toSI
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Unit.prototype.toString">
            function <span class="apidocSignatureSpan">mathjs.type.Unit.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.type.Unit.prototype.valueOf">
            function <span class="apidocSignatureSpan">mathjs.type.Unit.prototype.</span>valueOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.type.Unit.prototype.</span>type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.typed">module mathjs.typed</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.typed.typed">
            function <span class="apidocSignatureSpan">mathjs.</span>typed
            <span class="apidocSignatureSpan">(arg0, arg1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.typed.addConversion">
            function <span class="apidocSignatureSpan">mathjs.typed.</span>addConversion
            <span class="apidocSignatureSpan">(conversion)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.typed.addType">
            function <span class="apidocSignatureSpan">mathjs.typed.</span>addType
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.typed.convert">
            function <span class="apidocSignatureSpan">mathjs.typed.</span>convert
            <span class="apidocSignatureSpan">(value, type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.typed.create">
            function <span class="apidocSignatureSpan">mathjs.typed.</span>create
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.typed.find">
            function <span class="apidocSignatureSpan">mathjs.typed.</span>find
            <span class="apidocSignatureSpan">(fn, signature)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.typed.</span>config</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.typed.</span>conversions</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.typed.</span>ignore</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.typed.</span>signatures</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mathjs.typed.</span>types</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.typed.signatures">module mathjs.typed.signatures</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.typed.signatures.Object">
            function <span class="apidocSignatureSpan">mathjs.typed.signatures.</span>Object
            <span class="apidocSignatureSpan">(signatures)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.typeof">module mathjs.typeof</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.typeof.factory">
            function <span class="apidocSignatureSpan">mathjs.typeof.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.typeof.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.types">module mathjs.types</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.types.isScalar">
            function <span class="apidocSignatureSpan">mathjs.types.</span>isScalar
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.types.type">
            function <span class="apidocSignatureSpan">mathjs.types.</span>type
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.unaryMinus">module mathjs.unaryMinus</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.unaryMinus.factory">
            function <span class="apidocSignatureSpan">mathjs.unaryMinus.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.unaryMinus.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.unaryPlus">module mathjs.unaryPlus</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.unaryPlus.factory">
            function <span class="apidocSignatureSpan">mathjs.unaryPlus.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.unaryPlus.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.unequal">module mathjs.unequal</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.unequal.factory">
            function <span class="apidocSignatureSpan">mathjs.unequal.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.unequal.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.var">module mathjs.var</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.var.factory">
            function <span class="apidocSignatureSpan">mathjs.var.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.var.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.xgcd">module mathjs.xgcd</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.xgcd.factory">
            function <span class="apidocSignatureSpan">mathjs.xgcd.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.xgcd.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.xor">module mathjs.xor</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.xor.factory">
            function <span class="apidocSignatureSpan">mathjs.xor.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.xor.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mathjs.zeros">module mathjs.zeros</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mathjs.zeros.factory">
            function <span class="apidocSignatureSpan">mathjs.zeros.</span>factory
            <span class="apidocSignatureSpan">(type, config, load, typed)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mathjs.zeros.</span>name</span>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs" id="apidoc.module.mathjs">module mathjs</a></h1>






    <h2>
        <a href="#apidoc.element.mathjs.abs" id="apidoc.element.mathjs.abs">
        function <span class="apidocSignatureSpan">mathjs.</span>abs
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function abs(arg0) {
  "use strict";
  var name = 'abs';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Fraction
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Unit
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Unit
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature5(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature5(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert0(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test9(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Fraction,Unit,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function factory (type, config, load, typed) {
/**
 * Calculate the absolute value of a number. For matrices, the function is
 * evaluated element wise.
 *
 * Syntax:
 *
 *    math.<span class="apidocCodeKeywordSpan">abs</span>(x)
 *
 * Examples:
 *
 *    math.abs(3.5);                // returns number 3.5
 *    math.abs(-4.2);               // returns number 4.2
 *
 *    math.abs([3, -5, -1, 0, 2]);  // returns Array [3, 5, 1, 0, 2]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.acos" id="apidoc.element.mathjs.acos">
        function <span class="apidocSignatureSpan">mathjs.</span>acos
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function acos(arg0) {
  "use strict";
  var name = 'acos';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature2(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Calculate the inverse cosine of a value.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">acos</span>(x)
*
* Examples:
*
*    math.acos(0.5);           // returns number 1.0471975511965979
*    math.acos(math.cos(1.5)); // returns number 1.5
*
*    math.acos(2);             // returns Complex 0 + 1.3169578969248166 i
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.acosh" id="apidoc.element.mathjs.acosh">
        function <span class="apidocSignatureSpan">mathjs.</span>acosh
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function acosh(arg0) {
  "use strict";
  var name = 'acosh';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature2(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Calculate the hyperbolic arccos of a value,
* defined as `acosh(x) = ln(sqrt(x^2 - 1) + x)`.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">acosh</span>(x)
*
* Examples:
*
*    math.acosh(1.5);       // returns 0.9624236501192069
*
* See also:
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.acot" id="apidoc.element.mathjs.acot">
        function <span class="apidocSignatureSpan">mathjs.</span>acot
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function acot(arg0) {
  "use strict";
  var name = 'acot';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature2(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Calculate the inverse cotangent of a value, defined as `acot(x) = atan(1/x)`.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">acot</span>(x)
*
* Examples:
*
*    math.acot(0.5);           // returns number 0.4636476090008061
*    math.acot(math.cot(1.5)); // returns number 1.5
*
*    math.acot(2);             // returns Complex 1.5707963267948966 -1.3169578969248166 i
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.acoth" id="apidoc.element.mathjs.acoth">
        function <span class="apidocSignatureSpan">mathjs.</span>acoth
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function acoth(arg0) {
  "use strict";
  var name = 'acoth';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature2(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Calculate the hyperbolic arccotangent of a value,
* defined as `acoth(x) = atanh(1/x) = (ln((x+1)/x) + ln(x/(x-1))) / 2`.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">acoth</span>(x)
*
* Examples:
*
*    math.acoth(0.5);       // returns 0.8047189562170503
*
* See also:
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.acsc" id="apidoc.element.mathjs.acsc">
        function <span class="apidocSignatureSpan">mathjs.</span>acsc
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function acsc(arg0) {
  "use strict";
  var name = 'acsc';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature2(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Calculate the inverse cosecant of a value, defined as `acsc(x) = asin(1/x)`.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">acsc</span>(x)
*
* Examples:
*
*    math.acsc(0.5);           // returns number 0.5235987755982989
*    math.acsc(math.csc(1.5)); // returns number ~1.5
*
*    math.acsc(2);             // returns Complex 1.5707963267948966 -1.3169578969248166 i
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.acsch" id="apidoc.element.mathjs.acsch">
        function <span class="apidocSignatureSpan">mathjs.</span>acsch
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function acsch(arg0) {
  "use strict";
  var name = 'acsch';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature2(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Calculate the hyperbolic arccosecant of a value,
* defined as `acsch(x) = asinh(1/x) = ln(1/x + sqrt(1/x^2 + 1))`.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">acsch</span>(x)
*
* Examples:
*
*    math.acsch(0.5);       // returns 1.4436354751788103
*
* See also:
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.add" id="apidoc.element.mathjs.add">
        function <span class="apidocSignatureSpan">mathjs.</span>add
        <span class="apidocSignatureSpan">(arg0, arg1, arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function add(arg0, arg1, arg2) {
  "use strict";
  var name = 'add';
  if (test0(arg0)) { // type: number
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: number, number
      }
    }
    if (test1(arg1)) { // type: Complex
      if (arguments.length === 2) {
        return signature1(convert0(arg0), arg1); // signature: number, Complex
      }
    }
    if (test2(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature2(convert1(arg0), arg1); // signature: number, BigNumber
      }
    }
    if (test3(arg1)) { // type: Fraction
      if (arguments.length === 2) {
        return signature3(convert2(arg0), arg1); // signature: number, Fraction
      }
    }
    if (test4(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert3(arg1)); // signature: number, string
      }
    }
    if (test5(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert4(arg1)); // signature: number, boolean
      }
    }
    if (test6(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert5(arg1)); // signature: number, null
      }
    }
  }
  if (test1(arg0)) { // type: Complex
    if (test1(arg1)) { // type: Complex
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Complex, Complex
      }
    }
    if (test0(arg1)) { // type: number (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: Complex, number
      }
    }
    if (test2(arg1)) { // type: BigNumber (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert6(arg1)); // signature: Complex, BigNumber
      }
    }
    if (test3(arg1)) { // type: Fraction (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert7(arg1)); // signature: Complex, Fraction
      }
    }
    if (test4(arg1)) { // type: string (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert8(arg1)); // signature: Complex, string
      }
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (test1(arg1)) { // type: Complex
      if (arguments.length === 2) {
        return signature1(convert6(arg0), arg1); // signature: BigNumber, Complex
      }
    }
    if (test2(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: BigNumber, BigNumber
      }
    }
    if (test0(arg1)) { // type: number (convert to BigNumber)
      if (arguments.length === 2) {
        return signature2(arg0, convert1(arg1)); // signature: BigNumber, number
      }
    }
    if (test3(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature2(arg0, convert9(arg1)); // signature: BigNumber, Fraction
      }
    }
    if (test4(arg1)) { // type: string (convert to BigNumber)
      if (arguments.length === 2) {
        return signature2(arg0, convert10(arg1)); // signature: BigNumber, string
      }
    }
    if (test5(arg1)) { // type: boolean (convert to BigNumber)
      if (arguments.length === 2) {
        return signature2(arg0, convert11(arg1)); // signature: BigNumber, boolean
      }
    }
    if (test6(arg1)) { // type: null (convert to BigNumber)
      if (arguments.length === 2) {
        return signature2(arg0, convert12(arg1)); // signature: BigNumber, null
      }
    }
  }
  if (test3(arg0)) { // type: Fraction
    if (test1(arg1)) { // type: Complex
      if (arguments.length === 2) {
        return signature1(convert7(arg0), arg1); // signature: Fraction, Complex
      }
    }
    if (test2(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature2(convert9(arg0), arg1); // signature: Fraction, BigNumber
      }
    }
    if (test3(arg1)) { // type: Fraction
      if (a ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
math.eval('5.08 cm to inch');     // 2 inch
math.eval('sin(45 deg) ^ 2');     // 0.5
math.eval('9 / 3 + 2i');          // 3 + 2i
math.eval('det([-1, 2; 3, 1])');  // -7

// chaining
math.chain(3)
    .<span class="apidocCodeKeywordSpan">add</span>(4)
    .multiply(2)
    .done(); // 14
```

## Browser support

Math.js works on any ES5 compatible JavaScript engine: node.js 0.10, and Internet Explorer 9 and newer, and all other browsers (
Chrome, Firefox, Safari). If support for old browsers like Internet Explorer 8 is required, the [es5-shim](https://github.com/kriskowal
/es5-shim) library has to be loaded.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.and" id="apidoc.element.mathjs.and">
        function <span class="apidocSignatureSpan">mathjs.</span>and
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function and(arg0, arg1) {
  "use strict";
  var name = 'and';
  if (test0(arg0)) { // type: number
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: number, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: Complex
      if (arguments.length === 2) {
        return signature1(convert0(arg0), arg1); // signature: number, Complex
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature2(convert1(arg0), arg1); // signature: number, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature2(convert1(arg0), convert2(arg1)); // signature: number, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert3(arg1)); // signature: number, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert4(arg1)); // signature: number, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test6(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert5(arg1)); // signature: number, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
  }
  if (test1(arg0)) { // type: Complex
    if (test1(arg1)) { // type: Complex
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Complex, Complex
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test0(arg1)) { // type: number (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: Complex, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: BigNumber (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert6(arg1)); // signature: Complex, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: Fraction (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert7(arg1)); // signature: Complex, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: string (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert8(arg1)); // signature: Complex, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (test1(arg1)) { // type: Complex
      if (arguments.length === 2) {
        return signature1(convert6(arg0), arg1); // signature: BigNumber, Complex
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  /**
* Logical `and`. Test whether two values are both defined with a nonzero/nonempty value.
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">and</span>(x, y)
*
* Examples:
*
*    math.and(2, 4);   // returns true
*
*    a = [2, 0, 0];
*    b = [3, 7, 0];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.arg" id="apidoc.element.mathjs.arg">
        function <span class="apidocSignatureSpan">mathjs.</span>arg
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function arg(arg0) {
  "use strict";
  var name = 'arg';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature2(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   *                               the principal root is returned.
   * @returns {Complex | Array.&lt;Complex&gt; | Matrix.&lt;Complex&gt;} Returns the cubic root(s) of x
   * @private
   */
  function _cbrtComplex(x, allRoots) {
// https://www.wikiwand.com/en/Cube_root#/Complex_numbers

var arg_3 = x.<span class="apidocCodeKeywordSpan">arg</span>() / 3;
var abs = x.abs();

// principal root:
var principal = new type.Complex(_cbrtNumber(abs), 0).mul(
    new type.Complex(0, arg_3).exp());

if (allRoots) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.asec" id="apidoc.element.mathjs.asec">
        function <span class="apidocSignatureSpan">mathjs.</span>asec
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function asec(arg0) {
  "use strict";
  var name = 'asec';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature2(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Calculate the inverse secant of a value. Defined as `asec(x) = acos(1/x)`.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">asec</span>(x)
*
* Examples:
*
*    math.asec(0.5);           // returns 1.0471975511965979
*    math.asec(math.sec(1.5)); // returns 1.5
*
*    math.asec(2);             // returns 0 + 1.3169578969248166 i
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.asech" id="apidoc.element.mathjs.asech">
        function <span class="apidocSignatureSpan">mathjs.</span>asech
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function asech(arg0) {
  "use strict";
  var name = 'asech';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature2(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Calculate the hyperbolic arcsecant of a value,
* defined as `asech(x) = acosh(1/x) = ln(sqrt(1/x^2 - 1) + 1/x)`.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">asech</span>(x)
*
* Examples:
*
*    math.asech(0.5);       // returns 1.3169578969248166
*
* See also:
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.asin" id="apidoc.element.mathjs.asin">
        function <span class="apidocSignatureSpan">mathjs.</span>asin
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function asin(arg0) {
  "use strict";
  var name = 'asin';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature2(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   *
   * @param {number | Complex | Array | Matrix} x   Function input
   * @return {number | Complex | Array | Matrix} The arc cosecant of x
   */
  var acsc = typed('acsc', {
'number': function (x) {
  if (x &lt;= -1 || x &gt;= 1 || config.predictable) {
    return Math.<span class="apidocCodeKeywordSpan">asin</span>(1 / x);
  }
  return new type.Complex(x, 0).acsc();
},

'Complex': function (x) {
  return x.acsc();
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.asinh" id="apidoc.element.mathjs.asinh">
        function <span class="apidocSignatureSpan">mathjs.</span>asinh
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function asinh(arg0) {
  "use strict";
  var name = 'asinh';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature2(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  },

  'Complex': function (x) {
    return x.acsch();
  },

  'BigNumber': function (x) {
    return new type.BigNumber(1).div(x).<span class="apidocCodeKeywordSpan">asinh</span>();
  },

  'Array | Matrix': function (x) {
    return deepMap(x, acsch);
  }
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.atan" id="apidoc.element.mathjs.atan">
        function <span class="apidocSignatureSpan">mathjs.</span>atan
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function atan(arg0) {
  "use strict";
  var name = 'atan';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature2(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   *    cot, atan
   *
   * @param {number | Complex | Array | Matrix} x   Function input
   * @return {number | Complex | Array | Matrix} The arc cotangent of x
   */
  var acot = typed('acot', {
'number': function (x) {
  return Math.<span class="apidocCodeKeywordSpan">atan</span>(1 / x);
},

'Complex': function (x) {
  return x.acot();
},

'BigNumber': function (x) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.atan2" id="apidoc.element.mathjs.atan2">
        function <span class="apidocSignatureSpan">mathjs.</span>atan2
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function atan2(arg0, arg1) {
  "use strict";
  var name = 'atan2';
  if (test0(arg0)) { // type: number
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: number, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature1(convert0(arg0), arg1); // signature: number, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: number, Array
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature3(arg0, arg1); // signature: number, Matrix
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(convert0(arg0), convert1(arg1)); // signature: number, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert2(arg1)); // signature: number, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test6(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert3(arg1)); // signature: number, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test7(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert4(arg1)); // signature: number, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'number,BigNumber,Array,Matrix');
  }
  if (test1(arg0)) { // type: BigNumber
    if (test1(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: BigNumber, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: BigNumber, Array
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature3(arg0, arg1); // signature: BigNumber, Matrix
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test0(arg1)) { // type: number (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: BigNumber, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert1(arg1)); // signature: BigNumber, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: string (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert5(arg ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```js
// load math.js
var math = require('mathjs');

// functions and constants
math.round(math.e, 3);            // 2.718
math.<span class="apidocCodeKeywordSpan">atan2</span>(3, -3) / math.pi;      // 0.75
math.log(1000, 10);               // 3
math.sqrt(-4);                    // 2i
math.pow([[-1, 2], [3, 1]], 2);   // [[7, 0], [0, 7]]
math.derivative('x^2 + x', 'x');  // 2 * x + 1

// expressions
math.eval('12 / (2.3 + 0.7)');    // 4
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.atanh" id="apidoc.element.mathjs.atanh">
        function <span class="apidocSignatureSpan">mathjs.</span>atanh
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function atanh(arg0) {
  "use strict";
  var name = 'atanh';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature2(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  },

  'Complex': function (x) {
    return x.acoth();
  },

  'BigNumber': function (x) {
    return new type.BigNumber(1).div(x).<span class="apidocCodeKeywordSpan">atanh</span>();
  },

  'Array | Matrix': function (x) {
    return deepMap(x, acoth);
  }
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.bellNumbers" id="apidoc.element.mathjs.bellNumbers">
        function <span class="apidocSignatureSpan">mathjs.</span>bellNumbers
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bellNumbers(arg0) {
  "use strict";
  var name = 'bellNumbers';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature0(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature0(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,BigNumber');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* The Bell Numbers count the number of partitions of a set. A partition is a pairwise disjoint subset of S whose union is S.
* bellNumbers only takes integer arguments.
* The following condition must be enforced: n &gt;= 0
*
* Syntax:
*
*   math.<span class="apidocCodeKeywordSpan">bellNumbers</span>(n)
*
* Examples:
*
*    math.bellNumbers(3); // returns 5;
*    math.bellNumbers(8); // returns 4140;
*
* See also:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.bignumber" id="apidoc.element.mathjs.bignumber">
        function <span class="apidocSignatureSpan">mathjs.</span>bignumber
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bignumber(arg0) {
  "use strict";
  var name = 'bignumber';
  if (arguments.length === 0) {
    return signature0(); // signature:
  }
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature1(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: Fraction
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: string
    if (arguments.length === 1) {
      return signature4(arg0); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature5(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature5(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature1(convert0(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature1(convert1(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,BigNumber,Fraction,string,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
ConstantNode.prototype._compile = function (defs, args) {
  switch (this.valueType) {
    case 'number':
      // TODO: replace this with using config.number
      var numConfig = defs.math.config().number;
      if (numConfig === 'BigNumber') {
        return 'math.<span class="apidocCodeKeywordSpan">bignumber</span>("' + this.value + '")';
      }
      else if (numConfig === 'Fraction') {
        return 'math.fraction("' + this.value + '")';
      }
      else {
        // remove leading zeros like '003.2' which are not allowed by JavaScript
        return this.value.replace(/^(0*)[0-9]/, function (match, zeros) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.bitAnd" id="apidoc.element.mathjs.bitAnd">
        function <span class="apidocSignatureSpan">mathjs.</span>bitAnd
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bitAnd(arg0, arg1) {
  "use strict";
  var name = 'bitAnd';
  if (test0(arg0)) { // type: number
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: number, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature1(convert0(arg0), arg1); // signature: number, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(convert0(arg0), convert1(arg1)); // signature: number, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert2(arg1)); // signature: number, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert3(arg1)); // signature: number, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert4(arg1)); // signature: number, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
  }
  if (test1(arg0)) { // type: BigNumber
    if (test1(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: BigNumber, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test0(arg1)) { // type: number (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: BigNumber, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert1(arg1)); // signature: BigNumber, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: string (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert5(arg1)); // signature: BigNumber, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: boolean (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert6(arg1)); // signature: BigNumber, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: null (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert7(arg1)); // signature: BigNumber, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
  }
  if (test6(arg0)) { // type: Array
    if (test6(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: Array, Array
      }
    }
    if (test7(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature3(arg0, arg1); // signature: Array, Matrix
      }
    }
    // type: any
    if (arguments.length === 2) { ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  /**
* Bitwise AND two values, `x &amp; y`.
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">bitAnd</span>(x, y)
*
* Examples:
*
*    math.bitAnd(53, 131);               // returns number 1
*
*    math.bitAnd([1, 12, 31], 42);       // returns Array [0, 8, 10]
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.bitNot" id="apidoc.element.mathjs.bitNot">
        function <span class="apidocSignatureSpan">mathjs.</span>bitNot
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bitNot(arg0) {
  "use strict";
  var name = 'bitNot';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature1(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature2(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature2(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature1(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,BigNumber,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Bitwise NOT value, `~x`.
* For matrices, the function is evaluated element wise.
* For units, the function is evaluated on the best prefix base.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">bitNot</span>(x)
*
* Examples:
*
*    math.bitNot(1);               // returns number -2
*
*    math.bitNot([2, -3, 4]);      // returns Array [-3, 2, 5]
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.bitOr" id="apidoc.element.mathjs.bitOr">
        function <span class="apidocSignatureSpan">mathjs.</span>bitOr
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bitOr(arg0, arg1) {
  "use strict";
  var name = 'bitOr';
  if (test0(arg0)) { // type: number
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: number, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature1(convert0(arg0), arg1); // signature: number, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(convert0(arg0), convert1(arg1)); // signature: number, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert2(arg1)); // signature: number, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert3(arg1)); // signature: number, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert4(arg1)); // signature: number, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
  }
  if (test1(arg0)) { // type: BigNumber
    if (test1(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: BigNumber, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test0(arg1)) { // type: number (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: BigNumber, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert1(arg1)); // signature: BigNumber, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: string (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert5(arg1)); // signature: BigNumber, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: boolean (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert6(arg1)); // signature: BigNumber, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: null (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert7(arg1)); // signature: BigNumber, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
  }
  if (test6(arg0)) { // type: Array
    if (test6(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: Array, Array
      }
    }
    if (test7(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature3(arg0, arg1); // signature: Array, Matrix
      }
    }
    // type: any
    if (arguments.length === 2) { ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Bitwise OR two values, `x | y`.
* For matrices, the function is evaluated element wise.
* For units, the function is evaluated on the lowest print base.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">bitOr</span>(x, y)
*
* Examples:
*
*    math.bitOr(1, 2);               // returns number 3
*
*    math.bitOr([1, 2, 3], 4);       // returns Array [5, 6, 7]
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.bitXor" id="apidoc.element.mathjs.bitXor">
        function <span class="apidocSignatureSpan">mathjs.</span>bitXor
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bitXor(arg0, arg1) {
  "use strict";
  var name = 'bitXor';
  if (test0(arg0)) { // type: number
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: number, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature1(convert0(arg0), arg1); // signature: number, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(convert0(arg0), convert1(arg1)); // signature: number, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert2(arg1)); // signature: number, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert3(arg1)); // signature: number, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert4(arg1)); // signature: number, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
  }
  if (test1(arg0)) { // type: BigNumber
    if (test1(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: BigNumber, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test0(arg1)) { // type: number (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: BigNumber, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert1(arg1)); // signature: BigNumber, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: string (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert5(arg1)); // signature: BigNumber, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: boolean (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert6(arg1)); // signature: BigNumber, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: null (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert7(arg1)); // signature: BigNumber, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
  }
  if (test6(arg0)) { // type: Array
    if (test6(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: Array, Array
      }
    }
    if (test7(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature3(arg0, arg1); // signature: Array, Matrix
      }
    }
    // type: any
    if (arguments.length === 2) { ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  /**
* Bitwise XOR two values, `x ^ y`.
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">bitXor</span>(x, y)
*
* Examples:
*
*    math.bitXor(1, 2);               // returns number 3
*
*    math.bitXor([2, 3, 4], 4);       // returns Array [6, 7, 0]
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.boolean" id="apidoc.element.mathjs.boolean">
        function <span class="apidocSignatureSpan">mathjs.</span>boolean
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bool(arg0) {
  "use strict";
  var name = 'bool';
  if (arguments.length === 0) {
    return signature0(); // signature:
  }
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature1(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: string
    if (arguments.length === 1) {
      return signature3(arg0); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: boolean
    if (arguments.length === 1) {
      return signature5(arg0); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature2(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature1(convert1(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,BigNumber,string,Array,Matrix,boolean');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* In case of a number, `true` is returned for non-zero numbers, and `false` in
* case of zero.
* Strings can be `'true'` or `'false'`, or can contain a number.
* When value is a matrix, all elements will be converted to boolean.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">boolean</span>(x)
*
* Examples:
*
*    math.boolean(0);     // returns false
*    math.boolean(1);     // returns true
*    math.boolean(-3);     // returns true
*    math.boolean('true');     // returns true
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.catalan" id="apidoc.element.mathjs.catalan">
        function <span class="apidocSignatureSpan">mathjs.</span>catalan
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function catalan(arg0) {
  "use strict";
  var name = 'catalan';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature0(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature0(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,BigNumber');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* The Catalan Numbers enumerate combinatorial structures of many different types.
* catalan only takes integer arguments.
* The following condition must be enforced: n &gt;= 0
*
* Syntax:
*
*   math.<span class="apidocCodeKeywordSpan">catalan</span>(n)
*
* Examples:
*
*    math.catalan(3); // returns 5;
*    math.catalan(8); // returns 1430;
*
* See also:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.cbrt" id="apidoc.element.mathjs.cbrt">
        function <span class="apidocSignatureSpan">mathjs.</span>cbrt
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cbrt(arg0, arg1) {
  "use strict";
  var name = 'cbrt';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (test1(arg1)) { // type: boolean
      if (arguments.length === 2) {
        return signature1(convert0(arg0), arg1); // signature: number, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'boolean');
  }
  if (test2(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (test1(arg1)) { // type: boolean
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Complex, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'boolean');
  }
  if (test3(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (test1(arg1)) { // type: boolean
      if (arguments.length === 2) {
        return signature1(convert1(arg0), arg1); // signature: BigNumber, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'boolean');
  }
  if (test4(arg0)) { // type: Unit
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Unit
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature2(convert2(arg0)); // signature: Fraction
    }
    if (test1(arg1)) { // type: boolean
      if (arguments.length === 2) {
        return signature1(convert3(arg0), arg1); // signature: Fraction, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'boolean');
  }
  if (test8(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert4(arg0)); // signature: string
    }
    if (test1(arg1)) { // type: boolean
      if (arguments.length === 2) {
        return signature1(convert5(arg0), arg1); // signature: string, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'boolean');
  }
  if (test1(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert6(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test9(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert7(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Unit,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Calculate the cubic root of a value.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">cbrt</span>(x)
*    math.cbrt(x, allRoots)
*
* Examples:
*
*    math.cbrt(27);                  // returns 3
*    math.cube(3);                   // returns 27
*    math.cbrt(-64);                 // returns -4
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.ceil" id="apidoc.element.mathjs.ceil">
        function <span class="apidocSignatureSpan">mathjs.</span>ceil
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ceil(arg0) {
  "use strict";
  var name = 'ceil';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Fraction
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert0(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Fraction,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Round a value towards plus infinity
* If `x` is complex, both real and imaginary part are rounded towards plus infinity.
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">ceil</span>(x)
*
* Examples:
*
*    math.ceil(3.2);               // returns number 4
*    math.ceil(3.8);               // returns number 4
*    math.ceil(-4.2);              // returns number -4
*    math.ceil(-4.7);              // returns number -4
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.chain" id="apidoc.element.mathjs.chain">
        function <span class="apidocSignatureSpan">mathjs.</span>chain
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function chain(arg0) {
  "use strict";
  var name = 'chain';
  if (arguments.length === 0) {
    return signature0(); // signature:
  }
  // type: any
  if (arguments.length === 1) {
    return signature1(arg0); // signature: any
  }
  if (arguments.length &gt; 1) {
    throw createError(name, arguments.length, 1, arguments[1]);
  }
  throw createError(name, arguments.length, 0, arguments[0], 'any');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
math.eval('12 / (2.3 + 0.7)');    // 4
math.eval('5.08 cm to inch');     // 2 inch
math.eval('sin(45 deg) ^ 2');     // 0.5
math.eval('9 / 3 + 2i');          // 3 + 2i
math.eval('det([-1, 2; 3, 1])');  // -7

// chaining
math.<span class="apidocCodeKeywordSpan">chain</span>(3)
    .add(4)
    .multiply(2)
    .done(); // 14
```

## Browser support
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.clone" id="apidoc.element.mathjs.clone">
        function <span class="apidocSignatureSpan">mathjs.</span>clone
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function clone(arg0) {
  "use strict";
  var name = 'clone';
  // type: any
  if (arguments.length === 1) {
    return signature0(arg0); // signature: any
  }
  if (arguments.length &gt; 1) {
    throw createError(name, arguments.length, 1, arguments[1]);
  }
  throw createError(name, arguments.length, 0, arguments[0], 'any');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return desc;
};

/**
 * Export the help object to JSON
 */
Help.prototype.toJSON = function () {
  var obj = object.<span class="apidocCodeKeywordSpan">clone</span>(this.doc);
  obj.mathjs = 'Help';
  return obj;
};

/**
 * Instantiate a Help object from a JSON object
 * @param {Object} json
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.combinations" id="apidoc.element.mathjs.combinations">
        function <span class="apidocSignatureSpan">mathjs.</span>combinations
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function combinations(arg0, arg1) {
  "use strict";
  var name = 'combinations';
  if (test0(arg0)) { // type: number
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: number, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature1(convert0(arg0), arg1); // signature: number, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(convert0(arg0), convert1(arg1)); // signature: number, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert2(arg1)); // signature: number, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert3(arg1)); // signature: number, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert4(arg1)); // signature: number, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'number,BigNumber');
  }
  if (test1(arg0)) { // type: BigNumber
    if (test1(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: BigNumber, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test0(arg1)) { // type: number (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: BigNumber, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert1(arg1)); // signature: BigNumber, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: string (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert5(arg1)); // signature: BigNumber, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: boolean (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert6(arg1)); // signature: BigNumber, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: null (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert7(arg1)); // signature: BigNumber, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'BigNumber');
  }
  if (test2(arg0)) { // type: Fraction (convert to BigNumber)
    if (test1(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature1(convert1(arg0), arg1); // signature: Fraction, BigNumber ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* possibilities.
*
* Combinations only takes integer arguments.
* The following condition must be enforced: k &lt;= n.
*
* Syntax:
*
*     math.<span class="apidocCodeKeywordSpan">combinations</span>(n, k)
*
* Examples:
*
*    math.combinations(7, 5); // returns 21
*
* See also:
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.compare" id="apidoc.element.mathjs.compare">
        function <span class="apidocSignatureSpan">mathjs.</span>compare
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function compare(arg0, arg1) {
  "use strict";
  var name = 'compare';
  if (test0(arg0)) { // type: number
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: number, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: Complex
      if (arguments.length === 2) {
        return signature1(convert0(arg0), arg1); // signature: number, Complex
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature2(convert1(arg0), arg1); // signature: number, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: Fraction
      if (arguments.length === 2) {
        return signature3(convert2(arg0), arg1); // signature: number, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert3(arg1)); // signature: number, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert4(arg1)); // signature: number, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test6(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert5(arg1)); // signature: number, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
  }
  if (test1(arg0)) { // type: Complex
    if (test1(arg1)) { // type: Complex
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Complex, Complex
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test0(arg1)) { // type: number (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: Complex, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: BigNumber (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert6(arg1)); // signature: Complex, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: Fraction (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert7(arg1)); // signature: Complex, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: string (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert8(arg1)); // signature: Complex, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (test1(arg1)) { // type: Complex
      if (arguments.length === 2) {
        return signature1(convert6(arg0), arg1); // signature: BigNumber, Complex
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: BigNumber, Big ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* is smaller than the configured epsilon. The function cannot be used to
* compare values smaller than approximately 2.22e-16.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">compare</span>(x, y)
*
* Examples:
*
*    math.compare(6, 1);           // returns 1
*    math.compare(2, 3);           // returns -1
*    math.compare(7, 7);           // returns 0
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.compile" id="apidoc.element.mathjs.compile">
        function <span class="apidocSignatureSpan">mathjs.</span>compile
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function compile(arg0) {
  "use strict";
  var name = 'compile';
  if (test0(arg0)) { // type: string
    if (arguments.length === 1) {
      return signature0(arg0); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: number (convert to string)
    if (arguments.length === 1) {
      return signature0(convert0(arg0)); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: boolean (convert to string)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: null (convert to string)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'string,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*     parse(expr, options)
*     parse([expr1, expr2, expr3, ...])
*     parse([expr1, expr2, expr3, ...], options)
*
* Example:
*
*     var node = parse('sqrt(3^2 + 4^2)');
*     node.<span class="apidocCodeKeywordSpan">compile</span>(math).eval(); // 5
*
*     var scope = {a:3, b:4}
*     var node = parse('a * b'); // 12
*     var code = node.compile(math);
*     code.eval(scope); // 12
*     scope.a = 5;
*     code.eval(scope); // 20
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.complex" id="apidoc.element.mathjs.complex">
        function <span class="apidocSignatureSpan">mathjs.</span>complex
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function complex(arg0, arg1) {
  "use strict";
  var name = 'complex';
  if (arguments.length === 0) {
    return signature0(); // signature:
  }
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature1(arg0); // signature: number
    }
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: number, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature3(convert0(arg0), arg1); // signature: number, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature3(convert0(arg0), convert1(arg1)); // signature: number, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature2(arg0, convert2(arg1)); // signature: number, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature2(arg0, convert3(arg1)); // signature: number, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature2(arg0, convert4(arg1)); // signature: number, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'number,BigNumber');
  }
  if (test6(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature4(convert5(arg0)); // signature: BigNumber
    }
    if (test1(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature3(arg0, arg1); // signature: BigNumber, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test0(arg1)) { // type: number (convert to BigNumber)
      if (arguments.length === 2) {
        return signature3(arg0, convert0(arg1)); // signature: BigNumber, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature3(arg0, convert1(arg1)); // signature: BigNumber, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: string (convert to BigNumber)
      if (arguments.length === 2) {
        return signature3(arg0, convert6(arg1)); // signature: BigNumber, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: boolean (convert to BigNumber)
      if (arguments.length === 2) {
        return signature3(arg0, convert7(arg1)); // signature: BigNumber, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: null (convert to BigNumber)
      if (arguments.length === 2) { ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Syntax:
*
*    math.string(value)
*
* Examples:
*
*    math.string(4.2);               // returns string '4.2'
*    math.string(math.<span class="apidocCodeKeywordSpan">complex</span>(3, 2); // returns string '3 + 2i'
*
*    var u = math.unit(5, 'km');
*    math.string(u.to('m'));         // returns string '5000 m'
*
*    math.string([true, false]);     // returns ['true', 'false']
*
* See also:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.composition" id="apidoc.element.mathjs.composition">
        function <span class="apidocSignatureSpan">mathjs.</span>composition
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function composition(arg0, arg1) {
  "use strict";
  var name = 'composition';
  if (test0(arg0)) { // type: number
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: number, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: number, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature0(arg0, convert0(arg1)); // signature: number, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert1(arg1)); // signature: number, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert2(arg1)); // signature: number, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert3(arg1)); // signature: number, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'number,BigNumber');
  }
  if (test1(arg0)) { // type: BigNumber
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: BigNumber, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: BigNumber, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature0(arg0, convert0(arg1)); // signature: BigNumber, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert1(arg1)); // signature: BigNumber, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert2(arg1)); // signature: BigNumber, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert3(arg1)); // signature: BigNumber, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'number,BigNumber');
  }
  if (test2(arg0)) { // type: Fraction (convert to BigNumber)
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature0(convert0(arg0), arg1); // signature: Fraction, number
      }
      if (arguments.length &gt; 2) {
        throw createE ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* The composition counts of n into k parts.
*
* composition only takes integer arguments.
* The following condition must be enforced: k &lt;= n.
*
* Syntax:
*
*   math.<span class="apidocCodeKeywordSpan">composition</span>(n, k)
*
* Examples:
*
*    math.composition(5, 3); // returns 6
*
* See also:
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.concat" id="apidoc.element.mathjs.concat">
        function <span class="apidocSignatureSpan">mathjs.</span>concat
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function concat(arg0) {
  "use strict";
  var name = 'concat';
  if (test0(arg0)) { // type: ...string
    var varArgs = [arg0];
    for (var i = 1; i &lt; arguments.length; i++) {
      if (test0(arguments[i])) {
        varArgs.push(arguments[i]);
      } else {
        throw createError(name, arguments.length, i, arguments[i], 'string');
      }
    }
    return signature0(varArgs); // signature: ...string
  }
  if (test1(arg0) || test2(arg0) || test3(arg0) || test4(arg0) || test5(arg0) || test6(arg0) || test6(arg0) || test7(arg0) || test7
(arg0)) { // type: ...Array|Matrix|number|BigNumber|Fraction|boolean|null
    var varArgs = [arg0];
    for (var i = 1; i &lt; arguments.length; i++) {
      if (test1(arguments[i]) || test2(arguments[i]) || test3(arguments[i]) || test4(arguments[i])) {
        varArgs.push(arguments[i]);
      }
      else if (test5(arguments[i])) {
        varArgs.push(convert0(arguments[i]));
      }
      else if (test6(arguments[i])) {
        varArgs.push(convert1(arguments[i]));
      }
      else if (test6(arguments[i])) {
        varArgs.push(convert2(arguments[i]));
      }
      else if (test7(arguments[i])) {
        varArgs.push(convert3(arguments[i]));
      }
      else if (test7(arguments[i])) {
        varArgs.push(convert4(arguments[i]));
      } else {
        throw createError(name, arguments.length, i, arguments[i], 'Array,Matrix,number,BigNumber');
      }
    }
    return signature1(varArgs); // signature: ...Array|Matrix|number|BigNumber|Fraction|boolean|null
  }
  throw createError(name, arguments.length, 0, arguments[0], 'string,Array,Matrix,number,BigNumber');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// figure out what number of arguments the callback function expects
var args = maxArgumentCount(callback);

var recurse = function (value, index) {
  if (Array.isArray(value)) {
    value.forEach(function (child, i) {
      // we create a copy of the index array and append the new index value
      recurse(child, index.<span class="apidocCodeKeywordSpan">concat</span>(i + 1)); // one based index, hence i+1
    });
  }
  else {
    // invoke the callback function with the right number of arguments
    if (args === 1) {
      callback(value);
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.config" id="apidoc.element.mathjs.config">
        function <span class="apidocSignatureSpan">mathjs.</span>config
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _config(options) {
  if (options) {
    var prev = object.clone(config);

    // validate some of the options
    validateOption(options, 'matrix', MATRIX);
    validateOption(options, 'number', NUMBER);

    // merge options
    object.deepExtend(config, options);

    var curr = object.clone(config);

    var changes = object.clone(options);

    // emit 'config' event
    math.emit('config', curr, prev, changes);

    return curr;
  }
  else {
    return object.clone(config);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  /**
* Set configuration options for math.js, and get current options.
* Will emit a 'config' event, with arguments (curr, prev, changes).
*
* Syntax:
*
*     math.<span class="apidocCodeKeywordSpan">config</span>(config: Object): Object
*
* Examples:
*
*     math.config().number;                // outputs 'number'
*     math.eval('0.4');                    // outputs number 0.4
*     math.config({number: 'Fraction'});
*     math.eval('0.4');                    // outputs Fraction 2/5
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.conj" id="apidoc.element.mathjs.conj">
        function <span class="apidocSignatureSpan">mathjs.</span>conj
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function conj(arg0) {
  "use strict";
  var name = 'conj';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature2(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Compute the complex conjugate of a complex value.
* If `x = a+bi`, the complex conjugate of `x` is `a - bi`.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">conj</span>(x)
*
* Examples:
*
*    math.conj(math.complex('2 + 3i'));  // returns Complex 2 - 3i
*    math.conj(math.complex('2 - 3i'));  // returns Complex 2 + 3i
*    math.conj(math.complex('-5.2i'));  // returns Complex 5.2i
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.cos" id="apidoc.element.mathjs.cos">
        function <span class="apidocSignatureSpan">mathjs.</span>cos
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cos(arg0) {
  "use strict";
  var name = 'cos';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Unit
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Unit
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature2(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test9(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Unit,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      var u1, u2,
          picked = -1;
      // We reject values outside of the interval [0, 1]
      // TODO: check if it is ok to do that?
      while (picked &lt; 0 || picked &gt; 1) {
        u1 = rng();
        u2 = rng();
        picked = 1/6 * Math.pow(-2 * Math.log(u1), 0.5) * Math.<span class="apidocCodeKeywordSpan">cos</span>(2 * Math.PI * u2) +
0.5;
      }
      return picked;
    }
  }
};

distribution.toTex = undefined; // use default template
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.cosh" id="apidoc.element.mathjs.cosh">
        function <span class="apidocSignatureSpan">mathjs.</span>cosh
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cosh(arg0) {
  "use strict";
  var name = 'cosh';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Unit
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Unit
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature2(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test9(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Unit,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Calculate the hyperbolic cosine of a value,
* defined as `cosh(x) = 1/2 * (exp(x) + exp(-x))`.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">cosh</span>(x)
*
* Examples:
*
*    math.cosh(0.5);       // returns number 1.1276259652063807
*
* See also:
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.cot" id="apidoc.element.mathjs.cot">
        function <span class="apidocSignatureSpan">mathjs.</span>cot
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cot(arg0) {
  "use strict";
  var name = 'cot';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Unit
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Unit
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature2(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test9(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Unit,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Syntax:
*
*    math.acot(x)
*
* Examples:
*
*    math.acot(0.5);           // returns number 0.4636476090008061
*    math.acot(math.<span class="apidocCodeKeywordSpan">cot</span>(1.5)); // returns number 1.5
*
*    math.acot(2);             // returns Complex 1.5707963267948966 -1.3169578969248166 i
*
* See also:
*
*    cot, atan
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.coth" id="apidoc.element.mathjs.coth">
        function <span class="apidocSignatureSpan">mathjs.</span>coth
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function coth(arg0) {
  "use strict";
  var name = 'coth';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Unit
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Unit
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature2(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test9(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Unit,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Calculate the hyperbolic cotangent of a value,
* defined as `coth(x) = 1 / tanh(x)`.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">coth</span>(x)
*
* Examples:
*
*    // coth(x) = 1 / tanh(x)
*    math.coth(2);         // returns 1.0373147207275482
*    1 / math.tanh(2);     // returns 1.0373147207275482
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.create" id="apidoc.element.mathjs.create">
        function <span class="apidocSignatureSpan">mathjs.</span>create
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function create(config) {
  // create a new math.js instance
  var math = core.create(config);
  math.create = create;

  // import data types, functions, constants, expression parser, etc.
  math['import'](require('./lib'));

  return math;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *                              false (default), output type can vary depending
 *                              on input values. For example `math.sqrt(-4)`
 *                              returns `complex('2i')` when predictable is false, and
 *                              returns `NaN` when true.
 */
function create (config) {
  // create a new math.js instance
  var math = core.<span class="apidocCodeKeywordSpan">create</span>(config);
  math.create = create;

  // import data types, functions, constants, expression parser, etc.
  math['import'](require('./lib'));

  return math;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.createUnit" id="apidoc.element.mathjs.createUnit">
        function <span class="apidocSignatureSpan">mathjs.</span>createUnit
        <span class="apidocSignatureSpan">(arg0, arg1, arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createUnit(arg0, arg1, arg2) {
  "use strict";
  var name = 'createUnit';
  if (test0(arg0)) { // type: string
    if (arguments.length === 1) {
      return signature0(arg0); // signature: string
    }
    if (test1(arg1)) { // type: Unit
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: string, Unit
      }
      if (test2(arg2)) { // type: Object
        if (arguments.length === 3) {
          return signature2(arg0, arg1, arg2); // signature: string, Unit, Object
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      throw createError(name, arguments.length, 2, arguments[2], 'Object');
    }
    if (test0(arg1)) { // type: string
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: string, string
      }
      if (test2(arg2)) { // type: Object
        if (arguments.length === 3) {
          return signature2(arg0, arg1, arg2); // signature: string, string, Object
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      throw createError(name, arguments.length, 2, arguments[2], 'Object');
    }
    if (test3(arg1)) { // type: number (convert to string)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: string, number
      }
      if (test2(arg2)) { // type: Object
        if (arguments.length === 3) {
          return signature2(arg0, convert0(arg1), arg2); // signature: string, number, Object
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      throw createError(name, arguments.length, 2, arguments[2], 'Object');
    }
    if (test4(arg1)) { // type: boolean (convert to string)
      if (arguments.length === 2) {
        return signature1(arg0, convert1(arg1)); // signature: string, boolean
      }
      if (test2(arg2)) { // type: Object
        if (arguments.length === 3) {
          return signature2(arg0, convert1(arg1), arg2); // signature: string, boolean, Object
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      throw createError(name, arguments.length, 2, arguments[2], 'Object');
    }
    if (test5(arg1)) { // type: null (convert to string)
      if (arguments.length === 2) {
        return signature1(arg0, convert2(arg1)); // signature: string, null
      }
      if (test2(arg2)) { // type: Object
        if (arguments.length === 3) {
          return signature2(arg0, convert2(arg1), arg2); // signature: string, null, Object
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      throw createError(name, arguments.length, 2, arguments[2], 'Object');
    }
    if (test2(arg1)) { // type: Object
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: string, Object
      }
      if (test2(arg2)) { // type: Object
        if (arguments.length === 3) {
          return signature2(arg0, arg1, arg2); // signature: string, Object, Object
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      throw createError(name, arguments.length, 2, arguments[2], 'Object');
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Unit,string,Object');
  }
  if (test3(arg0)) { // type: number (convert to string)
    if (arguments.length === 1) {
      return signature0(convert0(arg0)); // signature: number
    }
    if (test1(arg1)) { // type: Unit
      if (arguments.length === 2) {
        return signature1(convert0(arg0), arg1); // signature: number, Unit
      }
      if (test2(arg2)) { // type: Object
        if (arguments.length === 3) {
          return signature2(convert0(arg0), arg1, arg2); // signature: number, Unit, Object
        } ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.cross" id="apidoc.element.mathjs.cross">
        function <span class="apidocSignatureSpan">mathjs.</span>cross
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cross(arg0, arg1) {
  "use strict";
  var name = 'cross';
  if (test0(arg0)) { // type: Array
    if (test0(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: Array, Array
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Array, Matrix
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Array,Matrix');
  }
  if (test1(arg0)) { // type: Matrix
    if (test0(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: Matrix, Array
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature3(arg0, arg1); // signature: Matrix, Matrix
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Array,Matrix');
  }
  throw createError(name, arguments.length, 0, arguments[0], 'Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*    ]
*
* If one of the input vectors has a dimension greater than 1, the output
* vector will be a 1x3 (2-dimensional) matrix.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">cross</span>(x, y)
*
* Examples:
*
*    math.cross([1, 1, 0],   [0, 1, 1]);       // Returns [1, -1, 1]
*    math.cross([3, -3, 1],  [4, 9, 2]);       // Returns [-15, -2, 39]
*    math.cross([2, 3, 4],   [5, 6, 7]);       // Returns [-3, 6, -3]
*    math.cross([[1, 2, 3]], [[4], [5], [6]]); // Returns [[-3, 6, -3]]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.csc" id="apidoc.element.mathjs.csc">
        function <span class="apidocSignatureSpan">mathjs.</span>csc
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function csc(arg0) {
  "use strict";
  var name = 'csc';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Unit
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Unit
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature2(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test9(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Unit,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Syntax:
*
*    math.acsc(x)
*
* Examples:
*
*    math.acsc(0.5);           // returns number 0.5235987755982989
*    math.acsc(math.<span class="apidocCodeKeywordSpan">csc</span>(1.5)); // returns number ~1.5
*
*    math.acsc(2);             // returns Complex 1.5707963267948966 -1.3169578969248166 i
*
* See also:
*
*    csc, asin, asec
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.csch" id="apidoc.element.mathjs.csch">
        function <span class="apidocSignatureSpan">mathjs.</span>csch
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function csch(arg0) {
  "use strict";
  var name = 'csch';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Unit
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Unit
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature2(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test9(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Unit,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Calculate the hyperbolic cosecant of a value,
* defined as `csch(x) = 1 / sinh(x)`.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">csch</span>(x)
*
* Examples:
*
*    // csch(x) = 1/ sinh(x)
*    math.csch(0.5);       // returns 1.9190347513349437
*    1 / math.sinh(0.5);   // returns 1.9190347513349437
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.cube" id="apidoc.element.mathjs.cube">
        function <span class="apidocSignatureSpan">mathjs.</span>cube
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cube(arg0) {
  "use strict";
  var name = 'cube';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Fraction
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Unit
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Unit
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature5(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature5(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert0(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test9(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Fraction,Unit,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
*    math.cbrt(x)
*    math.cbrt(x, allRoots)
*
* Examples:
*
*    math.cbrt(27);                  // returns 3
*    math.<span class="apidocCodeKeywordSpan">cube</span>(3);                   // returns 27
*    math.cbrt(-64);                 // returns -4
*    math.cbrt(math.unit('27 m^3')); // returns Unit 3 m
*    math.cbrt([27, 64, 125]);       // returns [3, 4, 5]
*
*    var x = math.complex('8i');
*    math.cbrt(x);                   // returns Complex 1.7320508075689 + i
*    math.cbrt(x, true);             // returns Matrix [
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.deepEqual" id="apidoc.element.mathjs.deepEqual">
        function <span class="apidocSignatureSpan">mathjs.</span>deepEqual
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deepEqual(arg0, arg1) {
  "use strict";
  var name = 'deepEqual';
  // type: any
  // type: any
  if (arguments.length === 2) {
    return signature0(arg0, arg1); // signature: any, any
  }
  if (arguments.length &gt; 2) {
    throw createError(name, arguments.length, 2, arguments[2]);
  }
  throw createError(name, arguments.length, 1, arguments[1], 'any');
  throw createError(name, arguments.length, 0, arguments[0], 'any');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (a.length != b.length) {
    return false;
  }

  for (i = 0, len = a.length; i &lt; len; i++) {
    if (!exports.<span class="apidocCodeKeywordSpan">deepEqual</span>(a[i], b[i])) {
      return false;
    }
  }
  return true;
}
else if (a instanceof Object) {
  if (Array.isArray(b) || !(b instanceof Object)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.derivative" id="apidoc.element.mathjs.derivative">
        function <span class="apidocSignatureSpan">mathjs.</span>derivative
        <span class="apidocSignatureSpan">(arg0, arg1, arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function derivative(arg0, arg1, arg2) {
  "use strict";
  var name = 'derivative';
  if (test0(arg0)) { // type: string
    if (test0(arg1)) { // type: string
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: string, string
      }
      if (test1(arg2)) { // type: Object
        if (arguments.length === 3) {
          return signature1(arg0, arg1, arg2); // signature: string, string, Object
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      throw createError(name, arguments.length, 2, arguments[2], 'Object');
    }
    if (test2(arg1)) { // type: SymbolNode
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: string, SymbolNode
      }
      if (test1(arg2)) { // type: Object
        if (arguments.length === 3) {
          return signature3(arg0, arg1, arg2); // signature: string, SymbolNode, Object
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      throw createError(name, arguments.length, 2, arguments[2], 'Object');
    }
    if (test3(arg1)) { // type: number (convert to string)
      if (arguments.length === 2) {
        return signature0(arg0, convert0(arg1)); // signature: string, number
      }
      if (test1(arg2)) { // type: Object
        if (arguments.length === 3) {
          return signature1(arg0, convert0(arg1), arg2); // signature: string, number, Object
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      throw createError(name, arguments.length, 2, arguments[2], 'Object');
    }
    if (test4(arg1)) { // type: boolean (convert to string)
      if (arguments.length === 2) {
        return signature0(arg0, convert1(arg1)); // signature: string, boolean
      }
      if (test1(arg2)) { // type: Object
        if (arguments.length === 3) {
          return signature1(arg0, convert1(arg1), arg2); // signature: string, boolean, Object
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      throw createError(name, arguments.length, 2, arguments[2], 'Object');
    }
    if (test5(arg1)) { // type: null (convert to string)
      if (arguments.length === 2) {
        return signature0(arg0, convert2(arg1)); // signature: string, null
      }
      if (test1(arg2)) { // type: Object
        if (arguments.length === 3) {
          return signature1(arg0, convert2(arg1), arg2); // signature: string, null, Object
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      throw createError(name, arguments.length, 2, arguments[2], 'Object');
    }
    throw createError(name, arguments.length, 1, arguments[1], 'string,SymbolNode');
  }
  if (test6(arg0)) { // type: Node
    if (test0(arg1)) { // type: string
      if (arguments.length === 2) {
        return signature4(arg0, arg1); // signature: Node, string
      }
      if (test1(arg2)) { // type: Object
        if (arguments.length === 3) {
          return signature5(arg0, arg1, arg2); // signature: Node, string, Object
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      throw createError(name, arguments.length, 2, arguments[2], 'Object');
    }
    if (test2(arg1)) { // type: SymbolNode
      if (arguments.length === 2) {
        return signature6(arg0, arg1); // signature: Node, SymbolNode
      }
      if (test1(arg2)) { // type: Object
        if (arguments.length === 3) {
          return signature7(arg0, arg1, arg2); // signature: Node, SymbolNode, Object
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      throw createError(name, arguments.length, 2, arguments[2], 'Object');
    }
    if (t ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// functions and constants
math.round(math.e, 3);            // 2.718
math.atan2(3, -3) / math.pi;      // 0.75
math.log(1000, 10);               // 3
math.sqrt(-4);                    // 2i
math.pow([[-1, 2], [3, 1]], 2);   // [[7, 0], [0, 7]]
math.<span class="apidocCodeKeywordSpan">derivative</span>('x^2 + x', 'x');  // 2 * x + 1

// expressions
math.eval('12 / (2.3 + 0.7)');    // 4
math.eval('5.08 cm to inch');     // 2 inch
math.eval('sin(45 deg) ^ 2');     // 0.5
math.eval('9 / 3 + 2i');          // 3 + 2i
math.eval('det([-1, 2; 3, 1])');  // -7
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.det" id="apidoc.element.mathjs.det">
        function <span class="apidocSignatureSpan">mathjs.</span>det
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function det(arg0) {
  "use strict";
  var name = 'det';
  if (test0(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature0(arg0); // signature: Array
    }
  }
  if (test1(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature0(arg0); // signature: Matrix
    }
  }
  // type: any
  if (arguments.length === 1) {
    return signature1(arg0); // signature: any
  }
  if (arguments.length &gt; 1) {
    throw createError(name, arguments.length, 1, arguments[1]);
  }
  throw createError(name, arguments.length, 0, arguments[0], 'Array,Matrix,any');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var unaryMinus = load(require('../arithmetic/unaryMinus'));

/**
 * Calculate the determinant of a matrix.
 *
 * Syntax:
 *
 *    math.<span class="apidocCodeKeywordSpan">det</span>(x)
 *
 * Examples:
 *
 *    math.det([[1, 2], [3, 4]]); // returns -2
 *
 *    var A = [
 *      [-2, 2, 3],
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.diag" id="apidoc.element.mathjs.diag">
        function <span class="apidocSignatureSpan">mathjs.</span>diag
        <span class="apidocSignatureSpan">(arg0, arg1, arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function diag(arg0, arg1, arg2) {
  "use strict";
  var name = 'diag';
  if (test0(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature0(arg0); // signature: Array
    }
    if (test1(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Array, number
      }
      if (test2(arg2)) { // type: string
        if (arguments.length === 3) {
          return signature2(arg0, arg1, arg2); // signature: Array, number, string
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test1(arg2)) { // type: number (convert to string)
        if (arguments.length === 3) {
          return signature2(arg0, arg1, convert0(arg2)); // signature: Array, number, number
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test3(arg2)) { // type: boolean (convert to string)
        if (arguments.length === 3) {
          return signature2(arg0, arg1, convert1(arg2)); // signature: Array, number, boolean
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test4(arg2)) { // type: null (convert to string)
        if (arguments.length === 3) {
          return signature2(arg0, arg1, convert2(arg2)); // signature: Array, number, null
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      throw createError(name, arguments.length, 2, arguments[2], 'string');
    }
    if (test5(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature3(arg0, arg1); // signature: Array, BigNumber
      }
      if (test2(arg2)) { // type: string
        if (arguments.length === 3) {
          return signature4(arg0, arg1, arg2); // signature: Array, BigNumber, string
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test1(arg2)) { // type: number (convert to string)
        if (arguments.length === 3) {
          return signature4(arg0, arg1, convert0(arg2)); // signature: Array, BigNumber, number
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test3(arg2)) { // type: boolean (convert to string)
        if (arguments.length === 3) {
          return signature4(arg0, arg1, convert1(arg2)); // signature: Array, BigNumber, boolean
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test4(arg2)) { // type: null (convert to string)
        if (arguments.length === 3) {
          return signature4(arg0, arg1, convert2(arg2)); // signature: Array, BigNumber, null
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      throw createError(name, arguments.length, 2, arguments[2], 'string');
    }
    if (test2(arg1)) { // type: string
      if (arguments.length === 2) {
        return signature5(arg0, arg1); // signature: Array, string
      }
      if (test2(arg2)) { // type: string
        if (arguments.length === 3) {
          return signature2(arg0, convert3(arg1), arg2); // signature: Array, string, string
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test1(arg2)) { // type: number (convert to string)
        if (arguments.length === 3) {
          return signature2(arg0, convert3(arg1), convert0(arg2)); // signature: Array, string, number
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test3(arg2)) { // type: boolean (convert to string)
        if (argume ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* When `x` is a vector, a matrix with vector `x` on the diagonal will be returned.
* When `x` is a two dimensional matrix, the matrixes `k`th diagonal will be returned as vector.
* When k is positive, the values are placed on the super diagonal.
* When k is negative, the values are placed on the sub diagonal.
*
* Syntax:
*
*     math.<span class="apidocCodeKeywordSpan">diag</span>(X)
*     math.diag(X, format)
*     math.diag(X, k)
*     math.diag(X, k, format)
*
* Examples:
*
*     // create a diagonal matrix
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.distance" id="apidoc.element.mathjs.distance">
        function <span class="apidocSignatureSpan">mathjs.</span>distance
        <span class="apidocSignatureSpan">(arg0, arg1, arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function distance(arg0, arg1, arg2) {
  "use strict";
  var name = 'distance';
  if (test0(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature0(arg0); // signature: Array
    }
    if (test0(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Array, Array
      }
      if (test0(arg2)) { // type: Array
        if (arguments.length === 3) {
          return signature2(arg0, arg1, arg2); // signature: Array, Array, Array
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test1(arg2)) { // type: Matrix (convert to Array)
        if (arguments.length === 3) {
          return signature2(arg0, arg1, convert0(arg2)); // signature: Array, Array, Matrix
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      throw createError(name, arguments.length, 2, arguments[2], 'Array');
    }
    if (test1(arg1)) { // type: Matrix (convert to Array)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: Array, Matrix
      }
      if (test0(arg2)) { // type: Array
        if (arguments.length === 3) {
          return signature2(arg0, convert0(arg1), arg2); // signature: Array, Matrix, Array
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test1(arg2)) { // type: Matrix (convert to Array)
        if (arguments.length === 3) {
          return signature2(arg0, convert0(arg1), convert0(arg2)); // signature: Array, Matrix, Matrix
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      throw createError(name, arguments.length, 2, arguments[2], 'Array');
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Array');
  }
  if (test1(arg0)) { // type: Matrix (convert to Array)
    if (arguments.length === 1) {
      return signature0(convert0(arg0)); // signature: Matrix
    }
    if (test0(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature1(convert0(arg0), arg1); // signature: Matrix, Array
      }
      if (test0(arg2)) { // type: Array
        if (arguments.length === 3) {
          return signature2(convert0(arg0), arg1, arg2); // signature: Matrix, Array, Array
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test1(arg2)) { // type: Matrix (convert to Array)
        if (arguments.length === 3) {
          return signature2(convert0(arg0), arg1, convert0(arg2)); // signature: Matrix, Array, Matrix
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      throw createError(name, arguments.length, 2, arguments[2], 'Array');
    }
    if (test1(arg1)) { // type: Matrix (convert to Array)
      if (arguments.length === 2) {
        return signature1(convert0(arg0), convert0(arg1)); // signature: Matrix, Matrix
      }
      if (test0(arg2)) { // type: Array
        if (arguments.length === 3) {
          return signature2(convert0(arg0), convert0(arg1), arg2); // signature: Matrix, Matrix, Array
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test1(arg2)) { // type: Matrix (convert to Array)
        if (arguments.length === 3) {
          return signature2(convert0(arg0), convert0(arg1), convert0(arg2)); // signature: Matrix, Matrix, Matrix
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      throw createError(name, arguments.length, 2, arguments[2], 'Array');
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Array');
  }
  if (test2(arg0)) { / ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*    Distance between point and a line in 2 and 3 dimensional spaces.
*    Pairwise distance between a set of 2D or 3D points
* NOTE:
*    When substituting coefficients of a line(a, b and c), use ax + by + c = 0 instead of ax + by = c
*    For parametric equation of a 3D line, x0, y0, z0, a, b, c are from: (xâˆ’x0, yâˆ’y0, zâˆ’z0) = t(a, b, c)
*
* Syntax:
*    math.<span class="apidocCodeKeywordSpan">distance</span>([x1, y1], [x2, y2])
*-   math.distance({pointOneX: 4, pointOneY: 5}, {pointTwoX: 2, pointTwoY: 7})
*    math.distance([x1, y1, z1], [x2, y2, z2])
*    math.distance({pointOneX: 4, pointOneY: 5, pointOneZ: 8}, {pointTwoX: 2, pointTwoY: 7, pointTwoZ: 9})
*    math.distance([[A], [B], [C]...])
*    math.distance([x1, y1], [LinePtX1, LinePtY1], [LinePtX2, LinePtY2])
*    math.distance({pointX: 1, pointY: 4}, {lineOnePtX: 6, lineOnePtY: 3}, {lineTwoPtX: 2, lineTwoPtY: 8})
*    math.distance([x1, y1, z1], [LinePtX1, LinePtY1, LinePtZ1], [LinePtX2, LinePtY2, LinePtZ2])
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.divide" id="apidoc.element.mathjs.divide">
        function <span class="apidocSignatureSpan">mathjs.</span>divide
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function divide(arg0, arg1) {
  "use strict";
  var name = 'divide';
  if (test0(arg0)) { // type: number
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: number, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: Complex
      if (arguments.length === 2) {
        return signature1(convert0(arg0), arg1); // signature: number, Complex
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature2(convert1(arg0), arg1); // signature: number, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: Fraction
      if (arguments.length === 2) {
        return signature3(convert2(arg0), arg1); // signature: number, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: Unit
      if (arguments.length === 2) {
        return signature4(arg0, arg1); // signature: number, Unit
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert3(arg1)); // signature: number, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test6(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert4(arg1)); // signature: number, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test7(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert5(arg1)); // signature: number, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
  }
  if (test1(arg0)) { // type: Complex
    if (test1(arg1)) { // type: Complex
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Complex, Complex
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test0(arg1)) { // type: number (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: Complex, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: BigNumber (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert6(arg1)); // signature: Complex, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: Fraction (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert7(arg1)); // signature: Complex, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: string (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert8(arg1)); // signature: Complex, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (test1(arg1)) { // type: Complex
      if (arguments.length === 2) {
        return signature1(convert6(arg0), arg1); // signature: BigNumber, Complex
      } ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  /**
* Divide two values, `x / y`.
* To divide matrices, `x` is multiplied with the inverse of `y`: `x * inv(y)`.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">divide</span>(x, y)
*
* Examples:
*
*    math.divide(2, 3);            // returns number 0.6666666666666666
*
*    var a = math.complex(5, 14);
*    var b = math.complex(4, 1);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.dot" id="apidoc.element.mathjs.dot">
        function <span class="apidocSignatureSpan">mathjs.</span>dot
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dot(arg0, arg1) {
  "use strict";
  var name = 'dot';
  if (test0(arg0)) { // type: Array
    if (test0(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: Array, Array
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Array, Matrix
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Array,Matrix');
  }
  if (test1(arg0)) { // type: Matrix
    if (test0(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: Matrix, Array
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature3(arg0, arg1); // signature: Matrix, Matrix
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Array,Matrix');
  }
  throw createError(name, arguments.length, 0, arguments[0], 'Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Calculate the dot product of two vectors. The dot product of
* `A = [a1, a2, a3, ..., an]` and `B = [b1, b2, b3, ..., bn]` is defined as:
*
*    dot(A, B) = a1 * b1 + a2 * b2 + a3 * b3 + ... + an * bn
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">dot</span>(x, y)
*
* Examples:
*
*    math.dot([2, 4, 1], [2, 2, 3]);       // returns number 15
*    math.multiply([2, 4, 1], [2, 2, 3]);  // returns number 15
*
* See also:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.dotDivide" id="apidoc.element.mathjs.dotDivide">
        function <span class="apidocSignatureSpan">mathjs.</span>dotDivide
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dotDivide(arg0, arg1) {
  "use strict";
  var name = 'dotDivide';
  if (test0(arg0)) { // type: Array
    if (test0(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: Array, Array
      }
    }
    if (test1(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Array, Matrix
      }
    }
    // type: any
    if (arguments.length === 2) {
      return signature2(arg0, arg1); // signature: Array, any
    }
    if (arguments.length &gt; 2) {
      throw createError(name, arguments.length, 2, arguments[2]);
    }
  }
  if (test1(arg0)) { // type: Matrix
    if (test0(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature3(arg0, arg1); // signature: Matrix, Array
      }
    }
    if (test1(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature4(arg0, arg1); // signature: Matrix, Matrix
      }
    }
    // type: any
    if (arguments.length === 2) {
      return signature5(arg0, arg1); // signature: Matrix, any
    }
    if (arguments.length &gt; 2) {
      throw createError(name, arguments.length, 2, arguments[2]);
    }
  }
  // type: any
  if (test0(arg1)) { // type: Array
    if (arguments.length === 2) {
      return signature6(arg0, arg1); // signature: any, Array
    }
  }
  if (test1(arg1)) { // type: Matrix
    if (arguments.length === 2) {
      return signature7(arg0, arg1); // signature: any, Matrix
    }
  }
  // type: any
  if (arguments.length === 2) {
    return signature8(arg0, arg1); // signature: any, any
  }
  if (arguments.length &gt; 2) {
    throw createError(name, arguments.length, 2, arguments[2]);
  }
  throw createError(name, arguments.length, 1, arguments[1], 'Array,Matrix,any');
  throw createError(name, arguments.length, 0, arguments[0], 'Array,Matrix,any');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  /**
* Divide two matrices element wise. The function accepts both matrices and
* scalar values.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">dotDivide</span>(x, y)
*
* Examples:
*
*    math.dotDivide(2, 4);   // returns 0.5
*
*    a = [[9, 5], [6, 1]];
*    b = [[3, 2], [5, 2]];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.dotMultiply" id="apidoc.element.mathjs.dotMultiply">
        function <span class="apidocSignatureSpan">mathjs.</span>dotMultiply
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dotMultiply(arg0, arg1) {
  "use strict";
  var name = 'dotMultiply';
  if (test0(arg0)) { // type: Array
    if (test0(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: Array, Array
      }
    }
    if (test1(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Array, Matrix
      }
    }
    // type: any
    if (arguments.length === 2) {
      return signature2(arg0, arg1); // signature: Array, any
    }
    if (arguments.length &gt; 2) {
      throw createError(name, arguments.length, 2, arguments[2]);
    }
  }
  if (test1(arg0)) { // type: Matrix
    if (test0(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature3(arg0, arg1); // signature: Matrix, Array
      }
    }
    if (test1(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature4(arg0, arg1); // signature: Matrix, Matrix
      }
    }
    // type: any
    if (arguments.length === 2) {
      return signature5(arg0, arg1); // signature: Matrix, any
    }
    if (arguments.length &gt; 2) {
      throw createError(name, arguments.length, 2, arguments[2]);
    }
  }
  // type: any
  if (test0(arg1)) { // type: Array
    if (arguments.length === 2) {
      return signature6(arg0, arg1); // signature: any, Array
    }
  }
  if (test1(arg1)) { // type: Matrix
    if (arguments.length === 2) {
      return signature7(arg0, arg1); // signature: any, Matrix
    }
  }
  // type: any
  if (arguments.length === 2) {
    return signature8(arg0, arg1); // signature: any, any
  }
  if (arguments.length &gt; 2) {
    throw createError(name, arguments.length, 2, arguments[2]);
  }
  throw createError(name, arguments.length, 1, arguments[1], 'Array,Matrix,any');
  throw createError(name, arguments.length, 0, arguments[0], 'Array,Matrix,any');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  /**
* Multiply two matrices element wise. The function accepts both matrices and
* scalar values.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">dotMultiply</span>(x, y)
*
* Examples:
*
*    math.dotMultiply(2, 4); // returns 8
*
*    a = [[9, 5], [6, 1]];
*    b = [[3, 2], [5, 2]];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.dotPow" id="apidoc.element.mathjs.dotPow">
        function <span class="apidocSignatureSpan">mathjs.</span>dotPow
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dotPow(arg0, arg1) {
  "use strict";
  var name = 'dotPow';
  if (test0(arg0)) { // type: Array
    if (test0(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: Array, Array
      }
    }
    if (test1(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Array, Matrix
      }
    }
    // type: any
    if (arguments.length === 2) {
      return signature2(arg0, arg1); // signature: Array, any
    }
    if (arguments.length &gt; 2) {
      throw createError(name, arguments.length, 2, arguments[2]);
    }
  }
  if (test1(arg0)) { // type: Matrix
    if (test0(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature3(arg0, arg1); // signature: Matrix, Array
      }
    }
    if (test1(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature4(arg0, arg1); // signature: Matrix, Matrix
      }
    }
    // type: any
    if (arguments.length === 2) {
      return signature5(arg0, arg1); // signature: Matrix, any
    }
    if (arguments.length &gt; 2) {
      throw createError(name, arguments.length, 2, arguments[2]);
    }
  }
  // type: any
  if (test0(arg1)) { // type: Array
    if (arguments.length === 2) {
      return signature6(arg0, arg1); // signature: any, Array
    }
  }
  if (test1(arg1)) { // type: Matrix
    if (arguments.length === 2) {
      return signature7(arg0, arg1); // signature: any, Matrix
    }
  }
  // type: any
  if (arguments.length === 2) {
    return signature8(arg0, arg1); // signature: any, any
  }
  if (arguments.length &gt; 2) {
    throw createError(name, arguments.length, 2, arguments[2]);
  }
  throw createError(name, arguments.length, 1, arguments[1], 'Array,Matrix,any');
  throw createError(name, arguments.length, 0, arguments[0], 'Array,Matrix,any');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));

/**
 * Calculates the power of x to y element wise.
 *
 * Syntax:
 *
 *    math.<span class="apidocCodeKeywordSpan">dotPow</span>(x, y)
 *
 * Examples:
 *
 *    math.dotPow(2, 3);            // returns number 8
 *
 *    var a = [[1, 2], [4, 3]];
 *    math.dotPow(a, 2);            // returns Array [[1, 4], [16, 9]]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.emit" id="apidoc.element.mathjs.emit">
        function <span class="apidocSignatureSpan">mathjs.</span>emit
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">emit = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    object.deepExtend(config, options);

    var curr = object.clone(config);

    var changes = object.clone(options);

    // emit 'config' event
    math.<span class="apidocCodeKeywordSpan">emit</span>('config', curr, prev, changes);

    return curr;
  }
  else {
    return object.clone(config);
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.equal" id="apidoc.element.mathjs.equal">
        function <span class="apidocSignatureSpan">mathjs.</span>equal
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function equal(arg0, arg1) {
  "use strict";
  var name = 'equal';
  if (test0(arg0)) { // type: Array
    if (test0(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: Array, Array
      }
    }
    if (test1(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Array, Matrix
      }
    }
    // type: any
    if (arguments.length === 2) {
      return signature2(arg0, arg1); // signature: Array, any
    }
    if (arguments.length &gt; 2) {
      throw createError(name, arguments.length, 2, arguments[2]);
    }
  }
  if (test1(arg0)) { // type: Matrix
    if (test0(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature3(arg0, arg1); // signature: Matrix, Array
      }
    }
    if (test1(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature4(arg0, arg1); // signature: Matrix, Matrix
      }
    }
    // type: any
    if (arguments.length === 2) {
      return signature5(arg0, arg1); // signature: Matrix, any
    }
    if (arguments.length &gt; 2) {
      throw createError(name, arguments.length, 2, arguments[2]);
    }
  }
  // type: any
  if (test0(arg1)) { // type: Array
    if (arguments.length === 2) {
      return signature6(arg0, arg1); // signature: any, Array
    }
  }
  if (test1(arg1)) { // type: Matrix
    if (arguments.length === 2) {
      return signature7(arg0, arg1); // signature: any, Matrix
    }
  }
  // type: any
  if (arguments.length === 2) {
    return signature8(arg0, arg1); // signature: any, any
  }
  if (arguments.length &gt; 2) {
    throw createError(name, arguments.length, 2, arguments[2]);
  }
  throw createError(name, arguments.length, 1, arguments[1], 'Array,Matrix,any');
  throw createError(name, arguments.length, 0, arguments[0], 'Array,Matrix,any');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
*    math.deepEqual(2, 4);   // returns false
*
*    a = [2, 5, 1];
*    b = [2, 7, 1];
*
*    math.deepEqual(a, b);   // returns false
*    math.<span class="apidocCodeKeywordSpan">equal</span>(a, b);       // returns [true, false, true]
*
* See also:
*
*    equal, unequal
*
* @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x First matrix to compare
* @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} y Second matrix to compare
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.erf" id="apidoc.element.mathjs.erf">
        function <span class="apidocSignatureSpan">mathjs.</span>erf
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function erf(arg0) {
  "use strict";
  var name = 'erf';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature1(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature2(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature2(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature1(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,BigNumber,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* "Rational Chebyshev Approximations for the Error Function" by W. J. Cody
* for an explanation of this process.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">erf</span>(x)
*
* Examples:
*
*    math.erf(0.2);    // returns 0.22270258921047847
*    math.erf(-0.5);   // returns -0.5204998778130465
*    math.erf(4);      // returns 0.9999999845827421
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.error.ArgumentsError" id="apidoc.element.mathjs.error.ArgumentsError">
        function <span class="apidocSignatureSpan">mathjs.</span>error.ArgumentsError
        <span class="apidocSignatureSpan">(fn, count, min, max)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ArgumentsError(fn, count, min, max) {
  if (!(this instanceof ArgumentsError)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  this.fn = fn;
  this.count = count;
  this.min = min;
  this.max = max;

  this.message = 'Wrong number of arguments in function ' + fn +
      ' (' + count + ' provided, ' +
      min + ((max != undefined) ? ('-' + max) : '') + ' expected)';

  this.stack = (new Error()).stack;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.error.ArgumentsError.prototype.constructor" id="apidoc.element.mathjs.error.ArgumentsError.prototype.constructor">
        function <span class="apidocSignatureSpan">mathjs.</span>error.ArgumentsError.prototype.constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Error() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.error.DimensionError" id="apidoc.element.mathjs.error.DimensionError">
        function <span class="apidocSignatureSpan">mathjs.</span>error.DimensionError
        <span class="apidocSignatureSpan">(actual, expected, relation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DimensionError(actual, expected, relation) {
  if (!(this instanceof DimensionError)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  this.actual   = actual;
  this.expected = expected;
  this.relation = relation;

  this.message = 'Dimension mismatch (' +
      (Array.isArray(actual) ? ('[' + actual.join(', ') + ']') : actual) +
      ' ' + (this.relation || '!=') + ' ' +
      (Array.isArray(expected) ? ('[' + expected.join(', ') + ']') : expected) +
      ')';

  this.stack = (new Error()).stack;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.error.IndexError" id="apidoc.element.mathjs.error.IndexError">
        function <span class="apidocSignatureSpan">mathjs.</span>error.IndexError
        <span class="apidocSignatureSpan">(index, min, max)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function IndexError(index, min, max) {
  if (!(this instanceof IndexError)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  this.index = index;
  if (arguments.length &lt; 3) {
    this.min = 0;
    this.max = min;
  }
  else {
    this.min = min;
    this.max = max;
  }

  if (this.min !== undefined &amp;&amp; this.index &lt; this.min) {
    this.message = 'Index out of range (' + this.index + ' &lt; ' + this.min + ')';
  }
  else if (this.max !== undefined &amp;&amp; this.index &gt;= this.max) {
    this.message = 'Index out of range (' + this.index + ' &gt; ' + (this.max - 1) + ')';
  }
  else {
    this.message = 'Index out of range (' + this.index + ')';
  }

  this.stack = (new Error()).stack;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.eval" id="apidoc.element.mathjs.eval">
        function <span class="apidocSignatureSpan">mathjs.</span>eval
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function compile(arg0, arg1) {
  "use strict";
  var name = 'compile';
  if (test0(arg0)) { // type: string
    if (arguments.length === 1) {
      return signature0(arg0); // signature: string
    }
    if (test1(arg1)) { // type: Object
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: string, Object
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Object');
  }
  if (test2(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature2(arg0); // signature: Array
    }
    if (test1(arg1)) { // type: Object
      if (arguments.length === 2) {
        return signature3(arg0, arg1); // signature: Array, Object
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Object');
  }
  if (test3(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature2(arg0); // signature: Matrix
    }
    if (test1(arg1)) { // type: Object
      if (arguments.length === 2) {
        return signature3(arg0, arg1); // signature: Matrix, Object
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Object');
  }
  if (test4(arg0)) { // type: number (convert to string)
    if (arguments.length === 1) {
      return signature0(convert0(arg0)); // signature: number
    }
    if (test1(arg1)) { // type: Object
      if (arguments.length === 2) {
        return signature1(convert0(arg0), arg1); // signature: number, Object
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Object');
  }
  if (test5(arg0)) { // type: boolean (convert to string)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: boolean
    }
    if (test1(arg1)) { // type: Object
      if (arguments.length === 2) {
        return signature1(convert1(arg0), arg1); // signature: boolean, Object
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Object');
  }
  if (test6(arg0)) { // type: null (convert to string)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: null
    }
    if (test1(arg1)) { // type: Object
      if (arguments.length === 2) {
        return signature1(convert2(arg0), arg1); // signature: null, Object
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Object');
  }
  throw createError(name, arguments.length, 0, arguments[0], 'string,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
math.atan2(3, -3) / math.pi;      // 0.75
math.log(1000, 10);               // 3
math.sqrt(-4);                    // 2i
math.pow([[-1, 2], [3, 1]], 2);   // [[7, 0], [0, 7]]
math.derivative('x^2 + x', 'x');  // 2 * x + 1

// expressions
math.<span class="apidocCodeKeywordSpan">eval</span>('12 / (2.3 + 0.7)');    // 4
math.eval('5.08 cm to inch');     // 2 inch
math.eval('sin(45 deg) ^ 2');     // 0.5
math.eval('9 / 3 + 2i');          // 3 + 2i
math.eval('det([-1, 2; 3, 1])');  // -7

// chaining
math.chain(3)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.exp" id="apidoc.element.mathjs.exp">
        function <span class="apidocSignatureSpan">mathjs.</span>exp
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function exp(arg0) {
  "use strict";
  var name = 'exp';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature2(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// https://www.wikiwand.com/en/Cube_root#/Complex_numbers

var arg_3 = x.arg() / 3;
var abs = x.abs();

// principal root:
var principal = new type.Complex(_cbrtNumber(abs), 0).mul(
    new type.Complex(0, arg_3).<span class="apidocCodeKeywordSpan">exp</span>());

if (allRoots) {
  var all = [
      principal,
      new type.Complex(_cbrtNumber(abs), 0).mul(
        new type.Complex(0, arg_3 + Math.PI * 2 / 3).exp()),
      new type.Complex(_cbrtNumber(abs), 0).mul(
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.Parser" id="apidoc.element.mathjs.expression.Parser">
        function <span class="apidocSignatureSpan">mathjs.</span>expression.Parser
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Parser() {
  if (!(this instanceof Parser)) {
    throw new SyntaxError(
        'Constructor must be called with the new operator');
  }
  this.scope = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.parse" id="apidoc.element.mathjs.expression.parse">
        function <span class="apidocSignatureSpan">mathjs.</span>expression.parse
        <span class="apidocSignatureSpan">(expr, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parse(expr, options) {
  if (arguments.length != 1 &amp;&amp; arguments.length != 2) {
    throw new ArgumentsError('parse', arguments.length, 1, 2);
  }

  // pass extra nodes
  extra_nodes = (options &amp;&amp; options.nodes) ? options.nodes : {};

  if (typeof expr === 'string') {
    // parse a single expression
    expression = expr;
    return parseStart();
  }
  else if (Array.isArray(expr) || expr instanceof type.Matrix) {
    // parse an array or matrix with expressions
    return deepMap(expr, function (elem) {
      if (typeof elem !== 'string') throw new TypeError('String expected');

      expression = elem;
      return parseStart();
    });
  }
  else {
    // oops
    throw new TypeError('String or matrix expected');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.eye" id="apidoc.element.mathjs.eye">
        function <span class="apidocSignatureSpan">mathjs.</span>eye
        <span class="apidocSignatureSpan">(arg0, arg1, arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function eye(arg0, arg1, arg2) {
  "use strict";
  var name = 'eye';
  if (arguments.length === 0) {
    return signature0(); // signature:
  }
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature1(arg0); // signature: number
    }
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: number, number
      }
      if (test1(arg2)) { // type: string
        if (arguments.length === 3) {
          return signature3(arg0, arg1, arg2); // signature: number, number, string
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test0(arg2)) { // type: number (convert to string)
        if (arguments.length === 3) {
          return signature3(arg0, arg1, convert0(arg2)); // signature: number, number, number
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test2(arg2)) { // type: boolean (convert to string)
        if (arguments.length === 3) {
          return signature3(arg0, arg1, convert1(arg2)); // signature: number, number, boolean
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test3(arg2)) { // type: null (convert to string)
        if (arguments.length === 3) {
          return signature3(arg0, arg1, convert2(arg2)); // signature: number, number, null
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      throw createError(name, arguments.length, 2, arguments[2], 'string');
    }
    if (test4(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: number, BigNumber
      }
      if (test1(arg2)) { // type: string
        if (arguments.length === 3) {
          return signature3(arg0, arg1, arg2); // signature: number, BigNumber, string
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test0(arg2)) { // type: number (convert to string)
        if (arguments.length === 3) {
          return signature3(arg0, arg1, convert0(arg2)); // signature: number, BigNumber, number
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test2(arg2)) { // type: boolean (convert to string)
        if (arguments.length === 3) {
          return signature3(arg0, arg1, convert1(arg2)); // signature: number, BigNumber, boolean
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test3(arg2)) { // type: null (convert to string)
        if (arguments.length === 3) {
          return signature3(arg0, arg1, convert2(arg2)); // signature: number, BigNumber, null
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      throw createError(name, arguments.length, 2, arguments[2], 'string');
    }
    if (test1(arg1)) { // type: string
      if (arguments.length === 2) {
        return signature4(arg0, arg1); // signature: number, string
      }
      if (test1(arg2)) { // type: string
        if (arguments.length === 3) {
          return signature3(arg0, convert3(arg1), arg2); // signature: number, string, string
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test0(arg2)) { // type: number (convert to string)
        if (arguments.length === 3) {
          return signature3(arg0, convert3(arg1), convert0(arg2)); // signature: number, string, number
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        } ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  /**
* Create a 2-dimensional identity matrix with size m x n or n x n.
* The matrix has ones on the diagonal and zeros elsewhere.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">eye</span>(n)
*    math.eye(n, format)
*    math.eye(m, n)
*    math.eye(m, n, format)
*    math.eye([m, n])
*    math.eye([m, n], format)
*
* Examples:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.factorial" id="apidoc.element.mathjs.factorial">
        function <span class="apidocSignatureSpan">mathjs.</span>factorial
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factorial(arg0) {
  "use strict";
  var name = 'factorial';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature1(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature2(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature2(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature1(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,BigNumber,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Compute the factorial of a value
*
* Factorial only supports an integer value as argument.
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">factorial</span>(n)
*
* Examples:
*
*    math.factorial(5);    // returns 120
*    math.factorial(3);    // returns 6
*
* See also:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.filter" id="apidoc.element.mathjs.filter">
        function <span class="apidocSignatureSpan">mathjs.</span>filter
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function filter(arg0, arg1) {
  "use strict";
  var name = 'filter';
  if (test0(arg0)) { // type: Array
    if (test1(arg1)) { // type: function
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: Array, function
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: RegExp
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Array, RegExp
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'function,RegExp');
  }
  if (test3(arg0)) { // type: Matrix
    if (test1(arg1)) { // type: function
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: Matrix, function
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: RegExp
      if (arguments.length === 2) {
        return signature3(arg0, arg1); // signature: Matrix, RegExp
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'function,RegExp');
  }
  throw createError(name, arguments.length, 0, arguments[0], 'Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            }
          }
        }
      }
    }

    // remove duplicates
    matches = matches.<span class="apidocCodeKeywordSpan">filter</span>(function(elem, pos, arr) {
      return arr.indexOf(elem) == pos;
    });
  }

  return [matches, keyword];
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.fix" id="apidoc.element.mathjs.fix">
        function <span class="apidocSignatureSpan">mathjs.</span>fix
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fix(arg0) {
  "use strict";
  var name = 'fix';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Fraction
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert0(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Fraction,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function factory (type, config, load, typed) {
/**
 * Round a value towards zero.
 * For matrices, the function is evaluated element wise.
 *
 * Syntax:
 *
 *    math.<span class="apidocCodeKeywordSpan">fix</span>(x)
 *
 * Examples:
 *
 *    math.fix(3.2);                // returns number 3
 *    math.fix(3.8);                // returns number 3
 *    math.fix(-4.2);               // returns number -4
 *    math.fix(-4.7);               // returns number -4
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.flatten" id="apidoc.element.mathjs.flatten">
        function <span class="apidocSignatureSpan">mathjs.</span>flatten
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function flatten(arg0) {
  "use strict";
  var name = 'flatten';
  if (test0(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature0(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @returns {Array}               Array whose data has been formatted to fit the
 *                                specified dimensions
 *
 * @throws {DimensionError}       If the product of the new dimension sizes does
 *                                not equal that of the old ones
 */
exports.reshape = function(array, sizes) {
var flatArray = exports.<span class="apidocCodeKeywordSpan">flatten</span>(array);
var newArray;

var product = function (arr) {
  return arr.reduce(function (prev, curr) {
    return prev * curr;
  });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.floor" id="apidoc.element.mathjs.floor">
        function <span class="apidocSignatureSpan">mathjs.</span>floor
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function floor(arg0) {
  "use strict";
  var name = 'floor';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Fraction
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert0(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Fraction,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   *    ceil, floor, round
   *
   * @param {number | BigNumber | Fraction | Complex | Array | Matrix} x Number to be rounded
   * @return {number | BigNumber | Fraction | Complex | Array | Matrix}            Rounded value
   */
  var fix = typed('fix', {
'number': function (x) {
  return (x &gt; 0) ? Math.<span class="apidocCodeKeywordSpan">floor</span>(x) : Math.ceil(x);
},

'Complex': function (x) {
  return new type.Complex(
      (x.re &gt; 0) ? Math.floor(x.re) : Math.ceil(x.re),
      (x.im &gt; 0) ? Math.floor(x.im) : Math.ceil(x.im)
  );
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.forEach" id="apidoc.element.mathjs.forEach">
        function <span class="apidocSignatureSpan">mathjs.</span>forEach
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function forEach(arg0, arg1) {
  "use strict";
  var name = 'forEach';
  if (test0(arg0)) { // type: Array
    if (test1(arg1)) { // type: function
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: Array, function
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'function');
  }
  if (test2(arg0)) { // type: Matrix
    if (test1(arg1)) { // type: function
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Matrix, function
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'function');
  }
  throw createError(name, arguments.length, 0, arguments[0], 'Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (def.indexOf(keyword) == 0) {
      matches.push(def);
    }
  }
}

// commandline keywords
['exit', 'quit', 'clear'].<span class="apidocCodeKeywordSpan">forEach</span>(function (cmd) {
  if (cmd.indexOf(keyword) == 0) {
    matches.push(cmd);
  }
});

// math functions and constants
var ignore = ['expr', 'type'];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.format" id="apidoc.element.mathjs.format">
        function <span class="apidocSignatureSpan">mathjs.</span>format
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function format(arg0, arg1) {
  "use strict";
  var name = 'format';
  // type: any
  if (arguments.length === 1) {
    return signature0(arg0); // signature: any
  }
  if (test0(arg1)) { // type: number
    if (arguments.length === 2) {
      return signature0(arg0, arg1); // signature: any, number
    }
    if (arguments.length &gt; 2) {
      throw createError(name, arguments.length, 2, arguments[2]);
    }
  }
  if (test1(arg1)) { // type: function
    if (arguments.length === 2) {
      return signature0(arg0, arg1); // signature: any, function
    }
    if (arguments.length &gt; 2) {
      throw createError(name, arguments.length, 2, arguments[2]);
    }
  }
  if (test2(arg1)) { // type: string (convert to number)
    if (arguments.length === 2) {
      return signature0(arg0, convert0(arg1)); // signature: any, string
    }
    if (arguments.length &gt; 2) {
      throw createError(name, arguments.length, 2, arguments[2]);
    }
  }
  if (test3(arg1)) { // type: boolean (convert to number)
    if (arguments.length === 2) {
      return signature0(arg0, convert1(arg1)); // signature: any, boolean
    }
    if (arguments.length &gt; 2) {
      throw createError(name, arguments.length, 2, arguments[2]);
    }
  }
  if (test4(arg1)) { // type: null (convert to number)
    if (arguments.length === 2) {
      return signature0(arg0, convert2(arg1)); // signature: any, null
    }
    if (arguments.length &gt; 2) {
      throw createError(name, arguments.length, 2, arguments[2]);
    }
  }
  if (test5(arg1)) { // type: Object
    if (arguments.length === 2) {
      return signature0(arg0, arg1); // signature: any, Object
    }
    if (arguments.length &gt; 2) {
      throw createError(name, arguments.length, 2, arguments[2]);
    }
  }
  throw createError(name, arguments.length, 1, arguments[1], 'number,function,Object');
  throw createError(name, arguments.length, 0, arguments[0], 'any');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Helper function to format a value. Regular numbers will be rounded
 * to 14 digits to prevent round-off errors from showing up.
 * @param {*} value
 */
function format(value) {
var math = getMath();

return math.<span class="apidocCodeKeywordSpan">format</span>(value, {
  fn: function (value) {
    if (typeof value === 'number') {
      // round numbers
      return math.format(value, PRECISION);
    }
    else {
      return math.format(value);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.fraction" id="apidoc.element.mathjs.fraction">
        function <span class="apidocSignatureSpan">mathjs.</span>fraction
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fraction(arg0, arg1) {
  "use strict";
  var name = 'fraction';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: number, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: number, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert1(arg1)); // signature: number, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert2(arg1)); // signature: number, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'number');
  }
  if (test4(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Fraction
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: string
    if (arguments.length === 1) {
      return signature4(arg0); // signature: string
    }
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature1(convert0(arg0), arg1); // signature: string, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature1(convert0(arg0), convert0(arg1)); // signature: string, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature1(convert0(arg0), convert1(arg1)); // signature: string, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature1(convert0(arg0), convert2(arg1)); // signature: string, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'number');
  }
  if (test6(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature5(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature5(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: boolean
    }
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature1(convert1(arg0), arg1); // signature: bo ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      case 'number':
// TODO: replace this with using config.number
var numConfig = defs.math.config().number;
if (numConfig === 'BigNumber') {
  return 'math.bignumber("' + this.value + '")';
}
else if (numConfig === 'Fraction') {
  return 'math.<span class="apidocCodeKeywordSpan">fraction</span>("' + this.value + '")';
}
else {
  // remove leading zeros like '003.2' which are not allowed by JavaScript
  return this.value.replace(/^(0*)[0-9]/, function (match, zeros) {
    return match.substring(zeros.length);
  });
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.gamma" id="apidoc.element.mathjs.gamma">
        function <span class="apidocSignatureSpan">mathjs.</span>gamma
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function gamma(arg0) {
  "use strict";
  var name = 'gamma';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature2(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Compute the gamma function of a value using Lanczos approximation for
* small values, and an extended Stirling approximation for large values.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">gamma</span>(n)
*
* Examples:
*
*    math.gamma(5);       // returns 24
*    math.gamma(-0.5);    // returns -3.5449077018110335
*    math.gamma(math.i);  // returns -0.15494982830180973 - 0.49801566811835596i
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.gcd" id="apidoc.element.mathjs.gcd">
        function <span class="apidocSignatureSpan">mathjs.</span>gcd
        <span class="apidocSignatureSpan">(arg0, arg1, arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function gcd(arg0, arg1, arg2) {
  "use strict";
  var name = 'gcd';
  if (test0(arg0)) { // type: number
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: number, number
      }
      if (test1(arg2) || test2(arg2) || test0(arg2) || test3(arg2)) { // type: ...Array|Matrix|number|BigNumber
        var varArgs = [arg2];
        for (var i = 3; i &lt; arguments.length; i++) {
          if (test1(arguments[i]) || test2(arguments[i]) || test0(arguments[i]) || test3(arguments[i])) {
            varArgs.push(arguments[i]);
          } else {
            throw createError(name, arguments.length, i, arguments[i], 'Array,Matrix,number,BigNumber');
          }
        }
        return signature1(arg0, arg1, varArgs); // signature: number, number, ...Array|Matrix|number|BigNumber
      }
      throw createError(name, arguments.length, 2, arguments[2], 'Array,Matrix,number,BigNumber');
    }
    if (test3(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature2(convert0(arg0), arg1); // signature: number, BigNumber
      }
      if (test1(arg2) || test2(arg2) || test0(arg2) || test3(arg2)) { // type: ...Array|Matrix|number|BigNumber
        var varArgs = [arg2];
        for (var i = 3; i &lt; arguments.length; i++) {
          if (test1(arguments[i]) || test2(arguments[i]) || test0(arguments[i]) || test3(arguments[i])) {
            varArgs.push(arguments[i]);
          } else {
            throw createError(name, arguments.length, i, arguments[i], 'Array,Matrix,number,BigNumber');
          }
        }
        return signature1(arg0, arg1, varArgs); // signature: number, BigNumber, ...Array|Matrix|number|BigNumber
      }
      throw createError(name, arguments.length, 2, arguments[2], 'Array,Matrix,number,BigNumber');
    }
    if (test4(arg1)) { // type: Fraction
      if (arguments.length === 2) {
        return signature3(convert1(arg0), arg1); // signature: number, Fraction
      }
      if (test1(arg2) || test2(arg2) || test0(arg2) || test3(arg2)) { // type: ...Array|Matrix|number|BigNumber
        var varArgs = [arg2];
        for (var i = 3; i &lt; arguments.length; i++) {
          if (test1(arguments[i]) || test2(arguments[i]) || test0(arguments[i]) || test3(arguments[i])) {
            varArgs.push(arguments[i]);
          } else {
            throw createError(name, arguments.length, i, arguments[i], 'Array,Matrix,number,BigNumber');
          }
        }
        return signature1(arg0, convert2(arg1), varArgs); // signature: number, Fraction, ...Array|Matrix|number|BigNumber
      }
      throw createError(name, arguments.length, 2, arguments[2], 'Array,Matrix,number,BigNumber');
    }
    if (test1(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature4(arg0, arg1); // signature: number, Array
      }
      if (test1(arg2) || test2(arg2) || test0(arg2) || test3(arg2)) { // type: ...Array|Matrix|number|BigNumber
        var varArgs = [arg2];
        for (var i = 3; i &lt; arguments.length; i++) {
          if (test1(arguments[i]) || test2(arguments[i]) || test0(arguments[i]) || test3(arguments[i])) {
            varArgs.push(arguments[i]);
          } else {
            throw createError(name, arguments.length, i, arguments[i], 'Array,Matrix,number,BigNumber');
          }
        }
        return signature1(arg0, arg1, varArgs); // signature: number, Array, ...Array|Matrix|number|BigNumber
      }
      throw createError(name, arguments.length, 2, arguments[2], 'Array,Matrix,number,BigNumber');
    }
    if (test2(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature5(arg0, arg1); // signature: number, Matrix
      }
      if (test1(arg2) || test2(arg2) || test0(arg2) || test3(arg2)) { // type: ...Array|Matrix|number|BigNumber
        var varArgs = [arg2];
        for (var i = 3; i &lt; arguments.length; i++) {
          if (test1(arguments[i]) || test2(arguments[i]) || test0(arguments[i]) || test3(arguments[i])) {
            varArgs.push(arguments[i]); ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Calculate the greatest common divisor for two or more values or arrays.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">gcd</span>(a, b)
*    math.gcd(a, b, c, ...)
*
* Examples:
*
*    math.gcd(8, 12);              // returns 4
*    math.gcd(-4, 6);              // returns 2
*    math.gcd(25, 15, -10);        // returns 5
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.help" id="apidoc.element.mathjs.help">
        function <span class="apidocSignatureSpan">mathjs.</span>help
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function help(arg0) {
  "use strict";
  var name = 'help';
  // type: any
  if (arguments.length === 1) {
    return signature0(arg0); // signature: any
  }
  if (arguments.length &gt; 1) {
    throw createError(name, arguments.length, 1, arguments[1]);
  }
  throw createError(name, arguments.length, 0, arguments[0], 'any');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Object                 | `'Object'`    | `math.typeof ({a: 2, b: 3})`
* RegExp                 | `'RegExp'`    | `math.typeof (/a regexp/)`
* undefined              | `'undefined'` | `math.typeof(undefined)`
* math.type.BigNumber    | `'BigNumber'` | `math.typeof (math.bignumber('2.3e500'))`
* math.type.Chain        | `'Chain'`     | `math.typeof (math.chain(2))`
* math.type.Complex      | `'Complex'`   | `math.typeof (math.complex(2, 3))`
* math.type.Fraction     | `'Fraction'`  | `math.typeof (math.fraction(1, 3))`
* math.type.Help         | `'Help'`      | `math.typeof (math.<span class="apidocCodeKeywordSpan">help</span>('sqrt
'))`
* math.type.Index        | `'Index'`     | `math.typeof (math.index(1, 3))`
* math.type.Matrix       | `'Matrix'`    | `math.typeof (math.matrix([[1,2], [3, 4]]))`
* math.type.Range        | `'Range'`     | `math.typeof (math.range(0, 10))`
* math.type.Unit         | `'Unit'`      | `math.typeof (math.unit('45 deg'))`
*
* Syntax:
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.hypot" id="apidoc.element.mathjs.hypot">
        function <span class="apidocSignatureSpan">mathjs.</span>hypot
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hypot(arg0) {
  "use strict";
  var name = 'hypot';
  if (test0(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature0(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0) || test3(arg0) || test4(arg0) || test5(arg0) || test5(arg0) || test6(arg0) || test6(arg0) || test7(arg0) || test7
(arg0)) { // type: ...number|BigNumber|Fraction|string|boolean|null
    var varArgs = [arg0];
    for (var i = 1; i &lt; arguments.length; i++) {
      if (test2(arguments[i]) || test3(arguments[i])) {
        varArgs.push(arguments[i]);
      }
      else if (test4(arguments[i])) {
        varArgs.push(convert0(arguments[i]));
      }
      else if (test5(arguments[i])) {
        varArgs.push(convert1(arguments[i]));
      }
      else if (test5(arguments[i])) {
        varArgs.push(convert2(arguments[i]));
      }
      else if (test6(arguments[i])) {
        varArgs.push(convert3(arguments[i]));
      }
      else if (test6(arguments[i])) {
        varArgs.push(convert4(arguments[i]));
      }
      else if (test7(arguments[i])) {
        varArgs.push(convert5(arguments[i]));
      }
      else if (test7(arguments[i])) {
        varArgs.push(convert6(arguments[i]));
      } else {
        throw createError(name, arguments.length, i, arguments[i], 'number,BigNumber');
      }
    }
    return signature2(varArgs); // signature: ...number|BigNumber|Fraction|string|boolean|null
  }
  throw createError(name, arguments.length, 0, arguments[0], 'Array,Matrix,number,BigNumber');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
*     hypot(a, b, c, ...) = sqrt(a^2 + b^2 + c^2 + ...)
*
* For matrix input, the hypotenusa is calculated for all values in the matrix.
*
* Syntax:
*
*     math.<span class="apidocCodeKeywordSpan">hypot</span>(a, b, ...)
*     math.hypot([a, b, c, ...])
*
* Examples:
*
*     math.hypot(3, 4);      // 5
*     math.hypot(3, 4, 5);   // 7.0710678118654755
*     math.hypot([3, 4, 5]); // 7.0710678118654755
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.im" id="apidoc.element.mathjs.im">
        function <span class="apidocSignatureSpan">mathjs.</span>im
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function im(arg0) {
  "use strict";
  var name = 'im';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature2(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Get the imaginary part of a complex number.
* For a complex number `a + bi`, the function returns `b`.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">im</span>(x)
*
* Examples:
*
*    var a = math.complex(2, 3);
*    math.re(a);                     // returns number 2
*    math.im(a);                     // returns number 3
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.import" id="apidoc.element.mathjs.import">
        function <span class="apidocSignatureSpan">mathjs.</span>import
        <span class="apidocSignatureSpan">(object, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function math_import(object, options) {
  var num = arguments.length;
  if (num !== 1 &amp;&amp; num !== 2) {
    throw new ArgumentsError('import', num, 1, 2);
  }

  if (!options) {
    options = {};
  }

  if (isFactory(object)) {
    _importFactory(object, options);
  }
  // TODO: allow a typed-function with name too
  else if (Array.isArray(object)) {
    object.forEach(function (entry) {
      math_import(entry, options);
    });
  }
  else if (typeof object === 'object') {
    // a map with functions
    for (var name in object) {
      if (object.hasOwnProperty(name)) {
        var value = object[name];
        if (isSupportedType(value)) {
          _import(name, value, options);
        }
        else if (isFactory(object)) {
          _importFactory(object, options);
        }
        else {
          math_import(value, options);
        }
      }
    }
  }
  else {
    if (!options.silent) {
      throw new TypeError('Factory, Object, or Array expected');
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

function factory (type, config, load, typed, math) {
/**
 * Import functions from an object or a module
 *
 * Syntax:
 *
 *    math.<span class="apidocCodeKeywordSpan">import</span>(object)
 *    math.import(object, options)
 *
 * Where:
 *
 * - `object: Object`
 *   An object with functions to be imported.
 * - `options: Object` An object with import options. Available options:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.index" id="apidoc.element.mathjs.index">
        function <span class="apidocSignatureSpan">mathjs.</span>index
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function index(arg0) {
  "use strict";
  var name = 'index';
  if (test0(arg0) || test1(arg0) || test2(arg0) || test3(arg0) || test4(arg0) || test5(arg0) || test6(arg0) || test7(arg0) || test7
(arg0) || test7(arg0) || test8(arg0) || test8(arg0) || test8(arg0)) { // type: ...number|string|BigNumber|Range|Array|Matrix|Fraction
|boolean|null
    var varArgs = [arg0];
    for (var i = 1; i &lt; arguments.length; i++) {
      if (test0(arguments[i]) || test1(arguments[i]) || test2(arguments[i]) || test3(arguments[i]) || test4(arguments[i]) || test5
(arguments[i])) {
        varArgs.push(arguments[i]);
      }
      else if (test6(arguments[i])) {
        varArgs.push(convert0(arguments[i]));
      }
      else if (test7(arguments[i])) {
        varArgs.push(convert1(arguments[i]));
      }
      else if (test7(arguments[i])) {
        varArgs.push(convert2(arguments[i]));
      }
      else if (test7(arguments[i])) {
        varArgs.push(convert3(arguments[i]));
      }
      else if (test8(arguments[i])) {
        varArgs.push(convert4(arguments[i]));
      }
      else if (test8(arguments[i])) {
        varArgs.push(convert5(arguments[i]));
      }
      else if (test8(arguments[i])) {
        varArgs.push(convert6(arguments[i]));
      } else {
        throw createError(name, arguments.length, i, arguments[i], 'number,string,BigNumber,Range,Array,Matrix');
      }
    }
    return signature0(varArgs); // signature: ...number|string|BigNumber|Range|Array|Matrix|Fraction|boolean|null
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,string,BigNumber,Range,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
          '})()'
    }
    else { // ConstantNode
      return range._compile(defs, childArgs);
    }
  });

  return 'math.<span class="apidocCodeKeywordSpan">index</span>(' + dimensions.join(', ') + ')';
};

/**
 * Execute a callback for each of the child nodes of this node
 * @param {function(child: Node, path: string, parent: Node)} callback
 */
IndexNode.prototype.forEach = function (callback) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.intersect" id="apidoc.element.mathjs.intersect">
        function <span class="apidocSignatureSpan">mathjs.</span>intersect
        <span class="apidocSignatureSpan">(arg0, arg1, arg2, arg3)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function intersect(arg0, arg1, arg2, arg3) {
  "use strict";
  var name = 'intersect';
  if (test0(arg0)) { // type: Array
    if (test0(arg1)) { // type: Array
      if (test0(arg2)) { // type: Array
        if (arguments.length === 3) {
          return signature0(arg0, arg1, arg2); // signature: Array, Array, Array
        }
        if (test0(arg3)) { // type: Array
          if (arguments.length === 4) {
            return signature1(arg0, arg1, arg2, arg3); // signature: Array, Array, Array, Array
          }
          if (arguments.length &gt; 4) {
            throw createError(name, arguments.length, 4, arguments[4]);
          }
        }
        if (test1(arg3)) { // type: Matrix (convert to Array)
          if (arguments.length === 4) {
            return signature1(arg0, arg1, arg2, convert0(arg3)); // signature: Array, Array, Array, Matrix
          }
          if (arguments.length &gt; 4) {
            throw createError(name, arguments.length, 4, arguments[4]);
          }
        }
        throw createError(name, arguments.length, 3, arguments[3], 'Array');
      }
      if (test1(arg2)) { // type: Matrix (convert to Array)
        if (arguments.length === 3) {
          return signature0(arg0, arg1, convert0(arg2)); // signature: Array, Array, Matrix
        }
        if (test0(arg3)) { // type: Array
          if (arguments.length === 4) {
            return signature1(arg0, arg1, convert0(arg2), arg3); // signature: Array, Array, Matrix, Array
          }
          if (arguments.length &gt; 4) {
            throw createError(name, arguments.length, 4, arguments[4]);
          }
        }
        if (test1(arg3)) { // type: Matrix (convert to Array)
          if (arguments.length === 4) {
            return signature1(arg0, arg1, convert0(arg2), convert0(arg3)); // signature: Array, Array, Matrix, Matrix
          }
          if (arguments.length &gt; 4) {
            throw createError(name, arguments.length, 4, arguments[4]);
          }
        }
        throw createError(name, arguments.length, 3, arguments[3], 'Array');
      }
      throw createError(name, arguments.length, 2, arguments[2], 'Array');
    }
    if (test1(arg1)) { // type: Matrix
      if (test0(arg2)) { // type: Array
        if (arguments.length === 3) {
          return signature0(arg0, convert0(arg1), arg2); // signature: Array, Matrix, Array
        }
        if (test0(arg3)) { // type: Array
          if (arguments.length === 4) {
            return signature1(arg0, convert0(arg1), arg2, arg3); // signature: Array, Matrix, Array, Array
          }
          if (arguments.length &gt; 4) {
            throw createError(name, arguments.length, 4, arguments[4]);
          }
        }
        if (test1(arg3)) { // type: Matrix (convert to Array)
          if (arguments.length === 4) {
            return signature1(arg0, convert0(arg1), arg2, convert0(arg3)); // signature: Array, Matrix, Array, Matrix
          }
          if (arguments.length &gt; 4) {
            throw createError(name, arguments.length, 4, arguments[4]);
          }
        }
        throw createError(name, arguments.length, 3, arguments[3], 'Array');
      }
      if (test1(arg2)) { // type: Matrix
        if (arguments.length === 3) {
          return signature2(convert1(arg0), arg1, arg2); // signature: Array, Matrix, Matrix
        }
        if (test0(arg3)) { // type: Array
          if (arguments.length === 4) {
            return signature1(arg0, convert0(arg1), convert0(arg2), arg3); // signature: Array, Matrix, Matrix, Array
          }
          if (arguments.length &gt; 4) {
            throw createError(name, arguments.length, 4, arguments[4]);
          }
        }
        if (test1(arg3)) { // type: Matrix
          if (arguments.length === 4) {
            return signature3(convert1(arg0), arg1, arg2, arg3); // signature: Array, Matrix, Matrix, Matrix
          }
          if (arguments.length &gt; 4) {
            throw createError(name, arguments.length, 4, arguments[4]);
          }
        }
        throw createError(name, arguments.length, 3, arguments[3], 'Array,Matrix ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* arrays or 1 dimensional matrices. The line intersection functions return null
* if the lines do not meet.
*
* Note: Fill the plane coefficients as `x + y + z = c` and not as `x + y + z + c = 0`.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">intersect</span>(endPoint1Line1, endPoint2Line1, endPoint1Line2, endPoint2Line2)
*    math.intersect(endPoint1, endPoint2, planeCoefficients)
*
* Examples:
*
*    math.intersect([0, 0], [10, 10], [10, 0], [0, 10]);              // Returns [5, 5]
*    math.intersect([0, 0, 0], [10, 10, 0], [10, 0, 0], [0, 10, 0]);  // Returns [5, 5, 0]
*    math.intersect([1, 0, 1],  [4, -2, 2], [1, 1, 1, 6]);            // Returns [7, -4, 3]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.inv" id="apidoc.element.mathjs.inv">
        function <span class="apidocSignatureSpan">mathjs.</span>inv
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function inv(arg0) {
  "use strict";
  var name = 'inv';
  if (test0(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature0(arg0); // signature: Array
    }
  }
  if (test1(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature0(arg0); // signature: Matrix
    }
  }
  // type: any
  if (arguments.length === 1) {
    return signature1(arg0); // signature: any
  }
  if (arguments.length &gt; 1) {
    throw createError(name, arguments.length, 1, arguments[1]);
  }
  throw createError(name, arguments.length, 0, arguments[0], 'Array,Matrix,any');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var eye          = load(require('./eye'));

/**
 * Calculate the inverse of a square matrix.
 *
 * Syntax:
 *
 *     math.<span class="apidocCodeKeywordSpan">inv</span>(x)
 *
 * Examples:
 *
 *     math.inv([[1, 2], [3, 4]]);  // returns [[-2, 1], [1.5, -0.5]]
 *     math.inv(4);                 // returns 0.25
 *     1 / 4;                       // returns 0.25
 *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.isInteger" id="apidoc.element.mathjs.isInteger">
        function <span class="apidocSignatureSpan">mathjs.</span>isInteger
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isInteger(arg0) {
  "use strict";
  var name = 'isInteger';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature1(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: Fraction
    if (arguments.length === 1) {
      return signature2(arg0); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert0(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,BigNumber,Fraction,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * Test whether index is an integer number with index &gt;= 0 and index &lt; length
 * when length is provided
 * @param {number} index    Zero-based index
 * @param {number} [length] Length of the array
 */
exports.validateIndex = function(index, length) {
  if (!number.isNumber(index) || !number.<span class="apidocCodeKeywordSpan">isInteger</span>(index)) {
    throw new TypeError('Index must be an integer (value: ' + index + ')');
  }
  if (index &lt; 0 || (typeof length === 'number' &amp;&amp; index &gt;= length)) {
    throw new IndexError(index, length);
  }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.isNaN" id="apidoc.element.mathjs.isNaN">
        function <span class="apidocSignatureSpan">mathjs.</span>isNaN
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isNaN(arg0) {
  "use strict";
  var name = 'isNaN';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Fraction
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Unit
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Unit
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature5(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature5(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert0(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test9(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Fraction,Unit,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
},

'Complex, Complex': function (x, y) {
  return (x.re !== 0 || x.im !== 0) &amp;&amp; (y.re !== 0 || y.im !== 0);
},

'BigNumber, BigNumber': function (x, y) {
  return !x.isZero() &amp;&amp; !y.isZero() &amp;&amp; !x.<span class="apidocCodeKeywordSpan">isNaN</span>() &amp;&amp; !y
.isNaN();
},

'Unit, Unit': function (x, y) {
  return and(x.value, y.value);
},

'Matrix, Matrix': function (x, y) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.isNegative" id="apidoc.element.mathjs.isNegative">
        function <span class="apidocSignatureSpan">mathjs.</span>isNegative
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isNegative(arg0) {
  "use strict";
  var name = 'isNegative';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature1(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: Fraction
    if (arguments.length === 1) {
      return signature2(arg0); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Unit
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Unit
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert0(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,BigNumber,Fraction,Unit,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return new type.Complex(
      (x.re &gt; 0) ? Math.floor(x.re) : Math.ceil(x.re),
      (x.im &gt; 0) ? Math.floor(x.im) : Math.ceil(x.im)
  );
},

'BigNumber': function (x) {
  return x.<span class="apidocCodeKeywordSpan">isNegative</span>() ? x.ceil() : x.floor();
},

'Fraction': function (x) {
  return x.s &lt; 0 ? x.ceil() : x.floor();
},

'Array | Matrix': function (x) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.isNumeric" id="apidoc.element.mathjs.isNumeric">
        function <span class="apidocSignatureSpan">mathjs.</span>isNumeric
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isNumeric(arg0) {
  "use strict";
  var name = 'isNumeric';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature0(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Fraction
    if (arguments.length === 1) {
      return signature0(arg0); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Unit
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Unit
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: string
    if (arguments.length === 1) {
      return signature1(arg0); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature2(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature2(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: boolean
    if (arguments.length === 1) {
      return signature0(arg0); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test9(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert0(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Fraction,Unit,string,Array,Matrix,boolean
');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Test whether a value is an numeric value.
*
* The function is evaluated element-wise in case of Array or Matrix input.
*
* Syntax:
*
*     math.<span class="apidocCodeKeywordSpan">isNumeric</span>(x)
*
* Examples:
*
*    math.isNumeric(2);                     // returns true
*    math.isNumeric(0);                     // returns true
*    math.isNumeric(math.bignumber(500));   // returns true
*    math.isNumeric(math.fraction(4));      // returns true
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.isPositive" id="apidoc.element.mathjs.isPositive">
        function <span class="apidocSignatureSpan">mathjs.</span>isPositive
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isPositive(arg0) {
  "use strict";
  var name = 'isPositive';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature1(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: Fraction
    if (arguments.length === 1) {
      return signature2(arg0); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Unit
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Unit
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert0(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,BigNumber,Fraction,Unit,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Test whether a value is positive: larger than zero.
* The function supports types `number`, `BigNumber`, `Fraction`, and `Unit`.
*
* The function is evaluated element-wise in case of Array or Matrix input.
*
* Syntax:
*
*     math.<span class="apidocCodeKeywordSpan">isPositive</span>(x)
*
* Examples:
*
*    math.isPositive(3);                     // returns true
*    math.isPositive(-2);                    // returns false
*    math.isPositive(0);                     // returns false
*    math.isPositive(-0);                    // returns false
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.isPrime" id="apidoc.element.mathjs.isPrime">
        function <span class="apidocSignatureSpan">mathjs.</span>isPrime
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isPrime(arg0) {
  "use strict";
  var name = 'isPrime';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature1(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature2(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature2(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature1(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,BigNumber,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Test whether a value is prime: has no divisors other than itself and one.
* The function supports type `number`, `bignumber`.
*
* The function is evaluated element-wise in case of Array or Matrix input.
*
* Syntax:
*
*     math.<span class="apidocCodeKeywordSpan">isPrime</span>(x)
*
* Examples:
*
*    math.isPrime(3);                     // returns true
*    math.isPrime(-2);                    // returns false
*    math.isPrime(0);                     // returns false
*    math.isPrime(-0);                    // returns false
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.isZero" id="apidoc.element.mathjs.isZero">
        function <span class="apidocSignatureSpan">mathjs.</span>isZero
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isZero(arg0) {
  "use strict";
  var name = 'isZero';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Fraction
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Unit
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Unit
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature5(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature5(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert0(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test9(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Fraction,Unit,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
},

'number': function (x) {
  return !!x;
},

'BigNumber': function (x) {
  return !x.<span class="apidocCodeKeywordSpan">isZero</span>();
},

'string': function (x) {
  // try case insensitive
  var lcase = x.toLowerCase();
  if (lcase === 'true') {
    return true;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.kldivergence" id="apidoc.element.mathjs.kldivergence">
        function <span class="apidocSignatureSpan">mathjs.</span>kldivergence
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function kldivergence(arg0, arg1) {
  "use strict";
  var name = 'kldivergence';
  if (test0(arg0)) { // type: Array
    if (test0(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: Array, Array
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Array, Matrix
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Array,Matrix');
  }
  if (test1(arg0)) { // type: Matrix
    if (test0(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: Matrix, Array
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature3(arg0, arg1); // signature: Matrix, Matrix
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Array,Matrix');
  }
  throw createError(name, arguments.length, 0, arguments[0], 'Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var isNumeric = load(require('../utils/isNumeric'));

/**
 * Calculate the Kullback-Leibler (KL) divergence  between two distributions
 *
 * Syntax:
 *
 *     math.<span class="apidocCodeKeywordSpan">kldivergence</span>(x, y)
 *
 * Examples:
 *
 *     math.kldivergence([0.7,0.5,0.4], [0.2,0.9,0.5]);   //returns 0.24376698773121153
 *
 *
 * @param  {Array | Matrix} q    First vector
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.kron" id="apidoc.element.mathjs.kron">
        function <span class="apidocSignatureSpan">mathjs.</span>kron
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function kron(arg0, arg1) {
  "use strict";
  var name = 'kron';
  if (test0(arg0)) { // type: Array
    if (test0(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: Array, Array
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Array, Matrix
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Array,Matrix');
  }
  if (test1(arg0)) { // type: Matrix
    if (test0(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: Matrix, Array
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature3(arg0, arg1); // signature: Matrix, Matrix
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Array,Matrix');
  }
  throw createError(name, arguments.length, 0, arguments[0], 'Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* NOTE: If a one dimensional vector / matrix is given, it will be
* wrapped so its two dimensions.
* See the examples.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">kron</span>(x, y)
*
* Examples:
*
*    math.kron([[1, 0], [0, 1]], [[1, 2], [3, 4]]);
*    // returns [ [ 1, 2, 0, 0 ], [ 3, 4, 0, 0 ], [ 0, 0, 1, 2 ], [ 0, 0, 3, 4 ] ]
*
*    math.kron([1,1], [2,3,4]);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.larger" id="apidoc.element.mathjs.larger">
        function <span class="apidocSignatureSpan">mathjs.</span>larger
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function larger(arg0, arg1) {
  "use strict";
  var name = 'larger';
  if (test0(arg0)) { // type: number
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: number, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: Complex
      if (arguments.length === 2) {
        return signature1(convert0(arg0), arg1); // signature: number, Complex
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature2(convert1(arg0), arg1); // signature: number, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: Fraction
      if (arguments.length === 2) {
        return signature3(convert2(arg0), arg1); // signature: number, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert3(arg1)); // signature: number, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert4(arg1)); // signature: number, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test6(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert5(arg1)); // signature: number, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
  }
  if (test1(arg0)) { // type: Complex
    if (test1(arg1)) { // type: Complex
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Complex, Complex
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test0(arg1)) { // type: number (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: Complex, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: BigNumber (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert6(arg1)); // signature: Complex, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: Fraction (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert7(arg1)); // signature: Complex, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: string (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert8(arg1)); // signature: Complex, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (test1(arg1)) { // type: Complex
      if (arguments.length === 2) {
        return signature1(convert6(arg0), arg1); // signature: BigNumber, Complex
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: BigNumber, BigNu ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* Syntax:
*
*    math.largerEq(x, y)
*
* Examples:
*
*    math.<span class="apidocCodeKeywordSpan">larger</span>(2, 1 + 1);         // returns false
*    math.largerEq(2, 1 + 1);       // returns true
*
* See also:
*
*    equal, unequal, smaller, smallerEq, larger, compare
*
* @param  {number | BigNumber | Fraction | boolean | Unit | string | Array | Matrix} x First value to compare
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.largerEq" id="apidoc.element.mathjs.largerEq">
        function <span class="apidocSignatureSpan">mathjs.</span>largerEq
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function largerEq(arg0, arg1) {
  "use strict";
  var name = 'largerEq';
  if (test0(arg0)) { // type: number
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: number, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: Complex
      if (arguments.length === 2) {
        return signature1(convert0(arg0), arg1); // signature: number, Complex
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature2(convert1(arg0), arg1); // signature: number, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: Fraction
      if (arguments.length === 2) {
        return signature3(convert2(arg0), arg1); // signature: number, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert3(arg1)); // signature: number, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert4(arg1)); // signature: number, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test6(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert5(arg1)); // signature: number, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
  }
  if (test1(arg0)) { // type: Complex
    if (test1(arg1)) { // type: Complex
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Complex, Complex
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test0(arg1)) { // type: number (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: Complex, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: BigNumber (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert6(arg1)); // signature: Complex, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: Fraction (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert7(arg1)); // signature: Complex, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: string (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert8(arg1)); // signature: Complex, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (test1(arg1)) { // type: Complex
      if (arguments.length === 2) {
        return signature1(convert6(arg0), arg1); // signature: BigNumber, Complex
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: BigNumber, B ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* difference between x and y is smaller than the configured epsilon. The
* function cannot be used to compare values smaller than approximately 2.22e-16.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">largerEq</span>(x, y)
*
* Examples:
*
*    math.larger(2, 1 + 1);         // returns false
*    math.largerEq(2, 1 + 1);       // returns true
*
* See also:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.lcm" id="apidoc.element.mathjs.lcm">
        function <span class="apidocSignatureSpan">mathjs.</span>lcm
        <span class="apidocSignatureSpan">(arg0, arg1, arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function lcm(arg0, arg1, arg2) {
  "use strict";
  var name = 'lcm';
  if (test0(arg0)) { // type: number
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: number, number
      }
      if (test1(arg2) || test2(arg2) || test0(arg2) || test3(arg2)) { // type: ...Array|Matrix|number|BigNumber
        var varArgs = [arg2];
        for (var i = 3; i &lt; arguments.length; i++) {
          if (test1(arguments[i]) || test2(arguments[i]) || test0(arguments[i]) || test3(arguments[i])) {
            varArgs.push(arguments[i]);
          } else {
            throw createError(name, arguments.length, i, arguments[i], 'Array,Matrix,number,BigNumber');
          }
        }
        return signature1(arg0, arg1, varArgs); // signature: number, number, ...Array|Matrix|number|BigNumber
      }
      throw createError(name, arguments.length, 2, arguments[2], 'Array,Matrix,number,BigNumber');
    }
    if (test3(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature2(convert0(arg0), arg1); // signature: number, BigNumber
      }
      if (test1(arg2) || test2(arg2) || test0(arg2) || test3(arg2)) { // type: ...Array|Matrix|number|BigNumber
        var varArgs = [arg2];
        for (var i = 3; i &lt; arguments.length; i++) {
          if (test1(arguments[i]) || test2(arguments[i]) || test0(arguments[i]) || test3(arguments[i])) {
            varArgs.push(arguments[i]);
          } else {
            throw createError(name, arguments.length, i, arguments[i], 'Array,Matrix,number,BigNumber');
          }
        }
        return signature1(arg0, arg1, varArgs); // signature: number, BigNumber, ...Array|Matrix|number|BigNumber
      }
      throw createError(name, arguments.length, 2, arguments[2], 'Array,Matrix,number,BigNumber');
    }
    if (test4(arg1)) { // type: Fraction
      if (arguments.length === 2) {
        return signature3(convert1(arg0), arg1); // signature: number, Fraction
      }
      if (test1(arg2) || test2(arg2) || test0(arg2) || test3(arg2)) { // type: ...Array|Matrix|number|BigNumber
        var varArgs = [arg2];
        for (var i = 3; i &lt; arguments.length; i++) {
          if (test1(arguments[i]) || test2(arguments[i]) || test0(arguments[i]) || test3(arguments[i])) {
            varArgs.push(arguments[i]);
          } else {
            throw createError(name, arguments.length, i, arguments[i], 'Array,Matrix,number,BigNumber');
          }
        }
        return signature1(arg0, convert2(arg1), varArgs); // signature: number, Fraction, ...Array|Matrix|number|BigNumber
      }
      throw createError(name, arguments.length, 2, arguments[2], 'Array,Matrix,number,BigNumber');
    }
    if (test1(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature4(arg0, arg1); // signature: number, Array
      }
      if (test1(arg2) || test2(arg2) || test0(arg2) || test3(arg2)) { // type: ...Array|Matrix|number|BigNumber
        var varArgs = [arg2];
        for (var i = 3; i &lt; arguments.length; i++) {
          if (test1(arguments[i]) || test2(arguments[i]) || test0(arguments[i]) || test3(arguments[i])) {
            varArgs.push(arguments[i]);
          } else {
            throw createError(name, arguments.length, i, arguments[i], 'Array,Matrix,number,BigNumber');
          }
        }
        return signature1(arg0, arg1, varArgs); // signature: number, Array, ...Array|Matrix|number|BigNumber
      }
      throw createError(name, arguments.length, 2, arguments[2], 'Array,Matrix,number,BigNumber');
    }
    if (test2(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature5(arg0, arg1); // signature: number, Matrix
      }
      if (test1(arg2) || test2(arg2) || test0(arg2) || test3(arg2)) { // type: ...Array|Matrix|number|BigNumber
        var varArgs = [arg2];
        for (var i = 3; i &lt; arguments.length; i++) {
          if (test1(arguments[i]) || test2(arguments[i]) || test0(arguments[i]) || test3(arguments[i])) {
            varArgs.push(arguments[i]); ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
*     lcm(a, b) = abs(a * b) / gcd(a, b)
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">lcm</span>(a, b)
*    math.lcm(a, b, c, ...)
*
* Examples:
*
*    math.lcm(4, 6);               // returns 12
*    math.lcm(6, 21);              // returns 42
*    math.lcm(6, 21, 5);           // returns 210
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.leftShift" id="apidoc.element.mathjs.leftShift">
        function <span class="apidocSignatureSpan">mathjs.</span>leftShift
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function leftShift(arg0, arg1) {
  "use strict";
  var name = 'leftShift';
  if (test0(arg0)) { // type: number
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: number, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature1(convert0(arg0), arg1); // signature: number, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: number, Array
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature3(arg0, arg1); // signature: number, Matrix
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(convert0(arg0), convert1(arg1)); // signature: number, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert2(arg1)); // signature: number, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test6(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert3(arg1)); // signature: number, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test7(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert4(arg1)); // signature: number, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'number,BigNumber,Array,Matrix');
  }
  if (test1(arg0)) { // type: BigNumber
    if (test1(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: BigNumber, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: BigNumber, Array
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature3(arg0, arg1); // signature: BigNumber, Matrix
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test0(arg1)) { // type: number (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: BigNumber, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert1(arg1)); // signature: BigNumber, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: string (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, conv ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Bitwise left logical shift of a value x by y number of bits, `x &lt;&lt; y`.
* For matrices, the function is evaluated element wise.
* For units, the function is evaluated on the best prefix base.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">leftShift</span>(x, y)
*
* Examples:
*
*    math.leftShift(1, 2);               // returns number 4
*
*    math.leftShift([1, 2, 3], 4);       // returns Array [16, 32, 64]
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.log" id="apidoc.element.mathjs.log">
        function <span class="apidocSignatureSpan">mathjs.</span>log
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function log(arg0, arg1) {
  "use strict";
  var name = 'log';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
  }
  if (test3(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Array
    }
  }
  if (test4(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Matrix
    }
  }
  if (test5(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature2(convert0(arg0)); // signature: Fraction
    }
  }
  if (test6(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: string
    }
  }
  if (test7(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
  }
  if (test8(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
  }
  // type: any
  // type: any
  if (arguments.length === 2) {
    return signature4(arg0, arg1); // signature: any, any
  }
  if (arguments.length &gt; 2) {
    throw createError(name, arguments.length, 2, arguments[2]);
  }
  throw createError(name, arguments.length, 1, arguments[1], 'any');
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Array,Matrix,any');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
// load math.js
var math = require('mathjs');

// functions and constants
math.round(math.e, 3);            // 2.718
math.atan2(3, -3) / math.pi;      // 0.75
math.<span class="apidocCodeKeywordSpan">log</span>(1000, 10);               // 3
math.sqrt(-4);                    // 2i
math.pow([[-1, 2], [3, 1]], 2);   // [[7, 0], [0, 7]]
math.derivative('x^2 + x', 'x');  // 2 * x + 1

// expressions
math.eval('12 / (2.3 + 0.7)');    // 4
math.eval('5.08 cm to inch');     // 2 inch
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.log10" id="apidoc.element.mathjs.log10">
        function <span class="apidocSignatureSpan">mathjs.</span>log10
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function log10(arg0) {
  "use strict";
  var name = 'log10';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature2(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Calculate the 10-base logarithm of a value. This is the same as calculating `log(x, 10)`.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">log10</span>(x)
*
* Examples:
*
*    math.log10(0.00001);            // returns -5
*    math.log10(10000);              // returns 4
*    math.log(10000) / math.log(10); // returns 4
*    math.pow(10, 4);                // returns 10000
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.lsolve" id="apidoc.element.mathjs.lsolve">
        function <span class="apidocSignatureSpan">mathjs.</span>lsolve
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function lsolve(arg0, arg1) {
  "use strict";
  var name = 'lsolve';
  if (test0(arg0)) { // type: Array
    if (test0(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: Array, Array
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: Array, Matrix
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Array,Matrix');
  }
  if (test2(arg0)) { // type: DenseMatrix
    if (test0(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: DenseMatrix, Array
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: DenseMatrix, Matrix
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Array,Matrix');
  }
  if (test3(arg0)) { // type: SparseMatrix
    if (test0(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: SparseMatrix, Array
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: SparseMatrix, Matrix
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Array,Matrix');
  }
  if (test1(arg0)) { // type: Matrix (convert to Array)
    if (test0(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature0(convert0(arg0), arg1); // signature: Matrix, Array
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature0(convert0(arg0), arg1); // signature: Matrix, Matrix
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Array,Matrix');
  }
  throw createError(name, arguments.length, 0, arguments[0], 'Array,DenseMatrix,SparseMatrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.lup" id="apidoc.element.mathjs.lup">
        function <span class="apidocSignatureSpan">mathjs.</span>lup
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function lup(arg0) {
  "use strict";
  var name = 'lup';
  if (test0(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature0(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: DenseMatrix
    if (arguments.length === 1) {
      return signature1(arg0); // signature: DenseMatrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: SparseMatrix
    if (arguments.length === 1) {
      return signature2(arg0); // signature: SparseMatrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Matrix (convert to Array)
    if (arguments.length === 1) {
      return signature0(convert0(arg0)); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'Array,DenseMatrix,SparseMatrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.lusolve" id="apidoc.element.mathjs.lusolve">
        function <span class="apidocSignatureSpan">mathjs.</span>lusolve
        <span class="apidocSignatureSpan">(arg0, arg1, arg2, arg3)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function lusolve(arg0, arg1, arg2, arg3) {
  "use strict";
  var name = 'lusolve';
  if (test0(arg0)) { // type: Array
    if (test0(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: Array, Array
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: Array, Matrix
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Array,Matrix');
  }
  if (test2(arg0)) { // type: DenseMatrix
    if (test0(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: DenseMatrix, Array
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: DenseMatrix, Matrix
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Array,Matrix');
  }
  if (test3(arg0)) { // type: SparseMatrix
    if (test0(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: SparseMatrix, Array
      }
      if (test4(arg2)) { // type: number
        if (test4(arg3)) { // type: number
          if (arguments.length === 4) {
            return signature3(arg0, arg1, arg2, arg3); // signature: SparseMatrix, Array, number, number
          }
          if (arguments.length &gt; 4) {
            throw createError(name, arguments.length, 4, arguments[4]);
          }
        }
        if (test5(arg3)) { // type: string (convert to number)
          if (arguments.length === 4) {
            return signature3(arg0, arg1, arg2, convert0(arg3)); // signature: SparseMatrix, Array, number, string
          }
          if (arguments.length &gt; 4) {
            throw createError(name, arguments.length, 4, arguments[4]);
          }
        }
        if (test6(arg3)) { // type: boolean (convert to number)
          if (arguments.length === 4) {
            return signature3(arg0, arg1, arg2, convert1(arg3)); // signature: SparseMatrix, Array, number, boolean
          }
          if (arguments.length &gt; 4) {
            throw createError(name, arguments.length, 4, arguments[4]);
          }
        }
        if (test7(arg3)) { // type: null (convert to number)
          if (arguments.length === 4) {
            return signature3(arg0, arg1, arg2, convert2(arg3)); // signature: SparseMatrix, Array, number, null
          }
          if (arguments.length &gt; 4) {
            throw createError(name, arguments.length, 4, arguments[4]);
          }
        }
        throw createError(name, arguments.length, 3, arguments[3], 'number');
      }
      if (test5(arg2)) { // type: string (convert to number)
        if (test4(arg3)) { // type: number
          if (arguments.length === 4) {
            return signature3(arg0, arg1, convert0(arg2), arg3); // signature: SparseMatrix, Array, string, number
          }
          if (arguments.length &gt; 4) {
            throw createError(name, arguments.length, 4, arguments[4]);
          }
        }
        if (test5(arg3)) { // type: string (convert to number)
          if (arguments.length === 4) {
            return signature3(arg0, arg1, convert0(arg2), convert0(arg3)); // signature: SparseMatrix, Array, string, string
          }
          if (arguments.length &gt; 4) {
            throw createError(name, arguments.length, 4, arguments[4]);
          }
        }
        if (test6(arg3)) { // type: boolean (convert to number)
          if (arguments.length === 4) {
            return signature3(arg0, arg1, convert0(arg2), convert1(arg3)); ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.mad" id="apidoc.element.mathjs.mad">
        function <span class="apidocSignatureSpan">mathjs.</span>mad
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mad(arg0) {
  "use strict";
  var name = 'mad';
  if (test0(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature0(arg0); // signature: Array
    }
  }
  if (test1(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature0(arg0); // signature: Matrix
    }
  }
  if (arguments.length &gt; 0) {
    var varArgs = [];
    for (var i = 0; i &lt; arguments.length; i++) {
      varArgs.push(arguments[i]);
    }
    return signature1(varArgs); // signature: ...any
  }
  throw createError(name, arguments.length, 0, arguments[0], 'Array,Matrix,any');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Compute the median absolute deviation of a matrix or a list with values.
* The median absolute deviation is defined as the median of the absolute
* deviations from the median.
*
* Syntax:
*
*     math.<span class="apidocCodeKeywordSpan">mad</span>(a, b, c, ...)
*     math.mad(A)
*
* Examples:
*
*     math.mad(10, 20, 30);             // returns 10
*     math.mad([1, 2, 3]);              // returns 1
*     math.mad([[1, 2, 3], [4, 5, 6]]); // returns 1.5
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.map" id="apidoc.element.mathjs.map">
        function <span class="apidocSignatureSpan">mathjs.</span>map
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function map(arg0, arg1) {
  "use strict";
  var name = 'map';
  if (test0(arg0)) { // type: Array
    if (test1(arg1)) { // type: function
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: Array, function
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'function');
  }
  if (test2(arg0)) { // type: Matrix
    if (test1(arg1)) { // type: function
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Matrix, function
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'function');
  }
  throw createError(name, arguments.length, 0, arguments[0], 'Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (res &amp;&amp; res.isResultSet) {
  // we can have 0 or 1 results in the ResultSet, as the CLI
  // does not allow multiple expressions separated by a return
  res = res.entries[0];
  node = node.blocks
      .filter(function (entry) { return entry.visible; })
      .<span class="apidocCodeKeywordSpan">map</span>(function (entry) { return entry.node })[0];
}

if (node) {
  if (node.isAssignmentNode) {
    var name = findSymbolName(node);
    if (name != null) {
      scope.ans = scope[name];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.matrix" id="apidoc.element.mathjs.matrix">
        function <span class="apidocSignatureSpan">mathjs.</span>matrix
        <span class="apidocSignatureSpan">(arg0, arg1, arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function matrix(arg0, arg1, arg2) {
  "use strict";
  var name = 'matrix';
  if (arguments.length === 0) {
    return signature0(); // signature:
  }
  if (test0(arg0)) { // type: string
    if (arguments.length === 1) {
      return signature1(arg0); // signature: string
    }
    if (test0(arg1)) { // type: string
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: string, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: number (convert to string)
      if (arguments.length === 2) {
        return signature2(arg0, convert0(arg1)); // signature: string, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: boolean (convert to string)
      if (arguments.length === 2) {
        return signature2(arg0, convert1(arg1)); // signature: string, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: null (convert to string)
      if (arguments.length === 2) {
        return signature2(arg0, convert2(arg1)); // signature: string, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'string');
  }
  if (test4(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Array
    }
    if (test0(arg1)) { // type: string
      if (arguments.length === 2) {
        return signature4(arg0, arg1); // signature: Array, string
      }
      if (test0(arg2)) { // type: string
        if (arguments.length === 3) {
          return signature4(arg0, arg1, arg2); // signature: Array, string, string
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test1(arg2)) { // type: number (convert to string)
        if (arguments.length === 3) {
          return signature4(arg0, arg1, convert0(arg2)); // signature: Array, string, number
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test2(arg2)) { // type: boolean (convert to string)
        if (arguments.length === 3) {
          return signature4(arg0, arg1, convert1(arg2)); // signature: Array, string, boolean
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test3(arg2)) { // type: null (convert to string)
        if (arguments.length === 3) {
          return signature4(arg0, arg1, convert2(arg2)); // signature: Array, string, null
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      throw createError(name, arguments.length, 2, arguments[2], 'string');
    }
    if (test1(arg1)) { // type: number (convert to string)
      if (arguments.length === 2) {
        return signature4(arg0, convert0(arg1)); // signature: Array, number
      }
      if (test0(arg2)) { // type: string
        if (arguments.length === 3) {
          return signature4(arg0, convert0(arg1), arg2); // signature: Array, number, string
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test1(arg2)) { // type: number (convert to string)
        if (arguments.length === 3) {
          return signature4(arg0, convert0(arg1), convert0(arg2)); // signature: Array, number, number
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test2(arg2)) { // type: boolean (convert to string)
        if (arguments.length === 3) {
          return signature4(a ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
ArrayNode.prototype._compile = function (defs, args) {
  var asMatrix = (defs.math.config().matrix !== 'Array');

  var items = this.items.map(function (node) {
    return node._compile(defs, args);
  });

  return (asMatrix ? 'math.<span class="apidocCodeKeywordSpan">matrix</span>([' : '[') +
      items.join(',') +
      (asMatrix ? '])' : ']');
};

/**
 * Execute a callback for each of the child nodes of this node
 * @param {function(child: Node, path: string, parent: Node)} callback
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.max" id="apidoc.element.mathjs.max">
        function <span class="apidocSignatureSpan">mathjs.</span>max
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function max(arg0, arg1) {
  "use strict";
  var name = 'max';
  if (test0(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature0(arg0); // signature: Array
    }
    if (test1(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Array, number
      }
    }
    if (test2(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Array, BigNumber
      }
    }
    if (test3(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: Array, Fraction
      }
    }
    if (test4(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert1(arg1)); // signature: Array, string
      }
    }
    if (test5(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert2(arg1)); // signature: Array, boolean
      }
    }
    if (test6(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert3(arg1)); // signature: Array, null
      }
    }
  }
  if (test7(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature0(arg0); // signature: Matrix
    }
    if (test1(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Matrix, number
      }
    }
    if (test2(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Matrix, BigNumber
      }
    }
    if (test3(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: Matrix, Fraction
      }
    }
    if (test4(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert1(arg1)); // signature: Matrix, string
      }
    }
    if (test5(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert2(arg1)); // signature: Matrix, boolean
      }
    }
    if (test6(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert3(arg1)); // signature: Matrix, null
      }
    }
  }
  if (arguments.length &gt; 0) {
    var varArgs = [];
    for (var i = 0; i &lt; arguments.length; i++) {
      varArgs.push(arguments[i]);
    }
    return signature2(varArgs); // signature: ...any
  }
  throw createError(name, arguments.length, 0, arguments[0], 'Array,Matrix,any');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @return {number} Returns the maximum number of expected arguments.
 *                  Returns -1 when no signatures where found on the function.
 */
exports.maxArgumentCount = function (fn) {
  return Object.keys(fn.signatures || {})
      .reduce(function (args, signature) {
        var count = (signature.match(/,/g) || []).length + 1;
        return Math.<span class="apidocCodeKeywordSpan">max</span>(args, count);
      }, -1);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.mean" id="apidoc.element.mathjs.mean">
        function <span class="apidocSignatureSpan">mathjs.</span>mean
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mean(arg0, arg1) {
  "use strict";
  var name = 'mean';
  if (test0(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature0(arg0); // signature: Array
    }
    if (test1(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Array, number
      }
    }
    if (test2(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Array, BigNumber
      }
    }
    if (test3(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: Array, Fraction
      }
    }
    if (test4(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert1(arg1)); // signature: Array, string
      }
    }
    if (test5(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert2(arg1)); // signature: Array, boolean
      }
    }
    if (test6(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert3(arg1)); // signature: Array, null
      }
    }
  }
  if (test7(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature0(arg0); // signature: Matrix
    }
    if (test1(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Matrix, number
      }
    }
    if (test2(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Matrix, BigNumber
      }
    }
    if (test3(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: Matrix, Fraction
      }
    }
    if (test4(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert1(arg1)); // signature: Matrix, string
      }
    }
    if (test5(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert2(arg1)); // signature: Matrix, boolean
      }
    }
    if (test6(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert3(arg1)); // signature: Matrix, null
      }
    }
  }
  if (arguments.length &gt; 0) {
    var varArgs = [];
    for (var i = 0; i &lt; arguments.length; i++) {
      varArgs.push(arguments[i]);
    }
    return signature2(varArgs); // signature: ...any
  }
  throw createError(name, arguments.length, 0, arguments[0], 'Array,Matrix,any');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Compute the mean value of matrix or a list with values.
* In case of a multi dimensional array, the mean of the flattened array
* will be calculated. When `dim` is provided, the maximum over the selected
* dimension will be calculated. Parameter `dim` is zero-based.
*
* Syntax:
*
*     math.<span class="apidocCodeKeywordSpan">mean</span>(a, b, c, ...)
*     math.mean(A)
*     math.mean(A, dim)
*
* Examples:
*
*     math.mean(2, 1, 4, 3);                     // returns 2.5
*     math.mean([1, 2.7, 3.2, 4]);               // returns 2.725
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.median" id="apidoc.element.mathjs.median">
        function <span class="apidocSignatureSpan">mathjs.</span>median
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function median(arg0, arg1) {
  "use strict";
  var name = 'median';
  if (test0(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature0(arg0); // signature: Array
    }
    if (test1(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Array, number
      }
    }
    if (test2(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Array, BigNumber
      }
    }
    if (test3(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: Array, Fraction
      }
    }
    if (test4(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert1(arg1)); // signature: Array, string
      }
    }
    if (test5(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert2(arg1)); // signature: Array, boolean
      }
    }
    if (test6(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert3(arg1)); // signature: Array, null
      }
    }
  }
  if (test7(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature0(arg0); // signature: Matrix
    }
    if (test1(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Matrix, number
      }
    }
    if (test2(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Matrix, BigNumber
      }
    }
    if (test3(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: Matrix, Fraction
      }
    }
    if (test4(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert1(arg1)); // signature: Matrix, string
      }
    }
    if (test5(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert2(arg1)); // signature: Matrix, boolean
      }
    }
    if (test6(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert3(arg1)); // signature: Matrix, null
      }
    }
  }
  if (arguments.length &gt; 0) {
    var varArgs = [];
    for (var i = 0; i &lt; arguments.length; i++) {
      varArgs.push(arguments[i]);
    }
    return signature2(varArgs); // signature: ...any
  }
  throw createError(name, arguments.length, 0, arguments[0], 'Array,Matrix,any');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Supported types of values are: Number, BigNumber, Unit
*
* In case of a (multi dimensional) array or matrix, the median of all
* elements will be calculated.
*
* Syntax:
*
*     math.<span class="apidocCodeKeywordSpan">median</span>(a, b, c, ...)
*     math.median(A)
*
* Examples:
*
*     math.median(5, 2, 7);        // returns 5
*     math.median([3, -1, 5, 7]);  // returns 4
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.min" id="apidoc.element.mathjs.min">
        function <span class="apidocSignatureSpan">mathjs.</span>min
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function min(arg0, arg1) {
  "use strict";
  var name = 'min';
  if (test0(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature0(arg0); // signature: Array
    }
    if (test1(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Array, number
      }
    }
    if (test2(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Array, BigNumber
      }
    }
    if (test3(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: Array, Fraction
      }
    }
    if (test4(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert1(arg1)); // signature: Array, string
      }
    }
    if (test5(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert2(arg1)); // signature: Array, boolean
      }
    }
    if (test6(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert3(arg1)); // signature: Array, null
      }
    }
  }
  if (test7(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature0(arg0); // signature: Matrix
    }
    if (test1(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Matrix, number
      }
    }
    if (test2(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Matrix, BigNumber
      }
    }
    if (test3(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: Matrix, Fraction
      }
    }
    if (test4(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert1(arg1)); // signature: Matrix, string
      }
    }
    if (test5(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert2(arg1)); // signature: Matrix, boolean
      }
    }
    if (test6(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert3(arg1)); // signature: Matrix, null
      }
    }
  }
  if (arguments.length &gt; 0) {
    var varArgs = [];
    for (var i = 0; i &lt; arguments.length; i++) {
      varArgs.push(arguments[i]);
    }
    return signature2(varArgs); // signature: ...any
  }
  throw createError(name, arguments.length, 0, arguments[0], 'Array,Matrix,any');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @private
 */
function _resize (array, size, dim, defaultValue) {
var i;
var elem;
var oldLen = array.length;
var newLen = size[dim];
var minLen = Math.<span class="apidocCodeKeywordSpan">min</span>(oldLen, newLen);

// apply new length
array.length = newLen;

if (dim &lt; size.length - 1) {
  // non-last dimension
  var dimNext = dim + 1;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.mod" id="apidoc.element.mathjs.mod">
        function <span class="apidocSignatureSpan">mathjs.</span>mod
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mod(arg0, arg1) {
  "use strict";
  var name = 'mod';
  if (test0(arg0)) { // type: number
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: number, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature1(convert0(arg0), arg1); // signature: number, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: Fraction
      if (arguments.length === 2) {
        return signature2(convert1(arg0), arg1); // signature: number, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert2(arg1)); // signature: number, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert3(arg1)); // signature: number, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert4(arg1)); // signature: number, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
  }
  if (test1(arg0)) { // type: BigNumber
    if (test1(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: BigNumber, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test0(arg1)) { // type: number (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: BigNumber, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert5(arg1)); // signature: BigNumber, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: string (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert6(arg1)); // signature: BigNumber, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: boolean (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert7(arg1)); // signature: BigNumber, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: null (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert8(arg1)); // signature: BigNumber, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
  }
  if (test2(arg0)) { // type: Fraction
    if (test1(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature1(convert5(arg0), arg1); // signature: Fraction, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: Fraction
      if (arguments.length === 2) {
        return signature2(arg0, ar ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (!a.isInt() || !b.isInt()) {
      throw new Error('Parameters in function gcd must be integer numbers');
    }

    // http://en.wikipedia.org/wiki/Euclidean_algorithm
    var zero = new type.BigNumber(0);
    while (!b.isZero()) {
      var r = a.<span class="apidocCodeKeywordSpan">mod</span>(b);
      a = b;
      b = r;
    }
    return a.lt(zero) ? a.neg() : a;
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.mode" id="apidoc.element.mathjs.mode">
        function <span class="apidocSignatureSpan">mathjs.</span>mode
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mode(arg0) {
  "use strict";
  var name = 'mode';
  if (test0(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature0(arg0); // signature: Array
    }
  }
  if (test1(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature0(arg0); // signature: Matrix
    }
  }
  if (arguments.length &gt; 0) {
    var varArgs = [];
    for (var i = 0; i &lt; arguments.length; i++) {
      varArgs.push(arguments[i]);
    }
    return signature1(varArgs); // signature: ...any
  }
  throw createError(name, arguments.length, 0, arguments[0], 'Array,Matrix,any');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
* Computes the mode of a set of numbers or a list with values(numbers or characters).
* If there are more than one modes, it returns a list of those values.
*
* Syntax:
*
*     math.<span class="apidocCodeKeywordSpan">mode</span>(a, b, c, ...)
*     math.mode(A)
*
* Examples:
*
*     math.mode(2, 1, 4, 3, 1);                            // returns [1]
*     math.mode([1, 2.7, 3.2, 4, 2.7]);                    // returns [2.7]
*     math.mode(1, 4, 6, 1, 6)                             // returns [1, 6]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.multinomial" id="apidoc.element.mathjs.multinomial">
        function <span class="apidocSignatureSpan">mathjs.</span>multinomial
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function multinomial(arg0) {
  "use strict";
  var name = 'multinomial';
  if (test0(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature0(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature0(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Multinomial Coefficients compute the number of ways of picking a1, a2, ..., ai unordered outcomes from `n` possibilities.
*
* multinomial takes one array of integers as an argument.
* The following condition must be enforced: every ai &lt;= 0
*
* Syntax:
*
*     math.<span class="apidocCodeKeywordSpan">multinomial</span>(a) // a is an array type
*
* Examples:
*
*    math.multinomial([1,2,1]); // returns 12
*
* See also:
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.multiply" id="apidoc.element.mathjs.multiply">
        function <span class="apidocSignatureSpan">mathjs.</span>multiply
        <span class="apidocSignatureSpan">(arg0, arg1, arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function multiply(arg0, arg1, arg2) {
  "use strict";
  var name = 'multiply';
  if (test0(arg0)) { // type: number
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: number, number
      }
    }
    if (test1(arg1)) { // type: Complex
      if (arguments.length === 2) {
        return signature1(convert0(arg0), arg1); // signature: number, Complex
      }
    }
    if (test2(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature2(convert1(arg0), arg1); // signature: number, BigNumber
      }
    }
    if (test3(arg1)) { // type: Fraction
      if (arguments.length === 2) {
        return signature3(convert2(arg0), arg1); // signature: number, Fraction
      }
    }
    if (test4(arg1)) { // type: Unit
      if (arguments.length === 2) {
        return signature4(arg0, arg1); // signature: number, Unit
      }
    }
    if (test5(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert3(arg1)); // signature: number, string
      }
    }
    if (test6(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert4(arg1)); // signature: number, boolean
      }
    }
    if (test7(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert5(arg1)); // signature: number, null
      }
    }
  }
  if (test1(arg0)) { // type: Complex
    if (test1(arg1)) { // type: Complex
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Complex, Complex
      }
    }
    if (test4(arg1)) { // type: Unit
      if (arguments.length === 2) {
        return signature4(arg0, arg1); // signature: Complex, Unit
      }
    }
    if (test0(arg1)) { // type: number (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: Complex, number
      }
    }
    if (test2(arg1)) { // type: BigNumber (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert6(arg1)); // signature: Complex, BigNumber
      }
    }
    if (test3(arg1)) { // type: Fraction (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert7(arg1)); // signature: Complex, Fraction
      }
    }
    if (test5(arg1)) { // type: string (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert8(arg1)); // signature: Complex, string
      }
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (test1(arg1)) { // type: Complex
      if (arguments.length === 2) {
        return signature1(convert6(arg0), arg1); // signature: BigNumber, Complex
      }
    }
    if (test2(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: BigNumber, BigNumber
      }
    }
    if (test4(arg1)) { // type: Unit
      if (arguments.length === 2) {
        return signature4(arg0, arg1); // signature: BigNumber, Unit
      }
    }
    if (test0(arg1)) { // type: number (convert to BigNumber)
      if (arguments.length === 2) {
        return signature2(arg0, convert1(arg1)); // signature: BigNumber, number
      }
    }
    if (test3(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature2(arg0, convert9(arg1)); // signature: BigNumber, Fraction
      }
    }
    if (test5(arg1)) { // type: string (convert to BigNumber)
      if (arguments.length === 2) {
        return signature2(arg0, convert10(arg1)); // signature: BigNumber, string
      }
    }
    if (test6(arg1)) { // type: boolean (convert to BigNumber)
      if (arguments.length === 2) {
        return signature2(arg0, convert11(arg1)); // signature: BigNumber, boolean
      }
    }
    if (test7(arg1)) { // type: null (convert to BigNumber)
      if (arguments.length === 2) {
        return signature2(arg0, convert12(arg1)); // signature ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
math.eval('sin(45 deg) ^ 2');     // 0.5
math.eval('9 / 3 + 2i');          // 3 + 2i
math.eval('det([-1, 2; 3, 1])');  // -7

// chaining
math.chain(3)
    .add(4)
    .<span class="apidocCodeKeywordSpan">multiply</span>(2)
    .done(); // 14
```

## Browser support

Math.js works on any ES5 compatible JavaScript engine: node.js 0.10, and Internet Explorer 9 and newer, and all other browsers (
Chrome, Firefox, Safari). If support for old browsers like Internet Explorer 8 is required, the [es5-shim](https://github.com/kriskowal
/es5-shim) library has to be loaded.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.norm" id="apidoc.element.mathjs.norm">
        function <span class="apidocSignatureSpan">mathjs.</span>norm
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function norm(arg0, arg1) {
  "use strict";
  var name = 'norm';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: number, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: number, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: string
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: number, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: number, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert1(arg1)); // signature: number, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert2(arg1)); // signature: number, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'number,BigNumber,string');
  }
  if (test6(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature2(arg0); // signature: Complex
    }
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Complex, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Complex, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: string
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Complex, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: Complex, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert1(arg1)); // signature: Complex, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert2(arg1)); // signature: Complex, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'number,BigNumber,string');
  }
  if (test1(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature3(arg0); // signature: BigNumber
    }
    if (test0(arg1)) { // type: nu ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Calculate the norm of a number, vector or matrix.
*
* The second parameter p is optional. If not provided, it defaults to 2.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">norm</span>(x)
*    math.norm(x, p)
*
* Examples:
*
*    math.abs(-3.5);                         // returns 3.5
*    math.norm(-3.5);                        // returns 3.5
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.not" id="apidoc.element.mathjs.not">
        function <span class="apidocSignatureSpan">mathjs.</span>not
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function not(arg0) {
  "use strict";
  var name = 'not';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Unit
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Unit
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature2(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test9(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Unit,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  /**
* Logical `not`. Flips boolean value of a given parameter.
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">not</span>(x)
*
* Examples:
*
*    math.not(2);      // returns false
*    math.not(0);      // returns true
*    math.not(true);   // returns false
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.nthRoot" id="apidoc.element.mathjs.nthRoot">
        function <span class="apidocSignatureSpan">mathjs.</span>nthRoot
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function nthRoot(arg0, arg1) {
  "use strict";
  var name = 'nthRoot';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: number, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature2(convert0(arg0), arg1); // signature: number, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature3(arg0, arg1); // signature: number, Array
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature4(arg0, arg1); // signature: number, Matrix
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature2(convert0(arg0), convert1(arg1)); // signature: number, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert2(arg1)); // signature: number, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test6(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert3(arg1)); // signature: number, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test7(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert4(arg1)); // signature: number, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'number,BigNumber,Array,Matrix');
  }
  if (test8(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature5(arg0); // signature: Complex
    }
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature6(arg0, arg1); // signature: Complex, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature6(arg0, convert2(arg1)); // signature: Complex, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test6(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature6(arg0, convert3(arg1)); // signature: Complex, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test7(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature6(arg0, convert4(arg1)); // signature: Complex, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'number');
  }
  if (test1(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature7(arg0); // signature: BigNumber
    }
    if ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
*     x^root = A
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*     math.<span class="apidocCodeKeywordSpan">nthRoot</span>(a)
*     math.nthRoot(a, root)
*
* Examples:
*
*     math.nthRoot(9, 2);    // returns 3, as 3^2 == 9
*     math.sqrt(9);          // returns 3, as 3^2 == 9
*     math.nthRoot(64, 3);   // returns 4, as 4^3 == 64
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.number" id="apidoc.element.mathjs.number">
        function <span class="apidocSignatureSpan">mathjs.</span>number
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function number(arg0, arg1) {
  "use strict";
  var name = 'number';
  if (arguments.length === 0) {
    return signature0(); // signature:
  }
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature1(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: Fraction
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Unit
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Unit
    }
    if (test3(arg1)) { // type: Unit
      if (arguments.length === 2) {
        return signature5(arg0, arg1); // signature: Unit, Unit
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: string
      if (arguments.length === 2) {
        return signature5(arg0, arg1); // signature: Unit, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test0(arg1)) { // type: number (convert to string)
      if (arguments.length === 2) {
        return signature5(arg0, convert0(arg1)); // signature: Unit, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: boolean (convert to string)
      if (arguments.length === 2) {
        return signature5(arg0, convert1(arg1)); // signature: Unit, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test6(arg1)) { // type: null (convert to string)
      if (arguments.length === 2) {
        return signature5(arg0, convert2(arg1)); // signature: Unit, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Unit,string');
  }
  if (test4(arg0)) { // type: string
    if (arguments.length === 1) {
      return signature6(arg0); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature7(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature7(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature1(convert3(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature1(convert4(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,BigNumber,Fraction,Unit,string,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function factory (type, config, load, typed) {
/**
 * Create a number or convert a string, boolean, or unit to a number.
 * When value is a matrix, all elements will be converted to number.
 *
 * Syntax:
 *
 *    math.<span class="apidocCodeKeywordSpan">number</span>(value)
 *    math.number(unit, valuelessUnit)
 *
 * Examples:
 *
 *    math.number(2);                         // returns number 2
 *    math.number('7.2');                     // returns number 7.2
 *    math.number(true);                      // returns number 1
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.off" id="apidoc.element.mathjs.off">
        function <span class="apidocSignatureSpan">mathjs.</span>off
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">off = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.on" id="apidoc.element.mathjs.on">
        function <span class="apidocSignatureSpan">mathjs.</span>on
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">on = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  // load math.js now, right *after* loading the prompt.
  var math = getMath();

  // TODO: automatic insertion of 'ans' before operators like +, -, *, /

  rl.<span class="apidocCodeKeywordSpan">on</span>('line', function(line) {
var expr = line.trim();

switch (expr.toLowerCase()) {
  case 'quit':
  case 'exit':
    // exit application
    rl.close();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.once" id="apidoc.element.mathjs.once">
        function <span class="apidocSignatureSpan">mathjs.</span>once
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">once = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.ones" id="apidoc.element.mathjs.ones">
        function <span class="apidocSignatureSpan">mathjs.</span>ones
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ones(arg0, arg1) {
  "use strict";
  var name = 'ones';
  if (arguments.length === 0) {
    return signature0(); // signature:
  }
  if (test0(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Array
    }
    if (test1(arg1)) { // type: string
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: Array, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: number (convert to string)
      if (arguments.length === 2) {
        return signature2(arg0, convert0(arg1)); // signature: Array, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: boolean (convert to string)
      if (arguments.length === 2) {
        return signature2(arg0, convert1(arg1)); // signature: Array, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: null (convert to string)
      if (arguments.length === 2) {
        return signature2(arg0, convert2(arg1)); // signature: Array, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'string');
  }
  if (test5(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Matrix
    }
    if (test1(arg1)) { // type: string
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: Matrix, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: number (convert to string)
      if (arguments.length === 2) {
        return signature2(arg0, convert0(arg1)); // signature: Matrix, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: boolean (convert to string)
      if (arguments.length === 2) {
        return signature2(arg0, convert1(arg1)); // signature: Matrix, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: null (convert to string)
      if (arguments.length === 2) {
        return signature2(arg0, convert2(arg1)); // signature: Matrix, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'string');
  }
  if (test2(arg0) || test6(arg0) || test1(arg0) || test7(arg0) || test3(arg0) || test3(arg0) || test3(arg0) || test4(arg0) || test4
(arg0) || test4(arg0)) { // type: ...number|BigNumber|string|Fraction|boolean|null
    var varArgs = [arg0];
    for (var i = 1; i &lt; arguments.length; i++) {
      if (test2(arguments[i]) || test6(arguments[i]) || test1(arguments[i])) {
        varArgs.push(arguments[i]);
      }
      else if (test7(arguments[i])) {
        varArgs.push(convert3(arguments[i]));
      }
      else if (test3(arguments[i])) {
        varArgs.push(convert4(arguments[i]));
      }
      else if (test3(arguments[i])) {
        varArgs.push(convert5(arguments[i]));
      }
      else if (test3(arguments[i])) {
        varArgs.push(convert1(arguments[i]));
      }
      else if (test4(arguments[i])) {
        varArgs.push(convert6(arguments[i]));
      }
      else if (test4(arguments[i])) {
        varArgs.push(convert2(arguments[i]));
      }
      else if (test4(arguments[i])) {
        varArgs.push(convert7(arguments[i]));
      } else {
        throw createError(name, arguments.length, i, arguments[i], 'number,BigNumber,string');
      }
    }
    return signature4(varArgs); // signature: ...number|BigNum ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  /**
* Create a matrix filled with ones. The created matrix can have one or
* multiple dimensions.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">ones</span>(m)
*    math.ones(m, format)
*    math.ones(m, n)
*    math.ones(m, n, format)
*    math.ones([m, n])
*    math.ones([m, n], format)
*    math.ones([m, n, p, ...])
*    math.ones([m, n, p, ...], format)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.or" id="apidoc.element.mathjs.or">
        function <span class="apidocSignatureSpan">mathjs.</span>or
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function or(arg0, arg1) {
  "use strict";
  var name = 'or';
  if (test0(arg0)) { // type: number
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: number, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: Complex
      if (arguments.length === 2) {
        return signature1(convert0(arg0), arg1); // signature: number, Complex
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature2(convert1(arg0), arg1); // signature: number, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature2(convert1(arg0), convert2(arg1)); // signature: number, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert3(arg1)); // signature: number, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert4(arg1)); // signature: number, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test6(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert5(arg1)); // signature: number, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
  }
  if (test1(arg0)) { // type: Complex
    if (test1(arg1)) { // type: Complex
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Complex, Complex
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test0(arg1)) { // type: number (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: Complex, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: BigNumber (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert6(arg1)); // signature: Complex, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: Fraction (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert7(arg1)); // signature: Complex, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: string (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert8(arg1)); // signature: Complex, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (test1(arg1)) { // type: Complex
      if (arguments.length === 2) {
        return signature1(convert6(arg0), arg1); // signature: BigNumber, Complex
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // si ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  /**
* Logical `or`. Test if at least one value is defined with a nonzero/nonempty value.
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">or</span>(x, y)
*
* Examples:
*
*    math.or(2, 4);   // returns true
*
*    a = [2, 5, 0];
*    b = [0, 22, 0];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.parse" id="apidoc.element.mathjs.parse">
        function <span class="apidocSignatureSpan">mathjs.</span>parse
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parse(arg0, arg1) {
  "use strict";
  var name = 'parse';
  if (test0(arg0)) { // type: string
    if (arguments.length === 1) {
      return signature0(arg0); // signature: string
    }
    if (test1(arg1)) { // type: Object
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: string, Object
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Object');
  }
  if (test2(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature0(arg0); // signature: Array
    }
    if (test1(arg1)) { // type: Object
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: Array, Object
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Object');
  }
  if (test3(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature0(arg0); // signature: Matrix
    }
    if (test1(arg1)) { // type: Object
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: Matrix, Object
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Object');
  }
  if (test4(arg0)) { // type: number (convert to string)
    if (arguments.length === 1) {
      return signature0(convert0(arg0)); // signature: number
    }
    if (test1(arg1)) { // type: Object
      if (arguments.length === 2) {
        return signature0(convert0(arg0), arg1); // signature: number, Object
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Object');
  }
  if (test5(arg0)) { // type: boolean (convert to string)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: boolean
    }
    if (test1(arg1)) { // type: Object
      if (arguments.length === 2) {
        return signature0(convert1(arg0), arg1); // signature: boolean, Object
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Object');
  }
  if (test6(arg0)) { // type: null (convert to string)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: null
    }
    if (test1(arg1)) { // type: Object
      if (arguments.length === 2) {
        return signature0(convert2(arg0), arg1); // signature: null, Object
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Object');
  }
  throw createError(name, arguments.length, 0, arguments[0], 'string,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        if (!expr) {
          break;
        }
        switch (mode) {
          case 'eval':
            // evaluate expression
            try {
var node = math.<span class="apidocCodeKeywordSpan">parse</span>(expr);
var res = node.eval(scope);

if (res &amp;&amp; res.isResultSet) {
  // we can have 0 or 1 results in the ResultSet, as the CLI
  // does not allow multiple expressions separated by a return
  res = res.entries[0];
  node = node.blocks
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.parser" id="apidoc.element.mathjs.parser">
        function <span class="apidocSignatureSpan">mathjs.</span>parser
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parser() {
  "use strict";
  var name = 'parser';
  if (arguments.length === 0) {
    return signature0(); // signature:
  }
  if (arguments.length &gt; 0) {
    throw createError(name, arguments.length, 0, arguments[0]);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*    parser.remove(name);               // clear a variable from the
*                                       // parsers scope
*    parser.clear();                    // clear the parsers scope
*
* Example usage:
*    var parser = new Parser();
*    // Note: there is a convenience method which can be used instead:
*    // var parser = new math.<span class="apidocCodeKeywordSpan">parser</span>();
*
*    // evaluate expressions
*    parser.eval('sqrt(3^2 + 4^2)');         // 5
*    parser.eval('sqrt(-4)');                // 2i
*    parser.eval('2 inch in cm');            // 5.08 cm
*    parser.eval('cos(45 deg)');             // 0.7071067811865476
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.partitionSelect" id="apidoc.element.mathjs.partitionSelect">
        function <span class="apidocSignatureSpan">mathjs.</span>partitionSelect
        <span class="apidocSignatureSpan">(arg0, arg1, arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function partitionSelect(arg0, arg1, arg2) {
  "use strict";
  var name = 'partitionSelect';
  if (test0(arg0)) { // type: Array
    if (test1(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: Array, number
      }
      if (test2(arg2)) { // type: string
        if (arguments.length === 3) {
          return signature1(arg0, arg1, arg2); // signature: Array, number, string
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test3(arg2)) { // type: function
        if (arguments.length === 3) {
          return signature2(arg0, arg1, arg2); // signature: Array, number, function
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test1(arg2)) { // type: number (convert to string)
        if (arguments.length === 3) {
          return signature1(arg0, arg1, convert0(arg2)); // signature: Array, number, number
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test4(arg2)) { // type: boolean (convert to string)
        if (arguments.length === 3) {
          return signature1(arg0, arg1, convert1(arg2)); // signature: Array, number, boolean
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test5(arg2)) { // type: null (convert to string)
        if (arguments.length === 3) {
          return signature1(arg0, arg1, convert2(arg2)); // signature: Array, number, null
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      throw createError(name, arguments.length, 2, arguments[2], 'string,function');
    }
    if (test2(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert3(arg1)); // signature: Array, string
      }
      if (test2(arg2)) { // type: string
        if (arguments.length === 3) {
          return signature1(arg0, convert3(arg1), arg2); // signature: Array, string, string
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test3(arg2)) { // type: function
        if (arguments.length === 3) {
          return signature2(arg0, convert3(arg1), arg2); // signature: Array, string, function
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test1(arg2)) { // type: number (convert to string)
        if (arguments.length === 3) {
          return signature1(arg0, convert3(arg1), convert0(arg2)); // signature: Array, string, number
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test4(arg2)) { // type: boolean (convert to string)
        if (arguments.length === 3) {
          return signature1(arg0, convert3(arg1), convert1(arg2)); // signature: Array, string, boolean
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test5(arg2)) { // type: null (convert to string)
        if (arguments.length === 3) {
          return signature1(arg0, convert3(arg1), convert2(arg2)); // signature: Array, string, null
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      throw createError(name, arguments.length, 2, arguments[2], 'string,function');
    }
    if (test4(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert4(arg1)); // signature: Array, boolean
      }
      if (test2(arg2)) { // type: string
        if (arguments.length === 3) { ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Partition-based selection of an array or 1D matrix.
* Will find the kth smallest value, and mutates the input array.
* Uses Quickselect.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">partitionSelect</span>(x, k)
*    math.partitionSelect(x, k, compare)
*
* Examples:
*
*    math.partitionSelect([5, 10, 1], 2);           // returns 10
*    math.partitionSelect(['C', 'B', 'A', 'D'], 1); // returns 'B'
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.permutations" id="apidoc.element.mathjs.permutations">
        function <span class="apidocSignatureSpan">mathjs.</span>permutations
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function permutations(arg0, arg1) {
  "use strict";
  var name = 'permutations';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: number, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature2(convert0(arg0), arg1); // signature: number, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature2(convert0(arg0), convert1(arg1)); // signature: number, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert2(arg1)); // signature: number, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert3(arg1)); // signature: number, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert4(arg1)); // signature: number, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'number,BigNumber');
  }
  if (test1(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature0(arg0); // signature: BigNumber
    }
    if (test1(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: BigNumber, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test0(arg1)) { // type: number (convert to BigNumber)
      if (arguments.length === 2) {
        return signature2(arg0, convert0(arg1)); // signature: BigNumber, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature2(arg0, convert1(arg1)); // signature: BigNumber, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: string (convert to BigNumber)
      if (arguments.length === 2) {
        return signature2(arg0, convert5(arg1)); // signature: BigNumber, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: boolean (convert to BigNumber)
      if (arguments.length === 2) {
        return signature2(arg0, convert6(arg1)); // signature: BigNumber, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: null (convert to BigNumber)
      if (arguments.length === 2) {
        return signature2(arg0, convert7(arg1)); // signature: BigNumber, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'BigNumber');
  }
  if (test2(arg0)) { // type: Fracti ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* from a set of `n` elements.
*
* Permutations only takes integer arguments.
* The following condition must be enforced: k &lt;= n.
*
* Syntax:
*
*     math.<span class="apidocCodeKeywordSpan">permutations</span>(n)
*     math.permutations(n, k)
*
* Examples:
*
*    math.permutations(5);     // 120
*    math.permutations(5, 3);  // 60
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.pow" id="apidoc.element.mathjs.pow">
        function <span class="apidocSignatureSpan">mathjs.</span>pow
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function pow(arg0, arg1) {
  "use strict";
  var name = 'pow';
  if (test0(arg0)) { // type: number
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: number, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: Complex
      if (arguments.length === 2) {
        return signature1(convert0(arg0), arg1); // signature: number, Complex
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature2(convert1(arg0), arg1); // signature: number, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: Fraction
      if (arguments.length === 2) {
        return signature3(convert2(arg0), arg1); // signature: number, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert3(arg1)); // signature: number, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert4(arg1)); // signature: number, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test6(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert5(arg1)); // signature: number, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'number,Complex,BigNumber,Fraction');
  }
  if (test1(arg0)) { // type: Complex
    if (test1(arg1)) { // type: Complex
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Complex, Complex
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test0(arg1)) { // type: number (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: Complex, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: BigNumber (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert6(arg1)); // signature: Complex, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: Fraction (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert7(arg1)); // signature: Complex, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: string (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert8(arg1)); // signature: Complex, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Complex');
  }
  if (test2(arg0)) { // type: BigNumber
    if (test1(arg1)) { // type: Complex
      if (arguments.length === 2) {
        return signature1(convert6(arg0), arg1); // signature: BigNumber, Complex
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, argume ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var math = require('mathjs');

// functions and constants
math.round(math.e, 3);            // 2.718
math.atan2(3, -3) / math.pi;      // 0.75
math.log(1000, 10);               // 3
math.sqrt(-4);                    // 2i
math.<span class="apidocCodeKeywordSpan">pow</span>([[-1, 2], [3, 1]], 2);   // [[7, 0], [0, 7]]
math.derivative('x^2 + x', 'x');  // 2 * x + 1

// expressions
math.eval('12 / (2.3 + 0.7)');    // 4
math.eval('5.08 cm to inch');     // 2 inch
math.eval('sin(45 deg) ^ 2');     // 0.5
math.eval('9 / 3 + 2i');          // 3 + 2i
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.print" id="apidoc.element.mathjs.print">
        function <span class="apidocSignatureSpan">mathjs.</span>print
        <span class="apidocSignatureSpan">(arg0, arg1, arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function print(arg0, arg1, arg2) {
  "use strict";
  var name = 'print';
  if (test0(arg0)) { // type: string
    if (test1(arg1)) { // type: Object
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: string, Object
      }
      if (test2(arg2)) { // type: number
        if (arguments.length === 3) {
          return signature0(arg0, arg1, arg2); // signature: string, Object, number
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test0(arg2)) { // type: string (convert to number)
        if (arguments.length === 3) {
          return signature0(arg0, arg1, convert0(arg2)); // signature: string, Object, string
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test3(arg2)) { // type: boolean (convert to number)
        if (arguments.length === 3) {
          return signature0(arg0, arg1, convert1(arg2)); // signature: string, Object, boolean
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test4(arg2)) { // type: null (convert to number)
        if (arguments.length === 3) {
          return signature0(arg0, arg1, convert2(arg2)); // signature: string, Object, null
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test1(arg2)) { // type: Object
        if (arguments.length === 3) {
          return signature0(arg0, arg1, arg2); // signature: string, Object, Object
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      throw createError(name, arguments.length, 2, arguments[2], 'number,Object');
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Object');
  }
  if (test2(arg0)) { // type: number (convert to string)
    if (test1(arg1)) { // type: Object
      if (arguments.length === 2) {
        return signature0(convert3(arg0), arg1); // signature: number, Object
      }
      if (test2(arg2)) { // type: number
        if (arguments.length === 3) {
          return signature0(convert3(arg0), arg1, arg2); // signature: number, Object, number
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test0(arg2)) { // type: string (convert to number)
        if (arguments.length === 3) {
          return signature0(convert3(arg0), arg1, convert0(arg2)); // signature: number, Object, string
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test3(arg2)) { // type: boolean (convert to number)
        if (arguments.length === 3) {
          return signature0(convert3(arg0), arg1, convert1(arg2)); // signature: number, Object, boolean
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test4(arg2)) { // type: null (convert to number)
        if (arguments.length === 3) {
          return signature0(convert3(arg0), arg1, convert2(arg2)); // signature: number, Object, null
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test1(arg2)) { // type: Object
        if (arguments.length === 3) {
          return signature0(convert3(arg0), arg1, arg2); // signature: number, Object, Object
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      throw createError(name, arguments.length, 2, arguments[2], 'number,Object');
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Object');
  }
  if (test3(arg0)) { // type: boolean (convert to string)
    if (test1(arg1)) { // typ ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

function factory (type, config, load, typed) {
/**
 * Interpolate values into a string template.
 *
 * Syntax:
 *
 *     math.<span class="apidocCodeKeywordSpan">print</span>(template, values)
 *     math.print(template, values, precision)
 *     math.print(template, values, options)
 *
 * Example usage:
 *
 *     // the following outputs: 'Lucy is 5 years old'
 *     math.print('Lucy is $age years old', {age: 5});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.prod" id="apidoc.element.mathjs.prod">
        function <span class="apidocSignatureSpan">mathjs.</span>prod
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function prod(arg0, arg1) {
  "use strict";
  var name = 'prod';
  if (test0(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature0(arg0); // signature: Array
    }
    if (test1(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Array, number
      }
    }
    if (test2(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Array, BigNumber
      }
    }
    if (test3(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: Array, Fraction
      }
    }
    if (test4(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert1(arg1)); // signature: Array, string
      }
    }
    if (test5(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert2(arg1)); // signature: Array, boolean
      }
    }
    if (test6(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert3(arg1)); // signature: Array, null
      }
    }
  }
  if (test7(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature0(arg0); // signature: Matrix
    }
    if (test1(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Matrix, number
      }
    }
    if (test2(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Matrix, BigNumber
      }
    }
    if (test3(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: Matrix, Fraction
      }
    }
    if (test4(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert1(arg1)); // signature: Matrix, string
      }
    }
    if (test5(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert2(arg1)); // signature: Matrix, boolean
      }
    }
    if (test6(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert3(arg1)); // signature: Matrix, null
      }
    }
  }
  if (arguments.length &gt; 0) {
    var varArgs = [];
    for (var i = 0; i &lt; arguments.length; i++) {
      varArgs.push(arguments[i]);
    }
    return signature2(varArgs); // signature: ...any
  }
  throw createError(name, arguments.length, 0, arguments[0], 'Array,Matrix,any');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Compute the product of a matrix or a list with values.
* In case of a (multi dimensional) array or matrix, the sum of all
* elements will be calculated.
*
* Syntax:
*
*     math.<span class="apidocCodeKeywordSpan">prod</span>(a, b, c, ...)
*     math.prod(A)
*
* Examples:
*
*     math.multiply(2, 3);           // returns 6
*     math.prod(2, 3);               // returns 6
*     math.prod(2, 3, 4);            // returns 24
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.qr" id="apidoc.element.mathjs.qr">
        function <span class="apidocSignatureSpan">mathjs.</span>qr
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function qr(arg0) {
  "use strict";
  var name = 'qr';
  if (test0(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature0(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: DenseMatrix
    if (arguments.length === 1) {
      return signature1(arg0); // signature: DenseMatrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: SparseMatrix
    if (arguments.length === 1) {
      return signature2(arg0); // signature: SparseMatrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Matrix (convert to Array)
    if (arguments.length === 1) {
      return signature0(convert0(arg0)); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'Array,DenseMatrix,SparseMatrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.quantileSeq" id="apidoc.element.mathjs.quantileSeq">
        function <span class="apidocSignatureSpan">mathjs.</span>quantileSeq
        <span class="apidocSignatureSpan">(data, probOrN, sorted)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function quantileSeq(data, probOrN, sorted) {
  var probArr, dataArr, one;

  if (arguments.length &lt; 2 || arguments.length &gt; 3) {
    throw new SyntaxError('Function quantileSeq requires two or three parameters');
  }

  if (isCollection(data)) {
    sorted = sorted || false;
    if (typeof sorted === 'boolean') {
      dataArr = data.valueOf();
      if (isNumber(probOrN)) {
        if (probOrN &lt; 0) {
          throw new Error('N/prob must be non-negative');
        }

        if (probOrN &lt;= 1) {
          // quantileSeq([a, b, c, d, ...], prob[,sorted])
          return _quantileSeq(dataArr, probOrN, sorted);
        }

        if (probOrN &gt; 1) {
          // quantileSeq([a, b, c, d, ...], N[,sorted])
          if (!isInteger(probOrN)) {
            throw new Error('N must be a positive integer');
          }

          var nPlusOne = probOrN + 1;
          probArr = new Array(probOrN);
          for (var i = 0; i &lt; probOrN;) {
            probArr[i] = _quantileSeq(dataArr, (++i) / nPlusOne, sorted);
          }
          return probArr;
        }
      }

      if (probOrN &amp;&amp; probOrN.isBigNumber) {
        if (probOrN.isNegative()) {
          throw new Error('N/prob must be non-negative');
        }

        one = new probOrN.constructor(1);

        if (probOrN.lte(one)) {
          // quantileSeq([a, b, c, d, ...], prob[,sorted])
          return _quantileSeq(dataArr, probOrN, sorted);
        }

        if (probOrN.gt(one)) {
          // quantileSeq([a, b, c, d, ...], N[,sorted])
          if (!probOrN.isInteger()) {
            throw new Error('N must be a positive integer');
          }

          // largest possible Array length is 2^32-1;
          // 2^32 &lt; 10^15, thus safe conversion guaranteed
          var intN = probOrN.toNumber();
          if (intN &gt; 4294967295) {
            throw new Error('N must be less than or equal to 2^32-1, as that is the maximum length of an Array');
          }

          var nPlusOne = new type.BigNumber(intN + 1);
          probArr = new Array(intN);
          for (var i = 0; i &lt; intN;) {
            probArr[i] = _quantileSeq(dataArr, new type.BigNumber(++i).div(nPlusOne), sorted);
          }
          return probArr;
        }
      }

      if (Array.isArray(probOrN)) {
        // quantileSeq([a, b, c, d, ...], [prob1, prob2, ...][,sorted])
        probArr = new Array(probOrN.length);
        for (var i = 0; i &lt; probArr.length; ++i) {
          var currProb = probOrN[i];
          if (isNumber(currProb)) {
            if (currProb &lt; 0 || currProb &gt; 1) {
              throw new Error('Probability must be between 0 and 1, inclusive');
            }
          } else if (currProb &amp;&amp; currProb.isBigNumber) {
            one = new currProb.constructor(1);
            if (currProb.isNegative() || currProb.gt(one)) {
              throw new Error('Probability must be between 0 and 1, inclusive');
            }
          } else {
            throw new TypeError('Unexpected type of argument in function quantileSeq'); // FIXME: becomes redundant when converted
 to typed-function
          }

          probArr[i] = _quantileSeq(dataArr, currProb, sorted);
        }
        return probArr;
      }

      throw new TypeError('Unexpected type of argument in function quantileSeq'); // FIXME: becomes redundant when converted to
typed-function
    }

    throw new TypeError('Unexpected type of argument in function quantileSeq'); // FIXME: becomes redundant when converted to typed
-function
  }

  throw new TypeError('Unexpected type of argument in function quantileSeq'); // FIXME: becomes redundant when converted to typed
-function
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Supported types of probability are: Number, BigNumber
*
* In case of a (multi dimensional) array or matrix, the prob order quantile
* of all elements will be calculated.
*
* Syntax:
*
*     math.<span class="apidocCodeKeywordSpan">quantileSeq</span>(A, prob[, sorted])
*     math.quantileSeq(A, [prob1, prob2, ...][, sorted])
*     math.quantileSeq(A, N[, sorted])
*
* Examples:
*
*     math.quantileSeq([3, -1, 5, 7], 0.5);         // returns 4
*     math.quantileSeq([3, -1, 5, 7], [1/3, 2/3]);  // returns [3, 5]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.range" id="apidoc.element.mathjs.range">
        function <span class="apidocSignatureSpan">mathjs.</span>range
        <span class="apidocSignatureSpan">(arg0, arg1, arg2, arg3)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function range(arg0, arg1, arg2, arg3) {
  "use strict";
  var name = 'range';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(convert0(arg0)); // signature: number
    }
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: number, number
      }
      if (test0(arg2)) { // type: number
        if (arguments.length === 3) {
          return signature2(arg0, arg1, arg2); // signature: number, number, number
        }
        if (test1(arg3)) { // type: boolean
          if (arguments.length === 4) {
            return signature3(arg0, arg1, arg2, arg3); // signature: number, number, number, boolean
          }
          if (arguments.length &gt; 4) {
            throw createError(name, arguments.length, 4, arguments[4]);
          }
        }
        throw createError(name, arguments.length, 3, arguments[3], 'boolean');
      }
      if (test2(arg2)) { // type: BigNumber
        if (arguments.length === 3) {
          return signature4(convert1(arg0), convert1(arg1), arg2); // signature: number, number, BigNumber
        }
        if (test1(arg3)) { // type: boolean
          if (arguments.length === 4) {
            return signature5(convert1(arg0), convert1(arg1), arg2, arg3); // signature: number, number, BigNumber, boolean
          }
          if (arguments.length &gt; 4) {
            throw createError(name, arguments.length, 4, arguments[4]);
          }
        }
        throw createError(name, arguments.length, 3, arguments[3], 'boolean');
      }
      if (test1(arg2)) { // type: boolean
        if (arguments.length === 3) {
          return signature6(arg0, arg1, arg2); // signature: number, number, boolean
        }
        if (test1(arg3)) { // type: boolean
          if (arguments.length === 4) {
            return signature3(arg0, arg1, convert2(arg2), arg3); // signature: number, number, boolean, boolean
          }
          if (arguments.length &gt; 4) {
            throw createError(name, arguments.length, 4, arguments[4]);
          }
        }
        throw createError(name, arguments.length, 3, arguments[3], 'boolean');
      }
      if (test3(arg2)) { // type: Fraction (convert to BigNumber)
        if (arguments.length === 3) {
          return signature4(convert1(arg0), convert1(arg1), convert3(arg2)); // signature: number, number, Fraction
        }
        if (test1(arg3)) { // type: boolean
          if (arguments.length === 4) {
            return signature5(convert1(arg0), convert1(arg1), convert3(arg2), arg3); // signature: number, number, Fraction, boolean
          }
          if (arguments.length &gt; 4) {
            throw createError(name, arguments.length, 4, arguments[4]);
          }
        }
        throw createError(name, arguments.length, 3, arguments[3], 'boolean');
      }
      if (test4(arg2)) { // type: string (convert to number)
        if (arguments.length === 3) {
          return signature2(arg0, arg1, convert4(arg2)); // signature: number, number, string
        }
        if (test1(arg3)) { // type: boolean
          if (arguments.length === 4) {
            return signature3(arg0, arg1, convert4(arg2), arg3); // signature: number, number, string, boolean
          }
          if (arguments.length &gt; 4) {
            throw createError(name, arguments.length, 4, arguments[4]);
          }
        }
        throw createError(name, arguments.length, 3, arguments[3], 'boolean');
      }
      if (test5(arg2)) { // type: null (convert to number)
        if (arguments.length === 3) {
          return signature2(arg0, arg1, convert5(arg2)); // signature: number, number, null
        }
        if (test1(arg3)) { // type: boolean
          if (arguments.length === 4) {
            return signature3(arg0, arg1, convert5(arg2), arg3); // signature: number, number, null, boolean
          }
          if (arguments.length &gt; 4) {
            throw createError(name, arguments.length, 4, arguments[4]);
          }
        }
        throw createError(name, arguments.length, 3, ar ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *                          the name of the argument, and the value is `true`.
 *                          The object may not be mutated, but must be
 *                          extended instead.
 * @return {string} js
 * @private
 */
RangeNode.prototype._compile = function (defs, args) {
  return 'math.<span class="apidocCodeKeywordSpan">range</span>(' +
      this.start._compile(defs, args) + ', ' +
      this.end._compile(defs, args) +
      (this.step ? (', ' + this.step._compile(defs, args)) : '') +
      ')';
};

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.re" id="apidoc.element.mathjs.re">
        function <span class="apidocSignatureSpan">mathjs.</span>re
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function re(arg0) {
  "use strict";
  var name = 're';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature2(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Syntax:
*
*    math.im(x)
*
* Examples:
*
*    var a = math.complex(2, 3);
*    math.<span class="apidocCodeKeywordSpan">re</span>(a);                     // returns number 2
*    math.im(a);                     // returns number 3
*
*    math.re(math.complex('-5.2i')); // returns number -5.2
*    math.re(math.complex(2.4));     // returns number 0
*
* See also:
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.reshape" id="apidoc.element.mathjs.reshape">
        function <span class="apidocSignatureSpan">mathjs.</span>reshape
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reshape(arg0, arg1) {
  "use strict";
  var name = 'reshape';
  if (test0(arg0)) { // type: Array
    if (test0(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: Array, Array
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: Matrix (convert to Array)
      if (arguments.length === 2) {
        return signature0(arg0, convert0(arg1)); // signature: Array, Matrix
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Array');
  }
  if (test1(arg0)) { // type: Matrix
    if (test0(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Matrix, Array
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: Matrix (convert to Array)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: Matrix, Matrix
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Array');
  }
  throw createError(name, arguments.length, 0, arguments[0], 'Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var matrix = load(require('../../type/matrix/function/matrix'));

/**
 * Reshape a multi dimensional array to fit the specified dimensions
 *
 * Syntax:
 *
 *     math.<span class="apidocCodeKeywordSpan">reshape</span>(x, sizes)
 *
 * Examples:
 *
 *     math.reshape([1, 2, 3, 4, 5, 6], [2, 3]);
 *     // returns Array  [[1, 2, 3], [4, 5, 6]]
 *
 *     math.reshape([[1, 2], [3, 4]], [1, 4]);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.resize" id="apidoc.element.mathjs.resize">
        function <span class="apidocSignatureSpan">mathjs.</span>resize
        <span class="apidocSignatureSpan">(x, size, defaultValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function resize(x, size, defaultValue) {
  if (arguments.length != 2 &amp;&amp; arguments.length != 3) {
    throw new ArgumentsError('resize', arguments.length, 2, 3);
  }

  if (size &amp;&amp; size.isMatrix === true) {
    size = size.valueOf(); // get Array
  }

  if (size.length &amp;&amp; size[0] &amp;&amp; size[0].isBigNumber === true) {
    // convert bignumbers to numbers
    size = size.map(function (value) {
      return (value &amp;&amp; value.isBigNumber === true) ? value.toNumber() : value;
    });
  }

  // check x is a Matrix
  if (x &amp;&amp; x.isMatrix === true) {
    // use optimized matrix implementation, return copy
    return x.resize(size, defaultValue, true);
  }

  if (typeof x === 'string') {
    // resize string
    return _resizeString(x, size, defaultValue);
  }

  // check result should be a matrix
  var asMatrix = Array.isArray(x) ? false : (config.matrix !== 'Array');

  if (size.length == 0) {
    // output a scalar
    while (Array.isArray(x)) {
      x = x[0];
    }

    return clone(x);
  }
  else {
    // output an array/matrix
    if (!Array.isArray(x)) {
      x = [x];
    }
    x = clone(x);

    var res = array.resize(x, size, defaultValue);
    return asMatrix ? matrix(res) : res;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // get matrix storage constructor
  var F = type.Matrix.storage(format);
  // create diagonal matrix (use optimized implementation for storage format)
  return F.diagonal(size, one, 0, defaultValue);
}

// create and resize array
var res = array.<span class="apidocCodeKeywordSpan">resize</span>([], size, defaultValue);
// fill in ones on the diagonal
var minimum = rows &lt; cols ? rows : cols;
// fill diagonal
for (var d = 0; d &lt; minimum; d++) {
  res[d][d] = one;
}
return res;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.rightArithShift" id="apidoc.element.mathjs.rightArithShift">
        function <span class="apidocSignatureSpan">mathjs.</span>rightArithShift
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function rightArithShift(arg0, arg1) {
  "use strict";
  var name = 'rightArithShift';
  if (test0(arg0)) { // type: number
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: number, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature1(convert0(arg0), arg1); // signature: number, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: number, Array
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature3(arg0, arg1); // signature: number, Matrix
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(convert0(arg0), convert1(arg1)); // signature: number, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert2(arg1)); // signature: number, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test6(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert3(arg1)); // signature: number, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test7(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert4(arg1)); // signature: number, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'number,BigNumber,Array,Matrix');
  }
  if (test1(arg0)) { // type: BigNumber
    if (test1(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: BigNumber, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: BigNumber, Array
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature3(arg0, arg1); // signature: BigNumber, Matrix
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test0(arg1)) { // type: number (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: BigNumber, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert1(arg1)); // signature: BigNumber, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: string (convert to BigNumber)
      if (arguments.length === 2) {
        return signature ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Bitwise right arithmetic shift of a value x by y number of bits, `x &gt;&gt; y`.
* For matrices, the function is evaluated element wise.
* For units, the function is evaluated on the best prefix base.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">rightArithShift</span>(x, y)
*
* Examples:
*
*    math.rightArithShift(4, 2);               // returns number 1
*
*    math.rightArithShift([16, -32, 64], 4);   // returns Array [1, -2, 3]
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.rightLogShift" id="apidoc.element.mathjs.rightLogShift">
        function <span class="apidocSignatureSpan">mathjs.</span>rightLogShift
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function rightLogShift(arg0, arg1) {
  "use strict";
  var name = 'rightLogShift';
  if (test0(arg0)) { // type: number
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: number, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: number, Array
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: number, Matrix
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert0(arg1)); // signature: number, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert1(arg1)); // signature: number, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert2(arg1)); // signature: number, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'number,Array,Matrix');
  }
  if (test6(arg0)) { // type: BigNumber
    if (test1(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: BigNumber, Array
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: BigNumber, Matrix
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Array,Matrix');
  }
  if (test1(arg0)) { // type: Array
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature3(arg0, arg1); // signature: Array, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test6(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature3(arg0, arg1); // signature: Array, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature4(arg0, arg1); // signature: Array, Array
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature5(arg0, arg1); // signature: Array, Matrix
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test7(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature3(arg0, convert3(arg1)); // signature: Array, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature3(arg0, c ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Bitwise right logical shift of value x by y number of bits, `x &gt;&gt;&gt; y`.
* For matrices, the function is evaluated element wise.
* For units, the function is evaluated on the best prefix base.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">rightLogShift</span>(x, y)
*
* Examples:
*
*    math.rightLogShift(4, 2);               // returns number 1
*
*    math.rightLogShift([16, -32, 64], 4);   // returns Array [1, 2, 3]
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.round" id="apidoc.element.mathjs.round">
        function <span class="apidocSignatureSpan">mathjs.</span>round
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function round(arg0, arg1) {
  "use strict";
  var name = 'round';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: number, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: number, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature3(arg0, arg1); // signature: number, Array
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature4(arg0, arg1); // signature: number, Matrix
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature2(arg0, convert0(arg1)); // signature: number, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert1(arg1)); // signature: number, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test6(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert2(arg1)); // signature: number, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test7(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert3(arg1)); // signature: number, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'number,BigNumber,Array,Matrix');
  }
  if (test8(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature5(arg0); // signature: Complex
    }
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature6(arg0, arg1); // signature: Complex, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature7(arg0, arg1); // signature: Complex, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature3(arg0, arg1); // signature: Complex, Array
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature4(arg0, arg1); // signature: Complex, Matrix
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature7(arg0, convert0(arg1)); // signature: Complex, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
[chained operations](http://mathjs.org/docs/chained_operations.html).

```js
// load math.js
var math = require('mathjs');

// functions and constants
math.<span class="apidocCodeKeywordSpan">round</span>(math.e, 3);            // 2.718
math.atan2(3, -3) / math.pi;      // 0.75
math.log(1000, 10);               // 3
math.sqrt(-4);                    // 2i
math.pow([[-1, 2], [3, 1]], 2);   // [[7, 0], [0, 7]]
math.derivative('x^2 + x', 'x');  // 2 * x + 1

// expressions
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.sec" id="apidoc.element.mathjs.sec">
        function <span class="apidocSignatureSpan">mathjs.</span>sec
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sec(arg0) {
  "use strict";
  var name = 'sec';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Unit
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Unit
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature2(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test9(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Unit,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Syntax:
*
*    math.asec(x)
*
* Examples:
*
*    math.asec(0.5);           // returns 1.0471975511965979
*    math.asec(math.<span class="apidocCodeKeywordSpan">sec</span>(1.5)); // returns 1.5
*
*    math.asec(2);             // returns 0 + 1.3169578969248166 i
*
* See also:
*
*    acos, acot, acsc
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.sech" id="apidoc.element.mathjs.sech">
        function <span class="apidocSignatureSpan">mathjs.</span>sech
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sech(arg0) {
  "use strict";
  var name = 'sech';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Unit
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Unit
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature2(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test9(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Unit,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Calculate the hyperbolic secant of a value,
* defined as `sech(x) = 1 / cosh(x)`.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">sech</span>(x)
*
* Examples:
*
*    // sech(x) = 1/ cosh(x)
*    math.sech(0.5);       // returns 0.886818883970074
*    1 / math.cosh(0.5);   // returns 0.886818883970074
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.sign" id="apidoc.element.mathjs.sign">
        function <span class="apidocSignatureSpan">mathjs.</span>sign
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sign(arg0) {
  "use strict";
  var name = 'sign';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Fraction
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Unit
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Unit
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature5(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature5(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert0(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test9(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Fraction,Unit,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* - -1 when x &lt; 0
* -  0 when x == 0
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">sign</span>(x)
*
* Examples:
*
*    math.sign(3.5);               // returns 1
*    math.sign(-4.2);              // returns -1
*    math.sign(0);                 // returns 0
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.simplify" id="apidoc.element.mathjs.simplify">
        function <span class="apidocSignatureSpan">mathjs.</span>simplify
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function simplify(arg0, arg1) {
  "use strict";
  var name = 'simplify';
  if (test0(arg0)) { // type: string
    if (arguments.length === 1) {
      return signature0(arg0); // signature: string
    }
    if (test1(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: string, Array
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: Matrix (convert to Array)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: string, Matrix
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Array');
  }
  if (test3(arg0)) { // type: Node
    if (arguments.length === 1) {
      return signature2(arg0); // signature: Node
    }
    if (test1(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature3(arg0, arg1); // signature: Node, Array
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: Matrix (convert to Array)
      if (arguments.length === 2) {
        return signature3(arg0, convert0(arg1)); // signature: Node, Matrix
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Array');
  }
  if (test4(arg0)) { // type: number (convert to string)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: number
    }
    if (test1(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature1(convert1(arg0), arg1); // signature: number, Array
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: Matrix (convert to Array)
      if (arguments.length === 2) {
        return signature1(convert1(arg0), convert0(arg1)); // signature: number, Matrix
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Array');
  }
  if (test5(arg0)) { // type: boolean (convert to string)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
    if (test1(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature1(convert2(arg0), arg1); // signature: boolean, Array
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: Matrix (convert to Array)
      if (arguments.length === 2) {
        return signature1(convert2(arg0), convert0(arg1)); // signature: boolean, Matrix
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Array');
  }
  if (test6(arg0)) { // type: null (convert to string)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
    if (test1(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature1(convert3(arg0), arg1); // signature: null, Array
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: Matrix (convert to Array)
      if (arguments.length === 2) {
        return signature1(convert3(arg0), convert0(arg1)); // signature: null, Matrix
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Array');
  }
  throw createError(name, arguments.length, 0, arg ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Syntax:
*
*     simplify(expr)
*     simplify(expr, rules)
*
* Examples:
*
*     math.<span class="apidocCodeKeywordSpan">simplify</span>('2 * 1 * x ^ (2 - 1)');      // Node {2 * x}
*     var f = math.parse('2 * 1 * x ^ (2 - 1)');
*     math.simplify(f);                          // Node {2 * x}
*
* See also:
*
*     derivative, parse, eval
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.sin" id="apidoc.element.mathjs.sin">
        function <span class="apidocSignatureSpan">mathjs.</span>sin
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sin(arg0) {
  "use strict";
  var name = 'sin';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Unit
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Unit
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature2(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test9(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Unit,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    res = 1;                          // 0! is per definition 1
  }

  return res;
}

if (n &lt; 0.5) {
  return Math.PI / (Math.<span class="apidocCodeKeywordSpan">sin</span>(Math.PI * n) * gamma(1-n));
}

if (n &gt;= 171.35) {
  return Infinity;                    // will overflow
}

if (n &gt; 85.0) {                       // Extended Stirling Approx
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.sinh" id="apidoc.element.mathjs.sinh">
        function <span class="apidocSignatureSpan">mathjs.</span>sinh
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sinh(arg0) {
  "use strict";
  var name = 'sinh';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Unit
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Unit
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature2(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test9(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Unit,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
*    math.csch(x)
*
* Examples:
*
*    // csch(x) = 1/ sinh(x)
*    math.csch(0.5);       // returns 1.9190347513349437
*    1 / math.<span class="apidocCodeKeywordSpan">sinh</span>(0.5);   // returns 1.9190347513349437
*
* See also:
*
*    sinh, sech, coth
*
* @param {number | Complex | Unit | Array | Matrix} x  Function input
* @return {number | Complex | Array | Matrix} Hyperbolic cosecant of x
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.size" id="apidoc.element.mathjs.size">
        function <span class="apidocSignatureSpan">mathjs.</span>size
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function size(arg0) {
  "use strict";
  var name = 'size';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature0(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature0(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Unit
    if (arguments.length === 1) {
      return signature0(arg0); // signature: Unit
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: string
    if (arguments.length === 1) {
      return signature1(arg0); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature2(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: boolean
    if (arguments.length === 1) {
      return signature0(arg0); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: null
    if (arguments.length === 1) {
      return signature0(arg0); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test9(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature0(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Unit,string,Array,Matrix,boolean,null');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

if (!Array.isArray(array) || !Array.isArray(sizes)) {
  throw new TypeError('Array expected');
}

if (sizes.length === 0) {
  throw new DimensionError(0, product(exports.<span class="apidocCodeKeywordSpan">size</span>(array)), '!=');
}

try {
  newArray  = _reshape(flatArray, sizes);
} catch (e) {
  if (e instanceof DimensionError) {
    throw new DimensionError(
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.slu" id="apidoc.element.mathjs.slu">
        function <span class="apidocSignatureSpan">mathjs.</span>slu
        <span class="apidocSignatureSpan">(arg0, arg1, arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function slu(arg0, arg1, arg2) {
  "use strict";
  var name = 'slu';
  if (test0(arg0)) { // type: SparseMatrix
    if (test1(arg1)) { // type: number
      if (test1(arg2)) { // type: number
        if (arguments.length === 3) {
          return signature0(arg0, arg1, arg2); // signature: SparseMatrix, number, number
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test2(arg2)) { // type: string (convert to number)
        if (arguments.length === 3) {
          return signature0(arg0, arg1, convert0(arg2)); // signature: SparseMatrix, number, string
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test3(arg2)) { // type: boolean (convert to number)
        if (arguments.length === 3) {
          return signature0(arg0, arg1, convert1(arg2)); // signature: SparseMatrix, number, boolean
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test4(arg2)) { // type: null (convert to number)
        if (arguments.length === 3) {
          return signature0(arg0, arg1, convert2(arg2)); // signature: SparseMatrix, number, null
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      throw createError(name, arguments.length, 2, arguments[2], 'number');
    }
    if (test2(arg1)) { // type: string (convert to number)
      if (test1(arg2)) { // type: number
        if (arguments.length === 3) {
          return signature0(arg0, convert0(arg1), arg2); // signature: SparseMatrix, string, number
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test2(arg2)) { // type: string (convert to number)
        if (arguments.length === 3) {
          return signature0(arg0, convert0(arg1), convert0(arg2)); // signature: SparseMatrix, string, string
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test3(arg2)) { // type: boolean (convert to number)
        if (arguments.length === 3) {
          return signature0(arg0, convert0(arg1), convert1(arg2)); // signature: SparseMatrix, string, boolean
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test4(arg2)) { // type: null (convert to number)
        if (arguments.length === 3) {
          return signature0(arg0, convert0(arg1), convert2(arg2)); // signature: SparseMatrix, string, null
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      throw createError(name, arguments.length, 2, arguments[2], 'number');
    }
    if (test3(arg1)) { // type: boolean (convert to number)
      if (test1(arg2)) { // type: number
        if (arguments.length === 3) {
          return signature0(arg0, convert1(arg1), arg2); // signature: SparseMatrix, boolean, number
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test2(arg2)) { // type: string (convert to number)
        if (arguments.length === 3) {
          return signature0(arg0, convert1(arg1), convert0(arg2)); // signature: SparseMatrix, boolean, string
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test3(arg2)) { // type: boolean (convert to number)
        if (arguments.length === 3) {
          return signature0(arg0, convert1(arg1), convert1(arg2)); // signature: SparseMatrix, boolean, boolean
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test4(ar ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.smaller" id="apidoc.element.mathjs.smaller">
        function <span class="apidocSignatureSpan">mathjs.</span>smaller
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function smaller(arg0, arg1) {
  "use strict";
  var name = 'smaller';
  if (test0(arg0)) { // type: number
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: number, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: Complex
      if (arguments.length === 2) {
        return signature1(convert0(arg0), arg1); // signature: number, Complex
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature2(convert1(arg0), arg1); // signature: number, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: Fraction
      if (arguments.length === 2) {
        return signature3(convert2(arg0), arg1); // signature: number, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert3(arg1)); // signature: number, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert4(arg1)); // signature: number, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test6(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert5(arg1)); // signature: number, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
  }
  if (test1(arg0)) { // type: Complex
    if (test1(arg1)) { // type: Complex
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Complex, Complex
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test0(arg1)) { // type: number (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: Complex, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: BigNumber (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert6(arg1)); // signature: Complex, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: Fraction (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert7(arg1)); // signature: Complex, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: string (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert8(arg1)); // signature: Complex, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (test1(arg1)) { // type: Complex
      if (arguments.length === 2) {
        return signature1(convert6(arg0), arg1); // signature: BigNumber, Complex
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: BigNumber, Big ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* Syntax:
*
*    math.smallerEq(x, y)
*
* Examples:
*
*    math.<span class="apidocCodeKeywordSpan">smaller</span>(1 + 2, 3);        // returns false
*    math.smallerEq(1 + 2, 3);      // returns true
*
* See also:
*
*    equal, unequal, smaller, larger, largerEq, compare
*
* @param  {number | BigNumber | Fraction | boolean | Unit | string | Array | Matrix} x First value to compare
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.smallerEq" id="apidoc.element.mathjs.smallerEq">
        function <span class="apidocSignatureSpan">mathjs.</span>smallerEq
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function smallerEq(arg0, arg1) {
  "use strict";
  var name = 'smallerEq';
  if (test0(arg0)) { // type: number
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: number, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: Complex
      if (arguments.length === 2) {
        return signature1(convert0(arg0), arg1); // signature: number, Complex
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature2(convert1(arg0), arg1); // signature: number, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: Fraction
      if (arguments.length === 2) {
        return signature3(convert2(arg0), arg1); // signature: number, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert3(arg1)); // signature: number, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert4(arg1)); // signature: number, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test6(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert5(arg1)); // signature: number, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
  }
  if (test1(arg0)) { // type: Complex
    if (test1(arg1)) { // type: Complex
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Complex, Complex
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test0(arg1)) { // type: number (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: Complex, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: BigNumber (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert6(arg1)); // signature: Complex, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: Fraction (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert7(arg1)); // signature: Complex, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: string (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert8(arg1)); // signature: Complex, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (test1(arg1)) { // type: Complex
      if (arguments.length === 2) {
        return signature1(convert6(arg0), arg1); // signature: BigNumber, Complex
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: BigNumber, ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* The function returns true when x is smaller than y or the relative
* difference between x and y is smaller than the configured epsilon. The
* function cannot be used to compare values smaller than approximately 2.22e-16.
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">smallerEq</span>(x, y)
*
* Examples:
*
*    math.smaller(1 + 2, 3);        // returns false
*    math.smallerEq(1 + 2, 3);      // returns true
*
* See also:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.sort" id="apidoc.element.mathjs.sort">
        function <span class="apidocSignatureSpan">mathjs.</span>sort
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sort(arg0, arg1) {
  "use strict";
  var name = 'sort';
  if (test0(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature0(arg0); // signature: Array
    }
    if (test1(arg1)) { // type: string
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Array, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: function
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: Array, function
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: number (convert to string)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: Array, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: boolean (convert to string)
      if (arguments.length === 2) {
        return signature1(arg0, convert1(arg1)); // signature: Array, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: null (convert to string)
      if (arguments.length === 2) {
        return signature1(arg0, convert2(arg1)); // signature: Array, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'string,function');
  }
  if (test6(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Matrix
    }
    if (test1(arg1)) { // type: string
      if (arguments.length === 2) {
        return signature4(arg0, arg1); // signature: Matrix, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: function
      if (arguments.length === 2) {
        return signature5(arg0, arg1); // signature: Matrix, function
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: number (convert to string)
      if (arguments.length === 2) {
        return signature4(arg0, convert0(arg1)); // signature: Matrix, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: boolean (convert to string)
      if (arguments.length === 2) {
        return signature4(arg0, convert1(arg1)); // signature: Matrix, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: null (convert to string)
      if (arguments.length === 2) {
        return signature4(arg0, convert2(arg1)); // signature: Matrix, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'string,function');
  }
  throw createError(name, arguments.length, 0, arguments[0], 'Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

/**
 * Sort the items in a matrix.
 *
 * Syntax:
 *
 *    math.<span class="apidocCodeKeywordSpan">sort</span>(x)
 *    math.sort(x, compare)
 *
 * Examples:
 *
 *    math.sort([5, 10, 1]); // returns [1, 5, 10]
 *    math.sort(['C', 'B', 'A', 'D']); // returns ['A', 'B', 'C
', 'D']
 *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.sparse" id="apidoc.element.mathjs.sparse">
        function <span class="apidocSignatureSpan">mathjs.</span>sparse
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sparse(arg0, arg1) {
  "use strict";
  var name = 'sparse';
  if (arguments.length === 0) {
    return signature0(); // signature:
  }
  if (test0(arg0)) { // type: string
    if (arguments.length === 1) {
      return signature1(arg0); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature2(arg0); // signature: Array
    }
    if (test0(arg1)) { // type: string
      if (arguments.length === 2) {
        return signature3(arg0, arg1); // signature: Array, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: number (convert to string)
      if (arguments.length === 2) {
        return signature3(arg0, convert0(arg1)); // signature: Array, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: boolean (convert to string)
      if (arguments.length === 2) {
        return signature3(arg0, convert1(arg1)); // signature: Array, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: null (convert to string)
      if (arguments.length === 2) {
        return signature3(arg0, convert2(arg1)); // signature: Array, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'string');
  }
  if (test5(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature2(arg0); // signature: Matrix
    }
    if (test0(arg1)) { // type: string
      if (arguments.length === 2) {
        return signature3(arg0, arg1); // signature: Matrix, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: number (convert to string)
      if (arguments.length === 2) {
        return signature3(arg0, convert0(arg1)); // signature: Matrix, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: boolean (convert to string)
      if (arguments.length === 2) {
        return signature3(arg0, convert1(arg1)); // signature: Matrix, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: null (convert to string)
      if (arguments.length === 2) {
        return signature3(arg0, convert2(arg1)); // signature: Matrix, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'string');
  }
  if (test2(arg0)) { // type: number (convert to string)
    if (arguments.length === 1) {
      return signature1(convert0(arg0)); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: boolean (convert to string)
    if (arguments.length === 1) {
      return signature1(convert1(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: null (convert to string)
    if (arguments.length === 1) {
      return signature1(convert2(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'string,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.splitUnit" id="apidoc.element.mathjs.splitUnit">
        function <span class="apidocSignatureSpan">mathjs.</span>splitUnit
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function splitUnit(arg0, arg1) {
  "use strict";
  var name = 'splitUnit';
  if (test0(arg0)) { // type: Unit
    if (test1(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: Unit, Array
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: Matrix (convert to Array)
      if (arguments.length === 2) {
        return signature0(arg0, convert0(arg1)); // signature: Unit, Matrix
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Array');
  }
  throw createError(name, arguments.length, 0, arguments[0], 'Unit');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * Returns an array of units whose sum is equal to this unit
   * @memberof Unit
   * @param {Array} [parts] An array of strings or valueless units.
   *
   *   Example:
   *
   *   var u = new Unit(1, 'm');
   *   u.<span class="apidocCodeKeywordSpan">splitUnit</span>(['feet', 'inch']);
   *     [ 3 feet, 3.3700787401575 inch ]
   *
   * @return {Array} An array of units.
   */
  Unit.prototype.splitUnit = function(parts) {

var x = this.clone();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.sqrt" id="apidoc.element.mathjs.sqrt">
        function <span class="apidocSignatureSpan">mathjs.</span>sqrt
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sqrt(arg0) {
  "use strict";
  var name = 'sqrt';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Unit
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Unit
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature2(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test9(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Unit,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// load math.js
var math = require('mathjs');

// functions and constants
math.round(math.e, 3);            // 2.718
math.atan2(3, -3) / math.pi;      // 0.75
math.log(1000, 10);               // 3
math.<span class="apidocCodeKeywordSpan">sqrt</span>(-4);                    // 2i
math.pow([[-1, 2], [3, 1]], 2);   // [[7, 0], [0, 7]]
math.derivative('x^2 + x', 'x');  // 2 * x + 1

// expressions
math.eval('12 / (2.3 + 0.7)');    // 4
math.eval('5.08 cm to inch');     // 2 inch
math.eval('sin(45 deg) ^ 2');     // 0.5
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.square" id="apidoc.element.mathjs.square">
        function <span class="apidocSignatureSpan">mathjs.</span>square
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function square(arg0) {
  "use strict";
  var name = 'square';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Fraction
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Unit
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Unit
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature5(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature5(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert0(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test9(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Fraction,Unit,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Syntax:
*
*    math.sqrt(x)
*
* Examples:
*
*    math.sqrt(25);                // returns 5
*    math.<span class="apidocCodeKeywordSpan">square</span>(5);               // returns 25
*    math.sqrt(-4);                // returns Complex 2i
*
* See also:
*
*    square, multiply, cube, cbrt
*
* @param {number | BigNumber | Complex | Array | Matrix | Unit} x
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.squeeze" id="apidoc.element.mathjs.squeeze">
        function <span class="apidocSignatureSpan">mathjs.</span>squeeze
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function squeeze(arg0) {
  "use strict";
  var name = 'squeeze';
  if (test0(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature0(arg0); // signature: Array
    }
  }
  if (test1(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Matrix
    }
  }
  // type: any
  if (arguments.length === 1) {
    return signature2(arg0); // signature: any
  }
  if (arguments.length &gt; 1) {
    throw createError(name, arguments.length, 1, arguments[1]);
  }
  throw createError(name, arguments.length, 0, arguments[0], 'Array,Matrix,any');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * @param {Array} y  Second vector
   * @returns {Array} Returns the cross product of x and y
   * @private
   */
  function _cross(x, y) {
var highestDimension = Math.max(array.size(x).length, array.size(y).length);

x = array.<span class="apidocCodeKeywordSpan">squeeze</span>(x);
y = array.squeeze(y);

var xSize = array.size(x);
var ySize = array.size(y);

if (xSize.length != 1 || ySize.length != 1 || xSize[0] != 3 || ySize[0] != 3) {
  throw new RangeError('Vectors with length 3 expected ' +
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.std" id="apidoc.element.mathjs.std">
        function <span class="apidocSignatureSpan">mathjs.</span>std
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function std(arg0, arg1) {
  "use strict";
  var name = 'std';
  if (test0(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature0(arg0); // signature: Array
    }
    if (test1(arg1)) { // type: string
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: Array, string
      }
    }
    if (test2(arg1)) { // type: number (convert to string)
      if (arguments.length === 2) {
        return signature0(arg0, convert0(arg1)); // signature: Array, number
      }
    }
    if (test3(arg1)) { // type: boolean (convert to string)
      if (arguments.length === 2) {
        return signature0(arg0, convert1(arg1)); // signature: Array, boolean
      }
    }
    if (test4(arg1)) { // type: null (convert to string)
      if (arguments.length === 2) {
        return signature0(arg0, convert2(arg1)); // signature: Array, null
      }
    }
  }
  if (test5(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature0(arg0); // signature: Matrix
    }
    if (test1(arg1)) { // type: string
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: Matrix, string
      }
    }
    if (test2(arg1)) { // type: number (convert to string)
      if (arguments.length === 2) {
        return signature0(arg0, convert0(arg1)); // signature: Matrix, number
      }
    }
    if (test3(arg1)) { // type: boolean (convert to string)
      if (arguments.length === 2) {
        return signature0(arg0, convert1(arg1)); // signature: Matrix, boolean
      }
    }
    if (test4(arg1)) { // type: null (convert to string)
      if (arguments.length === 2) {
        return signature0(arg0, convert2(arg1)); // signature: Matrix, null
      }
    }
  }
  if (arguments.length &gt; 0) {
    var varArgs = [];
    for (var i = 0; i &lt; arguments.length; i++) {
      varArgs.push(arguments[i]);
    }
    return signature1(varArgs); // signature: ...any
  }
  throw createError(name, arguments.length, 0, arguments[0], 'Array,Matrix,any');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* - 'unbiased' (default) The sum of squared errors is divided by (n - 1)
* - 'uncorrected'        The sum of squared errors is divided by n
* - 'biased'             The sum of squared errors is divided by (n + 1)
*
* Syntax:
*
*     math.<span class="apidocCodeKeywordSpan">std</span>(a, b, c, ...)
*     math.std(A)
*     math.std(A, normalization)
*
* Examples:
*
*     math.std(2, 4, 6);                     // returns 2
*     math.std([2, 4, 6, 8]);                // returns 2.581988897471611
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.stirlingS2" id="apidoc.element.mathjs.stirlingS2">
        function <span class="apidocSignatureSpan">mathjs.</span>stirlingS2
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function stirlingS2(arg0, arg1) {
  "use strict";
  var name = 'stirlingS2';
  if (test0(arg0)) { // type: number
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: number, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: number, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature0(arg0, convert0(arg1)); // signature: number, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert1(arg1)); // signature: number, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert2(arg1)); // signature: number, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert3(arg1)); // signature: number, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'number,BigNumber');
  }
  if (test1(arg0)) { // type: BigNumber
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: BigNumber, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: BigNumber, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature0(arg0, convert0(arg1)); // signature: BigNumber, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert1(arg1)); // signature: BigNumber, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert2(arg1)); // signature: BigNumber, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert3(arg1)); // signature: BigNumber, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'number,BigNumber');
  }
  if (test2(arg0)) { // type: Fraction (convert to BigNumber)
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature0(convert0(arg0), arg1); // signature: Fraction, number
      }
      if (arguments.length &gt; 2) {
        throw createErr ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* stirlingS2 only takes integer arguments.
* The following condition must be enforced: k &lt;= n.
*
*  If n = k or k = 1, then s(n,k) = 1
*
* Syntax:
*
*   math.<span class="apidocCodeKeywordSpan">stirlingS2</span>(n, k)
*
* Examples:
*
*    math.stirlingS2(5, 3); //returns 25
*
* See also:
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.string" id="apidoc.element.mathjs.string">
        function <span class="apidocSignatureSpan">mathjs.</span>string
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function string(arg0) {
  "use strict";
  var name = 'string';
  if (arguments.length === 0) {
    return signature0(); // signature:
  }
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature1(arg0); // signature: number
    }
  }
  if (test1(arg0)) { // type: string
    if (arguments.length === 1) {
      return signature2(arg0); // signature: string
    }
  }
  if (test2(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Array
    }
  }
  if (test3(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Matrix
    }
  }
  if (test4(arg0)) { // type: boolean
    if (arguments.length === 1) {
      return signature4(arg0); // signature: boolean
    }
  }
  if (test5(arg0)) { // type: null
    if (arguments.length === 1) {
      return signature5(arg0); // signature: null
    }
  }
  // type: any
  if (arguments.length === 1) {
    return signature6(arg0); // signature: any
  }
  if (arguments.length &gt; 1) {
    throw createError(name, arguments.length, 1, arguments[1]);
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,string,Array,Matrix,boolean,null,any');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function factory (type, config, load, typed) {
/**
 * Create a string or convert any object into a string.
 * Elements of Arrays and Matrices are processed element wise.
 *
 * Syntax:
 *
 *    math.<span class="apidocCodeKeywordSpan">string</span>(value)
 *
 * Examples:
 *
 *    math.string(4.2);               // returns string '4.2'
 *    math.string(math.complex(3, 2); // returns string '3 + 2i'
 *
 *    var u = math.unit(5, 'km');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.subset" id="apidoc.element.mathjs.subset">
        function <span class="apidocSignatureSpan">mathjs.</span>subset
        <span class="apidocSignatureSpan">(arg0, arg1, arg2, arg3)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function subset(arg0, arg1, arg2, arg3) {
  "use strict";
  var name = 'subset';
  if (test0(arg0)) { // type: string
    if (test1(arg1)) { // type: Index
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: string, Index
      }
      if (test0(arg2)) { // type: string
        if (arguments.length === 3) {
          return signature1(arg0, arg1, arg2); // signature: string, Index, string
        }
        if (test0(arg3)) { // type: string
          if (arguments.length === 4) {
            return signature1(arg0, arg1, arg2, arg3); // signature: string, Index, string, string
          }
          if (arguments.length &gt; 4) {
            throw createError(name, arguments.length, 4, arguments[4]);
          }
        }
        if (test2(arg3)) { // type: number (convert to string)
          if (arguments.length === 4) {
            return signature1(arg0, arg1, arg2, convert0(arg3)); // signature: string, Index, string, number
          }
          if (arguments.length &gt; 4) {
            throw createError(name, arguments.length, 4, arguments[4]);
          }
        }
        if (test3(arg3)) { // type: boolean (convert to string)
          if (arguments.length === 4) {
            return signature1(arg0, arg1, arg2, convert1(arg3)); // signature: string, Index, string, boolean
          }
          if (arguments.length &gt; 4) {
            throw createError(name, arguments.length, 4, arguments[4]);
          }
        }
        if (test4(arg3)) { // type: null (convert to string)
          if (arguments.length === 4) {
            return signature1(arg0, arg1, arg2, convert2(arg3)); // signature: string, Index, string, null
          }
          if (arguments.length &gt; 4) {
            throw createError(name, arguments.length, 4, arguments[4]);
          }
        }
        throw createError(name, arguments.length, 3, arguments[3], 'string');
      }
      if (test2(arg2)) { // type: number (convert to string)
        if (arguments.length === 3) {
          return signature1(arg0, arg1, convert0(arg2)); // signature: string, Index, number
        }
        if (test0(arg3)) { // type: string
          if (arguments.length === 4) {
            return signature1(arg0, arg1, convert0(arg2), arg3); // signature: string, Index, number, string
          }
          if (arguments.length &gt; 4) {
            throw createError(name, arguments.length, 4, arguments[4]);
          }
        }
        if (test2(arg3)) { // type: number (convert to string)
          if (arguments.length === 4) {
            return signature1(arg0, arg1, convert0(arg2), convert0(arg3)); // signature: string, Index, number, number
          }
          if (arguments.length &gt; 4) {
            throw createError(name, arguments.length, 4, arguments[4]);
          }
        }
        if (test3(arg3)) { // type: boolean (convert to string)
          if (arguments.length === 4) {
            return signature1(arg0, arg1, convert0(arg2), convert1(arg3)); // signature: string, Index, number, boolean
          }
          if (arguments.length &gt; 4) {
            throw createError(name, arguments.length, 4, arguments[4]);
          }
        }
        if (test4(arg3)) { // type: null (convert to string)
          if (arguments.length === 4) {
            return signature1(arg0, arg1, convert0(arg2), convert2(arg3)); // signature: string, Index, number, null
          }
          if (arguments.length &gt; 4) {
            throw createError(name, arguments.length, 4, arguments[4]);
          }
        }
        throw createError(name, arguments.length, 3, arguments[3], 'string');
      }
      if (test3(arg2)) { // type: boolean (convert to string)
        if (arguments.length === 3) {
          return signature1(arg0, arg1, convert1(arg2)); // signature: string, Index, boolean
        }
        if (test0(arg3)) { // type: string
          if (arguments.length === 4) {
            return signature1(arg0, arg1, convert1(arg2), arg3); // signature: string, Index, boolean, string
          }
          if (arguments.length &gt; 4) { ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function factory (type, config, load, typed) {
var matrix = load(require('../../type/matrix/function/matrix'));

/**
 * Get or set a subset of a matrix or string.
 *
 * Syntax:
 *     math.<span class="apidocCodeKeywordSpan">subset</span>(value, index)                                // retrieve a subset
 *     math.subset(value, index, replacement [, defaultValue])  // replace a subset
 *
 * Examples:
 *
 *     // get a subset
 *     var d = [[1, 2], [3, 4]];
 *     math.subset(d, math.index(1, 0));        // returns 3
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.subtract" id="apidoc.element.mathjs.subtract">
        function <span class="apidocSignatureSpan">mathjs.</span>subtract
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function subtract(arg0, arg1) {
  "use strict";
  var name = 'subtract';
  if (test0(arg0)) { // type: number
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: number, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: Complex
      if (arguments.length === 2) {
        return signature1(convert0(arg0), arg1); // signature: number, Complex
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature2(convert1(arg0), arg1); // signature: number, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: Fraction
      if (arguments.length === 2) {
        return signature3(convert2(arg0), arg1); // signature: number, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert3(arg1)); // signature: number, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert4(arg1)); // signature: number, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test6(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert5(arg1)); // signature: number, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
  }
  if (test1(arg0)) { // type: Complex
    if (test1(arg1)) { // type: Complex
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Complex, Complex
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test0(arg1)) { // type: number (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: Complex, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: BigNumber (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert6(arg1)); // signature: Complex, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: Fraction (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert7(arg1)); // signature: Complex, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: string (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert8(arg1)); // signature: Complex, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (test1(arg1)) { // type: Complex
      if (arguments.length === 2) {
        return signature1(convert6(arg0), arg1); // signature: BigNumber, Complex
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: BigNumber, B ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  /**
* Subtract two values, `x - y`.
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">subtract</span>(x, y)
*
* Examples:
*
*    math.subtract(5.3, 2);        // returns number 3.3
*
*    var a = math.complex(2, 3);
*    var b = math.complex(4, 1);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.sum" id="apidoc.element.mathjs.sum">
        function <span class="apidocSignatureSpan">mathjs.</span>sum
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sum(arg0, arg1) {
  "use strict";
  var name = 'sum';
  if (test0(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature0(arg0); // signature: Array
    }
    if (test1(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Array, number
      }
    }
    if (test2(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Array, BigNumber
      }
    }
    if (test3(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: Array, Fraction
      }
    }
    if (test4(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert1(arg1)); // signature: Array, string
      }
    }
    if (test5(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert2(arg1)); // signature: Array, boolean
      }
    }
    if (test6(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert3(arg1)); // signature: Array, null
      }
    }
  }
  if (test7(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature0(arg0); // signature: Matrix
    }
    if (test1(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Matrix, number
      }
    }
    if (test2(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Matrix, BigNumber
      }
    }
    if (test3(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: Matrix, Fraction
      }
    }
    if (test4(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert1(arg1)); // signature: Matrix, string
      }
    }
    if (test5(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert2(arg1)); // signature: Matrix, boolean
      }
    }
    if (test6(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert3(arg1)); // signature: Matrix, null
      }
    }
  }
  if (arguments.length &gt; 0) {
    var varArgs = [];
    for (var i = 0; i &lt; arguments.length; i++) {
      varArgs.push(arguments[i]);
    }
    return signature2(varArgs); // signature: ...any
  }
  throw createError(name, arguments.length, 0, arguments[0], 'Array,Matrix,any');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Compute the sum of a matrix or a list with values.
* In case of a (multi dimensional) array or matrix, the sum of all
* elements will be calculated.
*
* Syntax:
*
*     math.<span class="apidocCodeKeywordSpan">sum</span>(a, b, c, ...)
*     math.sum(A)
*
* Examples:
*
*     math.sum(2, 1, 4, 3);               // returns 10
*     math.sum([2, 1, 4, 3]);             // returns 10
*     math.sum([[2, 5], [4, 3], [1, 7]]); // returns 22
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.tan" id="apidoc.element.mathjs.tan">
        function <span class="apidocSignatureSpan">mathjs.</span>tan
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function tan(arg0) {
  "use strict";
  var name = 'tan';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Unit
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Unit
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature2(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test9(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Unit,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Syntax:
*
*    math.atan(x)
*
* Examples:
*
*    math.atan(0.5);           // returns number 0.4636476090008061
*    math.atan(math.<span class="apidocCodeKeywordSpan">tan</span>(1.5)); // returns number 1.5
*
*    math.atan(2);             // returns Complex 1.5707963267948966 -1.3169578969248166 i
*
* See also:
*
*    tan, asin, acos
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.tanh" id="apidoc.element.mathjs.tanh">
        function <span class="apidocSignatureSpan">mathjs.</span>tanh
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function tanh(arg0) {
  "use strict";
  var name = 'tanh';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Unit
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Unit
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature2(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test9(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Unit,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
*    math.coth(x)
*
* Examples:
*
*    // coth(x) = 1 / tanh(x)
*    math.coth(2);         // returns 1.0373147207275482
*    1 / math.<span class="apidocCodeKeywordSpan">tanh</span>(2);     // returns 1.0373147207275482
*
* See also:
*
*    sinh, tanh, cosh
*
* @param {number | Complex | Unit | Array | Matrix} x  Function input
* @return {number | Complex | Array | Matrix} Hyperbolic cotangent of x
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.to" id="apidoc.element.mathjs.to">
        function <span class="apidocSignatureSpan">mathjs.</span>to
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function to(arg0, arg1) {
  "use strict";
  var name = 'to';
  if (test0(arg0)) { // type: Unit
    if (test0(arg1)) { // type: Unit
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: Unit, Unit
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: string
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: Unit, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: number (convert to string)
      if (arguments.length === 2) {
        return signature0(arg0, convert0(arg1)); // signature: Unit, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: boolean (convert to string)
      if (arguments.length === 2) {
        return signature0(arg0, convert1(arg1)); // signature: Unit, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: null (convert to string)
      if (arguments.length === 2) {
        return signature0(arg0, convert2(arg1)); // signature: Unit, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
  }
  if (test5(arg0)) { // type: Array
    if (test5(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Array, Array
      }
    }
    if (test6(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: Array, Matrix
      }
    }
    // type: any
    if (arguments.length === 2) {
      return signature3(arg0, arg1); // signature: Array, any
    }
    if (arguments.length &gt; 2) {
      throw createError(name, arguments.length, 2, arguments[2]);
    }
  }
  if (test6(arg0)) { // type: Matrix
    if (test5(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature4(arg0, arg1); // signature: Matrix, Array
      }
    }
    if (test6(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature5(arg0, arg1); // signature: Matrix, Matrix
      }
    }
    // type: any
    if (arguments.length === 2) {
      return signature6(arg0, arg1); // signature: Matrix, any
    }
    if (arguments.length &gt; 2) {
      throw createError(name, arguments.length, 2, arguments[2]);
    }
  }
  // type: any
  if (test5(arg1)) { // type: Array
    if (arguments.length === 2) {
      return signature7(arg0, arg1); // signature: any, Array
    }
  }
  if (test6(arg1)) { // type: Matrix
    if (arguments.length === 2) {
      return signature8(arg0, arg1); // signature: any, Matrix
    }
  }
  throw createError(name, arguments.length, 1, arguments[1], 'Array,Matrix');
  throw createError(name, arguments.length, 0, arguments[0], 'Unit,Array,Matrix,any');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* Examples:
*
*    math.string(4.2);               // returns string '4.2'
*    math.string(math.complex(3, 2); // returns string '3 + 2i'
*
*    var u = math.unit(5, 'km');
*    math.string(u.<span class="apidocCodeKeywordSpan">to</span>('m'));         // returns string '5000 m'
*
*    math.string([true, false]);     // returns ['true', 'false']
*
* See also:
*
*    bignumber, boolean, complex, index, matrix, number, unit
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.trace" id="apidoc.element.mathjs.trace">
        function <span class="apidocSignatureSpan">mathjs.</span>trace
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function trace(arg0) {
  "use strict";
  var name = 'trace';
  if (test0(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature0(arg0); // signature: Array
    }
  }
  if (test1(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Matrix
    }
  }
  // type: any
  if (arguments.length === 1) {
    return signature2(arg0); // signature: any
  }
  if (arguments.length &gt; 1) {
    throw createError(name, arguments.length, 1, arguments[1]);
  }
  throw createError(name, arguments.length, 0, arguments[0], 'Array,Matrix,any');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  /**
* Calculate the trace of a matrix: the sum of the elements on the main
* diagonal of a square matrix.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">trace</span>(x)
*
* Examples:
*
*    math.trace([[1, 2], [3, 4]]); // returns 5
*
*    var A = [
*      [1, 2, 3],
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.transpose" id="apidoc.element.mathjs.transpose">
        function <span class="apidocSignatureSpan">mathjs.</span>transpose
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function transpose(arg0) {
  "use strict";
  var name = 'transpose';
  if (test0(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature0(arg0); // signature: Array
    }
  }
  if (test1(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Matrix
    }
  }
  // type: any
  if (arguments.length === 1) {
    return signature2(arg0); // signature: any
  }
  if (arguments.length &gt; 1) {
    throw createError(name, arguments.length, 1, arguments[1]);
  }
  throw createError(name, arguments.length, 0, arguments[0], 'Array,Matrix,any');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Transpose a matrix. All values of the matrix are reflected over its
* main diagonal. Only applicable to two dimensional matrices containing
* a vector (i.e. having size `[1,n]` or `[n,1]`). One dimensional
* vectors and scalars return the input unchanged.
*
* Syntax:
*
*     math.<span class="apidocCodeKeywordSpan">transpose</span>(x)
*
* Examples:
*
*     var A = [[1, 2, 3], [4, 5, 6]];
*     math.transpose(A);               // returns [[1, 4], [2, 5], [3, 6]]
*
* See also:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber" id="apidoc.element.mathjs.type.BigNumber">
        function <span class="apidocSignatureSpan">mathjs.</span>type.BigNumber
        <span class="apidocSignatureSpan">(v)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Decimal(v) {
  var e, i, t,
    x = this;

  // Decimal called without new.
  if (!(x instanceof Decimal)) return new Decimal(v);

  // Retain a reference to this Decimal constructor, and shadow Decimal.prototype.constructor
  // which points to Object.
  x.constructor = Decimal;

  // Duplicate.
  if (v instanceof Decimal) {
    x.s = v.s;
    x.e = v.e;
    x.d = (v = v.d) ? v.slice() : v;
    return;
  }

  t = typeof v;

  if (t === 'number') {
    if (v === 0) {
      x.s = 1 / v &lt; 0 ? -1 : 1;
      x.e = 0;
      x.d = [0];
      return;
    }

    if (v &lt; 0) {
      v = -v;
      x.s = -1;
    } else {
      x.s = 1;
    }

    // Fast path for small integers.
    if (v === ~~v &amp;&amp; v &lt; 1e7) {
      for (e = 0, i = v; i &gt;= 10; i /= 10) e++;
      x.e = e;
      x.d = [v];
      return;

    // Infinity, NaN.
    } else if (v * 0 !== 0) {
      if (!v) x.s = NaN;
      x.e = NaN;
      x.d = null;
      return;
    }

    return parseDecimal(x, v.toString());

  } else if (t !== 'string') {
    throw Error(invalidArgument + v);
  }

  // Minus sign?
  if (v.charCodeAt(0) === 45) {
    v = v.slice(1);
    x.s = -1;
  } else {
    x.s = 1;
  }

  return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain" id="apidoc.element.mathjs.type.Chain">
        function <span class="apidocSignatureSpan">mathjs.</span>type.Chain
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Chain(value) {
  if (!(this instanceof Chain)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  if (value &amp;&amp; value.isChain) {
    this.value = value.value;
  }
  else {
    this.value = value;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Complex" id="apidoc.element.mathjs.type.Complex">
        function <span class="apidocSignatureSpan">mathjs.</span>type.Complex
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Complex(a, b) {

  if (!(this instanceof Complex)) {
    return new Complex(a, b);
  }

  parse(a, b); // mutates P

  this["re"] = P["re"];
  this["im"] = P["im"];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.DenseMatrix" id="apidoc.element.mathjs.type.DenseMatrix">
        function <span class="apidocSignatureSpan">mathjs.</span>type.DenseMatrix
        <span class="apidocSignatureSpan">(data, datatype)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DenseMatrix(data, datatype) {
  if (!(this instanceof DenseMatrix))
    throw new SyntaxError('Constructor must be called with the new operator');
  if (datatype &amp;&amp; !isString(datatype))
    throw new Error('Invalid datatype: ' + datatype);

  if (data &amp;&amp; data.isMatrix === true) {
    // check data is a DenseMatrix
    if (data.type === 'DenseMatrix') {
      // clone data &amp; size
      this._data = object.clone(data._data);
      this._size = object.clone(data._size);
      this._datatype = datatype || data._datatype;
    }
    else {
      // build data from existing matrix
      this._data = data.toArray();
      this._size = data.size();
      this._datatype = datatype || data._datatype;
    }
  }
  else if (data &amp;&amp; isArray(data.data) &amp;&amp; isArray(data.size)) {
    // initialize fields from JSON representation
    this._data = data.data;
    this._size = data.size;
    this._datatype = datatype || data.datatype;
  }
  else if (isArray(data)) {
    // replace nested Matrices with Arrays
    this._data = preprocess(data);
    // get the dimensions of the array
    this._size = array.size(this._data);
    // verify the dimensions of the array, TODO: compute size while processing array
    array.validate(this._data, this._size);
    // data type unknown
    this._datatype = datatype;
  }
  else if (data) {
    // unsupported type
    throw new TypeError('Unsupported type of data (' + util.types.type(data) + ')');
  }
  else {
    // nothing provided
    this._data = [];
    this._size = [0];
    this._datatype = datatype;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.FibonacciHeap" id="apidoc.element.mathjs.type.FibonacciHeap">
        function <span class="apidocSignatureSpan">mathjs.</span>type.FibonacciHeap
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function FibonacciHeap() {
  if (!(this instanceof FibonacciHeap))
    throw new SyntaxError('Constructor must be called with the new operator');

  // initialize fields
  this._minimum = null;
  this._size = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Fraction" id="apidoc.element.mathjs.type.Fraction">
        function <span class="apidocSignatureSpan">mathjs.</span>type.Fraction
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Fraction(a, b) {

  if (!(this instanceof Fraction)) {
    return new Fraction(a, b);
  }

  parse(a, b);

  if (Fraction['REDUCE']) {
    a = gcd(P["d"], P["n"]); // Abuse a
  } else {
    a = 1;
  }

  this["s"] = P["s"];
  this["n"] = P["n"] / a;
  this["d"] = P["d"] / a;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Help" id="apidoc.element.mathjs.type.Help">
        function <span class="apidocSignatureSpan">mathjs.</span>type.Help
        <span class="apidocSignatureSpan">(doc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Help(doc) {
  if (!(this instanceof Help)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  if (!doc)  throw new Error('Argument "doc" missing');

  this.doc = doc;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.ImmutableDenseMatrix" id="apidoc.element.mathjs.type.ImmutableDenseMatrix">
        function <span class="apidocSignatureSpan">mathjs.</span>type.ImmutableDenseMatrix
        <span class="apidocSignatureSpan">(data, datatype)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ImmutableDenseMatrix(data, datatype) {
  if (!(this instanceof ImmutableDenseMatrix))
    throw new SyntaxError('Constructor must be called with the new operator');
  if (datatype &amp;&amp; !isString(datatype))
    throw new Error('Invalid datatype: ' + datatype);

  if ((data &amp;&amp; data.isMatrix === true) || isArray(data)) {
    // use DenseMatrix implementation
    var matrix = new DenseMatrix(data, datatype);
    // internal structures
    this._data = matrix._data;
    this._size = matrix._size;
    this._datatype = matrix._datatype;
    this._min = null;
    this._max = null;
  }
  else if (data &amp;&amp; isArray(data.data) &amp;&amp; isArray(data.size)) {
    // initialize fields from JSON representation
    this._data = data.data;
    this._size = data.size;
    this._datatype = data.datatype;
    this._min = typeof data.min !== 'undefined' ? data.min : null;
    this._max = typeof data.max !== 'undefined' ? data.max : null;
  }
  else if (data) {
    // unsupported type
    throw new TypeError('Unsupported type of data (' + util.types.type(data) + ')');
  }
  else {
    // nothing provided
    this._data = [];
    this._size = [0];
    this._datatype = datatype;
    this._min = null;
    this._max = null;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Index" id="apidoc.element.mathjs.type.Index">
        function <span class="apidocSignatureSpan">mathjs.</span>type.Index
        <span class="apidocSignatureSpan">(ranges)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Index(ranges) {
  if (!(this instanceof Index)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  this._dimensions = [];
  this._isScalar = true;

  for (var i = 0, ii = arguments.length; i &lt; ii; i++) {
    var arg = arguments[i];

    if (arg &amp;&amp; (arg.isRange === true)) {
      this._dimensions.push(arg);
      this._isScalar = false;
    }
    else if (arg &amp;&amp; (Array.isArray(arg) || arg.isMatrix === true)) {
      // create matrix
      var m = _createImmutableMatrix(arg.valueOf());
      this._dimensions.push(m);
      // size
      var size = m.size();
      // scalar
      if (size.length !== 1 || size[0] !== 1) {
        this._isScalar = false;
      }
    }
    else if (typeof arg === 'number') {
      this._dimensions.push(_createImmutableMatrix([arg]));
    }
    else if (typeof arg === 'string') {
      // object property (arguments.count should be 1)
      this._dimensions.push(arg);
    }
    // TODO: implement support for wildcard '*'
    else {
      throw new TypeError('Dimension must be an Array, Matrix, number, string, or Range');
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Matrix" id="apidoc.element.mathjs.type.Matrix">
        function <span class="apidocSignatureSpan">mathjs.</span>type.Matrix
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Matrix() {
  if (!(this instanceof Matrix)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Range" id="apidoc.element.mathjs.type.Range">
        function <span class="apidocSignatureSpan">mathjs.</span>type.Range
        <span class="apidocSignatureSpan">(start, end, step)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Range(start, end, step) {
  if (!(this instanceof Range)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  if (start != null) {
    if (start.isBigNumber === true)
      start = start.toNumber();
    else if (typeof start !== 'number')
      throw new TypeError('Parameter start must be a number');
  }
  if (end != null) {
    if (end.isBigNumber === true)
      end = end.toNumber();
    else if (typeof end !== 'number')
      throw new TypeError('Parameter end must be a number');
  }
  if (step != null) {
    if (step.isBigNumber === true)
      step = step.toNumber();
    else if (typeof step !== 'number')
      throw new TypeError('Parameter step must be a number');
  }

  this.start = (start != null) ? parseFloat(start) : 0;
  this.end   = (end != null)   ? parseFloat(end)   : 0;
  this.step  = (step != null)  ? parseFloat(step)  : 1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.ResultSet" id="apidoc.element.mathjs.type.ResultSet">
        function <span class="apidocSignatureSpan">mathjs.</span>type.ResultSet
        <span class="apidocSignatureSpan">(entries)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ResultSet(entries) {
  if (!(this instanceof ResultSet)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  this.entries = entries || [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Spa" id="apidoc.element.mathjs.type.Spa">
        function <span class="apidocSignatureSpan">mathjs.</span>type.Spa
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Spa() {
  if (!(this instanceof Spa))
    throw new SyntaxError('Constructor must be called with the new operator');

  // allocate vector, TODO use typed arrays
  this._values = [];
  this._heap = new type.FibonacciHeap();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.SparseMatrix" id="apidoc.element.mathjs.type.SparseMatrix">
        function <span class="apidocSignatureSpan">mathjs.</span>type.SparseMatrix
        <span class="apidocSignatureSpan">(data, datatype)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SparseMatrix(data, datatype) {
  if (!(this instanceof SparseMatrix))
    throw new SyntaxError('Constructor must be called with the new operator');
  if (datatype &amp;&amp; !isString(datatype))
    throw new Error('Invalid datatype: ' + datatype);

  if (data &amp;&amp; data.isMatrix === true) {
    // create from matrix
    _createFromMatrix(this, data, datatype);
  }
  else if (data &amp;&amp; isArray(data.index) &amp;&amp; isArray(data.ptr) &amp;&amp; isArray(data.size)) {
    // initialize fields
    this._values = data.values;
    this._index = data.index;
    this._ptr = data.ptr;
    this._size = data.size;
    this._datatype = datatype || data.datatype;
  }
  else if (isArray(data)) {
    // create from array
    _createFromArray(this, data, datatype);
  }
  else if (data) {
    // unsupported type
    throw new TypeError('Unsupported type of data (' + util.types.type(data) + ')');
  }
  else {
    // nothing provided
    this._values = [];
    this._index = [];
    this._ptr = [0];
    this._size = [0, 0];
    this._datatype = datatype;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Unit" id="apidoc.element.mathjs.type.Unit">
        function <span class="apidocSignatureSpan">mathjs.</span>type.Unit
        <span class="apidocSignatureSpan">(value, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Unit(value, name) {
  if (!(this instanceof Unit)) {
    throw new Error('Constructor must be called with the new operator');
  }

  if (!(value === undefined || isNumeric(value) || value.isComplex)) {
    throw new TypeError('First parameter in Unit constructor must be number, BigNumber, Fraction, Complex, or undefined');
  }
  if (name != undefined &amp;&amp; (typeof name !== 'string' || name == '')) {
    throw new TypeError('Second parameter in Unit constructor must be a string');
  }

  if (name != undefined) {
    var u = Unit.parse(name);
    this.units = u.units;
    this.dimensions = u.dimensions;
  }
  else {
    this.units = [
      {
        unit: UNIT_NONE,
        prefix: PREFIXES.NONE,  // link to a list with supported prefixes
        power: 0
      }
    ];
    this.dimensions = [];
    for(var i=0; i&lt;BASE_DIMENSIONS.length; i++) {
      this.dimensions[i] = 0;
    }
  }

  this.value = (value != undefined) ? this._normalize(value) : null;

  this.fixPrefix = false; // if true, function format will not search for the
                          // best prefix but leave it as initially provided.
                          // fixPrefix is set true by the method Unit.to

  // The justification behind this is that if the constructor is explicitly called,
  // the caller wishes the units to be returned exactly as he supplied.
  this.isUnitListSimplified = true;

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.typed" id="apidoc.element.mathjs.typed">
        function <span class="apidocSignatureSpan">mathjs.</span>typed
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function typed(arg0, arg1) {
  "use strict";
  var name = 'typed';
  if (test0(arg0)) { // type: string
    if (test1(arg1)) { // type: Object
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: string, Object
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Object');
  }
  if (test2(arg0)) { // type: ...Function
    var varArgs = [arg0];
    for (var i = 1; i &lt; arguments.length; i++) {
      if (test2(arguments[i])) {
        varArgs.push(arguments[i]);
      } else {
        throw createError(name, arguments.length, i, arguments[i], 'Function');
      }
    }
    return signature1(varArgs); // signature: ...Function
  }
  if (test1(arg0)) { // type: Object
    if (arguments.length === 1) {
      return signature2(arg0); // signature: Object
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'string,Function,Object');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.typeof" id="apidoc.element.mathjs.typeof">
        function <span class="apidocSignatureSpan">mathjs.</span>typeof
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _typeof(arg0) {
  "use strict";
  var name = '_typeof';
  // type: any
  if (arguments.length === 1) {
    return signature0(arg0); // signature: any
  }
  if (arguments.length &gt; 1) {
    throw createError(name, arguments.length, 1, arguments[1]);
  }
  throw createError(name, arguments.length, 0, arguments[0], 'any');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Determine the type of a variable.
*
* Function `typeof` recognizes the following types of objects:
*
* Object                 | Returns       | Example
* ---------------------- | ------------- | ------------------------------------------
* null                   | `'null'`      | `math.<span class="apidocCodeKeywordSpan">typeof</span>(null)`
* number                 | `'number'`    | `math.typeof(3.5)`
* boolean                | `'boolean'`   | `math.typeof (true)`
* string                 | `'string'`    | `math.typeof ('hello world')`
* Array                  | `'Array'`     | `math.typeof ([1, 2, 3])`
* Date                   | `'Date'`      | `math.typeof (new Date())`
* Function               | `'Function'`  | `math.typeof (function () {})`
* Object                 | `'Object'`    | `math.typeof ({a: 2, b: 3})`
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.unaryMinus" id="apidoc.element.mathjs.unaryMinus">
        function <span class="apidocSignatureSpan">mathjs.</span>unaryMinus
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function unaryMinus(arg0) {
  "use strict";
  var name = 'unaryMinus';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Fraction
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Unit
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Unit
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature5(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature5(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert0(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test9(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Fraction,Unit,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* For matrices, the function is evaluated element wise. Boolean values and
* strings will be converted to a number. For complex numbers, both real and
* complex value are inverted.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">unaryMinus</span>(x)
*
* Examples:
*
*    math.unaryMinus(3.5);      // returns -3.5
*    math.unaryMinus(-4.2);     // returns 4.2
*
* See also:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.unaryPlus" id="apidoc.element.mathjs.unaryPlus">
        function <span class="apidocSignatureSpan">mathjs.</span>unaryPlus
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function unaryPlus(arg0) {
  "use strict";
  var name = 'unaryPlus';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Fraction
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Unit
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Unit
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: string
    if (arguments.length === 1) {
      return signature5(arg0); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature6(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature6(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: boolean
    if (arguments.length === 1) {
      return signature5(arg0); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test9(arg0)) { // type: null
    if (arguments.length === 1) {
      return signature5(arg0); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Fraction,Unit,string,Array,Matrix,boolean
,null');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Unary plus operation.
* Boolean values and strings will be converted to a number, numeric values will be returned as is.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">unaryPlus</span>(x)
*
* Examples:
*
*    math.unaryPlus(3.5);      // returns 3.5
*    math.unaryPlus(1);     // returns 1
*
* See also:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.unequal" id="apidoc.element.mathjs.unequal">
        function <span class="apidocSignatureSpan">mathjs.</span>unequal
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function unequal(arg0, arg1) {
  "use strict";
  var name = 'unequal';
  if (test0(arg0)) { // type: Array
    if (test0(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: Array, Array
      }
    }
    if (test1(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Array, Matrix
      }
    }
    // type: any
    if (arguments.length === 2) {
      return signature2(arg0, arg1); // signature: Array, any
    }
    if (arguments.length &gt; 2) {
      throw createError(name, arguments.length, 2, arguments[2]);
    }
  }
  if (test1(arg0)) { // type: Matrix
    if (test0(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature3(arg0, arg1); // signature: Matrix, Array
      }
    }
    if (test1(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature4(arg0, arg1); // signature: Matrix, Matrix
      }
    }
    // type: any
    if (arguments.length === 2) {
      return signature5(arg0, arg1); // signature: Matrix, any
    }
    if (arguments.length &gt; 2) {
      throw createError(name, arguments.length, 2, arguments[2]);
    }
  }
  // type: any
  if (test0(arg1)) { // type: Array
    if (arguments.length === 2) {
      return signature6(arg0, arg1); // signature: any, Array
    }
  }
  if (test1(arg1)) { // type: Matrix
    if (arguments.length === 2) {
      return signature7(arg0, arg1); // signature: any, Matrix
    }
  }
  // type: any
  if (arguments.length === 2) {
    return signature8(arg0, arg1); // signature: any, any
  }
  if (arguments.length &gt; 2) {
    throw createError(name, arguments.length, 2, arguments[2]);
  }
  throw createError(name, arguments.length, 1, arguments[1], 'Array,Matrix,any');
  throw createError(name, arguments.length, 0, arguments[0], 'Array,Matrix,any');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* Values `null` and `undefined` are compared strictly, thus `null` is unequal
* with everything except `null`, and `undefined` is unequal with everying
* except. `undefined`.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">unequal</span>(x, y)
*
* Examples:
*
*    math.unequal(2 + 2, 3);       // returns true
*    math.unequal(2 + 2, 4);       // returns false
*
*    var a = math.unit('50 cm');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.unit" id="apidoc.element.mathjs.unit">
        function <span class="apidocSignatureSpan">mathjs.</span>unit
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function unit(arg0, arg1) {
  "use strict";
  var name = 'unit';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(convert0(arg0)); // signature: number
    }
    if (test1(arg1)) { // type: string
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: number, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test0(arg1)) { // type: number (convert to string)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: number, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: boolean (convert to string)
      if (arguments.length === 2) {
        return signature1(arg0, convert1(arg1)); // signature: number, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: null (convert to string)
      if (arguments.length === 2) {
        return signature1(arg0, convert2(arg1)); // signature: number, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'string');
  }
  if (test4(arg0)) { // type: Complex
    if (test1(arg1)) { // type: string
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Complex, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test0(arg1)) { // type: number (convert to string)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: Complex, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: boolean (convert to string)
      if (arguments.length === 2) {
        return signature1(arg0, convert1(arg1)); // signature: Complex, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: null (convert to string)
      if (arguments.length === 2) {
        return signature1(arg0, convert2(arg1)); // signature: Complex, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'string');
  }
  if (test5(arg0)) { // type: BigNumber
    if (test1(arg1)) { // type: string
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: BigNumber, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test0(arg1)) { // type: number (convert to string)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: BigNumber, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: boolean (convert to string)
      if (arguments.length === 2) {
        return signature1(arg0, convert1(arg1)); // signature: BigNumber, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: null (convert to string)
      if (arguments.length === 2) {
        return signature1(arg0, convert2(arg1)); // signature: BigNumber, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'string');
  }
  if (test6(arg0)) { // type: Fraction
    if (test1(arg1)) { // type: string
      if (argument ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* Examples:
*
*    math.number(2);                         // returns number 2
*    math.number('7.2');                     // returns number 7.2
*    math.number(true);                      // returns number 1
*    math.number([true, false, true, true]); // returns [1, 0, 1, 1]
*    math.number(math.<span class="apidocCodeKeywordSpan">unit</span>('52cm'), 'm');    // returns 0.52
*
* See also:
*
*    bignumber, boolean, complex, index, matrix, string, unit
*
* @param {string | number | BigNumber | Fraction | boolean | Array | Matrix | Unit | null} [value]  Value to be converted
* @param {Unit | string} [valuelessUnit] A valueless unit, used to convert a unit to a number
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.usolve" id="apidoc.element.mathjs.usolve">
        function <span class="apidocSignatureSpan">mathjs.</span>usolve
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function usolve(arg0, arg1) {
  "use strict";
  var name = 'usolve';
  if (test0(arg0)) { // type: Array
    if (test0(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: Array, Array
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: Array, Matrix
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Array,Matrix');
  }
  if (test2(arg0)) { // type: DenseMatrix
    if (test0(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: DenseMatrix, Array
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: DenseMatrix, Matrix
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Array,Matrix');
  }
  if (test3(arg0)) { // type: SparseMatrix
    if (test0(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: SparseMatrix, Array
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: SparseMatrix, Matrix
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Array,Matrix');
  }
  if (test1(arg0)) { // type: Matrix (convert to Array)
    if (test0(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature0(convert0(arg0), arg1); // signature: Matrix, Array
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature0(convert0(arg0), arg1); // signature: Matrix, Matrix
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Array,Matrix');
  }
  throw createError(name, arguments.length, 0, arguments[0], 'Array,DenseMatrix,SparseMatrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.var" id="apidoc.element.mathjs.var">
        function <span class="apidocSignatureSpan">mathjs.</span>var
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function variance(arg0, arg1) {
  "use strict";
  var name = 'variance';
  if (test0(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature0(arg0); // signature: Array
    }
    if (test1(arg1)) { // type: string
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Array, string
      }
    }
    if (test2(arg1)) { // type: number (convert to string)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: Array, number
      }
    }
    if (test3(arg1)) { // type: boolean (convert to string)
      if (arguments.length === 2) {
        return signature1(arg0, convert1(arg1)); // signature: Array, boolean
      }
    }
    if (test4(arg1)) { // type: null (convert to string)
      if (arguments.length === 2) {
        return signature1(arg0, convert2(arg1)); // signature: Array, null
      }
    }
  }
  if (test5(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature0(arg0); // signature: Matrix
    }
    if (test1(arg1)) { // type: string
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Matrix, string
      }
    }
    if (test2(arg1)) { // type: number (convert to string)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: Matrix, number
      }
    }
    if (test3(arg1)) { // type: boolean (convert to string)
      if (arguments.length === 2) {
        return signature1(arg0, convert1(arg1)); // signature: Matrix, boolean
      }
    }
    if (test4(arg1)) { // type: null (convert to string)
      if (arguments.length === 2) {
        return signature1(arg0, convert2(arg1)); // signature: Matrix, null
      }
    }
  }
  if (arguments.length &gt; 0) {
    var varArgs = [];
    for (var i = 0; i &lt; arguments.length; i++) {
      varArgs.push(arguments[i]);
    }
    return signature2(varArgs); // signature: ...any
  }
  throw createError(name, arguments.length, 0, arguments[0], 'Array,Matrix,any');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* - 'unbiased' (default) The sum of squared errors is divided by (n - 1)
* - 'uncorrected'        The sum of squared errors is divided by n
* - 'biased'             The sum of squared errors is divided by (n + 1)
*
* Note that older browser may not like the variable name `var`. In that
* case, the function can be called as `math['var'](...)` instead of
* `math.<span class="apidocCodeKeywordSpan">var</span>(...)`.
*
* Syntax:
*
*     math.var(a, b, c, ...)
*     math.var(A)
*     math.var(A, normalization)
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.xgcd" id="apidoc.element.mathjs.xgcd">
        function <span class="apidocSignatureSpan">mathjs.</span>xgcd
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function xgcd(arg0, arg1) {
  "use strict";
  var name = 'xgcd';
  if (test0(arg0)) { // type: number
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: number, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature1(convert0(arg0), arg1); // signature: number, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(convert0(arg0), convert1(arg1)); // signature: number, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert2(arg1)); // signature: number, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert3(arg1)); // signature: number, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert4(arg1)); // signature: number, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'number,BigNumber');
  }
  if (test1(arg0)) { // type: BigNumber
    if (test1(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: BigNumber, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test0(arg1)) { // type: number (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: BigNumber, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert1(arg1)); // signature: BigNumber, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: string (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert5(arg1)); // signature: BigNumber, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: boolean (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert6(arg1)); // signature: BigNumber, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: null (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert7(arg1)); // signature: BigNumber, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'BigNumber');
  }
  if (test2(arg0)) { // type: Fraction (convert to BigNumber)
    if (test1(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature1(convert1(arg0), arg1); // signature: Fraction, BigNumber
      }
      if ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  /**
* Calculate the extended greatest common divisor for two values.
* See http://en.wikipedia.org/wiki/Extended_Euclidean_algorithm.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">xgcd</span>(a, b)
*
* Examples:
*
*    math.xgcd(8, 12);             // returns [4, -1, 1]
*    math.gcd(8, 12);              // returns 4
*    math.xgcd(36163, 21199);      // returns [1247, -7, 12]
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.xor" id="apidoc.element.mathjs.xor">
        function <span class="apidocSignatureSpan">mathjs.</span>xor
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function xor(arg0, arg1) {
  "use strict";
  var name = 'xor';
  if (test0(arg0)) { // type: number
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: number, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: Complex
      if (arguments.length === 2) {
        return signature1(convert0(arg0), arg1); // signature: number, Complex
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature2(convert1(arg0), arg1); // signature: number, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature2(convert1(arg0), convert2(arg1)); // signature: number, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert3(arg1)); // signature: number, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert4(arg1)); // signature: number, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test6(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert5(arg1)); // signature: number, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
  }
  if (test1(arg0)) { // type: Complex
    if (test1(arg1)) { // type: Complex
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Complex, Complex
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test0(arg1)) { // type: number (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: Complex, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: BigNumber (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert6(arg1)); // signature: Complex, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: Fraction (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert7(arg1)); // signature: Complex, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: string (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert8(arg1)); // signature: Complex, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (test1(arg1)) { // type: Complex
      if (arguments.length === 2) {
        return signature1(convert6(arg0), arg1); // signature: BigNumber, Complex
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  /**
* Logical `xor`. Test whether one and only one value is defined with a nonzero/nonempty value.
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">xor</span>(x, y)
*
* Examples:
*
*    math.xor(2, 4);   // returns false
*
*    a = [2, 0, 0];
*    b = [2, 7, 0];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.zeros" id="apidoc.element.mathjs.zeros">
        function <span class="apidocSignatureSpan">mathjs.</span>zeros
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function zeros(arg0, arg1) {
  "use strict";
  var name = 'zeros';
  if (arguments.length === 0) {
    return signature0(); // signature:
  }
  if (test0(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Array
    }
    if (test1(arg1)) { // type: string
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: Array, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: number (convert to string)
      if (arguments.length === 2) {
        return signature2(arg0, convert0(arg1)); // signature: Array, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: boolean (convert to string)
      if (arguments.length === 2) {
        return signature2(arg0, convert1(arg1)); // signature: Array, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: null (convert to string)
      if (arguments.length === 2) {
        return signature2(arg0, convert2(arg1)); // signature: Array, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'string');
  }
  if (test5(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Matrix
    }
    if (test1(arg1)) { // type: string
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: Matrix, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: number (convert to string)
      if (arguments.length === 2) {
        return signature2(arg0, convert0(arg1)); // signature: Matrix, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: boolean (convert to string)
      if (arguments.length === 2) {
        return signature2(arg0, convert1(arg1)); // signature: Matrix, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: null (convert to string)
      if (arguments.length === 2) {
        return signature2(arg0, convert2(arg1)); // signature: Matrix, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'string');
  }
  if (test2(arg0) || test6(arg0) || test1(arg0) || test7(arg0) || test3(arg0) || test3(arg0) || test3(arg0) || test4(arg0) || test4
(arg0) || test4(arg0)) { // type: ...number|BigNumber|string|Fraction|boolean|null
    var varArgs = [arg0];
    for (var i = 1; i &lt; arguments.length; i++) {
      if (test2(arguments[i]) || test6(arguments[i]) || test1(arguments[i])) {
        varArgs.push(arguments[i]);
      }
      else if (test7(arguments[i])) {
        varArgs.push(convert3(arguments[i]));
      }
      else if (test3(arguments[i])) {
        varArgs.push(convert4(arguments[i]));
      }
      else if (test3(arguments[i])) {
        varArgs.push(convert5(arguments[i]));
      }
      else if (test3(arguments[i])) {
        varArgs.push(convert1(arguments[i]));
      }
      else if (test4(arguments[i])) {
        varArgs.push(convert6(arguments[i]));
      }
      else if (test4(arguments[i])) {
        varArgs.push(convert2(arguments[i]));
      }
      else if (test4(arguments[i])) {
        varArgs.push(convert7(arguments[i]));
      } else {
        throw createError(name, arguments.length, i, arguments[i], 'number,BigNumber,string');
      }
    }
    return signature4(varArgs); // signature: ...number|BigN ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*     math.squeeze(x)
*
* Examples:
*
*     math.squeeze([3]);           // returns 3
*     math.squeeze([[3]]);         // returns 3
*
*     var A = math.<span class="apidocCodeKeywordSpan">zeros</span>(3, 1);    // returns [[0], [0], [0]] (size 3x1)
*     math.squeeze(A);             // returns [0, 0, 0] (size 3)
*
*     var B = math.zeros(1, 3);    // returns [[0, 0, 0]] (size 1x3)
*     math.squeeze(B);             // returns [0, 0, 0] (size 3)
*
*     // only inner and outer dimensions are removed
*     var C = math.zeros(2, 1, 3); // returns [[[0, 0, 0]], [[0, 0, 0]]] (size 2x1x3)
...</pre></li>
    </ul>




























































































































































































































































































































































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.AccessorNode" id="apidoc.module.mathjs.AccessorNode">module mathjs.AccessorNode</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.AccessorNode.factory" id="apidoc.element.mathjs.AccessorNode.factory">
        function <span class="apidocSignatureSpan">mathjs.AccessorNode.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var Node = load(require('./Node'));
  var access = load(require('./utils/access'));
  var getSafeProperty = load(require('./utils/customs')).getSafeProperty;

<span class="apidocCodeCommentSpan">  /**
   * @constructor AccessorNode
   * @extends {Node}
   * Access an object property or get a matrix subset
   *
   * @param {Node} object                 The object from which to retrieve
   *                                      a property or subset.
   * @param {IndexNode} index             IndexNode containing ranges
   */
</span>  function AccessorNode(object, index) {
    if (!(this instanceof AccessorNode)) {
      throw new SyntaxError('Constructor must be called with the new operator');
    }

    if (!(object &amp;&amp; object.isNode)) {
      throw new TypeError('Node expected for parameter "object"');
    }
    if (!(index &amp;&amp; index.isIndexNode)) {
      throw new TypeError('IndexNode expected for parameter "index"');
    }

    this.object = object || null;
    this.index = index;

    // readonly property name
    Object.defineProperty(this, 'name', {
      get: function () {
        if (this.index) {
          return (this.index.isObjectProperty())
              ? this.index.getObjectProperty()
              : '';
        }
        else {
          return this.object.name || '';
        }
      }.bind(this),
      set: function () {
        throw new Error('Cannot assign a new name, name is read-only');
      }
    });
  }

  AccessorNode.prototype = new Node();

  AccessorNode.prototype.type = 'AccessorNode';

  AccessorNode.prototype.isAccessorNode = true;

  /**
   * Compile the node to javascript code
   * @param {Object} defs     Object which can be used to define functions
   *                          or constants globally available for the compiled
   *                          expression
   * @param {Object} args     Object with local function arguments, the key is
   *                          the name of the argument, and the value is `true`.
   *                          The object may not be mutated, but must be
   *                          extended instead.
   * @return {string} js
   * @private
   */
  AccessorNode.prototype._compile = function (defs, args) {
    defs.access = access;
    defs.getSafeProperty = getSafeProperty;

    var object = this.object._compile(defs, args);
    var index = this.index._compile(defs, args);

    if (this.index.isObjectProperty()) {
      var prop = this.index.getObjectProperty();
      return 'getSafeProperty(' + object + ', "' + prop + '")';
    }
    else if (this.index.needsSize()) {
      // if some parameters use the 'end' parameter, we need to calculate the size
      return '(function () {' +
          '  var object = ' + object + ';' +
          '  var size = math.size(object).valueOf();' +
          '  return access(object, ' + index + ');' +
          '})()';
    }
    else {
      return 'access(' + object + ', ' + index + ')';
    }
  };

  /**
   * Execute a callback for each of the child nodes of this node
   * @param {function(child: Node, path: string, parent: Node)} callback
   */
  AccessorNode.prototype.forEach = function (callback) {
    callback(this.object, 'object', this);
    callback(this.index, 'index', this);
  };

  /**
   * Create a new AccessorNode having it's childs be the results of calling
   * the provided callback function for each of the childs of the original node.
   * @param {function(child: Node, path: string, parent: Node): Node} callback
   * @returns {AccessorNode} Returns a transformed copy of the node
   */
  AccessorNode.prototype.map = function (callback) {
    return new AccessorNode(
        this._ifNode(callback(this.object, 'object', this)),
        this._ifNode(callback(this.index, 'index', this))
    );
  };

  /**
   * Create a clone of this node, a shallow copy
   * @return {AccessorNode}
   */
  AccessorNode.prototype.clone = function () {
    return new AccessorNode(this.object, this.index);
  };

  /**
   * Get string representation
   * @param {Object} options
   * @return {string}
   */
  AccessorNode.pr ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.ArrayNode" id="apidoc.module.mathjs.ArrayNode">module mathjs.ArrayNode</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.ArrayNode.factory" id="apidoc.element.mathjs.ArrayNode.factory">
        function <span class="apidocSignatureSpan">mathjs.ArrayNode.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var Node = load(require('./Node'));

<span class="apidocCodeCommentSpan">  /**
   * @constructor ArrayNode
   * @extends {Node}
   * Holds an 1-dimensional array with items
   * @param {Node[]} [items]   1 dimensional array with items
   */
</span>  function ArrayNode(items) {
    if (!(this instanceof ArrayNode)) {
      throw new SyntaxError('Constructor must be called with the new operator');
    }

    this.items = items || [];

    // validate input
    if (!Array.isArray(this.items)
        || !this.items.every(function (item) {return item &amp;&amp; item.isNode;})) {
      throw new TypeError('Array containing Nodes expected');
    }

    // TODO: deprecated since v3, remove some day
    var deprecated = function () {
      throw new Error('Property `ArrayNode.nodes` is deprecated, use `ArrayNode.items` instead');
    };
    Object.defineProperty(this, 'nodes', { get: deprecated, set: deprecated });
  }

  ArrayNode.prototype = new Node();

  ArrayNode.prototype.type = 'ArrayNode';

  ArrayNode.prototype.isArrayNode = true;

  /**
   * Compile the node to javascript code
   * @param {Object} defs     Object which can be used to define functions
   *                          or constants globally available for the compiled
   *                          expression
   * @param {Object} args     Object with local function arguments, the key is
   *                          the name of the argument, and the value is `true`.
   *                          The object may not be mutated, but must be
   *                          extended instead.
   * @private
   */
  ArrayNode.prototype._compile = function (defs, args) {
    var asMatrix = (defs.math.config().matrix !== 'Array');

    var items = this.items.map(function (node) {
      return node._compile(defs, args);
    });

    return (asMatrix ? 'math.matrix([' : '[') +
        items.join(',') +
        (asMatrix ? '])' : ']');
  };

  /**
   * Execute a callback for each of the child nodes of this node
   * @param {function(child: Node, path: string, parent: Node)} callback
   */
  ArrayNode.prototype.forEach = function (callback) {
    for (var i = 0; i &lt; this.items.length; i++) {
      var node = this.items[i];
      callback(node, 'items[' + i + ']', this);
    }
  };

  /**
   * Create a new ArrayNode having it's childs be the results of calling
   * the provided callback function for each of the childs of the original node.
   * @param {function(child: Node, path: string, parent: Node): Node} callback
   * @returns {ArrayNode} Returns a transformed copy of the node
   */
  ArrayNode.prototype.map = function (callback) {
    var items = [];
    for (var i = 0; i &lt; this.items.length; i++) {
      items[i] = this._ifNode(callback(this.items[i], 'items[' + i + ']', this));
    }
    return new ArrayNode(items);
  };

  /**
   * Create a clone of this node, a shallow copy
   * @return {ArrayNode}
   */
  ArrayNode.prototype.clone = function() {
    return new ArrayNode(this.items.slice(0));
  };

  /**
   * Get string representation
   * @param {Object} options
   * @return {string} str
   * @override
   */
  ArrayNode.prototype._toString = function(options) {
    var items = this.items.map(function (node) {
      return node.toString(options);
    });
    return '[' + items.join(', ') + ']';
  };

  /**
   * Get LaTeX representation
   * @param {Object} options
   * @return {string} str
   */
  ArrayNode.prototype._toTex = function(options) {
    var s = '\\begin{bmatrix}';

    this.items.forEach(function(node) {
      if (node.items) {
        s += node.items.map(function(childNode) {
          return childNode.toTex(options);
        }).join('&amp;');
      }
      else {
        s += node.toTex(options);
      }

      // new line
      s += '\\\\';
    });
    s += '\\end{bmatrix}';
    return s;
  };

  return ArrayNode;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.AssignmentNode" id="apidoc.module.mathjs.AssignmentNode">module mathjs.AssignmentNode</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.AssignmentNode.factory" id="apidoc.element.mathjs.AssignmentNode.factory">
        function <span class="apidocSignatureSpan">mathjs.AssignmentNode.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var Node = load(require('./Node'));
  var ArrayNode = load(require('./ArrayNode'));
  var matrix = load(require('../../type/matrix/function/matrix'));
  var assign = load(require('./utils/assign'));
  var access = load(require('./utils/access'));
  var getSafeProperty = load(require('./utils/customs')).getSafeProperty;
  var setSafeProperty = load(require('./utils/customs')).setSafeProperty;

  var keywords = require('../keywords');
  var operators = require('../operators');

<span class="apidocCodeCommentSpan">  /**
   * @constructor AssignmentNode
   * @extends {Node}
   *
   * Define a symbol, like `a=3.2`, update a property like `a.b=3.2`, or
   * replace a subset of a matrix like `A[2,2]=42`.
   *
   * Syntax:
   *
   *     new AssignmentNode(symbol, value)
   *     new AssignmentNode(object, index, value)
   *
   * Usage:
   *
   *    new AssignmentNode(new SymbolNode('a'), new ConstantNode(2));                      // a=2
   *    new AssignmentNode(new SymbolNode('a'), new IndexNode('b'), new ConstantNode(2))   // a.b=2
   *    new AssignmentNode(new SymbolNode('a'), new IndexNode(1, 2), new ConstantNode(3))  // a[1,2]=3
   *
   * @param {SymbolNode | AccessorNode} object  Object on which to assign a value
   * @param {IndexNode} [index=null]            Index, property name or matrix
   *                                            index. Optional. If not provided
   *                                            and `object` is a SymbolNode,
   *                                            the property is assigned to the
   *                                            global scope.
   * @param {Node} value                        The value to be assigned
   */
</span>  function AssignmentNode(object, index, value) {
    if (!(this instanceof AssignmentNode)) {
      throw new SyntaxError('Constructor must be called with the new operator');
    }

    this.object = object;
    this.index = value ? index : null;
    this.value = value ? value : index;

    // validate input
    if (!object || !(object.isSymbolNode || object.isAccessorNode)) {
      throw new TypeError('SymbolNode or AccessorNode expected as "object"');
    }
    if (object &amp;&amp; object.isSymbolNode &amp;&amp; object.name === 'end') {
      throw new Error('Cannot assign to symbol "end"');
    }
    if (this.index &amp;&amp; !this.index.isIndexNode) {
      throw new TypeError('IndexNode expected as "index"');
    }
    if (!this.value || !this.value.isNode) {
      throw new TypeError('Node expected as "value"');
    }

    // readonly property name
    Object.defineProperty(this, 'name', {
      get: function () {
        if (this.index) {
          return (this.index.isObjectProperty())
              ? this.index.getObjectProperty()
              : '';
        }
        else {
          return this.object.name || '';
        }
      }.bind(this),
      set: function () {
        throw new Error('Cannot assign a new name, name is read-only');
      }
    });
  }

  AssignmentNode.prototype = new Node();

  AssignmentNode.prototype.type = 'AssignmentNode';

  AssignmentNode.prototype.isAssignmentNode = true;

  /**
   * Compile the node to javascript code
   * @param {Object} defs     Object which can be used to define functions
   *                          or constants globally available for the compiled
   *                          expression
   * @param {Object} args     Object with local function arguments, the key is
   *                          the name of the argument, and the value is `true`.
   *                          The object may not be mutated, but must be
   *                          extended instead.
   * @private
   */
  AssignmentNode.prototype._compile = function (defs, args) {
    defs.assign = assign;
    defs.access = access;
    defs.getSafeProperty = getSafeProperty;
    defs.setSafeProperty = setSafeProperty;

    var size;
    var object = this.object._compile(defs, args);
    var index = this.index ? this.index._compile(defs, args) : null;
    var value = this.value._compile(defs, args);

    if (!this.index) {
      // apply a variab ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.BigNumber" id="apidoc.module.mathjs.BigNumber">module mathjs.BigNumber</a></h1>




    <h2>
        <a href="#apidoc.element.mathjs.BigNumber.factory" id="apidoc.element.mathjs.BigNumber.factory">
        function <span class="apidocSignatureSpan">mathjs.BigNumber.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed, math)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed, math) {
  var BigNumber = Decimal.clone({precision: config.precision});

<span class="apidocCodeCommentSpan">  /**
   * Attach type information
   */
</span>  BigNumber.prototype.type = 'BigNumber';
  BigNumber.prototype.isBigNumber = true;

  /**
   * Get a JSON representation of a BigNumber containing
   * type information
   * @returns {Object} Returns a JSON object structured as:
   *                   `{"mathjs": "BigNumber", "value": "0.2"}`
   */
  BigNumber.prototype.toJSON = function () {
    return {
      mathjs: 'BigNumber',
      value: this.toString()
    };
  };

  /**
   * Instantiate a BigNumber from a JSON object
   * @param {Object} json  a JSON object structured as:
   *                       `{"mathjs": "BigNumber", "value": "0.2"}`
   * @return {BigNumber}
   */
  BigNumber.fromJSON = function (json) {
    return new BigNumber(json.value);
  };

  // listen for changed in the configuration, automatically apply changed precision
  math.on('config', function (curr, prev) {
    if (curr.precision !== prev.precision) {
      BigNumber.config({ precision: curr.precision });
    }
  });

  return BigNumber;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.BlockNode" id="apidoc.module.mathjs.BlockNode">module mathjs.BlockNode</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.BlockNode.factory" id="apidoc.element.mathjs.BlockNode.factory">
        function <span class="apidocSignatureSpan">mathjs.BlockNode.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var Node = load(require('./Node'));
  var ResultSet = load(require('../../type/resultset/ResultSet'));

<span class="apidocCodeCommentSpan">  /**
   * @constructor BlockNode
   * @extends {Node}
   * Holds a set with blocks
   * @param {Array.&lt;{node: Node} | {node: Node, visible: boolean}&gt;} blocks
   *            An array with blocks, where a block is constructed as an Object
   *            with properties block, which is a Node, and visible, which is
   *            a boolean. The property visible is optional and is true by default
   */
</span>  function BlockNode(blocks) {
    if (!(this instanceof BlockNode)) {
      throw new SyntaxError('Constructor must be called with the new operator');
    }

    // validate input, copy blocks
    if (!Array.isArray(blocks)) throw new Error('Array expected');
    this.blocks = blocks.map(function (block) {
      var node = block &amp;&amp; block.node;
      var visible = block &amp;&amp; block.visible !== undefined ? block.visible : true;

      if (!(node &amp;&amp; node.isNode))      throw new TypeError('Property "node" must be a Node');
      if (typeof visible !== 'boolean') throw new TypeError('Property "visible" must be a boolean');

      return {
        node: node,
        visible: visible
      }
    });
  }

  BlockNode.prototype = new Node();

  BlockNode.prototype.type = 'BlockNode';

  BlockNode.prototype.isBlockNode = true;

  /**
   * Compile the node to javascript code
   * @param {Object} defs     Object which can be used to define functions
   *                          or constants globally available for the compiled
   *                          expression
   * @param {Object} args     Object with local function arguments, the key is
   *                          the name of the argument, and the value is `true`.
   *                          The object may not be mutated, but must be
   *                          extended instead.
   * @return {string} js
   * @private
   */
  BlockNode.prototype._compile = function (defs, args) {
    defs.ResultSet = ResultSet;
    var blocks = this.blocks.map(function (param) {
      var js = param.node._compile(defs, args);
      if (param.visible) {
        return 'results.push(' + js + ');';
      }
      else {
        return js + ';';
      }
    });

    return '(function () {' +
        'var results = [];' +
        blocks.join('') +
        'return new ResultSet(results);' +
        '})()';
  };

  /**
   * Execute a callback for each of the child blocks of this node
   * @param {function(child: Node, path: string, parent: Node)} callback
   */
  BlockNode.prototype.forEach = function (callback) {
    for (var i = 0; i &lt; this.blocks.length; i++) {
      callback(this.blocks[i].node, 'blocks[' + i + '].node', this);
    }
  };

  /**
   * Create a new BlockNode having it's childs be the results of calling
   * the provided callback function for each of the childs of the original node.
   * @param {function(child: Node, path: string, parent: Node): Node} callback
   * @returns {BlockNode} Returns a transformed copy of the node
   */
  BlockNode.prototype.map = function (callback) {
    var blocks = [];
    for (var i = 0; i &lt; this.blocks.length; i++) {
      var block = this.blocks[i];
      var node = this._ifNode(callback(block.node, 'blocks[' + i + '].node', this));
      blocks[i] = {
        node: node,
        visible: block.visible
      };
    }
    return new BlockNode(blocks);
  };

  /**
   * Create a clone of this node, a shallow copy
   * @return {BlockNode}
   */
  BlockNode.prototype.clone = function () {
    var blocks = this.blocks.map(function (block) {
      return {
        node: block.node,
        visible: block.visible
      };
    });

    return new BlockNode(blocks);
  };

  /**
   * Get string representation
   * @param {Object} options
   * @return {string} str
   * @override
   */
  BlockNode.prototype._toString = function (options) {
    return this.blocks.map(function (param) {
      return param.node.toString(options) + (param.visible ? '' : ';');
    }).join('\n');
  };

  /**
   * Get LaTeX represent ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.Chain" id="apidoc.module.mathjs.Chain">module mathjs.Chain</a></h1>






    <h2>
        <a href="#apidoc.element.mathjs.Chain.factory" id="apidoc.element.mathjs.Chain.factory">
        function <span class="apidocSignatureSpan">mathjs.Chain.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed, math)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed, math) {
<span class="apidocCodeCommentSpan">  /**
   * @constructor Chain
   * Wrap any value in a chain, allowing to perform chained operations on
   * the value.
   *
   * All methods available in the math.js library can be called upon the chain,
   * and then will be evaluated with the value itself as first argument.
   * The chain can be closed by executing chain.done(), which will return
   * the final value.
   *
   * The Chain has a number of special functions:
   * - done()             Finalize the chained operation and return the
   *                      chain's value.
   * - valueOf()          The same as done()
   * - toString()         Returns a string representation of the chain's value.
   *
   * @param {*} [value]
   */
</span>  function Chain (value) {
    if (!(this instanceof Chain)) {
      throw new SyntaxError('Constructor must be called with the new operator');
    }

    if (value &amp;&amp; value.isChain) {
      this.value = value.value;
    }
    else {
      this.value = value;
    }
  }

  /**
   * Attach type information
   */
  Chain.prototype.type = 'Chain';
  Chain.prototype.isChain = true;

  /**
   * Close the chain. Returns the final value.
   * Does the same as method valueOf()
   * @returns {*} value
   */
  Chain.prototype.done = function () {
    return this.value;
  };

  /**
   * Close the chain. Returns the final value.
   * Does the same as method done()
   * @returns {*} value
   */
  Chain.prototype.valueOf = function () {
    return this.value;
  };

  /**
   * Get a string representation of the value in the chain
   * @returns {string}
   */
  Chain.prototype.toString = function () {
    return format(this.value);
  };

  /**
   * Create a proxy method for the chain
   * @param {string} name
   * @param {Function} fn      The function to be proxied
   *                           If fn is no function, it is silently ignored.
   * @private
   */
  function createProxy(name, fn) {
    if (typeof fn === 'function') {
      Chain.prototype[name] = chainify(fn);
    }
  }

  /**
   * Create a proxy method for the chain
   * @param {string} name
   * @param {function} resolver   The function resolving with the
   *                              function to be proxied
   * @private
   */
  function createLazyProxy(name, resolver) {
    lazy(Chain.prototype, name, function outerResolver() {
      var fn = resolver();
      if (typeof fn === 'function') {
        return chainify(fn);
      }

      return undefined; // if not a function, ignore
    });
  }

  /**
   * Make a function chainable
   * @param {function} fn
   * @return {Function} chain function
   * @private
   */
  function chainify (fn) {
    return function () {
      var args = [this.value];  // `this` will be the context of a Chain instance
      for (var i = 0; i &lt; arguments.length; i++) {
        args[i + 1] = arguments[i];
      }

      return new Chain(fn.apply(fn, args));
    }
  }

  /**
   * Create a proxy for a single method, or an object with multiple methods.
   * Example usage:
   *
   *   Chain.createProxy('add', function add (x, y) {...});
   *   Chain.createProxy({
   *     add:      function add (x, y) {...},
   *     subtract: function subtract (x, y) {...}
   *   }
   *
   * @param {string | Object} arg0   A name (string), or an object with
   *                                 functions
   * @param {*} [arg1]               A function, when arg0 is a name
   */
  Chain.createProxy = function (arg0, arg1) {
    if (typeof arg0 === 'string') {
      // createProxy(name, value)
      createProxy(arg0, arg1);
    }
    else {
      // createProxy(values)
      for (var prop in arg0) {
        if (arg0.hasOwnProperty(prop)) {
          createProxy(prop, arg0[prop]);
        }
      }
    }
  };

  // create proxy for everything that is in math.js
  Chain.createProxy(math);

  // register on the import event, automatically add a proxy for every imported function.
  math.on('import', function (name, resolver, path) {
    if (path === undefined) {
      // an imported function (not a data type or something special) ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.Complex" id="apidoc.module.mathjs.Complex">module mathjs.Complex</a></h1>




    <h2>
        <a href="#apidoc.element.mathjs.Complex.factory" id="apidoc.element.mathjs.Complex.factory">
        function <span class="apidocSignatureSpan">mathjs.Complex.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed, math)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed, math) {

<span class="apidocCodeCommentSpan">  /**
   * Attach type information
   */
</span>  Complex.prototype.type = 'Complex';
  Complex.prototype.isComplex = true;


  /**
   * Get a JSON representation of the complex number
   * @returns {Object} Returns a JSON object structured as:
   *                   `{"mathjs": "Complex", "re": 2, "im": 3}`
   */
  Complex.prototype.toJSON = function () {
    return {
      mathjs: 'Complex',
      re: this.re,
      im: this.im
    };
  };

  /*
   * Return the value of the complex number in polar notation
   * The angle phi will be set in the interval of [-pi, pi].
   * @return {{r: number, phi: number}} Returns and object with properties r and phi.
   */
  Complex.prototype.toPolar = function () {
    return {
      r: this.abs(),
      phi: this.arg()
    };
  };

  /**
   * Get a string representation of the complex number,
   * with optional formatting options.
   * @param {Object | number | Function} [options]  Formatting options. See
   *                                                lib/utils/number:format for a
   *                                                description of the available
   *                                                options.
   * @return {string} str
   */
  Complex.prototype.format = function (options) {
    var str = '';
    var im = this.im;
    var re = this.re;
    var strRe = format(this.re, options);
    var strIm = format(this.im, options);

    // round either re or im when smaller than the configured precision
    var precision = isNumber(options) ? options : options ? options.precision : null;
    if (precision !== null) {
      var epsilon = Math.pow(10, -precision);
      if (Math.abs(re / im) &lt; epsilon) {
        re = 0;
      }
      if (Math.abs(im / re) &lt; epsilon) {
        im = 0;
      }
    }

    if (im == 0) {
      // real value
      str = strRe;
    } else if (re == 0) {
      // purely complex value
      if (im == 1) {
        str = 'i';
      } else if (im == -1) {
        str = '-i';
      } else {
        str = strIm + 'i';
      }
    } else {
      // complex value
      if (im &gt; 0) {
        if (im == 1) {
          str = strRe + ' + i';
        } else {
          str = strRe + ' + ' + strIm + 'i';
        }
      } else {
        if (im == -1) {
          str = strRe + ' - i';
        } else {
          str = strRe + ' - ' + strIm.substring(1) + 'i';
        }
      }
    }
    return str;
  };

  /**
   * Create a complex number from polar coordinates
   *
   * Usage:
   *
   *     Complex.fromPolar(r: number, phi: number) : Complex
   *     Complex.fromPolar({r: number, phi: number}) : Complex
   *
   * @param {*} args...
   * @return {Complex}
   */
  Complex.fromPolar = function (args) {
    switch (arguments.length) {
      case 1:
        var arg = arguments[0];
        if (typeof arg === 'object') {
          return Complex(arg);
        }
        throw new TypeError('Input has to be an object with r and phi keys.');

      case 2:
        var r = arguments[0],
            phi = arguments[1];
        if (isNumber(r)) {
          if (phi &amp;&amp; phi.isUnit &amp;&amp; phi.hasBase('ANGLE')) {
            // convert unit to a number in radians
            phi = phi.toNumber('rad');
          }

          if (isNumber(phi)) {
            return new Complex({r: r, phi: phi});
          }

          throw new TypeError('Phi is not a number nor an angle unit.');
        } else {
          throw new TypeError('Radius r is not a number.');
        }

      default:
        throw new SyntaxError('Wrong number of arguments in function fromPolar');
    }
  };


  Complex.prototype.valueOf = Complex.prototype.toString;

  /**
   * Create a Complex number from a JSON object
   * @param {Object} json  A JSON Object structured as
   *                       {"mathjs": "Complex", "re": 2, "im": 3}
   *                       All properties are optional, default values
   *                       for `re` and `im` are 0.
   * @return {Complex} Returns a new Complex number
   */
  Complex.fromJSON = function (json) {
    return new C ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.ConditionalNode" id="apidoc.module.mathjs.ConditionalNode">module mathjs.ConditionalNode</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.ConditionalNode.factory" id="apidoc.element.mathjs.ConditionalNode.factory">
        function <span class="apidocSignatureSpan">mathjs.ConditionalNode.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var Node = load(require('./Node'));

<span class="apidocCodeCommentSpan">  /**
   * A lazy evaluating conditional operator: 'condition ? trueExpr : falseExpr'
   *
   * @param {Node} condition   Condition, must result in a boolean
   * @param {Node} trueExpr    Expression evaluated when condition is true
   * @param {Node} falseExpr   Expression evaluated when condition is true
   *
   * @constructor ConditionalNode
   * @extends {Node}
   */
</span>  function ConditionalNode(condition, trueExpr, falseExpr) {
    if (!(this instanceof ConditionalNode)) {
      throw new SyntaxError('Constructor must be called with the new operator');
    }
    if (!(condition &amp;&amp; condition.isNode)) throw new TypeError('Parameter condition must be a Node');
    if (!(trueExpr &amp;&amp; trueExpr.isNode))  throw new TypeError('Parameter trueExpr must be a Node');
    if (!(falseExpr &amp;&amp; falseExpr.isNode)) throw new TypeError('Parameter falseExpr must be a Node');

    this.condition = condition;
    this.trueExpr = trueExpr;
    this.falseExpr = falseExpr;
  }

  ConditionalNode.prototype = new Node();

  ConditionalNode.prototype.type = 'ConditionalNode';

  ConditionalNode.prototype.isConditionalNode = true;

  /**
   * Compile the node to javascript code
   * @param {Object} defs     Object which can be used to define functions
   *                          or constants globally available for the compiled
   *                          expression
   * @param {Object} args     Object with local function arguments, the key is
   *                          the name of the argument, and the value is `true`.
   *                          The object may not be mutated, but must be
   *                          extended instead.
   * @return {string} js
   * @private
   */
  ConditionalNode.prototype._compile = function (defs, args) {
    /**
     * Test whether a condition is met
     * @param {*} condition
     * @returns {boolean} true if condition is true or non-zero, else false
     */
    defs.testCondition = function (condition) {
      if (typeof condition === 'number'
          || typeof condition === 'boolean'
          || typeof condition === 'string') {
        return condition ? true : false;
      }

      if (condition) {
        if (condition.isBigNumber === true) {
          return condition.isZero() ? false : true;
        }

        if (condition.isComplex === true) {
          return (condition.re || condition.im) ? true : false;
        }

        if (condition.isUnit === true) {
          return condition.value ? true : false;
        }
      }

      if (condition === null || condition === undefined) {
        return false;
      }

      throw new TypeError('Unsupported type of condition "' + defs.math['typeof'](condition) + '"');
    };

    return (
      'testCondition(' + this.condition._compile(defs, args) + ') ? ' +
      '( ' + this.trueExpr._compile(defs, args) + ') : ' +
      '( ' + this.falseExpr._compile(defs, args) + ')'
    );
  };

  /**
   * Execute a callback for each of the child nodes of this node
   * @param {function(child: Node, path: string, parent: Node)} callback
   */
  ConditionalNode.prototype.forEach = function (callback) {
    callback(this.condition, 'condition', this);
    callback(this.trueExpr, 'trueExpr', this);
    callback(this.falseExpr, 'falseExpr', this);
  };

  /**
   * Create a new ConditionalNode having it's childs be the results of calling
   * the provided callback function for each of the childs of the original node.
   * @param {function(child: Node, path: string, parent: Node): Node} callback
   * @returns {ConditionalNode} Returns a transformed copy of the node
   */
  ConditionalNode.prototype.map = function (callback) {
    return new ConditionalNode(
        this._ifNode(callback(this.condition, 'condition', this)),
        this._ifNode(callback(this.trueExpr, 'trueExpr', this)),
        this._ifNode(callback(this.falseExpr, 'falseExpr', this))
    );
  };

  /**
   * Create a clone of this node, a shallow copy
   * @return {ConditionalNode}
   */
  ConditionalNode.prototyp ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.ConstantNode" id="apidoc.module.mathjs.ConstantNode">module mathjs.ConstantNode</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.ConstantNode.factory" id="apidoc.element.mathjs.ConstantNode.factory">
        function <span class="apidocSignatureSpan">mathjs.ConstantNode.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var Node = load(require('./Node'));

<span class="apidocCodeCommentSpan">  /**
   * A ConstantNode holds a constant value like a number or string. A ConstantNode
   * stores a stringified version of the value and uses this to compile to
   * JavaScript.
   *
   * In case of a stringified number as input, this may be compiled to a BigNumber
   * when the math instance is configured for BigNumbers.
   *
   * Usage:
   *
   *     // stringified values with type
   *     new ConstantNode('2.3', 'number');
   *     new ConstantNode('true', 'boolean');
   *     new ConstantNode('hello', 'string');
   *
   *     // non-stringified values, type will be automatically detected
   *     new ConstantNode(2.3);
   *     new ConstantNode('hello');
   *
   * @param {string | number | boolean | null | undefined} value
   *                            When valueType is provided, value must contain
   *                            an uninterpreted string representing the value.
   *                            When valueType is undefined, value can be a
   *                            number, string, boolean, null, or undefined, and
   *                            the type will be determined automatically.
   * @param {string} [valueType]  The type of value. Choose from 'number', 'string',
   *                              'boolean', 'undefined', 'null'
   * @constructor ConstantNode
   * @extends {Node}
   */
</span>  function ConstantNode(value, valueType) {
    if (!(this instanceof ConstantNode)) {
      throw new SyntaxError('Constructor must be called with the new operator');
    }

    if (valueType) {
      if (typeof valueType !== 'string') {
        throw new TypeError('String expected for parameter "valueType"');
      }
      if (typeof value !== 'string') {
        throw new TypeError('String expected for parameter "value"');
      }

      this.value = value;
      this.valueType = valueType;
    }
    else {
      // stringify the value and determine the type
      this.value = value + '';
      this.valueType = getType(value);
    }

    if (!SUPPORTED_TYPES[this.valueType]) {
      throw new TypeError('Unsupported type of value "' + this.valueType + '"');
    }
  }

  var SUPPORTED_TYPES = {
    'number': true,
    'string': true,
    'boolean': true,
    'undefined': true,
    'null': true
  };

  ConstantNode.prototype = new Node();

  ConstantNode.prototype.type = 'ConstantNode';

  ConstantNode.prototype.isConstantNode = true;

  /**
   * Compile the node to javascript code
   * @param {Object} defs     Object which can be used to define functions
   *                          or constants globally available for the compiled
   *                          expression
   * @param {Object} args     Object with local function arguments, the key is
   *                          the name of the argument, and the value is `true`.
   *                          The object may not be mutated, but must be
   *                          extended instead.
   * @return {string} js
   * @private
   */
  ConstantNode.prototype._compile = function (defs, args) {
    switch (this.valueType) {
      case 'number':
        // TODO: replace this with using config.number
        var numConfig = defs.math.config().number;
        if (numConfig === 'BigNumber') {
          return 'math.bignumber("' + this.value + '")';
        }
        else if (numConfig === 'Fraction') {
          return 'math.fraction("' + this.value + '")';
        }
        else {
          // remove leading zeros like '003.2' which are not allowed by JavaScript
          return this.value.replace(/^(0*)[0-9]/, function (match, zeros) {
            return match.substring(zeros.length);
          });
        }

      case 'string':
        return '"' + this.value + '"';

      case 'boolean':
        return this.value;

      case 'undefined':
        return this.value;

      case 'null':
        return this.value;

      default:
        // TODO: move this error to the constructor?
        throw new TypeError('Unsupported type of constant "' + this.valueType + '"'); ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.DenseMatrix" id="apidoc.module.mathjs.DenseMatrix">module mathjs.DenseMatrix</a></h1>




    <h2>
        <a href="#apidoc.element.mathjs.DenseMatrix.factory" id="apidoc.element.mathjs.DenseMatrix.factory">
        function <span class="apidocSignatureSpan">mathjs.DenseMatrix.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var Matrix = load(require('./Matrix')); // force loading Matrix (do not use via type.Matrix)

<span class="apidocCodeCommentSpan">  /**
   * Dense Matrix implementation. A regular, dense matrix, supporting multi-dimensional matrices. This is the default matrix type
.
   * @class DenseMatrix
   */
</span>  function DenseMatrix(data, datatype) {
    if (!(this instanceof DenseMatrix))
      throw new SyntaxError('Constructor must be called with the new operator');
    if (datatype &amp;&amp; !isString(datatype))
      throw new Error('Invalid datatype: ' + datatype);

    if (data &amp;&amp; data.isMatrix === true) {
      // check data is a DenseMatrix
      if (data.type === 'DenseMatrix') {
        // clone data &amp; size
        this._data = object.clone(data._data);
        this._size = object.clone(data._size);
        this._datatype = datatype || data._datatype;
      }
      else {
        // build data from existing matrix
        this._data = data.toArray();
        this._size = data.size();
        this._datatype = datatype || data._datatype;
      }
    }
    else if (data &amp;&amp; isArray(data.data) &amp;&amp; isArray(data.size)) {
      // initialize fields from JSON representation
      this._data = data.data;
      this._size = data.size;
      this._datatype = datatype || data.datatype;
    }
    else if (isArray(data)) {
      // replace nested Matrices with Arrays
      this._data = preprocess(data);
      // get the dimensions of the array
      this._size = array.size(this._data);
      // verify the dimensions of the array, TODO: compute size while processing array
      array.validate(this._data, this._size);
      // data type unknown
      this._datatype = datatype;
    }
    else if (data) {
      // unsupported type
      throw new TypeError('Unsupported type of data (' + util.types.type(data) + ')');
    }
    else {
      // nothing provided
      this._data = [];
      this._size = [0];
      this._datatype = datatype;
    }
  }

  DenseMatrix.prototype = new Matrix();

  /**
   * Attach type information
   */
  DenseMatrix.prototype.type = 'DenseMatrix';
  DenseMatrix.prototype.isDenseMatrix = true;

  /**
   * Get the storage format used by the matrix.
   *
   * Usage:
   *     var format = matrix.storage()                   // retrieve storage format
   *
   * @memberof DenseMatrix
   * @return {string}           The storage format.
   */
  DenseMatrix.prototype.storage = function () {
    return 'dense';
  };

  /**
   * Get the datatype of the data stored in the matrix.
   *
   * Usage:
   *     var format = matrix.datatype()                   // retrieve matrix datatype
   *
   * @memberof DenseMatrix
   * @return {string}           The datatype.
   */
  DenseMatrix.prototype.datatype = function () {
    return this._datatype;
  };

  /**
   * Create a new DenseMatrix
   * @memberof DenseMatrix
   * @param {Array} data
   * @param {string} [datatype]
   */
  DenseMatrix.prototype.create = function (data, datatype) {
    return new DenseMatrix(data, datatype);
  };

  /**
   * Get a subset of the matrix, or replace a subset of the matrix.
   *
   * Usage:
   *     var subset = matrix.subset(index)               // retrieve subset
   *     var value = matrix.subset(index, replacement)   // replace subset
   *
   * @memberof DenseMatrix
   * @param {Index} index
   * @param {Array | DenseMatrix | *} [replacement]
   * @param {*} [defaultValue=0]      Default value, filled in on new entries when
   *                                  the matrix is resized. If not provided,
   *                                  new matrix elements will be filled with zeros.
   */
  DenseMatrix.prototype.subset = function (index, replacement, defaultValue) {
    switch (arguments.length) {
      case 1:
        return _get(this, index);

        // intentional fall through
      case 2:
      case 3:
        return _set(this, index, replacement, defaultValue);

      default:
        throw new SyntaxError('Wrong number of arguments');
    }
  };

  /**
   * Get a single element from the matrix.
   * @memberof DenseMatrix
   * @param { ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.FibonacciHeap" id="apidoc.module.mathjs.FibonacciHeap">module mathjs.FibonacciHeap</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.FibonacciHeap.factory" id="apidoc.element.mathjs.FibonacciHeap.factory">
        function <span class="apidocSignatureSpan">mathjs.FibonacciHeap.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {

  var smaller = load(require('../../function/relational/smaller'));
  var larger = load(require('../../function/relational/larger'));

  var oneOverLogPhi = 1.0 / Math.log((1.0 + Math.sqrt(5.0)) / 2.0);

<span class="apidocCodeCommentSpan">  /**
   * Fibonacci Heap implementation, used interally for Matrix math.
   * @class FibonacciHeap
   * @constructor FibonacciHeap
   */
</span>  function FibonacciHeap() {
    if (!(this instanceof FibonacciHeap))
      throw new SyntaxError('Constructor must be called with the new operator');

    // initialize fields
    this._minimum = null;
    this._size = 0;
  }

  /**
   * Attach type information
   */
  FibonacciHeap.prototype.type = 'FibonacciHeap';
  FibonacciHeap.prototype.isFibonacciHeap = true;

  /**
   * Inserts a new data element into the heap. No heap consolidation is
   * performed at this time, the new node is simply inserted into the root
   * list of this heap. Running time: O(1) actual.
   * @memberof FibonacciHeap
   */
  FibonacciHeap.prototype.insert = function (key, value) {
    // create node
    var node = {
      key: key,
      value: value,
      degree: 0
    };
    // check we have a node in the minimum
    if (this._minimum) {
      // minimum node
      var minimum = this._minimum;
      // update left &amp; right of node
      node.left = minimum;
      node.right = minimum.right;
      minimum.right = node;
      node.right.left = node;
      // update minimum node in heap if needed
      if (smaller(key, minimum.key)) {
        // node has a smaller key, use it as minimum
        this._minimum = node;
      }
    }
    else {
      // set left &amp; right
      node.left = node;
      node.right = node;
      // this is the first node
      this._minimum = node;
    }
    // increment number of nodes in heap
    this._size++;
    // return node
    return node;
  };

  /**
   * Returns the number of nodes in heap. Running time: O(1) actual.
   * @memberof FibonacciHeap
   */
  FibonacciHeap.prototype.size = function () {
    return this._size;
  };

  /**
   * Removes all elements from this heap.
   * @memberof FibonacciHeap
   */
  FibonacciHeap.prototype.clear = function () {
    this._minimum = null;
    this._size = 0;
  };

  /**
   * Returns true if the heap is empty, otherwise false.
   * @memberof FibonacciHeap
   */
  FibonacciHeap.prototype.isEmpty = function () {
    return !!this._minimum;
  };

  /**
   * Extracts the node with minimum key from heap. Amortized running
   * time: O(log n).
   * @memberof FibonacciHeap
   */
  FibonacciHeap.prototype.extractMinimum = function () {
    // node to remove
    var node = this._minimum;
    // check we have a minimum
    if (node === null)
      return node;
    // current minimum
    var minimum = this._minimum;
    // get number of children
    var numberOfChildren = node.degree;
    // pointer to the first child
    var x = node.child;
    // for each child of node do...
    while (numberOfChildren &gt; 0) {
      // store node in right side
      var tempRight = x.right;
      // remove x from child list
      x.left.right = x.right;
      x.right.left = x.left;
      // add x to root list of heap
      x.left = minimum;
      x.right = minimum.right;
      minimum.right = x;
      x.right.left = x;
      // set Parent[x] to null
      x.parent = null;
      x = tempRight;
      numberOfChildren--;
    }
    // remove node from root list of heap
    node.left.right = node.right;
    node.right.left = node.left;
    // update minimum
    if (node == node.right) {
      // empty
      minimum = null;
    }
    else {
      // update minimum
      minimum = node.right;
      // we need to update the pointer to the root with minimum key
      minimum = _findMinimumNode(minimum, this._size);
    }
    // decrement size of heap
    this._size--;
    // update minimum
    this._minimum = minimum;
    // return node
    return node;
  };

  /**
   * Removes a node from the heap given the reference to the node. The trees
   * in the heap will be consolidated, if necessary. This operation may ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.Fraction" id="apidoc.module.mathjs.Fraction">module mathjs.Fraction</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.Fraction.factory" id="apidoc.element.mathjs.Fraction.factory">
        function <span class="apidocSignatureSpan">mathjs.Fraction.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  return Fraction;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.FunctionAssignmentNode" id="apidoc.module.mathjs.FunctionAssignmentNode">module mathjs.FunctionAssignmentNode</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.FunctionAssignmentNode.factory" id="apidoc.element.mathjs.FunctionAssignmentNode.factory">
        function <span class="apidocSignatureSpan">mathjs.FunctionAssignmentNode.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var Node = load(require('./Node'));
  var setSafeProperty = load(require('./utils/customs')).setSafeProperty;

<span class="apidocCodeCommentSpan">  /**
   * @constructor FunctionAssignmentNode
   * @extends {Node}
   * Function assignment
   *
   * @param {string} name           Function name
   * @param {string[] | Array.&lt;{name: string, type: string}&gt;} params
   *                                Array with function parameter names, or an
   *                                array with objects containing the name
   *                                and type of the parameter
   * @param {Node} expr             The function expression
   */
</span>  function FunctionAssignmentNode(name, params, expr) {
    if (!(this instanceof FunctionAssignmentNode)) {
      throw new SyntaxError('Constructor must be called with the new operator');
    }

    // validate input
    if (typeof name !== 'string') throw new TypeError('String expected for parameter "name"');
    if (!Array.isArray(params))  throw new TypeError('Array containing strings or objects expected for parameter "params"');
    if (!(expr &amp;&amp; expr.isNode)) throw new TypeError('Node expected for parameter "expr"');
    if (name in keywords) throw new Error('Illegal function name, "' + name + '" is a reserved keyword');

    this.name = name;
    this.params = params.map(function (param) {
      return param &amp;&amp; param.name || param;
    });
    this.types = params.map(function (param) {
      return param &amp;&amp; param.type || 'any'
    });
    this.expr = expr;
  }

  FunctionAssignmentNode.prototype = new Node();

  FunctionAssignmentNode.prototype.type = 'FunctionAssignmentNode';

  FunctionAssignmentNode.prototype.isFunctionAssignmentNode = true;

  /**
   * Compile the node to javascript code
   * @param {Object} defs     Object which can be used to define functions
   *                          or constants globally available for the compiled
   *                          expression
   * @param {Object} args     Object with local function arguments, the key is
   *                          the name of the argument, and the value is `true`.
   *                          The object may not be mutated, but must be
   *                          extended instead.
   * @return {string} js
   * @private
   */
  FunctionAssignmentNode.prototype._compile = function (defs, args) {
    defs.typed = typed;
    defs.setSafeProperty = setSafeProperty;

    // we extend the original args and add the args to the child object
    var childArgs = Object.create(args);
    this.params.forEach(function (variable) {
      childArgs[variable] = true;
    });

    // compile the function expression with the child args
    var jsExpr = this.expr._compile(defs, childArgs);

    return 'setSafeProperty(scope, "' + this.name + '", ' +
        '  (function () {' +
        '    var fn = typed("' + this.name + '", {' +
        '      "' + this.types.join(',') + '": function (' + this.params.join(',') + ') {' +
        '        return ' + jsExpr + '' +
        '      }' +
        '    });' +
        '    fn.syntax = "' + this.name + '(' + this.params.join(', ') + ')";' +
        '    return fn;' +
        '  })())';
  };

  /**
   * Execute a callback for each of the child nodes of this node
   * @param {function(child: Node, path: string, parent: Node)} callback
   */
  FunctionAssignmentNode.prototype.forEach = function (callback) {
    callback(this.expr, 'expr', this);
  };

  /**
   * Create a new FunctionAssignmentNode having it's childs be the results of calling
   * the provided callback function for each of the childs of the original node.
   * @param {function(child: Node, path: string, parent: Node): Node} callback
   * @returns {FunctionAssignmentNode} Returns a transformed copy of the node
   */
  FunctionAssignmentNode.prototype.map = function (callback) {
    var expr = this._ifNode(callback(this.expr, 'expr', this));

    return new FunctionAssignmentNode(this.name, this.params.slice(0), expr);
  };

  /**
   * Create a clone of this node, a shallow copy
   * @return {FunctionAssignm ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.FunctionNode" id="apidoc.module.mathjs.FunctionNode">module mathjs.FunctionNode</a></h1>




    <h2>
        <a href="#apidoc.element.mathjs.FunctionNode.factory" id="apidoc.element.mathjs.FunctionNode.factory">
        function <span class="apidocSignatureSpan">mathjs.FunctionNode.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed, math)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed, math) {
  var Node = load(require('./Node'));
  var SymbolNode = load(require('./SymbolNode'));
  var validateSafeMethod = load(require('./utils/customs')).validateSafeMethod;

<span class="apidocCodeCommentSpan">  /**
   * @constructor FunctionNode
   * @extends {./Node}
   * invoke a list with arguments on a node
   * @param {./Node | string} fn Node resolving with a function on which to invoke
   *                             the arguments, typically a SymboNode or AccessorNode
   * @param {./Node[]} args
   */
</span>  function FunctionNode(fn, args) {
    if (!(this instanceof FunctionNode)) {
      throw new SyntaxError('Constructor must be called with the new operator');
    }

    if (typeof fn === 'string') {
      fn = new SymbolNode(fn);
    }

    // validate input
    if (!fn || !fn.isNode) throw new TypeError('Node expected as parameter "fn"');
    if (!Array.isArray(args)
        || !args.every(function (arg) {return arg &amp;&amp; arg.isNode;})) {
      throw new TypeError('Array containing Nodes expected for parameter "args"');
    }

    this.fn = fn;
    this.args = args || [];

    // readonly property name
    Object.defineProperty(this, 'name', {
      get: function () {
        return this.fn.name || '';
      }.bind(this),
      set: function () {
        throw new Error('Cannot assign a new name, name is read-only');
      }
    });

    // TODO: deprecated since v3, remove some day
    var deprecated = function () {
      throw new Error('Property `FunctionNode.object` is deprecated, use `FunctionNode.fn` instead');
    };
    Object.defineProperty(this, 'object', { get: deprecated, set: deprecated });
  }

  FunctionNode.prototype = new Node();

  FunctionNode.prototype.type = 'FunctionNode';

  FunctionNode.prototype.isFunctionNode = true;

  /**
   * Compile the node to javascript code
   * @param {Object} defs     Object which can be used to define functions
   *                          or constants globally available for the compiled
   *                          expression
   * @param {Object} args     Object with local function arguments, the key is
   *                          the name of the argument, and the value is `true`.
   *                          The object may not be mutated, but must be
   *                          extended instead.
   * @return {string} js
   * @private
   */
  FunctionNode.prototype._compile = function (defs, args) {
    // compile fn and arguments
    var jsFn = this.fn._compile(defs, args);
    var jsArgs = this.args.map(function (arg) {
      return arg._compile(defs, args);
    });
    var jsScope = this._compileScope(defs, args);
    var argsName;

    if (this.fn.isSymbolNode) {
      // we can statically determine whether the function has an rawArgs property
      var name = this.fn.name;
      var fn = defs.math[name];
      var isRaw = (typeof fn === 'function') &amp;&amp; (fn.rawArgs == true);

      if (isRaw) {
        // pass unevaluated parameters (nodes) to the function
        argsName = this._getUniqueArgumentsName(defs);
        defs[argsName] = this.args;

        return jsFn + '(' + argsName + ', math, ' + jsScope + ')';
      }
      else {
        // "regular" evaluation
        return jsFn + '(' + jsArgs.join(', ') + ')';
      }
    }
    else if (this.fn.isAccessorNode &amp;&amp; this.fn.index.isObjectProperty()) {
      // execute the function with the right context: the object of the AccessorNode
      argsName = this._getUniqueArgumentsName(defs);
      defs[argsName] = this.args;
      defs.validateSafeMethod = validateSafeMethod

      var jsObject = this.fn.object._compile(defs, args);
      var prop = this.fn.index.getObjectProperty();

      return '(function () {' +
          'var object = ' + jsObject + ';' +
          'validateSafeMethod(object, "' + prop + '");' +
          'return (object["' + prop + '"] &amp;&amp; object["' + prop + '"].rawArgs) ' +
          ' ? object["' + prop + '"](' + argsName + ', math, ' + jsScope + ')' +
          ' : object["' + prop + '"](' + jsArgs.join(', ') + ')' +
          '})()';
    }
    else { // this.fn.isAcce ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.Help" id="apidoc.module.mathjs.Help">module mathjs.Help</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.Help.factory" id="apidoc.element.mathjs.Help.factory">
        function <span class="apidocSignatureSpan">mathjs.Help.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var parser = load(require('./function/parser'))();

<span class="apidocCodeCommentSpan">  /**
   * Documentation object
   * @param {Object} doc  Object containing properties:
   *                      {string} name
   *                      {string} category
   *                      {string} description
   *                      {string[]} syntax
   *                      {string[]} examples
   *                      {string[]} seealso
   * @constructor
   */
</span>  function Help(doc) {
    if (!(this instanceof Help)) {
      throw new SyntaxError('Constructor must be called with the new operator');
    }

    if (!doc)  throw new Error('Argument "doc" missing');

    this.doc = doc;
  }

  /**
   * Attach type information
   */
  Help.prototype.type = 'Help';
  Help.prototype.isHelp = true;

  /**
   * Generate a string representation of the Help object
   * @return {string} Returns a string
   * @private
   */
  Help.prototype.toString = function () {
    var doc = this.doc || {};
    var desc = '\n';

    if (doc.name) {
      desc += 'Name: ' + doc.name + '\n\n';
    }
    if (doc.category) {
      desc += 'Category: ' + doc.category + '\n\n';
    }
    if (doc.description) {
      desc += 'Description:\n    ' + doc.description + '\n\n';
    }
    if (doc.syntax) {
      desc += 'Syntax:\n    ' + doc.syntax.join('\n    ') + '\n\n';
    }
    if (doc.examples) {
      desc += 'Examples:\n';
      for (var i = 0; i &lt; doc.examples.length; i++) {
        var expr = doc.examples[i];
        desc += '    ' + expr + '\n';

        var res;
        try {
          res = parser.eval(expr);
        }
        catch (e) {
          res = e;
        }
        if (res &amp;&amp; !res.isHelp) {
          desc += '        ' + string.format(res, {precision: 14}) + '\n';
        }
      }
      desc += '\n';
    }
    if (doc.seealso) {
      desc += 'See also: ' + doc.seealso.join(', ') + '\n';
    }

    return desc;
  };

  /**
   * Export the help object to JSON
   */
  Help.prototype.toJSON = function () {
    var obj = object.clone(this.doc);
    obj.mathjs = 'Help';
    return obj;
  };

  /**
   * Instantiate a Help object from a JSON object
   * @param {Object} json
   * @returns {Help} Returns a new Help object
   */
  Help.fromJSON = function (json) {
    var doc = {};
    for (var prop in json) {
      if (prop !== 'mathjs') { // ignore mathjs field
        doc[prop] = json[prop];
      }
    }
    return new Help(doc);
  };

  /**
   * Returns a string representation of the Help object
   */
  Help.prototype.valueOf = Help.prototype.toString;

  return Help;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.ImmutableDenseMatrix" id="apidoc.module.mathjs.ImmutableDenseMatrix">module mathjs.ImmutableDenseMatrix</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.ImmutableDenseMatrix.factory" id="apidoc.element.mathjs.ImmutableDenseMatrix.factory">
        function <span class="apidocSignatureSpan">mathjs.ImmutableDenseMatrix.</span>factory
        <span class="apidocSignatureSpan">(type, config, load)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load) {

  var DenseMatrix = load(require('./DenseMatrix'));

  var smaller = load(require('../../function/relational/smaller'));

  function ImmutableDenseMatrix(data, datatype) {
    if (!(this instanceof ImmutableDenseMatrix))
      throw new SyntaxError('Constructor must be called with the new operator');
    if (datatype &amp;&amp; !isString(datatype))
      throw new Error('Invalid datatype: ' + datatype);

    if ((data &amp;&amp; data.isMatrix === true) || isArray(data)) {
      // use DenseMatrix implementation
      var matrix = new DenseMatrix(data, datatype);
      // internal structures
      this._data = matrix._data;
      this._size = matrix._size;
      this._datatype = matrix._datatype;
      this._min = null;
      this._max = null;
    }
    else if (data &amp;&amp; isArray(data.data) &amp;&amp; isArray(data.size)) {
      // initialize fields from JSON representation
      this._data = data.data;
      this._size = data.size;
      this._datatype = data.datatype;
      this._min = typeof data.min !== 'undefined' ? data.min : null;
      this._max = typeof data.max !== 'undefined' ? data.max : null;
    }
    else if (data) {
      // unsupported type
      throw new TypeError('Unsupported type of data (' + util.types.type(data) + ')');
    }
    else {
      // nothing provided
      this._data = [];
      this._size = [0];
      this._datatype = datatype;
      this._min = null;
      this._max = null;
    }
  }

  ImmutableDenseMatrix.prototype = new DenseMatrix();

<span class="apidocCodeCommentSpan">  /**
   * Attach type information
   */
</span>  ImmutableDenseMatrix.prototype.type = 'ImmutableDenseMatrix';
  ImmutableDenseMatrix.prototype.isImmutableDenseMatrix = true;

  /**
   * Get a subset of the matrix, or replace a subset of the matrix.
   *
   * Usage:
   *     var subset = matrix.subset(index)               // retrieve subset
   *     var value = matrix.subset(index, replacement)   // replace subset
   *
   * @param {Index} index
   * @param {Array | ImmutableDenseMatrix | *} [replacement]
   * @param {*} [defaultValue=0]      Default value, filled in on new entries when
   *                                  the matrix is resized. If not provided,
   *                                  new matrix elements will be filled with zeros.
   */
  ImmutableDenseMatrix.prototype.subset = function (index) {
    switch (arguments.length) {
      case 1:
        // use base implementation
        var m = DenseMatrix.prototype.subset.call(this, index);
        // check result is a matrix
        if (m.isMatrix) {
          // return immutable matrix
          return new ImmutableDenseMatrix({
            data: m._data,
            size: m._size,
            datatype: m._datatype
          });
        }
        return m;

        // intentional fall through
      case 2:
      case 3:
        throw new Error('Cannot invoke set subset on an Immutable Matrix instance');

      default:
        throw new SyntaxError('Wrong number of arguments');
    }
  };

  /**
   * Replace a single element in the matrix.
   * @param {Number[]} index   Zero-based index
   * @param {*} value
   * @param {*} [defaultValue]        Default value, filled in on new entries when
   *                                  the matrix is resized. If not provided,
   *                                  new matrix elements will be left undefined.
   * @return {ImmutableDenseMatrix} self
   */
  ImmutableDenseMatrix.prototype.set = function () {
    throw new Error('Cannot invoke set on an Immutable Matrix instance');
  };

  /**
   * Resize the matrix to the given size. Returns a copy of the matrix when
   * `copy=true`, otherwise return the matrix itself (resize in place).
   *
   * @param {Number[]} size           The new size the matrix should have.
   * @param {*} [defaultValue=0]      Default value, filled in on new entries.
   *                                  If not provided, the matrix elements will
   *                                  be filled with zeros.
   * @param {boolean} [copy]          Return a resized copy of the matrix
   *
   * @return {Matrix} ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.IndexNode" id="apidoc.module.mathjs.IndexNode">module mathjs.IndexNode</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.IndexNode.factory" id="apidoc.element.mathjs.IndexNode.factory">
        function <span class="apidocSignatureSpan">mathjs.IndexNode.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var Node = load(require('./Node'));
  var RangeNode = load(require('./RangeNode'));
  var SymbolNode = load(require('./SymbolNode'));

  var Range = load(require('../../type/matrix/Range'));

  var isArray = Array.isArray;

<span class="apidocCodeCommentSpan">  /**
   * @constructor IndexNode
   * @extends Node
   *
   * Describes a subset of a matrix or an object property.
   * Cannot be used on its own, needs to be used within an AccessorNode or
   * AssignmentNode.
   *
   * @param {Node[]} dimensions
   * @param {boolean} [dotNotation=false]  Optional property describing whether
   *                                       this index was written using dot
   *                                       notation like `a.b`, or using bracket
   *                                       notation like `a["b"]` (default).
   *                                       Used to stringify an IndexNode.
   */
</span>  function IndexNode(dimensions, dotNotation) {
    if (!(this instanceof IndexNode)) {
      throw new SyntaxError('Constructor must be called with the new operator');
    }

    this.dimensions = dimensions;
    this.dotNotation = dotNotation || false;

    // validate input
    if (!isArray(dimensions)
        || !dimensions.every(function (range) {return range &amp;&amp; range.isNode;})) {
      throw new TypeError('Array containing Nodes expected for parameter "dimensions"');
    }
    if (this.dotNotation &amp;&amp; !this.isObjectProperty()) {
      throw new Error('dotNotation only applicable for object properties');
    }

    // TODO: deprecated since v3, remove some day
    var deprecated = function () {
      throw new Error('Property `IndexNode.object` is deprecated, use `IndexNode.fn` instead');
    };
    Object.defineProperty(this, 'object', { get: deprecated, set: deprecated });
  }

  IndexNode.prototype = new Node();

  IndexNode.prototype.type = 'IndexNode';

  IndexNode.prototype.isIndexNode = true;

  /**
   * Compile all range nodes
   *
   * When some of the dimensions has `end` defined, the IndexNode requires
   * a variable `size` to be defined in the current closure, and must contain
   * the size of the matrix that's being handled. To check whether the `size`
   * variable is needed, call IndexNode.needsSize().
   *
   * @param {Object} defs           Object which can be used to define functions
   *                                or constants globally available for the
   *                                compiled expression
   * @param {Object} args           Object with local function arguments, the key is
   *                                the name of the argument, and the value is `true`.
   *                                The object may not be mutated, but must be
   *                                extended instead.
   * @return {string} code
   */
  IndexNode.prototype._compile = function (defs, args) {
    // args can be mutated by IndexNode, when dimensions use `end`
    var childArgs = Object.create(args);

    // helper function to create a Range from start, step and end
    defs.range = function (start, end, step) {
      return new Range(
          (start &amp;&amp; start.isBigNumber === true) ? start.toNumber() : start,
          (end   &amp;&amp; end.isBigNumber === true)   ? end.toNumber()   : end,
          (step  &amp;&amp; step.isBigNumber === true)  ? step.toNumber()  : step
      );
    };

    // TODO: implement support for bignumber (currently bignumbers are silently
    //       reduced to numbers when changing the value to zero-based)

    // TODO: Optimization: when the range values are ConstantNodes,
    //       we can beforehand resolve the zero-based value

    // optimization for a simple object property
    var dimensions = this.dimensions.map(function (range, i) {
      if (range &amp;&amp; range.isRangeNode) {
        if (range.needsEnd()) {
          childArgs.end = true;

          // resolve end and create range
          return '(function () {' +
              'var end = size[' + i + ']; ' +
              'return range(' +
              range.start._compile(defs, childArgs) + ', ' +
              range. ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.Matrix" id="apidoc.module.mathjs.Matrix">module mathjs.Matrix</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.Matrix.factory" id="apidoc.element.mathjs.Matrix.factory">
        function <span class="apidocSignatureSpan">mathjs.Matrix.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
<span class="apidocCodeCommentSpan">  /**
   * @constructor Matrix
   *
   * A Matrix is a wrapper around an Array. A matrix can hold a multi dimensional
   * array. A matrix can be constructed as:
   *     var matrix = math.matrix(data)
   *
   * Matrix contains the functions to resize, get and set values, get the size,
   * clone the matrix and to convert the matrix to a vector, array, or scalar.
   * Furthermore, one can iterate over the matrix using map and forEach.
   * The internal Array of the Matrix can be accessed using the function valueOf.
   *
   * Example usage:
   *     var matrix = math.matrix([[1, 2], [3, 4]]);
   *     matix.size();              // [2, 2]
   *     matrix.resize([3, 2], 5);
   *     matrix.valueOf();          // [[1, 2], [3, 4], [5, 5]]
   *     matrix.subset([1,2])       // 3 (indexes are zero-based)
   *
   */
</span>  function Matrix() {
    if (!(this instanceof Matrix)) {
      throw new SyntaxError('Constructor must be called with the new operator');
    }
  }

  /**
   * Attach type information
   */
  Matrix.prototype.type = 'Matrix';
  Matrix.prototype.isMatrix = true;

  /**
   * Get the Matrix storage constructor for the given format.
   *
   * @param {string} format       The Matrix storage format.
   *
   * @return {Function}           The Matrix storage constructor.
   */
  Matrix.storage = function (format) {
    // check storage format is a string
    if (!isString(format)) {
      throw new TypeError('format must be a string value');
    }

    // get storage format constructor
    var constructor = Matrix._storage[format];
    if (!constructor) {
      throw new SyntaxError('Unsupported matrix storage format: ' + format);
    }

    // return storage constructor
    return constructor;
  };

  // a map with all constructors for all storage types
  Matrix._storage = {};

  /**
   * Get the storage format used by the matrix.
   *
   * Usage:
   *     var format = matrix.storage()                   // retrieve storage format
   *
   * @return {string}           The storage format.
   */
  Matrix.prototype.storage = function () {
    // must be implemented by each of the Matrix implementations
    throw new Error('Cannot invoke storage on a Matrix interface');
  };

  /**
   * Get the datatype of the data stored in the matrix.
   *
   * Usage:
   *     var format = matrix.datatype()                   // retrieve matrix datatype
   *
   * @return {string}           The datatype.
   */
  Matrix.prototype.datatype = function () {
    // must be implemented by each of the Matrix implementations
    throw new Error('Cannot invoke datatype on a Matrix interface');
  };

  /**
   * Create a new Matrix With the type of the current matrix instance
   * @param {Array | Object} data
   * @param {string} [datatype]
   */
  Matrix.prototype.create = function (data, datatype) {
    throw new Error('Cannot invoke create on a Matrix interface');
  };

  /**
   * Get a subset of the matrix, or replace a subset of the matrix.
   *
   * Usage:
   *     var subset = matrix.subset(index)               // retrieve subset
   *     var value = matrix.subset(index, replacement)   // replace subset
   *
   * @param {Index} index
   * @param {Array | Matrix | *} [replacement]
   * @param {*} [defaultValue=0]      Default value, filled in on new entries when
   *                                  the matrix is resized. If not provided,
   *                                  new matrix elements will be filled with zeros.
   */
  Matrix.prototype.subset = function (index, replacement, defaultValue) {
    // must be implemented by each of the Matrix implementations
    throw new Error('Cannot invoke subset on a Matrix interface');
  };

  /**
   * Get a single element from the matrix.
   * @param {number[]} index   Zero-based index
   * @return {*} value
   */
  Matrix.prototype.get = function (index) {
    // must be implemented by each of the Matrix implementations
    throw new Error('Cannot invoke get on a Matrix interface');
  };

  /**
   * Replace a single element in the matrix.
   * @param {num ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.MatrixIndex" id="apidoc.module.mathjs.MatrixIndex">module mathjs.MatrixIndex</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.MatrixIndex.factory" id="apidoc.element.mathjs.MatrixIndex.factory">
        function <span class="apidocSignatureSpan">mathjs.MatrixIndex.</span>factory
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type) {

<span class="apidocCodeCommentSpan">  /**
   * Create an index. An Index can store ranges and sets for multiple dimensions.
   * Matrix.get, Matrix.set, and math.subset accept an Index as input.
   *
   * Usage:
   *     var index = new Index(range1, range2, matrix1, array1, ...);
   *
   * Where each parameter can be any of:
   *     A number
   *     A string (containing a name of an object property)
   *     An instance of Range
   *     An Array with the Set values
   *     A Matrix with the Set values
   *
   * The parameters start, end, and step must be integer numbers.
   *
   * @class Index
   * @Constructor Index
   * @param {...*} ranges
   */
</span>  function Index(ranges) {
    if (!(this instanceof Index)) {
      throw new SyntaxError('Constructor must be called with the new operator');
    }

    this._dimensions = [];
    this._isScalar = true;

    for (var i = 0, ii = arguments.length; i &lt; ii; i++) {
      var arg = arguments[i];

      if (arg &amp;&amp; (arg.isRange === true)) {
        this._dimensions.push(arg);
        this._isScalar = false;
      }
      else if (arg &amp;&amp; (Array.isArray(arg) || arg.isMatrix === true)) {
        // create matrix
        var m = _createImmutableMatrix(arg.valueOf());
        this._dimensions.push(m);
        // size
        var size = m.size();
        // scalar
        if (size.length !== 1 || size[0] !== 1) {
          this._isScalar = false;
        }
      }
      else if (typeof arg === 'number') {
        this._dimensions.push(_createImmutableMatrix([arg]));
      }
      else if (typeof arg === 'string') {
        // object property (arguments.count should be 1)
        this._dimensions.push(arg);
      }
      // TODO: implement support for wildcard '*'
      else {
        throw new TypeError('Dimension must be an Array, Matrix, number, string, or Range');
      }
    }
  }

  /**
   * Attach type information
   */
  Index.prototype.type = 'Index';
  Index.prototype.isIndex = true;

  function _createImmutableMatrix(arg) {
    // loop array elements
    for (var i = 0, l = arg.length; i &lt; l; i++) {
      if (typeof arg[i] !== 'number' || !isInteger(arg[i])) {
        throw new TypeError('Index parameters must be positive integer numbers');
      }
    }
    // create matrix
    return new type.ImmutableDenseMatrix(arg);
  }

  /**
   * Create a clone of the index
   * @memberof Index
   * @return {Index} clone
   */
  Index.prototype.clone = function () {
    var index = new Index();
    index._dimensions = clone(this._dimensions);
    index._isScalar = this._isScalar;
    return index;
  };

  /**
   * Create an index from an array with ranges/numbers
   * @memberof Index
   * @param {Array.&lt;Array | number&gt;} ranges
   * @return {Index} index
   * @private
   */
  Index.create = function (ranges) {
    var index = new Index();
    Index.apply(index, ranges);
    return index;
  };

  /**
   * Retrieve the size of the index, the number of elements for each dimension.
   * @memberof Index
   * @returns {number[]} size
   */
  Index.prototype.size = function () {
    var size = [];

    for (var i = 0, ii = this._dimensions.length; i &lt; ii; i++) {
      var d = this._dimensions[i];
      size[i] = (typeof d === 'string') ? 1 : d.size()[0];
    }

    return size;
  };

  /**
   * Get the maximum value for each of the indexes ranges.
   * @memberof Index
   * @returns {number[]} max
   */
  Index.prototype.max = function () {
    var values = [];

    for (var i = 0, ii = this._dimensions.length; i &lt; ii; i++) {
      var range = this._dimensions[i];
      values[i] = (typeof range === 'string') ? range : range.max();
    }

    return values;
  };

  /**
   * Get the minimum value for each of the indexes ranges.
   * @memberof Index
   * @returns {number[]} min
   */
  Index.prototype.min = function () {
    var values = [];

    for (var i = 0, ii = this._dimensions.length; i &lt; ii; i++) {
      var range = this._dimensions[i];
      values[i] = (typeof range === 'string') ? range : range.min();
    }

    return values;
  };

  /**
   * Loop over each of the ranges of the index
   * ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.Node" id="apidoc.module.mathjs.Node">module mathjs.Node</a></h1>




    <h2>
        <a href="#apidoc.element.mathjs.Node.factory" id="apidoc.element.mathjs.Node.factory">
        function <span class="apidocSignatureSpan">mathjs.Node.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed, math)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed, math) {
<span class="apidocCodeCommentSpan">  /**
   * Node
   */
</span>  function Node() {
    if (!(this instanceof Node)) {
      throw new SyntaxError('Constructor must be called with the new operator');
    }
  }

  /**
   * Evaluate the node
   * @param {Object} [scope]  Scope to read/write variables
   * @return {*}              Returns the result
   */
  Node.prototype.eval = function(scope) {
    return this.compile().eval(scope);
  };

  Node.prototype.type = 'Node';

  Node.prototype.isNode = true;

  Node.prototype.comment = '';

  /**
   * Compile the node to javascript code
   * @return {{eval: function}} expr  Returns an object with a function 'eval',
   *                                  which can be invoked as expr.eval([scope]),
   *                                  where scope is an optional object with
   *                                  variables.
   */
  Node.prototype.compile = function () {
    // TODO: calling compile(math) is deprecated since version 2.0.0. Remove this warning some day
    if (arguments.length &gt; 0) {
      throw new Error('Calling compile(math) is deprecated. Call the function as compile() instead.');
    }

    // definitions globally available inside the closure of the compiled expressions
    var defs = {
      math: math.expression.mathWithTransform,
      args: {}, // can be filled with names of FunctionAssignment arguments
      _validateScope: _validateScope
    };

    // will be used to put local function arguments
    var args = {};

    var code = this._compile(defs, args);

    var defsCode = Object.keys(defs).map(function (name) {
      return '    var ' + name + ' = defs["' + name + '"];';
    });

    var factoryCode =
        defsCode.join(' ') +
        'return {' +
        '  "eval": function (scope) {' +
        '    if (scope) _validateScope(scope);' +
        '    scope = scope || {};' +
        '    return ' + code + ';' +
        '  }' +
        '};';

    var factory = new Function('defs', factoryCode);
    return factory(defs);
  };

  /**
   * Compile the node to javascript code
   * @param {Object} defs     Object which can be used to define functions
   *                          and constants globally available inside the closure
   *                          of the compiled expression
   * @param {Object} args     Object with local function arguments, the key is
   *                          the name of the argument, and the value is `true`.
   *                          The object may not be mutated, but must be
   *                          extended instead.
   * @return {string} js
   * @private
   */
  Node.prototype._compile = function (defs, args) {
    // must be implemented by each of the Node implementations
    throw new Error('Cannot compile a Node interface');
  };

  /**
   * Execute a callback for each of the child nodes of this node
   * @param {function(child: Node, path: string, parent: Node)} callback
   */
  Node.prototype.forEach = function (callback) {
    // must be implemented by each of the Node implementations
    throw new Error('Cannot run forEach on a Node interface');
  };

  /**
   * Create a new Node having it's childs be the results of calling
   * the provided callback function for each of the childs of the original node.
   * @param {function(child: Node, path: string, parent: Node): Node} callback
   * @returns {OperatorNode} Returns a transformed copy of the node
   */
  Node.prototype.map = function (callback) {
    // must be implemented by each of the Node implementations
    throw new Error('Cannot run map on a Node interface');
  };

  /**
   * Validate whether an object is a Node, for use with map
   * @param {Node} node
   * @returns {Node} Returns the input if it's a node, else throws an Error
   * @protected
   */
  Node.prototype._ifNode = function (node) {
    if (!(node &amp;&amp; node.isNode)) {
      throw new TypeError('Callback function must return a Node');
    }

    return node;
  };

  /**
   * Recursively traverse all nodes in a node tree. Executes given callback for
   * this node and each of its ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.ObjectNode" id="apidoc.module.mathjs.ObjectNode">module mathjs.ObjectNode</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.ObjectNode.factory" id="apidoc.element.mathjs.ObjectNode.factory">
        function <span class="apidocSignatureSpan">mathjs.ObjectNode.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var Node = load(require('./Node'));

<span class="apidocCodeCommentSpan">  /**
   * @constructor ObjectNode
   * @extends {Node}
   * Holds an object with keys/values
   * @param {Object.&lt;string, Node&gt;} [properties]   array with key/value pairs
   */
</span>  function ObjectNode(properties) {
    if (!(this instanceof ObjectNode)) {
      throw new SyntaxError('Constructor must be called with the new operator');
    }

    this.properties = properties || {};

    // validate input
    if (properties) {
      if (!(typeof properties === 'object') || Object.keys(properties).some(function (key) {
            return !properties[key] || !properties[key].isNode;
          })) {
        throw new TypeError('Object containing Nodes expected');
      }
    }
  }

  ObjectNode.prototype = new Node();

  ObjectNode.prototype.type = 'ObjectNode';

  ObjectNode.prototype.isObjectNode = true;

  /**
   * Compile the node to javascript code
   * @param {Object} defs     Object which can be used to define functions
   *                          or constants globally available for the compiled
   *                          expression
   * @param {Object} args     Object with local function arguments, the key is
   *                          the name of the argument, and the value is `true`.
   *                          The object may not be mutated, but must be
   *                          extended instead.
   * @return {string} code
   * @private
   */
  ObjectNode.prototype._compile = function (defs, args) {
    var entries = [];
    for (var key in this.properties) {
      if (this.properties.hasOwnProperty(key)) {
        entries.push('"' + key + '": ' + this.properties[key]._compile(defs, args));
      }
    }
    return '{' + entries.join(', ') + '}';
  };

  /**
   * Execute a callback for each of the child nodes of this node
   * @param {function(child: Node, path: string, parent: Node)} callback
   */
  ObjectNode.prototype.forEach = function (callback) {
    for (var key in this.properties) {
      if (this.properties.hasOwnProperty(key)) {
        callback(this.properties[key], 'properties["' + key + '"]', this);
      }
    }
  };

  /**
   * Create a new ObjectNode having it's childs be the results of calling
   * the provided callback function for each of the childs of the original node.
   * @param {function(child: Node, path: string, parent: Node): Node} callback
   * @returns {ObjectNode} Returns a transformed copy of the node
   */
  ObjectNode.prototype.map = function (callback) {
    var properties = {};
    for (var key in this.properties) {
      if (this.properties.hasOwnProperty(key)) {
        properties[key] = this._ifNode(callback(this.properties[key], 'properties["' + key + '"]', this));
      }
    }
    return new ObjectNode(properties);
  };

  /**
   * Create a clone of this node, a shallow copy
   * @return {ObjectNode}
   */
  ObjectNode.prototype.clone = function() {
    var properties = {};
    for (var key in this.properties) {
      if (this.properties.hasOwnProperty(key)) {
        properties[key] = this.properties[key];
      }
    }
    return new ObjectNode(properties);
  };

  /**
   * Get string representation
   * @param {Object} options
   * @return {string} str
   * @override
   */
  ObjectNode.prototype._toString = function(options) {
    var entries = [];
    for (var key in this.properties) {
      if (this.properties.hasOwnProperty(key)) {
        entries.push('"' + key + '": ' + this.properties[key].toString(options));
      }
    }
    return '{' + entries.join(', ') + '}';
  };

  /**
   * Get LaTeX representation
   * @param {Object} options
   * @return {string} str
   */
  ObjectNode.prototype._toTex = function(options) {
    var entries = [];
    for (var key in this.properties) {
      if (this.properties.hasOwnProperty(key)) {
        entries.push("\\mathbf{" + key + ':} &amp; ' + this.properties[key].toTex(options) + "\\\\");
      }
    }
    return '\\left\\{\\begin{array}{ll}' + entries.join('\n') + '\\end{array}\\right\\}';
  };

  return ObjectNode;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.OperatorNode" id="apidoc.module.mathjs.OperatorNode">module mathjs.OperatorNode</a></h1>




    <h2>
        <a href="#apidoc.element.mathjs.OperatorNode.factory" id="apidoc.element.mathjs.OperatorNode.factory">
        function <span class="apidocSignatureSpan">mathjs.OperatorNode.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed, math)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed, math) {
  var Node         = load(require('./Node'));
  var ConstantNode = load(require('./ConstantNode'));
  var SymbolNode   = load(require('./SymbolNode'));
  var FunctionNode = load(require('./FunctionNode'));

<span class="apidocCodeCommentSpan">  /**
   * @constructor OperatorNode
   * @extends {Node}
   * An operator with two arguments, like 2+3
   *
   * @param {string} op           Operator name, for example '+'
   * @param {string} fn           Function name, for example 'add'
   * @param {Node[]} args         Operator arguments
   * @param {boolean} [implicit]  Is this an implicit multiplication?
   */
</span>  function OperatorNode(op, fn, args, implicit) {
    if (!(this instanceof OperatorNode)) {
      throw new SyntaxError('Constructor must be called with the new operator');
    }

    //validate input
    if (typeof op !== 'string') {
      throw new TypeError('string expected for parameter "op"');
    }
    if (typeof fn !== 'string') {
      throw new TypeError('string expected for parameter "fn"');
    }
    if (!Array.isArray(args)
        || !args.every(function (node) {return node &amp;&amp; node.isNode;})) {
      throw new TypeError('Array containing Nodes expected for parameter "args"');
    }

    this.implicit = (implicit === true);
    this.op = op;
    this.fn = fn;
    this.args = args || [];
  }

  OperatorNode.prototype = new Node();

  OperatorNode.prototype.type = 'OperatorNode';

  OperatorNode.prototype.isOperatorNode = true;

  /**
   * Compile the node to javascript code
   * @param {Object} defs     Object which can be used to define functions
   *                          or constants globally available for the compiled
   *                          expression
   * @param {Object} args     Object with local function arguments, the key is
   *                          the name of the argument, and the value is `true`.
   *                          The object may not be mutated, but must be
   *                          extended instead.
   * @return {string} js
   * @private
   */
  OperatorNode.prototype._compile = function (defs, args) {
    if (!defs.math[this.fn]) {
      throw new Error('Function ' + this.fn + ' missing in provided namespace "math"');
    }

    var jsArgs = this.args.map(function (arg) {
      return arg._compile(defs, args);
    });

    return 'math.' + this.fn + '(' + jsArgs.join(', ') + ')';
  };

  /**
   * Execute a callback for each of the child nodes of this node
   * @param {function(child: Node, path: string, parent: Node)} callback
   */
  OperatorNode.prototype.forEach = function (callback) {
    for (var i = 0; i &lt; this.args.length; i++) {
      callback(this.args[i], 'args[' + i + ']', this);
    }
  };

  /**
   * Create a new OperatorNode having it's childs be the results of calling
   * the provided callback function for each of the childs of the original node.
   * @param {function(child: Node, path: string, parent: Node): Node} callback
   * @returns {OperatorNode} Returns a transformed copy of the node
   */
  OperatorNode.prototype.map = function (callback) {
    var args = [];
    for (var i = 0; i &lt; this.args.length; i++) {
      args[i] = this._ifNode(callback(this.args[i], 'args[' + i + ']', this));
    }
    return new OperatorNode(this.op, this.fn, args);
  };

  /**
   * Create a clone of this node, a shallow copy
   * @return {OperatorNode}
   */
  OperatorNode.prototype.clone = function () {
    return new OperatorNode(this.op, this.fn, this.args.slice(0), this.implicit);
  };

  /**
   * Calculate which parentheses are necessary. Gets an OperatorNode
   * (which is the root of the tree) and an Array of Nodes
   * (this.args) and returns an array where 'true' means that an argument
   * has to be enclosed in parentheses whereas 'false' means the opposite.
   *
   * @param {OperatorNode} root
   * @param {string} parenthesis
   * @param {Node[]} args
   * @param {boolean} latex
   * @return {boolean[]}
   * @private
   */
  function calculateNecessaryParentheses(root, parenthesis, args, latex) {
    //precedence of the root OperatorNode ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.ParenthesisNode" id="apidoc.module.mathjs.ParenthesisNode">module mathjs.ParenthesisNode</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.ParenthesisNode.factory" id="apidoc.element.mathjs.ParenthesisNode.factory">
        function <span class="apidocSignatureSpan">mathjs.ParenthesisNode.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var Node = load(require('./Node'));

<span class="apidocCodeCommentSpan">  /**
   * @constructor ParenthesisNode
   * @extends {Node}
   * A parenthesis node describes manual parenthesis from the user input
   * @param {Node} content
   * @extends {Node}
   */
</span>  function ParenthesisNode(content) {
    if (!(this instanceof ParenthesisNode)) {
      throw new SyntaxError('Constructor must be called with the new operator');
    }

    // validate input
    if (!(content &amp;&amp; content.isNode)) {
      throw new TypeError('Node expected for parameter "content"');
    }

    this.content = content;
  }

  ParenthesisNode.prototype = new Node();

  ParenthesisNode.prototype.type = 'ParenthesisNode';

  ParenthesisNode.prototype.isParenthesisNode = true;

  /**
   * Compile the node to javascript code
   * @param {Object} defs     Object which can be used to define functions
   *                          or constants globally available for the compiled
   *                          expression
   * @param {Object} args     Object with local function arguments, the key is
   *                          the name of the argument, and the value is `true`.
   *                          The object may not be mutated, but must be
   *                          extended instead.
   * @return {string} js
   * @private
   */
  ParenthesisNode.prototype._compile = function (defs, args) {
    return this.content._compile(defs, args);
  };

  /**
   * Get the content of the current Node.
   * @return {Node} content
   * @override
   **/
  ParenthesisNode.prototype.getContent = function () {
    return this.content.getContent();
  };

  /**
   * Execute a callback for each of the child nodes of this node
   * @param {function(child: Node, path: string, parent: Node)} callback
   */
  ParenthesisNode.prototype.forEach = function (callback) {
    callback(this.content, 'content', this);
  };

  /**
   * Create a new ParenthesisNode having it's childs be the results of calling
   * the provided callback function for each of the childs of the original node.
   * @param {function(child: Node, path: string, parent: Node) : Node} callback
   * @returns {ParenthesisNode} Returns a clone of the node
   */
  ParenthesisNode.prototype.map = function (callback) {
    var content = callback(this.content, 'content', this);
    return new ParenthesisNode(content);
  };

  /**
   * Create a clone of this node, a shallow copy
   * @return {ParenthesisNode}
   */
  ParenthesisNode.prototype.clone = function() {
    return new ParenthesisNode(this.content);
  };

  /**
   * Get string representation
   * @param {Object} options
   * @return {string} str
   * @override
   */
  ParenthesisNode.prototype._toString = function(options) {
    if ((!options) || (options &amp;&amp; !options.parenthesis) || (options &amp;&amp; options.parenthesis === 'keep')) {
      return '(' + this.content.toString(options) + ')';
    }
    return this.content.toString(options);
  };

  /**
   * Get LaTeX representation
   * @param {Object} options
   * @return {string} str
   * @override
   */
  ParenthesisNode.prototype._toTex = function(options) {
    if ((!options) || (options &amp;&amp; !options.parenthesis) || (options &amp;&amp; options.parenthesis === 'keep')) {
      return '\\left(' + this.content.toTex(options) + '\\right)';
    }
    return this.content.toTex(options);
  };

  return ParenthesisNode;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.Parser" id="apidoc.module.mathjs.Parser">module mathjs.Parser</a></h1>




    <h2>
        <a href="#apidoc.element.mathjs.Parser.factory" id="apidoc.element.mathjs.Parser.factory">
        function <span class="apidocSignatureSpan">mathjs.Parser.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed, math)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed, math) {
  var _parse = load(require('./parse'));
  var customs = load(require('./node/utils/customs'));

<span class="apidocCodeCommentSpan">  /**
   * @constructor Parser
   * Parser contains methods to evaluate or parse expressions, and has a number
   * of convenience methods to get, set, and remove variables from memory. Parser
   * keeps a scope containing variables in memory, which is used for all
   * evaluations.
   *
   * Methods:
   *    var result = parser.eval(expr);    // evaluate an expression
   *    var value = parser.get(name);      // retrieve a variable from the parser
   *    var values = parser.getAll();      // retrieve all defined variables
   *    parser.set(name, value);           // set a variable in the parser
   *    parser.remove(name);               // clear a variable from the
   *                                       // parsers scope
   *    parser.clear();                    // clear the parsers scope
   *
   * Example usage:
   *    var parser = new Parser();
   *    // Note: there is a convenience method which can be used instead:
   *    // var parser = new math.parser();
   *
   *    // evaluate expressions
   *    parser.eval('sqrt(3^2 + 4^2)');         // 5
   *    parser.eval('sqrt(-4)');                // 2i
   *    parser.eval('2 inch in cm');            // 5.08 cm
   *    parser.eval('cos(45 deg)');             // 0.7071067811865476
   *
   *    // define variables and functions
   *    parser.eval('x = 7 / 2');               // 3.5
   *    parser.eval('x + 3');                   // 6.5
   *    parser.eval('function f(x, y) = x^y');  // f(x, y)
   *    parser.eval('f(2, 3)');                 // 8
   *
   *    // get and set variables and functions
   *    var x = parser.get('x');                // 7
   *    var f = parser.get('f');                // function
   *    var g = f(3, 2);                        // 9
   *    parser.set('h', 500);
   *    var i = parser.eval('h / 2');           // 250
   *    parser.set('hello', function (name) {
   *        return 'hello, ' + name + '!';
   *    });
   *    parser.eval('hello("user")');           // "hello, user!"
   *
   *    // clear defined functions and variables
   *    parser.clear();
   *
   */
</span>  function Parser() {
    if (!(this instanceof Parser)) {
      throw new SyntaxError(
          'Constructor must be called with the new operator');
    }
    this.scope = {};
  }

  /**
   * Attach type information
   */
  Parser.prototype.type = 'Parser';
  Parser.prototype.isParser = true;

  /**
   * Parse an expression and return the parsed function node.
   * The node tree can be compiled via `code = node.compile(math)`,
   * and the compiled code can be executed as `code.eval([scope])`
   * @param {string} expr
   * @return {Node} node
   * @throws {Error}
   */
  Parser.prototype.parse = function (expr) {
    throw new Error('Parser.parse is deprecated. Use math.parse instead.');
  };

  /**
   * Parse and compile an expression, return the compiled javascript code.
   * The node can be evaluated via code.eval([scope])
   * @param {string} expr
   * @return {{eval: function}} code
   * @throws {Error}
   */
  Parser.prototype.compile = function (expr) {
    throw new Error('Parser.compile is deprecated. Use math.compile instead.');
  };

  /**
   * Parse and evaluate the given expression
   * @param {string} expr   A string containing an expression, for example "2+3"
   * @return {*} result     The result, or undefined when the expression was empty
   * @throws {Error}
   */
  Parser.prototype.eval = function (expr) {
    // TODO: validate arguments
    return _parse(expr)
        .compile()
        .eval(this.scope);
  };

  /**
   * Get a variable (a function or variable) by name from the parsers scope.
   * Returns undefined when not found
   * @param {string} name
   * @return {* | undefined} value
   */
  Parser.prototype.get = function (name) {
    // TODO: validate arguments
    return name in this.scope
        ? customs.getSafeProperty(this.scope, name)
        : undefined;
  };

  /**
   * Get a map with all de ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.Range" id="apidoc.module.mathjs.Range">module mathjs.Range</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.Range.factory" id="apidoc.element.mathjs.Range.factory">
        function <span class="apidocSignatureSpan">mathjs.Range.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
<span class="apidocCodeCommentSpan">  /**
   * Create a range. A range has a start, step, and end, and contains functions
   * to iterate over the range.
   *
   * A range can be constructed as:
   *     var range = new Range(start, end);
   *     var range = new Range(start, end, step);
   *
   * To get the result of the range:
   *     range.forEach(function (x) {
   *         console.log(x);
   *     });
   *     range.map(function (x) {
   *         return math.sin(x);
   *     });
   *     range.toArray();
   *
   * Example usage:
   *     var c = new Range(2, 6);         // 2:1:5
   *     c.toArray();                     // [2, 3, 4, 5]
   *     var d = new Range(2, -3, -1);    // 2:-1:-2
   *     d.toArray();                     // [2, 1, 0, -1, -2]
   *
   * @class Range
   * @constructor Range
   * @param {number} start  included lower bound
   * @param {number} end    excluded upper bound
   * @param {number} [step] step size, default value is 1
   */
</span>  function Range(start, end, step) {
    if (!(this instanceof Range)) {
      throw new SyntaxError('Constructor must be called with the new operator');
    }

    if (start != null) {
      if (start.isBigNumber === true)
        start = start.toNumber();
      else if (typeof start !== 'number')
        throw new TypeError('Parameter start must be a number');
    }
    if (end != null) {
      if (end.isBigNumber === true)
        end = end.toNumber();
      else if (typeof end !== 'number')
        throw new TypeError('Parameter end must be a number');
    }
    if (step != null) {
      if (step.isBigNumber === true)
        step = step.toNumber();
      else if (typeof step !== 'number')
        throw new TypeError('Parameter step must be a number');
    }

    this.start = (start != null) ? parseFloat(start) : 0;
    this.end   = (end != null)   ? parseFloat(end)   : 0;
    this.step  = (step != null)  ? parseFloat(step)  : 1;
  }

  /**
   * Attach type information
   */
  Range.prototype.type = 'Range';
  Range.prototype.isRange = true;

  /**
   * Parse a string into a range,
   * The string contains the start, optional step, and end, separated by a colon.
   * If the string does not contain a valid range, null is returned.
   * For example str='0:2:11'.
   * @memberof Range
   * @param {string} str
   * @return {Range | null} range
   */
  Range.parse = function (str) {
    if (typeof str !== 'string') {
      return null;
    }

    var args = str.split(':');
    var nums = args.map(function (arg) {
      return parseFloat(arg);
    });

    var invalid = nums.some(function (num) {
      return isNaN(num);
    });
    if (invalid) {
      return null;
    }

    switch (nums.length) {
      case 2:
        return new Range(nums[0], nums[1]);
      case 3:
        return new Range(nums[0], nums[2], nums[1]);
      default:
        return null;
    }
  };

  /**
   * Create a clone of the range
   * @return {Range} clone
   */
  Range.prototype.clone = function () {
    return new Range(this.start, this.end, this.step);
  };

  /**
   * Retrieve the size of the range.
   * Returns an array containing one number, the number of elements in the range.
   * @memberof Range
   * @returns {number[]} size
   */
  Range.prototype.size = function () {
    var len = 0,
        start = this.start,
        step = this.step,
        end = this.end,
        diff = end - start;

    if (number.sign(step) == number.sign(diff)) {
      len = Math.ceil((diff) / step);
    }
    else if (diff == 0) {
      len = 0;
    }

    if (isNaN(len)) {
      len = 0;
    }
    return [len];
  };

  /**
   * Calculate the minimum value in the range
   * @memberof Range
   * @return {number | undefined} min
   */
  Range.prototype.min = function () {
    var size = this.size()[0];

    if (size &gt; 0) {
      if (this.step &gt; 0) {
        // positive step
        return this.start;
      }
      else {
        // negative step
        return this.start + (size - 1) * this.step;
      }
    }
    else {
      return undefined;
    }
  };

  /**
   * Calculate the maximum value ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.RangeNode" id="apidoc.module.mathjs.RangeNode">module mathjs.RangeNode</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.RangeNode.factory" id="apidoc.element.mathjs.RangeNode.factory">
        function <span class="apidocSignatureSpan">mathjs.RangeNode.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var Node = load(require('./Node'));

<span class="apidocCodeCommentSpan">  /**
   * @constructor RangeNode
   * @extends {Node}
   * create a range
   * @param {Node} start  included lower-bound
   * @param {Node} end    included upper-bound
   * @param {Node} [step] optional step
   */
</span>  function RangeNode(start, end, step) {
    if (!(this instanceof RangeNode)) {
      throw new SyntaxError('Constructor must be called with the new operator');
    }

    // validate inputs
    if (!(start &amp;&amp; start.isNode)) throw new TypeError('Node expected');
    if (!(end &amp;&amp; end.isNode)) throw new TypeError('Node expected');
    if (step &amp;&amp; !(step &amp;&amp; step.isNode)) throw new TypeError('Node expected');
    if (arguments.length &gt; 3) throw new Error('Too many arguments');

    this.start = start;         // included lower-bound
    this.end = end;           // included upper-bound
    this.step = step || null;  // optional step
  }

  RangeNode.prototype = new Node();

  RangeNode.prototype.type = 'RangeNode';

  RangeNode.prototype.isRangeNode = true;

  /**
   * Check whether the RangeNode needs the `end` symbol to be defined.
   * This end is the size of the Matrix in current dimension.
   * @return {boolean}
   */
  RangeNode.prototype.needsEnd = function () {
    // find all `end` symbols in this RangeNode
    var endSymbols = this.filter(function (node) {
      return (node &amp;&amp; node.isSymbolNode) &amp;&amp; (node.name == 'end');
    });

    return endSymbols.length &gt; 0;
  };

  /**
   * Compile the node to javascript code
   *
   * When the range has a symbol `end` defined, the RangeNode requires
   * a variable `end` to be defined in the current closure, which must contain
   * the length of the of the matrix that's being handled in the range's
   * dimension. To check whether the `end` variable is needed, call
   * RangeNode.needsEnd().
   *
   * @param {Object} defs     Object which can be used to define functions
   *                          or constants globally available for the compiled
   *                          expression
   * @param {Object} args     Object with local function arguments, the key is
   *                          the name of the argument, and the value is `true`.
   *                          The object may not be mutated, but must be
   *                          extended instead.
   * @return {string} js
   * @private
   */
  RangeNode.prototype._compile = function (defs, args) {
    return 'math.range(' +
        this.start._compile(defs, args) + ', ' +
        this.end._compile(defs, args) +
        (this.step ? (', ' + this.step._compile(defs, args)) : '') +
        ')';
  };

  /**
   * Execute a callback for each of the child nodes of this node
   * @param {function(child: Node, path: string, parent: Node)} callback
   */
  RangeNode.prototype.forEach = function (callback) {
    callback(this.start, 'start', this);
    callback(this.end, 'end', this);
    if (this.step) {
      callback(this.step, 'step', this);
    }
  };

  /**
   * Create a new RangeNode having it's childs be the results of calling
   * the provided callback function for each of the childs of the original node.
   * @param {function(child: Node, path: string, parent: Node): Node} callback
   * @returns {RangeNode} Returns a transformed copy of the node
   */
  RangeNode.prototype.map = function (callback) {
    return new RangeNode(
        this._ifNode(callback(this.start, 'start', this)),
        this._ifNode(callback(this.end, 'end', this)),
        this.step &amp;&amp; this._ifNode(callback(this.step, 'step', this))
    );
  };

  /**
   * Create a clone of this node, a shallow copy
   * @return {RangeNode}
   */
  RangeNode.prototype.clone = function () {
    return new RangeNode(this.start, this.end, this.step &amp;&amp; this.step);
  };

  /**
   * Calculate the necessary parentheses
   * @param {Node} node
   * @param {string} parenthesis
   * @return {Object} parentheses
   * @private
   */
  function calculateNecessaryParentheses(node, parenthesis) {
    var precedence = operators.getPrecedence(node, parenthesis);
    var paren ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.ResultSet" id="apidoc.module.mathjs.ResultSet">module mathjs.ResultSet</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.ResultSet.factory" id="apidoc.element.mathjs.ResultSet.factory">
        function <span class="apidocSignatureSpan">mathjs.ResultSet.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
<span class="apidocCodeCommentSpan">  /**
   * A ResultSet contains a list or results
   * @class ResultSet
   * @param {Array} entries
   * @constructor ResultSet
   */
</span>  function ResultSet(entries) {
    if (!(this instanceof ResultSet)) {
      throw new SyntaxError('Constructor must be called with the new operator');
    }

    this.entries = entries || [];
  }

  /**
   * Attach type information
   */
  ResultSet.prototype.type = 'ResultSet';
  ResultSet.prototype.isResultSet = true;

  /**
   * Returns the array with results hold by this ResultSet
   * @memberof ResultSet
   * @returns {Array} entries
   */
  ResultSet.prototype.valueOf = function () {
    return this.entries;
  };

  /**
   * Returns the stringified results of the ResultSet
   * @memberof ResultSet
   * @returns {string} string
   */
  ResultSet.prototype.toString = function () {
    return '[' + this.entries.join(', ') + ']';
  };

  /**
   * Get a JSON representation of the ResultSet
   * @memberof ResultSet
   * @returns {Object} Returns a JSON object structured as:
   *                   `{"mathjs": "ResultSet", "entries": [...]}`
   */
  ResultSet.prototype.toJSON = function () {
    return {
      mathjs: 'ResultSet',
      entries: this.entries
    };
  };

  /**
   * Instantiate a ResultSet from a JSON object
   * @memberof ResultSet
   * @param {Object} json  A JSON object structured as:
   *                       `{"mathjs": "ResultSet", "entries": [...]}`
   * @return {ResultSet}
   */
  ResultSet.fromJSON = function (json) {
    return new ResultSet(json.entries);
  };

  return ResultSet;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.Spa" id="apidoc.module.mathjs.Spa">module mathjs.Spa</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.Spa.factory" id="apidoc.element.mathjs.Spa.factory">
        function <span class="apidocSignatureSpan">mathjs.Spa.</span>factory
        <span class="apidocSignatureSpan">(type, config, load)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load) {

  var add = load(require('../../function/arithmetic/add'));
  var equalScalar = load(require('../../function/relational/equalScalar'));

<span class="apidocCodeCommentSpan">  /**
   * An ordered Sparse Accumulator is a representation for a sparse vector that includes a dense array
   * of the vector elements and an ordered list of non-zero elements.
   */
</span>  function Spa() {
    if (!(this instanceof Spa))
      throw new SyntaxError('Constructor must be called with the new operator');

    // allocate vector, TODO use typed arrays
    this._values = [];
    this._heap = new type.FibonacciHeap();
  }

  /**
   * Attach type information
   */
  Spa.prototype.type = 'Spa';
  Spa.prototype.isSpa = true;

  /**
   * Set the value for index i.
   *
   * @param {number} i                       The index
   * @param {number | BigNumber | Complex}   The value at index i
   */
  Spa.prototype.set = function (i, v) {
    // check we have a value @ i
    if (!this._values[i]) {
      // insert in heap
      var node = this._heap.insert(i, v);
      // set the value @ i
      this._values[i] = node;
    }
    else {
      // update the value @ i
      this._values[i].value = v;
    }
  };

  Spa.prototype.get = function (i) {
    var node = this._values[i];
    if (node)
      return node.value;
    return 0;
  };

  Spa.prototype.accumulate = function (i, v) {
    // node @ i
    var node = this._values[i];
    if (!node) {
      // insert in heap
      node = this._heap.insert(i, v);
      // initialize value
      this._values[i] = node;
    }
    else {
      // accumulate value
      node.value = add(node.value, v);
    }
  };

  Spa.prototype.forEach = function (from, to, callback) {
    // references
    var heap = this._heap;
    var values = this._values;
    // nodes
    var nodes = [];
    // node with minimum key, save it
    var node = heap.extractMinimum();
    if (node)
      nodes.push(node);
    // extract nodes from heap (ordered)
    while (node &amp;&amp; node.key &lt;= to) {
      // check it is in range
      if (node.key &gt;= from) {
        // check value is not zero
        if (!equalScalar(node.value, 0)) {
          // invoke callback
          callback(node.key, node.value, this);
        }
      }
      // extract next node, save it
      node = heap.extractMinimum();
      if (node)
        nodes.push(node);
    }
    // reinsert all nodes in heap
    for (var i = 0; i &lt; nodes.length; i++) {
      // current node
      var n = nodes[i];
      // insert node in heap
      node = heap.insert(n.key, n.value);
      // update values
      values[node.key] = node;
    }
  };

  Spa.prototype.swap = function (i, j) {
    // node @ i and j
    var nodei = this._values[i];
    var nodej = this._values[j];
    // check we need to insert indeces
    if (!nodei &amp;&amp; nodej) {
      // insert in heap
      nodei = this._heap.insert(i, nodej.value);
      // remove from heap
      this._heap.remove(nodej);
      // set values
      this._values[i] = nodei;
      this._values[j] = undefined;
    }
    else if (nodei &amp;&amp; !nodej) {
      // insert in heap
      nodej = this._heap.insert(j, nodei.value);
      // remove from heap
      this._heap.remove(nodei);
      // set values
      this._values[j] = nodej;
      this._values[i] = undefined;
    }
    else if (nodei &amp;&amp; nodej) {
      // swap values
      var v = nodei.value;
      nodei.value = nodej.value;
      nodej.value = v;
    }
  };

  return Spa;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.SparseMatrix" id="apidoc.module.mathjs.SparseMatrix">module mathjs.SparseMatrix</a></h1>




    <h2>
        <a href="#apidoc.element.mathjs.SparseMatrix.factory" id="apidoc.element.mathjs.SparseMatrix.factory">
        function <span class="apidocSignatureSpan">mathjs.SparseMatrix.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var Matrix = load(require('./Matrix')); // force loading Matrix (do not use via type.Matrix)
  var equalScalar = load(require('../../function/relational/equalScalar'));

<span class="apidocCodeCommentSpan">  /**
   * Sparse Matrix implementation. This type implements a Compressed Column Storage format
   * for sparse matrices.
   * @class SparseMatrix
   */
</span>  function SparseMatrix(data, datatype) {
    if (!(this instanceof SparseMatrix))
      throw new SyntaxError('Constructor must be called with the new operator');
    if (datatype &amp;&amp; !isString(datatype))
      throw new Error('Invalid datatype: ' + datatype);

    if (data &amp;&amp; data.isMatrix === true) {
      // create from matrix
      _createFromMatrix(this, data, datatype);
    }
    else if (data &amp;&amp; isArray(data.index) &amp;&amp; isArray(data.ptr) &amp;&amp; isArray(data.size)) {
      // initialize fields
      this._values = data.values;
      this._index = data.index;
      this._ptr = data.ptr;
      this._size = data.size;
      this._datatype = datatype || data.datatype;
    }
    else if (isArray(data)) {
      // create from array
      _createFromArray(this, data, datatype);
    }
    else if (data) {
      // unsupported type
      throw new TypeError('Unsupported type of data (' + util.types.type(data) + ')');
    }
    else {
      // nothing provided
      this._values = [];
      this._index = [];
      this._ptr = [0];
      this._size = [0, 0];
      this._datatype = datatype;
    }
  }

  var _createFromMatrix = function (matrix, source, datatype) {
    // check matrix type
    if (source.type === 'SparseMatrix') {
      // clone arrays
      matrix._values = source._values ? object.clone(source._values) : undefined;
      matrix._index = object.clone(source._index);
      matrix._ptr = object.clone(source._ptr);
      matrix._size = object.clone(source._size);
      matrix._datatype = datatype || source._datatype;
    }
    else {
      // build from matrix data
      _createFromArray(matrix, source.valueOf(), datatype || source._datatype);
    }
  };

  var _createFromArray = function (matrix, data, datatype) {
    // initialize fields
    matrix._values = [];
    matrix._index = [];
    matrix._ptr = [];
    matrix._datatype = datatype;
    // discover rows &amp; columns, do not use math.size() to avoid looping array twice
    var rows = data.length;
    var columns = 0;

    // equal signature to use
    var eq = equalScalar;
    // zero value
    var zero = 0;

    if (isString(datatype)) {
      // find signature that matches (datatype, datatype)
      eq = typed.find(equalScalar, [datatype, datatype]) || equalScalar;
      // convert 0 to the same datatype
      zero = typed.convert(0, datatype);
    }

    // check we have rows (empty array)
    if (rows &gt; 0) {
      // column index
      var j = 0;
      do {
        // store pointer to values index
        matrix._ptr.push(matrix._index.length);
        // loop rows
        for (var i = 0; i &lt; rows; i++) {
          // current row
          var row = data[i];
          // check row is an array
          if (isArray(row)) {
            // update columns if needed (only on first column)
            if (j === 0 &amp;&amp; columns &lt; row.length)
              columns = row.length;
            // check row has column
            if (j &lt; row.length) {
              // value
              var v = row[j];
              // check value != 0
              if (!eq(v, zero)) {
                // store value
                matrix._values.push(v);
                // index
                matrix._index.push(i);
              }
            }
          }
          else {
            // update columns if needed (only on first column)
            if (j === 0 &amp;&amp; columns &lt; 1)
              columns = 1;
            // check value != 0 (row is a scalar)
            if (!eq(row, zero)) {
              // store value
              matrix._values.push(row);
              // index
              matrix._index.push(i);
            }
          }
        }
        // increment index
        j++;
      }
      whil ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.SymbolNode" id="apidoc.module.mathjs.SymbolNode">module mathjs.SymbolNode</a></h1>




    <h2>
        <a href="#apidoc.element.mathjs.SymbolNode.factory" id="apidoc.element.mathjs.SymbolNode.factory">
        function <span class="apidocSignatureSpan">mathjs.SymbolNode.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed, math)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed, math) {
  var Node = load(require('./Node'));
  var Unit = load(require('../../type/unit/Unit'));
  var getSafeProperty = load(require('./utils/customs')).getSafeProperty;

<span class="apidocCodeCommentSpan">  /**
   * @constructor SymbolNode
   * @extends {Node}
   * A symbol node can hold and resolve a symbol
   * @param {string} name
   * @extends {Node}
   */
</span>  function SymbolNode(name) {
    if (!(this instanceof SymbolNode)) {
      throw new SyntaxError('Constructor must be called with the new operator');
    }

    // validate input
    if (typeof name !== 'string')  throw new TypeError('String expected for parameter "name"');

    this.name = name;
  }

  SymbolNode.prototype = new Node();

  SymbolNode.prototype.type = 'SymbolNode';

  SymbolNode.prototype.isSymbolNode = true;

  /**
   * Compile the node to javascript code
   * @param {Object} defs     Object which can be used to define functions
   *                          or constants globally available for the compiled
   *                          expression
   * @param {Object} args     Object with local function arguments, the key is
   *                          the name of the argument, and the value is `true`.
   *                          The object may not be mutated, but must be
   *                          extended instead.
   * @return {string} js
   * @private
   */
  SymbolNode.prototype._compile = function (defs, args) {
    // add a function to the definitions
    defs['undef'] = undef;
    defs['Unit'] = Unit;
    defs.getSafeProperty = getSafeProperty;

    if (args[this.name]) {
      // this is a FunctionAssignment argument
      // (like an x when inside the expression of a function assignment `f(x) = ...`)
      return this.name;
    }
    else if (this.name in defs.math) {
      return '("' + this.name + '" in scope ? getSafeProperty(scope, "' + this.name + '") : getSafeProperty(math, "' + this.name
 + '"))';
    }
    else {
      return '(' +
          '"' + this.name + '" in scope ? getSafeProperty(scope, "' + this.name + '") : ' +
          (Unit.isValuelessUnit(this.name) ?
          'new Unit(null, "' + this.name + '")' :
          'undef("' + this.name + '")') +
          ')';
    }
  };

  /**
   * Execute a callback for each of the child nodes of this node
   * @param {function(child: Node, path: string, parent: Node)} callback
   */
  SymbolNode.prototype.forEach = function (callback) {
    // nothing to do, we don't have childs
  };

  /**
   * Create a new SymbolNode having it's childs be the results of calling
   * the provided callback function for each of the childs of the original node.
   * @param {function(child: Node, path: string, parent: Node) : Node} callback
   * @returns {SymbolNode} Returns a clone of the node
   */
  SymbolNode.prototype.map = function (callback) {
    return this.clone();
  };

  /**
   * Throws an error 'Undefined symbol {name}'
   * @param {string} name
   */
  function undef (name) {
    throw new Error('Undefined symbol ' + name);
  }

  /**
   * Create a clone of this node, a shallow copy
   * @return {SymbolNode}
   */
  SymbolNode.prototype.clone = function() {
    return new SymbolNode(this.name);
  };

  /**
   * Get string representation
   * @param {Object} options
   * @return {string} str
   * @override
   */
  SymbolNode.prototype._toString = function(options) {
    return this.name;
  };

  /**
   * Get LaTeX representation
   * @param {Object} options
   * @return {string} str
   * @override
   */
  SymbolNode.prototype._toTex = function(options) {
    var isUnit = false;
    if ((typeof math[this.name] === 'undefined') &amp;&amp; Unit.isValuelessUnit(this.name)) {
      isUnit = true;
    }
    var symbol = latex.toSymbol(this.name, isUnit);
    if (symbol[0] === '\\') {
      //no space needed if the symbol starts with '\'
      return symbol;
    }
    //the space prevents symbols from breaking stuff like '\cdot' if it's written right before the symbol
    return ' ' + symbol;
  };

  return SymbolNode;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.Unit" id="apidoc.module.mathjs.Unit">module mathjs.Unit</a></h1>




    <h2>
        <a href="#apidoc.element.mathjs.Unit.factory" id="apidoc.element.mathjs.Unit.factory">
        function <span class="apidocSignatureSpan">mathjs.Unit.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed, math)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed, math) {
  var add       = load(require('../../function/arithmetic/addScalar'));
  var subtract  = load(require('../../function/arithmetic/subtract'));
  var multiply  = load(require('../../function/arithmetic/multiplyScalar'));
  var divide    = load(require('../../function/arithmetic/divideScalar'));
  var pow       = load(require('../../function/arithmetic/pow'));
  var abs       = load(require('../../function/arithmetic/abs'));
  var fix       = load(require('../../function/arithmetic/fix'));
  var equal     = load(require('../../function/relational/equal'));
  var isNumeric = load(require('../../function/utils/isNumeric'));
  var format    = load(require('../../function/string/format'));
  var getTypeOf = load(require('../../function/utils/typeof'));
  var toNumber  = load(require('../../type/number'));
  var Complex   = load(require('../../type/complex/Complex'));

<span class="apidocCodeCommentSpan">  /**
   * A unit can be constructed in the following ways:
   *     var a = new Unit(value, name);
   *     var b = new Unit(null, name);
   *     var c = Unit.parse(str);
   *
   * Example usage:
   *     var a = new Unit(5, 'cm');               // 50 mm
   *     var b = Unit.parse('23 kg');             // 23 kg
   *     var c = math.in(a, new Unit(null, 'm');  // 0.05 m
   *     var d = new Unit(9.81, "m/s^2");         // 9.81 m/s^2
   *
   * @class Unit
   * @constructor Unit
   * @param {number | BigNumber | Fraction | Complex | boolean} [value]  A value like 5.2
   * @param {string} [name]   A unit name like "cm" or "inch", or a derived unit of the form: "u1[^ex1] [u2[^ex2] ...] [/ u3[^ex3
] [u4[^ex4]]]", such as "kg m^2/s^2", where each unit appearing after the forward slash is taken to be in the denominator. "kg m
^2 s^-2" is a synonym and is also acceptable. Any of the units can include a prefix.
   */
</span>  function Unit(value, name) {
    if (!(this instanceof Unit)) {
      throw new Error('Constructor must be called with the new operator');
    }

    if (!(value === undefined || isNumeric(value) || value.isComplex)) {
      throw new TypeError('First parameter in Unit constructor must be number, BigNumber, Fraction, Complex, or undefined');
    }
    if (name != undefined &amp;&amp; (typeof name !== 'string' || name == '')) {
      throw new TypeError('Second parameter in Unit constructor must be a string');
    }

    if (name != undefined) {
      var u = Unit.parse(name);
      this.units = u.units;
      this.dimensions = u.dimensions;
    }
    else {
      this.units = [
        {
          unit: UNIT_NONE,
          prefix: PREFIXES.NONE,  // link to a list with supported prefixes
          power: 0
        }
      ];
      this.dimensions = [];
      for(var i=0; i&lt;BASE_DIMENSIONS.length; i++) {
        this.dimensions[i] = 0;
      }
    }

    this.value = (value != undefined) ? this._normalize(value) : null;

    this.fixPrefix = false; // if true, function format will not search for the
                            // best prefix but leave it as initially provided.
                            // fixPrefix is set true by the method Unit.to

    // The justification behind this is that if the constructor is explicitly called,
    // the caller wishes the units to be returned exactly as he supplied.
    this.isUnitListSimplified = true;

  }

  /**
   * Attach type information
   */
  Unit.prototype.type = 'Unit';
  Unit.prototype.isUnit = true;

  // private variables and functions for the Unit parser
  var text, index, c;

  function skipWhitespace() {
    while (c == ' ' || c == '\t') {
      next();
    }
  }

  function isDigitDot(c) {
    return ((c &gt;= '0' &amp;&amp; c &lt;= '9') || c == '.');
  }

  function isDigit(c) {
    return ((c &gt;= '0' &amp;&amp; c &lt;= '9'));
  }

  function next() {
    index++;
    c = text.charAt(index);
  }

  function revert(oldIndex) {
    index = oldIndex;
    c = text.charAt(index);
  }

  function parseNumber() {
    var number = '';
    var oldIndex;
    oldIndex = index;

    if (c == '+') {
      next();
    }
    else if (c == '-') {
      number += c;
      next();
    } ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.UpdateNode" id="apidoc.module.mathjs.UpdateNode">module mathjs.UpdateNode</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.UpdateNode.factory" id="apidoc.element.mathjs.UpdateNode.factory">
        function <span class="apidocSignatureSpan">mathjs.UpdateNode.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
<span class="apidocCodeCommentSpan">  /**
   * @constructor UpdateNode
   */
</span>  function UpdateNode() {
    // TODO: deprecated since v3. Cleanup some day
    throw new Error('UpdateNode is deprecated. Use AssignmentNode instead.');
  }

  return UpdateNode;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.abs" id="apidoc.module.mathjs.abs">module mathjs.abs</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.abs.factory" id="apidoc.element.mathjs.abs.factory">
        function <span class="apidocSignatureSpan">mathjs.abs.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
<span class="apidocCodeCommentSpan">  /**
   * Calculate the absolute value of a number. For matrices, the function is
   * evaluated element wise.
   *
   * Syntax:
   *
   *    math.abs(x)
   *
   * Examples:
   *
   *    math.abs(3.5);                // returns number 3.5
   *    math.abs(-4.2);               // returns number 4.2
   *
   *    math.abs([3, -5, -1, 0, 2]);  // returns Array [3, 5, 1, 0, 2]
   *
   * See also:
   *
   *    sign
   *
   * @param  {number | BigNumber | Fraction | Complex | Array | Matrix | Unit} x
   *            A number or matrix for which to get the absolute value
   * @return {number | BigNumber | Fraction | Complex | Array | Matrix | Unit}
   *            Absolute value of `x`
   */
</span>  var abs = typed('abs', {
    'number': Math.abs,

    'Complex': function (x) {
      return x.abs();
    },

    'BigNumber': function (x) {
      return x.abs();
    },

    'Fraction': function (x) {
      return x.abs();
    },

    'Array | Matrix': function (x) {
      // deep map collection, skip zeros since abs(0) = 0
      return deepMap(x, abs, true);
    },

    'Unit': function(x) {
      return x.abs();
    }
  });

  abs.toTex = {1: '\\left|${args[0]}\\right|'};

  return abs;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.acos" id="apidoc.module.mathjs.acos">module mathjs.acos</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.acos.factory" id="apidoc.element.mathjs.acos.factory">
        function <span class="apidocSignatureSpan">mathjs.acos.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {

<span class="apidocCodeCommentSpan">  /**
   * Calculate the inverse cosine of a value.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.acos(x)
   *
   * Examples:
   *
   *    math.acos(0.5);           // returns number 1.0471975511965979
   *    math.acos(math.cos(1.5)); // returns number 1.5
   *
   *    math.acos(2);             // returns Complex 0 + 1.3169578969248166 i
   *
   * See also:
   *
   *    cos, atan, asin
   *
   * @param {number | BigNumber | Complex | Array | Matrix} x  Function input
   * @return {number | BigNumber | Complex | Array | Matrix} The arc cosine of x
   */
</span>  var acos = typed('acos', {
    'number': function (x) {
      if ((x &gt;= -1 &amp;&amp; x &lt;= 1) || config.predictable) {
        return Math.acos(x);
      }
      else {
        return new type.Complex(x, 0).acos();
      }
    },

    'Complex': function (x) {
      return x.acos();
    },

    'BigNumber': function (x) {
      return x.acos();
    },

    'Array | Matrix': function (x) {
      return deepMap(x, acos);
    }
  });

  acos.toTex = {1: '\\cos^{-1}\\left(${args[0]}\\right)'};

  return acos;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.acosh" id="apidoc.module.mathjs.acosh">module mathjs.acosh</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.acosh.factory" id="apidoc.element.mathjs.acosh.factory">
        function <span class="apidocSignatureSpan">mathjs.acosh.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {

<span class="apidocCodeCommentSpan">  /**
   * Calculate the hyperbolic arccos of a value,
   * defined as `acosh(x) = ln(sqrt(x^2 - 1) + x)`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.acosh(x)
   *
   * Examples:
   *
   *    math.acosh(1.5);       // returns 0.9624236501192069
   *
   * See also:
   *
   *    cosh, asinh, atanh
   *
   * @param {number | Complex | Unit | Array | Matrix} x  Function input
   * @return {number | Complex | Array | Matrix} Hyperbolic arccosine of x
   */
</span>  var acosh = typed('acosh', {
    'number': function (x) {
      if (x &gt;= 1 || config.predictable) {
        return _acosh(x);
      }
      if (x &lt;= -1) {
        return new type.Complex(Math.log(Math.sqrt(x*x - 1) - x), Math.PI);
      }
      return new type.Complex(x, 0).acosh();
    },

    'Complex': function (x) {
      return x.acosh();
    },

    'BigNumber': function (x) {
      return x.acosh();
    },

    'Array | Matrix': function (x) {
      return deepMap(x, acosh);
    }
  });

  acosh.toTex = {1: '\\cosh^{-1}\\left(${args[0]}\\right)'};

  return acosh;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.acot" id="apidoc.module.mathjs.acot">module mathjs.acot</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.acot.factory" id="apidoc.element.mathjs.acot.factory">
        function <span class="apidocSignatureSpan">mathjs.acot.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {

<span class="apidocCodeCommentSpan">  /**
   * Calculate the inverse cotangent of a value, defined as `acot(x) = atan(1/x)`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.acot(x)
   *
   * Examples:
   *
   *    math.acot(0.5);           // returns number 0.4636476090008061
   *    math.acot(math.cot(1.5)); // returns number 1.5
   *
   *    math.acot(2);             // returns Complex 1.5707963267948966 -1.3169578969248166 i
   *
   * See also:
   *
   *    cot, atan
   *
   * @param {number | Complex | Array | Matrix} x   Function input
   * @return {number | Complex | Array | Matrix} The arc cotangent of x
   */
</span>  var acot = typed('acot', {
    'number': function (x) {
      return Math.atan(1 / x);
    },

    'Complex': function (x) {
      return x.acot();
    },

    'BigNumber': function (x) {
      return new type.BigNumber(1).div(x).atan();
    },

    'Array | Matrix': function (x) {
      return deepMap(x, acot);
    }
  });

  acot.toTex = {1: '\\cot^{-1}\\left(${args[0]}\\right)'};

  return acot;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.acoth" id="apidoc.module.mathjs.acoth">module mathjs.acoth</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.acoth.factory" id="apidoc.element.mathjs.acoth.factory">
        function <span class="apidocSignatureSpan">mathjs.acoth.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {

<span class="apidocCodeCommentSpan">  /**
   * Calculate the hyperbolic arccotangent of a value,
   * defined as `acoth(x) = atanh(1/x) = (ln((x+1)/x) + ln(x/(x-1))) / 2`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.acoth(x)
   *
   * Examples:
   *
   *    math.acoth(0.5);       // returns 0.8047189562170503
   *
   * See also:
   *
   *    acsch, asech
   *
   * @param {number | Complex | Array | Matrix} x  Function input
   * @return {number | Complex | Array | Matrix} Hyperbolic arccotangent of x
   */
</span>  var acoth = typed('acoth', {
    'number': function (x) {
      if (x &gt;= 1 || x &lt;= -1 || config.predictable) {
        return isFinite(x) ? (Math.log((x+1)/x) + Math.log(x/(x-1))) / 2 : 0;
      }
      return new type.Complex(x, 0).acoth();
    },

    'Complex': function (x) {
      return x.acoth();
    },

    'BigNumber': function (x) {
      return new type.BigNumber(1).div(x).atanh();
    },

    'Array | Matrix': function (x) {
      return deepMap(x, acoth);
    }
  });

  acoth.toTex = {1: '\\coth^{-1}\\left(${args[0]}\\right)'};

  return acoth;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.acsc" id="apidoc.module.mathjs.acsc">module mathjs.acsc</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.acsc.factory" id="apidoc.element.mathjs.acsc.factory">
        function <span class="apidocSignatureSpan">mathjs.acsc.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {

<span class="apidocCodeCommentSpan">  /**
   * Calculate the inverse cosecant of a value, defined as `acsc(x) = asin(1/x)`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.acsc(x)
   *
   * Examples:
   *
   *    math.acsc(0.5);           // returns number 0.5235987755982989
   *    math.acsc(math.csc(1.5)); // returns number ~1.5
   *
   *    math.acsc(2);             // returns Complex 1.5707963267948966 -1.3169578969248166 i
   *
   * See also:
   *
   *    csc, asin, asec
   *
   * @param {number | Complex | Array | Matrix} x   Function input
   * @return {number | Complex | Array | Matrix} The arc cosecant of x
   */
</span>  var acsc = typed('acsc', {
    'number': function (x) {
      if (x &lt;= -1 || x &gt;= 1 || config.predictable) {
        return Math.asin(1 / x);
      }
      return new type.Complex(x, 0).acsc();
    },

    'Complex': function (x) {
      return x.acsc();
    },

    'BigNumber': function (x) {
      return new type.BigNumber(1).div(x).asin();
    },

    'Array | Matrix': function (x) {
      return deepMap(x, acsc);
    }
  });

  acsc.toTex = {1: '\\csc^{-1}\\left(${args[0]}\\right)'};

  return acsc;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.acsch" id="apidoc.module.mathjs.acsch">module mathjs.acsch</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.acsch.factory" id="apidoc.element.mathjs.acsch.factory">
        function <span class="apidocSignatureSpan">mathjs.acsch.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {

<span class="apidocCodeCommentSpan">  /**
   * Calculate the hyperbolic arccosecant of a value,
   * defined as `acsch(x) = asinh(1/x) = ln(1/x + sqrt(1/x^2 + 1))`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.acsch(x)
   *
   * Examples:
   *
   *    math.acsch(0.5);       // returns 1.4436354751788103
   *
   * See also:
   *
   *    asech, acoth
   *
   * @param {number | Complex | Array | Matrix} x  Function input
   * @return {number | Complex | Array | Matrix} Hyperbolic arccosecant of x
   */
</span>  var acsch = typed('acsch', {
    'number': function (x) {
      x = 1 / x;
      return Math.log(x + Math.sqrt(x*x + 1));
    },

    'Complex': function (x) {
      return x.acsch();
    },

    'BigNumber': function (x) {
      return new type.BigNumber(1).div(x).asinh();
    },

    'Array | Matrix': function (x) {
      return deepMap(x, acsch);
    }
  });

  acsch.toTex = {1: '\\mathrm{csch}^{-1}\\left(${args[0]}\\right)'};

  return acsch;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.add" id="apidoc.module.mathjs.add">module mathjs.add</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.add.factory" id="apidoc.element.mathjs.add.factory">
        function <span class="apidocSignatureSpan">mathjs.add.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {

  var matrix = load(require('../../type/matrix/function/matrix'));
  var addScalar = load(require('./addScalar'));
  var latex = require('../../utils/latex.js');

  var algorithm01 = load(require('../../type/matrix/utils/algorithm01'));
  var algorithm04 = load(require('../../type/matrix/utils/algorithm04'));
  var algorithm10 = load(require('../../type/matrix/utils/algorithm10'));
  var algorithm13 = load(require('../../type/matrix/utils/algorithm13'));
  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));

<span class="apidocCodeCommentSpan">  /**
   * Add two or more values, `x + y`.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.add(x, y)
   *    math.add(x, y, z, ...)
   *
   * Examples:
   *
   *    math.add(2, 3);               // returns number 5
   *    math.add(2, 3, 4);            // returns number 9
   *
   *    var a = math.complex(2, 3);
   *    var b = math.complex(-4, 1);
   *    math.add(a, b);               // returns Complex -2 + 4i
   *
   *    math.add([1, 2, 3], 4);       // returns Array [5, 6, 7]
   *
   *    var c = math.unit('5 cm');
   *    var d = math.unit('2.1 mm');
   *    math.add(c, d);               // returns Unit 52.1 mm
   *
   *    math.add("2.3", "4");         // returns number 6.3
   *
   * See also:
   *
   *    subtract, sum
   *
   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x First value to add
   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} y Second value to add
   * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} Sum of `x` and `y`
   */
</span>  var add = typed('add', extend({
    // we extend the signatures of addScalar with signatures dealing with matrices

    'Matrix, Matrix': function (x, y) {
      // result
      var c;

      // process matrix storage
      switch (x.storage()) {
        case 'sparse':
          switch (y.storage()) {
            case 'sparse':
              // sparse + sparse
              c = algorithm04(x, y, addScalar);
              break;
            default:
              // sparse + dense
              c = algorithm01(y, x, addScalar, true);
              break;
          }
          break;
        default:
          switch (y.storage()) {
            case 'sparse':
              // dense + sparse
              c = algorithm01(x, y, addScalar, false);
              break;
            default:
              // dense + dense
              c = algorithm13(x, y, addScalar);
              break;
          }
          break;
      }
      return c;
    },

    'Array, Array': function (x, y) {
      // use matrix implementation
      return add(matrix(x), matrix(y)).valueOf();
    },

    'Array, Matrix': function (x, y) {
      // use matrix implementation
      return add(matrix(x), y);
    },

    'Matrix, Array': function (x, y) {
      // use matrix implementation
      return add(x, matrix(y));
    },

    'Matrix, any': function (x, y) {
      // result
      var c;
      // check storage format
      switch (x.storage()) {
        case 'sparse':
          c = algorithm10(x, y, addScalar, false);
          break;
        default:
          c = algorithm14(x, y, addScalar, false);
          break;
      }
      return c;
    },

    'any, Matrix': function (x, y) {
      // result
      var c;
      // check storage format
      switch (y.storage()) {
        case 'sparse':
          c = algorithm10(y, x, addScalar, true);
          break;
        default:
          c = algorithm14(y, x, addScalar, true);
          break;
      }
      return c;
    },

    'Array, any': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(x), y, addScalar, false).valueOf();
    },

    'any, Array': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(y), x, addScalar, true).valueOf();
    },

    'any, any': addScalar,

    'any, any, ...any': function (x, y, rest) {
      var result = add(x, y);

      f ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.addScalar" id="apidoc.module.mathjs.addScalar">module mathjs.addScalar</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.addScalar.factory" id="apidoc.element.mathjs.addScalar.factory">
        function <span class="apidocSignatureSpan">mathjs.addScalar.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {

<span class="apidocCodeCommentSpan">  /**
   * Add two scalar values, `x + y`.
   * This function is meant for internal use: it is used by the public function
   * `add`
   *
   * This function does not support collections (Array or Matrix), and does
   * not validate the number of of inputs.
   *
   * @param  {number | BigNumber | Fraction | Complex | Unit} x   First value to add
   * @param  {number | BigNumber | Fraction | Complex} y          Second value to add
   * @return {number | BigNumber | Fraction | Complex | Unit}                      Sum of `x` and `y`
   * @private
   */
</span>  var add = typed('add', {

    'number, number': function (x, y) {
      return x + y;
    },

    'Complex, Complex': function (x, y) {
      return x.add(y);
    },

    'BigNumber, BigNumber': function (x, y) {
      return x.plus(y);
    },

    'Fraction, Fraction': function (x, y) {
      return x.add(y);
    },

    'Unit, Unit': function (x, y) {
      if (x.value == null) throw new Error('Parameter x contains a unit with undefined value');
      if (y.value == null) throw new Error('Parameter y contains a unit with undefined value');
      if (!x.equalBase(y)) throw new Error('Units do not match');

      var res = x.clone();
      res.value = add(res.value, y.value);
      res.fixPrefix = false;
      return res;
    }
  });

  return add;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.and" id="apidoc.module.mathjs.and">module mathjs.and</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.and.factory" id="apidoc.element.mathjs.and.factory">
        function <span class="apidocSignatureSpan">mathjs.and.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var latex = require('../../utils/latex');

  var matrix = load(require('../../type/matrix/function/matrix'));
  var zeros = load(require('../matrix/zeros'));
  var not = load(require('./not'));
  var isZero = load(require('../utils/isZero'));

  var algorithm02 = load(require('../../type/matrix/utils/algorithm02'));
  var algorithm06 = load(require('../../type/matrix/utils/algorithm06'));
  var algorithm11 = load(require('../../type/matrix/utils/algorithm11'));
  var algorithm13 = load(require('../../type/matrix/utils/algorithm13'));
  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));

<span class="apidocCodeCommentSpan">  /**
   * Logical `and`. Test whether two values are both defined with a nonzero/nonempty value.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.and(x, y)
   *
   * Examples:
   *
   *    math.and(2, 4);   // returns true
   *
   *    a = [2, 0, 0];
   *    b = [3, 7, 0];
   *    c = 0;
   *
   *    math.and(a, b);   // returns [true, false, false]
   *    math.and(a, c);   // returns [false, false, false]
   *
   * See also:
   *
   *    not, or, xor
   *
   * @param  {number | BigNumber | Complex | Unit | Array | Matrix} x First value to check
   * @param  {number | BigNumber | Complex | Unit | Array | Matrix} y Second value to check
   * @return {boolean | Array | Matrix}
   *            Returns true when both inputs are defined with a nonzero/nonempty value.
   */
</span>  var and = typed('and', {

    'number, number': function (x, y) {
      return !!(x &amp;&amp; y);
    },

    'Complex, Complex': function (x, y) {
      return (x.re !== 0 || x.im !== 0) &amp;&amp; (y.re !== 0 || y.im !== 0);
    },

    'BigNumber, BigNumber': function (x, y) {
      return !x.isZero() &amp;&amp; !y.isZero() &amp;&amp; !x.isNaN() &amp;&amp; !y.isNaN();
    },

    'Unit, Unit': function (x, y) {
      return and(x.value, y.value);
    },

    'Matrix, Matrix': function (x, y) {
      // result
      var c;

      // process matrix storage
      switch (x.storage()) {
        case 'sparse':
          switch (y.storage()) {
            case 'sparse':
              // sparse &amp; sparse
              c = algorithm06(x, y, and, false);
              break;
            default:
              // sparse &amp; dense
              c = algorithm02(y, x, and, true);
              break;
          }
          break;
        default:
          switch (y.storage()) {
            case 'sparse':
              // dense &amp; sparse
              c = algorithm02(x, y, and, false);
              break;
            default:
              // dense &amp; dense
              c = algorithm13(x, y, and);
              break;
          }
          break;
      }
      return c;
    },

    'Array, Array': function (x, y) {
      // use matrix implementation
      return and(matrix(x), matrix(y)).valueOf();
    },

    'Array, Matrix': function (x, y) {
      // use matrix implementation
      return and(matrix(x), y);
    },

    'Matrix, Array': function (x, y) {
      // use matrix implementation
      return and(x, matrix(y));
    },

    'Matrix, any': function (x, y) {
      // check scalar
      if (not(y)) {
        // return zero matrix
        return zeros(x.size(), x.storage());
      }
      // result
      var c;
      // check storage format
      switch (x.storage()) {
        case 'sparse':
          c = algorithm11(x, y, and, false);
          break;
        default:
          c = algorithm14(x, y, and, false);
          break;
      }
      return c;
    },

    'any, Matrix': function (x, y) {
      // check scalar
      if (not(x)) {
        // return zero matrix
        return zeros(x.size(), x.storage());
      }
      // result
      var c;
      // check storage format
      switch (y.storage()) {
        case 'sparse':
          c = algorithm11(y, x, and, true);
          break;
        default:
          c = algorithm14(y, x, and, true);
          break;
      }
      return c;
    },

    'Array, any': function (x, y) {
      // use matrix implementation
      return and(matrix(x), y).val ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.arg" id="apidoc.module.mathjs.arg">module mathjs.arg</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.arg.factory" id="apidoc.element.mathjs.arg.factory">
        function <span class="apidocSignatureSpan">mathjs.arg.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
<span class="apidocCodeCommentSpan">  /**
   * Compute the argument of a complex value.
   * For a complex number `a + bi`, the argument is computed as `atan2(b, a)`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.arg(x)
   *
   * Examples:
   *
   *    var a = math.complex(2, 2);
   *    math.arg(a) / math.pi;          // returns number 0.25
   *
   *    var b = math.complex('2 + 3i');
   *    math.arg(b);                    // returns number 0.982793723247329
   *    math.atan2(3, 2);               // returns number 0.982793723247329
   *
   * See also:
   *
   *    re, im, conj, abs
   *
   * @param {number | BigNumber | Complex | Array | Matrix} x
   *            A complex number or array with complex numbers
   * @return {number | BigNumber | Array | Matrix} The argument of x
   */
</span>  var arg = typed('arg', {
    'number': function (x) {
      return Math.atan2(0, x);
    },

    'BigNumber': function (x) {
      return type.BigNumber.atan2(0, x);
    },

    'Complex': function (x) {
      return x.arg();
    },

    // TODO: implement BigNumber support for function arg

    'Array | Matrix': function (x) {
      return deepMap(x, arg);
    }
  });

  arg.toTex = {1: '\\arg\\left(${args[0]}\\right)'};

  return arg;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.array" id="apidoc.module.mathjs.array">module mathjs.array</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.array.flatten" id="apidoc.element.mathjs.array.flatten">
        function <span class="apidocSignatureSpan">mathjs.array.</span>flatten
        <span class="apidocSignatureSpan">(array)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">flatten = function (array) {
  if (!Array.isArray(array)) {
    //if not an array, return as is
    return array;
  }
  var flat = [];

  array.forEach(function callback(value) {
    if (Array.isArray(value)) {
      value.forEach(callback);  //traverse through sub-arrays recursively
    }
    else {
      flat.push(value);
    }
  });

  return flat;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @returns {Array}               Array whose data has been formatted to fit the
 *                                specified dimensions
 *
 * @throws {DimensionError}       If the product of the new dimension sizes does
 *                                not equal that of the old ones
 */
exports.reshape = function(array, sizes) {
var flatArray = exports.<span class="apidocCodeKeywordSpan">flatten</span>(array);
var newArray;

var product = function (arr) {
  return arr.reduce(function (prev, curr) {
    return prev * curr;
  });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.array.isArray" id="apidoc.element.mathjs.array.isArray">
        function <span class="apidocSignatureSpan">mathjs.array.</span>isArray
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isArray() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    extra_nodes = (options &amp;&amp; options.nodes) ? options.nodes : {};

    if (typeof expr === 'string') {
// parse a single expression
expression = expr;
return parseStart();
    }
    else if (Array.<span class="apidocCodeKeywordSpan">isArray</span>(expr) || expr instanceof type.Matrix) {
// parse an array or matrix with expressions
return deepMap(expr, function (elem) {
  if (typeof elem !== 'string') throw new TypeError('String expected');

  expression = elem;
  return parseStart();
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.array.reshape" id="apidoc.element.mathjs.array.reshape">
        function <span class="apidocSignatureSpan">mathjs.array.</span>reshape
        <span class="apidocSignatureSpan">(array, sizes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reshape = function (array, sizes) {
  var flatArray = exports.flatten(array);
  var newArray;

  var product = function (arr) {
    return arr.reduce(function (prev, curr) {
      return prev * curr;
    });
  };

  if (!Array.isArray(array) || !Array.isArray(sizes)) {
    throw new TypeError('Array expected');
  }

  if (sizes.length === 0) {
    throw new DimensionError(0, product(exports.size(array)), '!=');
  }

  try {
    newArray  = _reshape(flatArray, sizes);
  } catch (e) {
    if (e instanceof DimensionError) {
      throw new DimensionError(
        product(sizes),
        product(exports.size(array)),
        '!='
      );
    }
    throw e;
  }

  if (flatArray.length &gt; 0) {
    throw new DimensionError(
      product(sizes),
      product(exports.size(array)),
      '!='
    );
  }

  return newArray;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var matrix = load(require('../../type/matrix/function/matrix'));

/**
 * Reshape a multi dimensional array to fit the specified dimensions
 *
 * Syntax:
 *
 *     math.<span class="apidocCodeKeywordSpan">reshape</span>(x, sizes)
 *
 * Examples:
 *
 *     math.reshape([1, 2, 3, 4, 5, 6], [2, 3]);
 *     // returns Array  [[1, 2, 3], [4, 5, 6]]
 *
 *     math.reshape([[1, 2], [3, 4]], [1, 4]);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.array.resize" id="apidoc.element.mathjs.array.resize">
        function <span class="apidocSignatureSpan">mathjs.array.</span>resize
        <span class="apidocSignatureSpan">(array, size, defaultValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resize = function (array, size, defaultValue) {
  // TODO: add support for scalars, having size=[] ?

  // check the type of the arguments
  if (!Array.isArray(array) || !Array.isArray(size)) {
    throw new TypeError('Array expected');
  }
  if (size.length === 0) {
    throw new Error('Resizing to scalar is not supported');
  }

  // check whether size contains positive integers
  size.forEach(function (value) {
    if (!number.isNumber(value) || !number.isInteger(value) || value &lt; 0) {
      throw new TypeError('Invalid size, must contain positive integers ' +
          '(size: ' + string.format(size) + ')');
    }
  });

  // recursively resize the array
  var _defaultValue = (defaultValue !== undefined) ? defaultValue : 0;
  _resize(array, size, 0, _defaultValue);

  return array;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // get matrix storage constructor
  var F = type.Matrix.storage(format);
  // create diagonal matrix (use optimized implementation for storage format)
  return F.diagonal(size, one, 0, defaultValue);
}

// create and resize array
var res = array.<span class="apidocCodeKeywordSpan">resize</span>([], size, defaultValue);
// fill in ones on the diagonal
var minimum = rows &lt; cols ? rows : cols;
// fill diagonal
for (var d = 0; d &lt; minimum; d++) {
  res[d][d] = one;
}
return res;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.array.size" id="apidoc.element.mathjs.array.size">
        function <span class="apidocSignatureSpan">mathjs.array.</span>size
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">size = function (x) {
  var s = [];

  while (Array.isArray(x)) {
    s.push(x.length);
    x = x[0];
  }

  return s;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

if (!Array.isArray(array) || !Array.isArray(sizes)) {
  throw new TypeError('Array expected');
}

if (sizes.length === 0) {
  throw new DimensionError(0, product(exports.<span class="apidocCodeKeywordSpan">size</span>(array)), '!=');
}

try {
  newArray  = _reshape(flatArray, sizes);
} catch (e) {
  if (e instanceof DimensionError) {
    throw new DimensionError(
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.array.squeeze" id="apidoc.element.mathjs.array.squeeze">
        function <span class="apidocSignatureSpan">mathjs.array.</span>squeeze
        <span class="apidocSignatureSpan">(array, size)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">squeeze = function (array, size) {
  var s = size || exports.size(array);

  // squeeze outer dimensions
  while (Array.isArray(array) &amp;&amp; array.length === 1) {
    array = array[0];
    s.shift();
  }

  // find the first dimension to be squeezed
  var dims = s.length;
  while (s[dims - 1] === 1) {
    dims--;
  }

  // squeeze inner dimensions
  if (dims &lt; s.length) {
    array = _squeeze(array, dims, 0);
    s.length = dims;
  }

  return array;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * @param {Array} y  Second vector
   * @returns {Array} Returns the cross product of x and y
   * @private
   */
  function _cross(x, y) {
var highestDimension = Math.max(array.size(x).length, array.size(y).length);

x = array.<span class="apidocCodeKeywordSpan">squeeze</span>(x);
y = array.squeeze(y);

var xSize = array.size(x);
var ySize = array.size(y);

if (xSize.length != 1 || ySize.length != 1 || xSize[0] != 3 || ySize[0] != 3) {
  throw new RangeError('Vectors with length 3 expected ' +
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.array.unsqueeze" id="apidoc.element.mathjs.array.unsqueeze">
        function <span class="apidocSignatureSpan">mathjs.array.</span>unsqueeze
        <span class="apidocSignatureSpan">(array, dims, outer, size)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unsqueeze = function (array, dims, outer, size) {
  var s = size || exports.size(array);

  // unsqueeze outer dimensions
  if (outer) {
    for (var i = 0; i &lt; outer; i++) {
      array = [array];
      s.unshift(1);
    }
  }

  // unsqueeze inner dimensions
  array = _unsqueeze(array, dims, 0);
  while (s.length &lt; dims) {
    s.push(1);
  }

  return array;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  while (iSize[i] === 1) {
    outer++;
    i++;
  }

  // unsqueeze both outer and inner dimensions
  submatrix = array.<span class="apidocCodeKeywordSpan">unsqueeze</span>(submatrix, iSize.length, outer, sSize);
}

// check whether the size of the submatrix matches the index size
if (!object.deepEqual(iSize, sSize)) {
  throw new DimensionError(iSize, sSize, '&gt;');
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.array.validate" id="apidoc.element.mathjs.array.validate">
        function <span class="apidocSignatureSpan">mathjs.array.</span>validate
        <span class="apidocSignatureSpan">(array, size)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validate = function (array, size) {
  var isScalar = (size.length == 0);
  if (isScalar) {
    // scalar
    if (Array.isArray(array)) {
      throw new DimensionError(array.length, 0);
    }
  }
  else {
    // array
    _validate(array, size, 0);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
else if (isArray(data)) {
  // replace nested Matrices with Arrays
  this._data = preprocess(data);
  // get the dimensions of the array
  this._size = array.size(this._data);
  // verify the dimensions of the array, TODO: compute size while processing array
  array.<span class="apidocCodeKeywordSpan">validate</span>(this._data, this._size);
  // data type unknown
  this._datatype = datatype;
}
else if (data) {
  // unsupported type
  throw new TypeError('Unsupported type of data (' + util.types.type(data) + ')');
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.array.validateIndex" id="apidoc.element.mathjs.array.validateIndex">
        function <span class="apidocSignatureSpan">mathjs.array.</span>validateIndex
        <span class="apidocSignatureSpan">(index, length)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validateIndex = function (index, length) {
  if (!number.isNumber(index) || !number.isInteger(index)) {
    throw new TypeError('Index must be an integer (value: ' + index + ')');
  }
  if (index &lt; 0 || (typeof length === 'number' &amp;&amp; index &gt;= length)) {
    throw new IndexError(index, length);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.asec" id="apidoc.module.mathjs.asec">module mathjs.asec</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.asec.factory" id="apidoc.element.mathjs.asec.factory">
        function <span class="apidocSignatureSpan">mathjs.asec.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {

<span class="apidocCodeCommentSpan">  /**
   * Calculate the inverse secant of a value. Defined as `asec(x) = acos(1/x)`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.asec(x)
   *
   * Examples:
   *
   *    math.asec(0.5);           // returns 1.0471975511965979
   *    math.asec(math.sec(1.5)); // returns 1.5
   *
   *    math.asec(2);             // returns 0 + 1.3169578969248166 i
   *
   * See also:
   *
   *    acos, acot, acsc
   *
   * @param {number | Complex | Array | Matrix} x  Function input
   * @return {number | Complex | Array | Matrix} The arc secant of x
   */
</span>  var asec = typed('asec', {
    'number': function (x) {
      if (x &lt;= -1 || x &gt;= 1 || config.predictable) {
        return Math.acos(1 / x);
      }
      return new type.Complex(x, 0).asec();
    },

    'Complex': function (x) {
      return x.asec();
    },

    'BigNumber': function (x) {
      return new type.BigNumber(1).div(x).acos();
    },

    'Array | Matrix': function (x) {
      return deepMap(x, asec);
    }
  });

  asec.toTex = {1: '\\sec^{-1}\\left(${args[0]}\\right)'};

  return asec;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.asech" id="apidoc.module.mathjs.asech">module mathjs.asech</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.asech.factory" id="apidoc.element.mathjs.asech.factory">
        function <span class="apidocSignatureSpan">mathjs.asech.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var acosh = typed.find(load(require('./acosh')), ['Complex']);

<span class="apidocCodeCommentSpan">  /**
   * Calculate the hyperbolic arcsecant of a value,
   * defined as `asech(x) = acosh(1/x) = ln(sqrt(1/x^2 - 1) + 1/x)`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.asech(x)
   *
   * Examples:
   *
   *    math.asech(0.5);       // returns 1.3169578969248166
   *
   * See also:
   *
   *    acsch, acoth
   *
   * @param {number | Complex | Array | Matrix} x  Function input
   * @return {number | Complex | Array | Matrix} Hyperbolic arcsecant of x
   */
</span>  var asech = typed('asech', {
    'number': function (x) {
      if ((x &lt;= 1 &amp;&amp; x &gt;= -1) || config.predictable) {
        x = 1 / x;

        var ret = Math.sqrt(x*x - 1);
        if (x &gt; 0 || config.predictable) {
          return Math.log(ret + x);
        }

        return new type.Complex(Math.log(ret - x), Math.PI);
      }

      return new type.Complex(x, 0).asech();
    },

    'Complex': function (x) {
      return x.asech()
    },

    'BigNumber': function (x) {
      return new type.BigNumber(1).div(x).acosh();
    },

    'Array | Matrix': function (x) {
      return deepMap(x, asech);
    }
  });

  asech.toTex = {1: '\\mathrm{sech}^{-1}\\left(${args[0]}\\right)'};

  return asech;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.asin" id="apidoc.module.mathjs.asin">module mathjs.asin</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.asin.factory" id="apidoc.element.mathjs.asin.factory">
        function <span class="apidocSignatureSpan">mathjs.asin.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {

<span class="apidocCodeCommentSpan">  /**
   * Calculate the inverse sine of a value.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.asin(x)
   *
   * Examples:
   *
   *    math.asin(0.5);           // returns number 0.5235987755982989
   *    math.asin(math.sin(1.5)); // returns number ~1.5
   *
   *    math.asin(2);             // returns Complex 1.5707963267948966 -1.3169578969248166 i
   *
   * See also:
   *
   *    sin, atan, acos
   *
   * @param {number | BigNumber | Complex | Array | Matrix} x   Function input
   * @return {number | BigNumber | Complex | Array | Matrix} The arc sine of x
   */
</span>  var asin = typed('asin', {
    'number': function (x) {
      if ((x &gt;= -1 &amp;&amp; x &lt;= 1) || config.predictable) {
        return Math.asin(x);
      }
      else {
        return new type.Complex(x, 0).asin();
      }
    },

    'Complex': function (x) {
      return x.asin();
    },

    'BigNumber': function (x) {
      return x.asin();
    },

    'Array | Matrix': function (x) {
      // deep map collection, skip zeros since asin(0) = 0
      return deepMap(x, asin, true);
    }
  });

  asin.toTex = {1: '\\sin^{-1}\\left(${args[0]}\\right)'};

  return asin;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.asinh" id="apidoc.module.mathjs.asinh">module mathjs.asinh</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.asinh.factory" id="apidoc.element.mathjs.asinh.factory">
        function <span class="apidocSignatureSpan">mathjs.asinh.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {

<span class="apidocCodeCommentSpan">  /**
   * Calculate the hyperbolic arcsine of a value,
   * defined as `asinh(x) = ln(x + sqrt(x^2 + 1))`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.asinh(x)
   *
   * Examples:
   *
   *    math.asinh(0.5);       // returns 0.48121182505960347
   *
   * See also:
   *
   *    acosh, atanh
   *
   * @param {number | Complex | Array | Matrix} x  Function input
   * @return {number | Complex | Array | Matrix} Hyperbolic arcsine of x
   */
</span>  var asinh = typed('asinh', {
    'number': Math.asinh || function (x) {
      return Math.log(Math.sqrt(x*x + 1) + x);
    },

    'Complex': function (x) {
        return x.asinh();
    },

    'BigNumber': function (x) {
      return x.asinh();
    },

    'Array | Matrix': function (x) {
      // deep map collection, skip zeros since asinh(0) = 0
      return deepMap(x, asinh, true);
    }
  });

  asinh.toTex = {1: '\\sinh^{-1}\\left(${args[0]}\\right)'};

  return asinh;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.atan" id="apidoc.module.mathjs.atan">module mathjs.atan</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.atan.factory" id="apidoc.element.mathjs.atan.factory">
        function <span class="apidocSignatureSpan">mathjs.atan.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {

<span class="apidocCodeCommentSpan">  /**
   * Calculate the inverse tangent of a value.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.atan(x)
   *
   * Examples:
   *
   *    math.atan(0.5);           // returns number 0.4636476090008061
   *    math.atan(math.tan(1.5)); // returns number 1.5
   *
   *    math.atan(2);             // returns Complex 1.5707963267948966 -1.3169578969248166 i
   *
   * See also:
   *
   *    tan, asin, acos
   *
   * @param {number | BigNumber | Complex | Array | Matrix} x   Function input
   * @return {number | BigNumber | Complex | Array | Matrix} The arc tangent of x
   */
</span>  var atan = typed('atan', {
    'number': function (x) {
      return Math.atan(x);
    },

    'Complex': function (x) {
      return x.atan();
    },

    'BigNumber': function (x) {
      return x.atan();
    },

    'Array | Matrix': function (x) {
      // deep map collection, skip zeros since atan(0) = 0
      return deepMap(x, atan, true);
    }
  });

  atan.toTex = {1: '\\tan^{-1}\\left(${args[0]}\\right)'};

  return atan;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.atan2" id="apidoc.module.mathjs.atan2">module mathjs.atan2</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.atan2.factory" id="apidoc.element.mathjs.atan2.factory">
        function <span class="apidocSignatureSpan">mathjs.atan2.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {

  var matrix = load(require('../../type/matrix/function/matrix'));

  var algorithm02 = load(require('../../type/matrix/utils/algorithm02'));
  var algorithm03 = load(require('../../type/matrix/utils/algorithm03'));
  var algorithm09 = load(require('../../type/matrix/utils/algorithm09'));
  var algorithm11 = load(require('../../type/matrix/utils/algorithm11'));
  var algorithm12 = load(require('../../type/matrix/utils/algorithm12'));
  var algorithm13 = load(require('../../type/matrix/utils/algorithm13'));
  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));

<span class="apidocCodeCommentSpan">  /**
   * Calculate the inverse tangent function with two arguments, y/x.
   * By providing two arguments, the right quadrant of the computed angle can be
   * determined.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.atan2(y, x)
   *
   * Examples:
   *
   *    math.atan2(2, 2) / math.pi;       // returns number 0.25
   *
   *    var angle = math.unit(60, 'deg'); // returns Unit 60 deg
   *    var x = math.cos(angle);
   *    var y = math.sin(angle);
   *
   *    math.atan(2);             // returns Complex 1.5707963267948966 -1.3169578969248166 i
   *
   * See also:
   *
   *    tan, atan, sin, cos
   *
   * @param {number | Array | Matrix} y  Second dimension
   * @param {number | Array | Matrix} x  First dimension
   * @return {number | Array | Matrix} Four-quadrant inverse tangent
   */
</span>  var atan2 = typed('atan2', {

    'number, number': Math.atan2,

    // Complex numbers doesn't seem to have a reasonable implementation of
    // atan2(). Even Matlab removed the support, after they only calculated
    // the atan only on base of the real part of the numbers and ignored the imaginary.

    'BigNumber, BigNumber': function (y, x) {
      return type.BigNumber.atan2(y, x);
    },

    'Matrix, Matrix': function (x, y) {
      // result
      var c;

      // process matrix storage
      switch (x.storage()) {
        case 'sparse':
          switch (y.storage()) {
            case 'sparse':
              // sparse .* sparse
              c = algorithm09(x, y, atan2, false);
              break;
            default:
              // sparse .* dense
              c = algorithm02(y, x, atan2, true);
              break;
          }
          break;
        default:
          switch (y.storage()) {
            case 'sparse':
              // dense .* sparse
              c = algorithm03(x, y, atan2, false);
              break;
            default:
              // dense .* dense
              c = algorithm13(x, y, atan2);
              break;
          }
          break;
      }
      return c;
    },

    'Array, Array': function (x, y) {
      // use matrix implementation
      return atan2(matrix(x), matrix(y)).valueOf();
    },

    'Array, Matrix': function (x, y) {
      // use matrix implementation
      return atan2(matrix(x), y);
    },

    'Matrix, Array': function (x, y) {
      // use matrix implementation
      return atan2(x, matrix(y));
    },

    'Matrix, number | BigNumber': function (x, y) {
      // result
      var c;
      // check storage format
      switch (x.storage()) {
        case 'sparse':
          c = algorithm11(x, y, atan2, false);
          break;
        default:
          c = algorithm14(x, y, atan2, false);
          break;
      }
      return c;
    },

    'number | BigNumber, Matrix': function (x, y) {
      // result
      var c;
      // check storage format
      switch (y.storage()) {
        case 'sparse':
          c = algorithm12(y, x, atan2, true);
          break;
        default:
          c = algorithm14(y, x, atan2, true);
          break;
      }
      return c;
    },

    'Array, number | BigNumber': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(x), y, atan2, false).valueOf();
    },

    'number | BigNumber, Array': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(y), x, atan2, true).valueOf();
    }
  });

  at ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.atanh" id="apidoc.module.mathjs.atanh">module mathjs.atanh</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.atanh.factory" id="apidoc.element.mathjs.atanh.factory">
        function <span class="apidocSignatureSpan">mathjs.atanh.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
<span class="apidocCodeCommentSpan">  /**
   * Calculate the hyperbolic arctangent of a value,
   * defined as `atanh(x) = ln((1 + x)/(1 - x)) / 2`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.atanh(x)
   *
   * Examples:
   *
   *    math.atanh(0.5);       // returns 0.5493061443340549
   *
   * See also:
   *
   *    acosh, asinh
   *
   * @param {number | Complex | Array | Matrix} x  Function input
   * @return {number | Complex | Array | Matrix} Hyperbolic arctangent of x
   */
</span>  var atanh = typed('atanh', {
    'number': function (x) {
      if ((x &lt;= 1 &amp;&amp; x &gt;= -1) || config.predictable) {
        return _atanh(x);
      }
      return new type.Complex(x, 0).atanh();
    },

    'Complex': function (x) {
      return x.atanh();
    },

    'BigNumber': function (x) {
      return x.atanh();
    },

    'Array | Matrix': function (x) {
      // deep map collection, skip zeros since atanh(0) = 0
      return deepMap(x, atanh, true);
    }
  });

  atanh.toTex = {1: '\\tanh^{-1}\\left(${args[0]}\\right)'};

  return atanh;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.bellNumbers" id="apidoc.module.mathjs.bellNumbers">module mathjs.bellNumbers</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.bellNumbers.factory" id="apidoc.element.mathjs.bellNumbers.factory">
        function <span class="apidocSignatureSpan">mathjs.bellNumbers.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var add = load(require('../arithmetic/add'));
  var stirlingS2 = load(require('./stirlingS2'));
  var isNegative = load(require('../utils/isNegative'));
  var isInteger = load(require('../utils/isInteger'));

<span class="apidocCodeCommentSpan">  /**
   * The Bell Numbers count the number of partitions of a set. A partition is a pairwise disjoint subset of S whose union is S.
   * bellNumbers only takes integer arguments.
   * The following condition must be enforced: n &gt;= 0
   *
   * Syntax:
   *
   *   math.bellNumbers(n)
   *
   * Examples:
   *
   *    math.bellNumbers(3); // returns 5;
   *    math.bellNumbers(8); // returns 4140;
   *
   * See also:
   *
   *    stirlingS2
   *
   * @param {Number | BigNumber} n    Total number of objects in the set
   * @return {Number | BigNumber}     B(n)
   */
</span>  var bellNumbers = typed('bellNumbers', {
    'number | BigNumber': function (n) {

      if (!isInteger(n) || isNegative(n)) {
        throw new TypeError('Non-negative integer value expected in function bellNumbers');
      }

      // Sum (k=0, n) S(n,k).
      var result = 0;
      for(var i = 0; i &lt;= n; i++) {
        result = add(result, stirlingS2(n, i));
      }

      return result;
    }
  });

  bellNumbers.toTex = {1: '\\mathrm{B}_{${args[0]}}'};

  return bellNumbers;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.bitAnd" id="apidoc.module.mathjs.bitAnd">module mathjs.bitAnd</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.bitAnd.factory" id="apidoc.element.mathjs.bitAnd.factory">
        function <span class="apidocSignatureSpan">mathjs.bitAnd.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var latex = require('../../utils/latex');

  var matrix = load(require('../../type/matrix/function/matrix'));

  var algorithm02 = load(require('../../type/matrix/utils/algorithm02'));
  var algorithm06 = load(require('../../type/matrix/utils/algorithm06'));
  var algorithm11 = load(require('../../type/matrix/utils/algorithm11'));
  var algorithm13 = load(require('../../type/matrix/utils/algorithm13'));
  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));

<span class="apidocCodeCommentSpan">  /**
   * Bitwise AND two values, `x &amp; y`.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.bitAnd(x, y)
   *
   * Examples:
   *
   *    math.bitAnd(53, 131);               // returns number 1
   *
   *    math.bitAnd([1, 12, 31], 42);       // returns Array [0, 8, 10]
   *
   * See also:
   *
   *    bitNot, bitOr, bitXor, leftShift, rightArithShift, rightLogShift
   *
   * @param  {number | BigNumber | Array | Matrix} x First value to and
   * @param  {number | BigNumber | Array | Matrix} y Second value to and
   * @return {number | BigNumber | Array | Matrix} AND of `x` and `y`
   */
</span>  var bitAnd = typed('bitAnd', {

    'number, number': function (x, y) {
      if (!isInteger(x) || !isInteger(y)) {
        throw new Error('Integers expected in function bitAnd');
      }

      return x &amp; y;
    },

    'BigNumber, BigNumber': bigBitAnd,

    'Matrix, Matrix': function (x, y) {
      // result
      var c;

      // process matrix storage
      switch (x.storage()) {
        case 'sparse':
          switch (y.storage()) {
            case 'sparse':
              // sparse &amp; sparse
              c = algorithm06(x, y, bitAnd, false);
              break;
            default:
              // sparse &amp; dense
              c = algorithm02(y, x, bitAnd, true);
              break;
          }
          break;
        default:
          switch (y.storage()) {
            case 'sparse':
              // dense &amp; sparse
              c = algorithm02(x, y, bitAnd, false);
              break;
            default:
              // dense &amp; dense
              c = algorithm13(x, y, bitAnd);
              break;
          }
          break;
      }
      return c;
    },

    'Array, Array': function (x, y) {
      // use matrix implementation
      return bitAnd(matrix(x), matrix(y)).valueOf();
    },

    'Array, Matrix': function (x, y) {
      // use matrix implementation
      return bitAnd(matrix(x), y);
    },

    'Matrix, Array': function (x, y) {
      // use matrix implementation
      return bitAnd(x, matrix(y));
    },

    'Matrix, any': function (x, y) {
      // result
      var c;
      // check storage format
      switch (x.storage()) {
        case 'sparse':
          c = algorithm11(x, y, bitAnd, false);
          break;
        default:
          c = algorithm14(x, y, bitAnd, false);
          break;
      }
      return c;
    },

    'any, Matrix': function (x, y) {
      // result
      var c;
      // check storage format
      switch (y.storage()) {
        case 'sparse':
          c = algorithm11(y, x, bitAnd, true);
          break;
        default:
          c = algorithm14(y, x, bitAnd, true);
          break;
      }
      return c;
    },

    'Array, any': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(x), y, bitAnd, false).valueOf();
    },

    'any, Array': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(y), x, bitAnd, true).valueOf();
    }
  });

  bitAnd.toTex = {
    2: '\\left(${args[0]}' + latex.operators['bitAnd'] + '${args[1]}\\right)'
  };

  return bitAnd;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.bitNot" id="apidoc.module.mathjs.bitNot">module mathjs.bitNot</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.bitNot.factory" id="apidoc.element.mathjs.bitNot.factory">
        function <span class="apidocSignatureSpan">mathjs.bitNot.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var latex = require('../../utils/latex');

<span class="apidocCodeCommentSpan">  /**
   * Bitwise NOT value, `~x`.
   * For matrices, the function is evaluated element wise.
   * For units, the function is evaluated on the best prefix base.
   *
   * Syntax:
   *
   *    math.bitNot(x)
   *
   * Examples:
   *
   *    math.bitNot(1);               // returns number -2
   *
   *    math.bitNot([2, -3, 4]);      // returns Array [-3, 2, 5]
   *
   * See also:
   *
   *    bitAnd, bitOr, bitXor, leftShift, rightArithShift, rightLogShift
   *
   * @param  {number | BigNumber | Array | Matrix} x Value to not
   * @return {number | BigNumber | Array | Matrix} NOT of `x`
   */
</span>  var bitNot = typed('bitNot', {
    'number': function (x) {
      if (!isInteger(x)) {
        throw new Error('Integer expected in function bitNot');
      }

      return ~x;
    },

    'BigNumber': bigBitNot,

    'Array | Matrix': function (x) {
      return deepMap(x, bitNot);
    }
  });

  bitNot.toTex = {
    1: latex.operators['bitNot'] + '\\left(${args[0]}\\right)'
  };

  return bitNot;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.bitOr" id="apidoc.module.mathjs.bitOr">module mathjs.bitOr</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.bitOr.factory" id="apidoc.element.mathjs.bitOr.factory">
        function <span class="apidocSignatureSpan">mathjs.bitOr.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var latex = require('../../utils/latex');

  var matrix = load(require('../../type/matrix/function/matrix'));

  var algorithm01 = load(require('../../type/matrix/utils/algorithm01'));
  var algorithm04 = load(require('../../type/matrix/utils/algorithm04'));
  var algorithm10 = load(require('../../type/matrix/utils/algorithm10'));
  var algorithm13 = load(require('../../type/matrix/utils/algorithm13'));
  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));

<span class="apidocCodeCommentSpan">  /**
   * Bitwise OR two values, `x | y`.
   * For matrices, the function is evaluated element wise.
   * For units, the function is evaluated on the lowest print base.
   *
   * Syntax:
   *
   *    math.bitOr(x, y)
   *
   * Examples:
   *
   *    math.bitOr(1, 2);               // returns number 3
   *
   *    math.bitOr([1, 2, 3], 4);       // returns Array [5, 6, 7]
   *
   * See also:
   *
   *    bitAnd, bitNot, bitXor, leftShift, rightArithShift, rightLogShift
   *
   * @param  {number | BigNumber | Array | Matrix} x First value to or
   * @param  {number | BigNumber | Array | Matrix} y Second value to or
   * @return {number | BigNumber | Array | Matrix} OR of `x` and `y`
   */
</span>  var bitOr = typed('bitOr', {

    'number, number': function (x, y) {
      if (!isInteger(x) || !isInteger(y)) {
        throw new Error('Integers expected in function bitOr');
      }

      return x | y;
    },

    'BigNumber, BigNumber': bigBitOr,

    'Matrix, Matrix': function (x, y) {
      // result
      var c;

      // process matrix storage
      switch (x.storage()) {
        case 'sparse':
          switch (y.storage()) {
            case 'sparse':
              // sparse + sparse
              c = algorithm04(x, y, bitOr);
              break;
            default:
              // sparse + dense
              c = algorithm01(y, x, bitOr, true);
              break;
          }
          break;
        default:
          switch (y.storage()) {
            case 'sparse':
              // dense + sparse
              c = algorithm01(x, y, bitOr, false);
              break;
            default:
              c = algorithm13(x, y, bitOr);
              break;
          }
          break;
      }
      return c;
    },

    'Array, Array': function (x, y) {
      // use matrix implementation
      return bitOr(matrix(x), matrix(y)).valueOf();
    },

    'Array, Matrix': function (x, y) {
      // use matrix implementation
      return bitOr(matrix(x), y);
    },

    'Matrix, Array': function (x, y) {
      // use matrix implementation
      return bitOr(x, matrix(y));
    },

    'Matrix, any': function (x, y) {
      // result
      var c;
      // check storage format
      switch (x.storage()) {
        case 'sparse':
          c = algorithm10(x, y, bitOr, false);
          break;
        default:
          c = algorithm14(x, y, bitOr, false);
          break;
      }
      return c;
    },

    'any, Matrix': function (x, y) {
      // result
      var c;
      // check storage format
      switch (y.storage()) {
        case 'sparse':
          c = algorithm10(y, x, bitOr, true);
          break;
        default:
          c = algorithm14(y, x, bitOr, true);
          break;
      }
      return c;
    },

    'Array, any': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(x), y, bitOr, false).valueOf();
    },

    'any, Array': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(y), x, bitOr, true).valueOf();
    }
  });

  bitOr.toTex = {
    2: '\\left(${args[0]}' + latex.operators['bitOr'] + '${args[1]}\\right)'
  };

  return bitOr;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.bitXor" id="apidoc.module.mathjs.bitXor">module mathjs.bitXor</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.bitXor.factory" id="apidoc.element.mathjs.bitXor.factory">
        function <span class="apidocSignatureSpan">mathjs.bitXor.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var latex = require('../../utils/latex');

  var matrix = load(require('../../type/matrix/function/matrix'));

  var algorithm03 = load(require('../../type/matrix/utils/algorithm03'));
  var algorithm07 = load(require('../../type/matrix/utils/algorithm07'));
  var algorithm12 = load(require('../../type/matrix/utils/algorithm12'));
  var algorithm13 = load(require('../../type/matrix/utils/algorithm13'));
  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));

<span class="apidocCodeCommentSpan">  /**
   * Bitwise XOR two values, `x ^ y`.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.bitXor(x, y)
   *
   * Examples:
   *
   *    math.bitXor(1, 2);               // returns number 3
   *
   *    math.bitXor([2, 3, 4], 4);       // returns Array [6, 7, 0]
   *
   * See also:
   *
   *    bitAnd, bitNot, bitOr, leftShift, rightArithShift, rightLogShift
   *
   * @param  {number | BigNumber | Array | Matrix} x First value to xor
   * @param  {number | BigNumber | Array | Matrix} y Second value to xor
   * @return {number | BigNumber | Array | Matrix} XOR of `x` and `y`
   */
</span>  var bitXor = typed('bitXor', {

    'number, number': function (x, y) {
      if (!isInteger(x) || !isInteger(y)) {
        throw new Error('Integers expected in function bitXor');
      }

      return x ^ y;
    },

    'BigNumber, BigNumber': bigBitXor,

    'Matrix, Matrix': function (x, y) {
      // result
      var c;

      // process matrix storage
      switch (x.storage()) {
        case 'sparse':
          switch (y.storage()) {
            case 'sparse':
              // sparse + sparse
              c = algorithm07(x, y, bitXor);
              break;
            default:
              // sparse + dense
              c = algorithm03(y, x, bitXor, true);
              break;
          }
          break;
        default:
          switch (y.storage()) {
            case 'sparse':
              // dense + sparse
              c = algorithm03(x, y, bitXor, false);
              break;
            default:
              // dense + dense
              c = algorithm13(x, y, bitXor);
              break;
          }
          break;
      }
      return c;
    },

    'Array, Array': function (x, y) {
      // use matrix implementation
      return bitXor(matrix(x), matrix(y)).valueOf();
    },

    'Array, Matrix': function (x, y) {
      // use matrix implementation
      return bitXor(matrix(x), y);
    },

    'Matrix, Array': function (x, y) {
      // use matrix implementation
      return bitXor(x, matrix(y));
    },

    'Matrix, any': function (x, y) {
      // result
      var c;
      // check storage format
      switch (x.storage()) {
        case 'sparse':
          c = algorithm12(x, y, bitXor, false);
          break;
        default:
          c = algorithm14(x, y, bitXor, false);
          break;
      }
      return c;
    },

    'any, Matrix': function (x, y) {
      // result
      var c;
      // check storage format
      switch (y.storage()) {
        case 'sparse':
          c = algorithm12(y, x, bitXor, true);
          break;
        default:
          c = algorithm14(y, x, bitXor, true);
          break;
      }
      return c;
    },

    'Array, any': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(x), y, bitXor, false).valueOf();
    },

    'any, Array': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(y), x, bitXor, true).valueOf();
    }
  });

  bitXor.toTex = {
    2: '\\left(${args[0]}' + latex.operators['bitXor'] + '${args[1]}\\right)'
  };

  return bitXor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.boolean" id="apidoc.module.mathjs.boolean">module mathjs.boolean</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.boolean.factory" id="apidoc.element.mathjs.boolean.factory">
        function <span class="apidocSignatureSpan">mathjs.boolean.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
<span class="apidocCodeCommentSpan">  /**
   * Create a boolean or convert a string or number to a boolean.
   * In case of a number, `true` is returned for non-zero numbers, and `false` in
   * case of zero.
   * Strings can be `'true'` or `'false'`, or can contain a number.
   * When value is a matrix, all elements will be converted to boolean.
   *
   * Syntax:
   *
   *    math.boolean(x)
   *
   * Examples:
   *
   *    math.boolean(0);     // returns false
   *    math.boolean(1);     // returns true
   *    math.boolean(-3);     // returns true
   *    math.boolean('true');     // returns true
   *    math.boolean('false');     // returns false
   *    math.boolean([1, 0, 1, 1]);     // returns [true, false, true, true]
   *
   * See also:
   *
   *    bignumber, complex, index, matrix, string, unit
   *
   * @param {string | number | boolean | Array | Matrix | null} value  A value of any type
   * @return {boolean | Array | Matrix} The boolean value
   */
</span>  var bool = typed('bool', {
    '': function () {
      return false;
    },

    'boolean': function (x) {
      return x;
    },

    'number': function (x) {
      return !!x;
    },

    'BigNumber': function (x) {
      return !x.isZero();
    },

    'string': function (x) {
      // try case insensitive
      var lcase = x.toLowerCase();
      if (lcase === 'true') {
        return true;
      }
      else if (lcase === 'false') {
        return false;
      }

      // test whether value is a valid number
      var num = Number(x);
      if (x != '' &amp;&amp; !isNaN(num)) {
        return !!num;
      }

      throw new Error('Cannot convert "' + x + '" to a boolean');
    },

    'Array | Matrix': function (x) {
      return deepMap(x, bool);
    }
  });

  return bool;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.catalan" id="apidoc.module.mathjs.catalan">module mathjs.catalan</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.catalan.factory" id="apidoc.element.mathjs.catalan.factory">
        function <span class="apidocSignatureSpan">mathjs.catalan.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var add = load(require('../arithmetic/add'));
  var divide = load(require('../arithmetic/divide'));
  var multiply = load(require('../arithmetic/multiply'));
  var combinations = load(require('../probability/combinations'));
  var isNegative = load(require('../utils/isNegative'));
  var isInteger = load(require('../utils/isInteger'));


<span class="apidocCodeCommentSpan">  /**
   * The Catalan Numbers enumerate combinatorial structures of many different types.
   * catalan only takes integer arguments.
   * The following condition must be enforced: n &gt;= 0
   *
   * Syntax:
   *
   *   math.catalan(n)
   *
   * Examples:
   *
   *    math.catalan(3); // returns 5;
   *    math.catalan(8); // returns 1430;
   *
   * See also:
   *
   *    bellNumbers
   *
   * @param {Number | BigNumber} n    nth Catalan number
   * @return {Number | BigNumber}     Cn(n)
   */
</span>  var catalan = typed('catalan', {
    'number | BigNumber': function (n) {

      if (!isInteger(n) || isNegative(n)) {
        throw new TypeError('Non-negative integer value expected in function catalan');
      }

      return divide(combinations(multiply(n,2), n), add(n,1));

    }
  });

  catalan.toTex = {1: '\\mathrm{C}_{${args[0]}}'};

  return catalan;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.cbrt" id="apidoc.module.mathjs.cbrt">module mathjs.cbrt</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.cbrt.factory" id="apidoc.element.mathjs.cbrt.factory">
        function <span class="apidocSignatureSpan">mathjs.cbrt.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var unaryMinus = load(require('./unaryMinus'));
  var isNegative = load(require('../utils/isNegative'));
  var matrix = load(require('../../type/matrix/function/matrix'));

<span class="apidocCodeCommentSpan">  /**
   * Calculate the cubic root of a value.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.cbrt(x)
   *    math.cbrt(x, allRoots)
   *
   * Examples:
   *
   *    math.cbrt(27);                  // returns 3
   *    math.cube(3);                   // returns 27
   *    math.cbrt(-64);                 // returns -4
   *    math.cbrt(math.unit('27 m^3')); // returns Unit 3 m
   *    math.cbrt([27, 64, 125]);       // returns [3, 4, 5]
   *
   *    var x = math.complex('8i');
   *    math.cbrt(x);                   // returns Complex 1.7320508075689 + i
   *    math.cbrt(x, true);             // returns Matrix [
   *                                    //    1.7320508075689 + i
   *                                    //   -1.7320508075689 + i
   *                                    //   -2i
   *                                    // ]
   *
   * See also:
   *
   *    square, sqrt, cube
   *
   * @param {number | BigNumber | Complex | Unit | Array | Matrix} x
   *            Value for which to calculate the cubic root.
   * @param {boolean} [allRoots]  Optional, false by default. Only applicable
   *            when `x` is a number or complex number. If true, all complex
   *            roots are returned, if false (default) the principal root is
   *            returned.
   * @return {number | BigNumber | Complex | Unit | Array | Matrix}
   *            Returns the cubic root of `x`
   */
</span>  var cbrt = typed('cbrt', {
    'number': _cbrtNumber,
    // note: signature 'number, boolean' is also supported,
    //       created by typed as it knows how to convert number to Complex

    'Complex': _cbrtComplex,

    'Complex, boolean': _cbrtComplex,

    'BigNumber': function (x) {
      return x.cbrt();
    },

    'Unit': _cbrtUnit,

    'Array | Matrix': function (x) {
      // deep map collection, skip zeros since cbrt(0) = 0
      return deepMap(x, cbrt, true);
    }
  });

  /**
   * Calculate the cubic root for a complex number
   * @param {Complex} x
   * @param {boolean} [allRoots]   If true, the function will return an array
   *                               with all three roots. If false or undefined,
   *                               the principal root is returned.
   * @returns {Complex | Array.&lt;Complex&gt; | Matrix.&lt;Complex&gt;} Returns the cubic root(s) of x
   * @private
   */
  function _cbrtComplex(x, allRoots) {
    // https://www.wikiwand.com/en/Cube_root#/Complex_numbers

    var arg_3 = x.arg() / 3;
    var abs = x.abs();

    // principal root:
    var principal = new type.Complex(_cbrtNumber(abs), 0).mul(
        new type.Complex(0, arg_3).exp());

    if (allRoots) {
      var all = [
          principal,
          new type.Complex(_cbrtNumber(abs), 0).mul(
            new type.Complex(0, arg_3 + Math.PI * 2 / 3).exp()),
          new type.Complex(_cbrtNumber(abs), 0).mul(
            new type.Complex(0, arg_3 - Math.PI * 2 / 3).exp())
      ];

      return (config.matrix === 'Array') ? all : matrix(all);
    }
    else {
      return principal;
    }
  }

  /**
   * Calculate the cubic root for a Unit
   * @param {Unit} x
   * @return {Unit} Returns the cubic root of x
   * @private
   */
  function _cbrtUnit(x) {
    if(x.value &amp;&amp; x.value.isComplex) {
      var result = x.clone();
      result.value = 1.0;
      result = result.pow(1.0/3);           // Compute the units
      result.value = _cbrtComplex(x.value); // Compute the value
      return result;
    }
    else {
      var negate = isNegative(x.value);
      if (negate) {
        x.value = unaryMinus(x.value);
      }

      // TODO: create a helper function for this
      var third;
      if (x.value &amp;&amp; x.value.isBigNumber) {
        third = new type.BigNumber(1).div(3);
      }
      else if (x.value &amp;&amp; x.value.isFraction) {
        third = new type.Fraction(1, 3);
      } ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.ceil" id="apidoc.module.mathjs.ceil">module mathjs.ceil</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.ceil.factory" id="apidoc.element.mathjs.ceil.factory">
        function <span class="apidocSignatureSpan">mathjs.ceil.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
<span class="apidocCodeCommentSpan">  /**
   * Round a value towards plus infinity
   * If `x` is complex, both real and imaginary part are rounded towards plus infinity.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.ceil(x)
   *
   * Examples:
   *
   *    math.ceil(3.2);               // returns number 4
   *    math.ceil(3.8);               // returns number 4
   *    math.ceil(-4.2);              // returns number -4
   *    math.ceil(-4.7);              // returns number -4
   *
   *    var c = math.complex(3.2, -2.7);
   *    math.ceil(c);                 // returns Complex 4 - 2i
   *
   *    math.ceil([3.2, 3.8, -4.7]);  // returns Array [4, 4, -4]
   *
   * See also:
   *
   *    floor, fix, round
   *
   * @param  {number | BigNumber | Fraction | Complex | Array | Matrix} x  Number to be rounded
   * @return {number | BigNumber | Fraction | Complex | Array | Matrix} Rounded value
   */
</span>  var ceil = typed('ceil', {
    'number': Math.ceil,

    'Complex': function (x) {
      return x.ceil();
    },

    'BigNumber': function (x) {
      return x.ceil();
    },

    'Fraction': function (x) {
      return x.ceil();
    },

    'Array | Matrix': function (x) {
      // deep map collection, skip zeros since ceil(0) = 0
      return deepMap(x, ceil, true);
    }
  });

  ceil.toTex = {1: '\\left\\lceil${args[0]}\\right\\rceil'};

  return ceil;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.clone" id="apidoc.module.mathjs.clone">module mathjs.clone</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.clone.factory" id="apidoc.element.mathjs.clone.factory">
        function <span class="apidocSignatureSpan">mathjs.clone.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
<span class="apidocCodeCommentSpan">  /**
   * Clone an object.
   *
   * Syntax:
   *
   *     math.clone(x)
   *
   * Examples:
   *
   *    math.clone(3.5);                   // returns number 3.5
   *    math.clone(math.complex('2-4i'); // returns Complex 2 - 4i
   *    math.clone(math.unit(45, 'deg'));  // returns Unit 45 deg
   *    math.clone([[1, 2], [3, 4]]);      // returns Array [[1, 2], [3, 4]]
   *    math.clone("hello world");         // returns string "hello world"
   *
   * @param {*} x   Object to be cloned
   * @return {*} A clone of object x
   */
</span>  var clone = typed('clone', {
    'any': object.clone
  });

  clone.toTex = undefined; // use default template

  return clone;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.combinations" id="apidoc.module.mathjs.combinations">module mathjs.combinations</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.combinations.factory" id="apidoc.element.mathjs.combinations.factory">
        function <span class="apidocSignatureSpan">mathjs.combinations.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
<span class="apidocCodeCommentSpan">  /**
   * Compute the number of ways of picking `k` unordered outcomes from `n`
   * possibilities.
   *
   * Combinations only takes integer arguments.
   * The following condition must be enforced: k &lt;= n.
   *
   * Syntax:
   *
   *     math.combinations(n, k)
   *
   * Examples:
   *
   *    math.combinations(7, 5); // returns 21
   *
   * See also:
   *
   *    permutations, factorial
   *
   * @param {number | BigNumber} n    Total number of objects in the set
   * @param {number | BigNumber} k    Number of objects in the subset
   * @return {number | BigNumber}     Number of possible combinations.
   */
</span>  var combinations = typed('combinations', {
    'number, number': function (n, k) {
      var max, result, i;

      if (!isInteger(n) || n &lt; 0) {
        throw new TypeError('Positive integer value expected in function combinations');
      }
      if (!isInteger(k) || k &lt; 0) {
        throw new TypeError('Positive integer value expected in function combinations');
      }
      if (k &gt; n) {
        throw new TypeError('k must be less than or equal to n');
      }

      max = Math.max(k, n - k);
      result = 1;
      for (i = 1; i &lt;= n - max; i++) {
        result = result * (max + i) / i;
      }

      return result;
    },

    'BigNumber, BigNumber': function (n, k) {
      var max, result, i, ii;
      var one = new type.BigNumber(1);

      if (!isPositiveInteger(n) || !isPositiveInteger(k)) {
        throw new TypeError('Positive integer value expected in function combinations');
      }
      if (k.gt(n)) {
        throw new TypeError('k must be less than n in function combinations');
      }

      max = n.minus(k);
      if (k.lt(max)) max = k;
      result = one;
      for (i = one, ii = n.minus(max); i.lte(ii); i = i.plus(1)) {
        result = result.times(max.plus(i)).dividedBy(i);
      }

      return result;
    }

    // TODO: implement support for collection in combinations
  });

  combinations.toTex = {2: '\\binom{${args[0]}}{${args[1]}}'};

  return combinations;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.compare" id="apidoc.module.mathjs.compare">module mathjs.compare</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.compare.factory" id="apidoc.element.mathjs.compare.factory">
        function <span class="apidocSignatureSpan">mathjs.compare.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {

  var matrix = load(require('../../type/matrix/function/matrix'));

  var algorithm03 = load(require('../../type/matrix/utils/algorithm03'));
  var algorithm05 = load(require('../../type/matrix/utils/algorithm05'));
  var algorithm12 = load(require('../../type/matrix/utils/algorithm12'));
  var algorithm13 = load(require('../../type/matrix/utils/algorithm13'));
  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));

<span class="apidocCodeCommentSpan">  /**
   * Compare two values. Returns 1 when x &gt; y, -1 when x &lt; y, and 0 when x == y.
   *
   * x and y are considered equal when the relative difference between x and y
   * is smaller than the configured epsilon. The function cannot be used to
   * compare values smaller than approximately 2.22e-16.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.compare(x, y)
   *
   * Examples:
   *
   *    math.compare(6, 1);           // returns 1
   *    math.compare(2, 3);           // returns -1
   *    math.compare(7, 7);           // returns 0
   *
   *    var a = math.unit('5 cm');
   *    var b = math.unit('40 mm');
   *    math.compare(a, b);           // returns 1
   *
   *    math.compare(2, [1, 2, 3]);   // returns [1, 0, -1]
   *
   * See also:
   *
   *    equal, unequal, smaller, smallerEq, larger, largerEq
   *
   * @param  {number | BigNumber | Fraction | Unit | string | Array | Matrix} x First value to compare
   * @param  {number | BigNumber | Fraction | Unit | string | Array | Matrix} y Second value to compare
   * @return {number | BigNumber | Fraction | Array | Matrix} Returns the result of the comparison: 1, 0 or -1.
   */
</span>  var compare = typed('compare', {

    'boolean, boolean': function (x, y) {
      return x === y ? 0 : (x &gt; y ? 1 : -1);
    },

    'number, number': function (x, y) {
      return (x === y || nearlyEqual(x, y, config.epsilon))
          ? 0
          : (x &gt; y ? 1 : -1);
    },

    'BigNumber, BigNumber': function (x, y) {
      return (x.eq(y) || bigNearlyEqual(x, y, config.epsilon))
          ? new type.BigNumber(0)
          : new type.BigNumber(x.cmp(y));
    },

    'Fraction, Fraction': function (x, y) {
      return new type.Fraction(x.compare(y));
    },

    'Complex, Complex': function () {
      throw new TypeError('No ordering relation is defined for complex numbers');
    },

    'Unit, Unit': function (x, y) {
      if (!x.equalBase(y)) {
        throw new Error('Cannot compare units with different base');
      }
      return compare(x.value, y.value);
    },

    'string, string': function (x, y) {
      return x === y ? 0 : (x &gt; y ? 1 : -1);
    },

    'Matrix, Matrix': function (x, y) {
      // result
      var c;

      // process matrix storage
      switch (x.storage()) {
        case 'sparse':
          switch (y.storage()) {
            case 'sparse':
              // sparse + sparse
              c = algorithm05(x, y, compare);
              break;
            default:
              // sparse + dense
              c = algorithm03(y, x, compare, true);
              break;
          }
          break;
        default:
          switch (y.storage()) {
            case 'sparse':
              // dense + sparse
              c = algorithm03(x, y, compare, false);
              break;
            default:
              // dense + dense
              c = algorithm13(x, y, compare);
              break;
          }
          break;
      }
      return c;
    },

    'Array, Array': function (x, y) {
      // use matrix implementation
      return compare(matrix(x), matrix(y)).valueOf();
    },

    'Array, Matrix': function (x, y) {
      // use matrix implementation
      return compare(matrix(x), y);
    },

    'Matrix, Array': function (x, y) {
      // use matrix implementation
      return compare(x, matrix(y));
    },

    'Matrix, any': function (x, y) {
      // result
      var c;
      // check storage format
      switch (x.storage()) {
        case 'sparse':
          c = algorithm12(x, y, compare, false);
          break; ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.compile" id="apidoc.module.mathjs.compile">module mathjs.compile</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.compile.factory" id="apidoc.element.mathjs.compile.factory">
        function <span class="apidocSignatureSpan">mathjs.compile.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var parse = load(require('../parse'));

<span class="apidocCodeCommentSpan">  /**
   * Parse and compile an expression.
   * Returns a an object with a function `eval([scope])` to evaluate the
   * compiled expression.
   *
   * Syntax:
   *
   *     math.compile(expr)                       // returns one node
   *     math.compile([expr1, expr2, expr3, ...]) // returns an array with nodes
   *
   * Examples:
   *
   *     var code = math.compile('sqrt(3^2 + 4^2)');
   *     code.eval(); // 5
   *
   *     var scope = {a: 3, b: 4}
   *     var code = math.compile('a * b'); // 12
   *     code.eval(scope); // 12
   *     scope.a = 5;
   *     code.eval(scope); // 20
   *
   *     var nodes = math.compile(['a = 3', 'b = 4', 'a * b']);
   *     nodes[2].eval(); // 12
   *
   * See also:
   *
   *    parse, eval
   *
   * @param {string | string[] | Array | Matrix} expr
   *            The expression to be compiled
   * @return {{eval: Function} | Array.&lt;{eval: Function}&gt;} code
   *            An object with the compiled expression
   * @throws {Error}
   */
</span>  return typed('compile', {
    'string': function (expr) {
      return parse(expr).compile();
    },

    'Array | Matrix': function (expr) {
      return deepMap(expr, function (entry) {
        return parse(entry).compile();
      });
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.composition" id="apidoc.module.mathjs.composition">module mathjs.composition</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.composition.factory" id="apidoc.element.mathjs.composition.factory">
        function <span class="apidocSignatureSpan">mathjs.composition.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var combinations = load(require('../probability/combinations'));
  var add = load(require('../arithmetic/addScalar'));
  var isPositive = load(require('../utils/isPositive'));
  var isInteger = load(require('../utils/isInteger'));
  var larger = load(require('../relational/larger'));

<span class="apidocCodeCommentSpan">  /**
   * The composition counts of n into k parts.
   *
   * composition only takes integer arguments.
   * The following condition must be enforced: k &lt;= n.
   *
   * Syntax:
   *
   *   math.composition(n, k)
   *
   * Examples:
   *
   *    math.composition(5, 3); // returns 6
   *
   * See also:
   *
   *    combinations
   *
   * @param {Number | BigNumber} n    Total number of objects in the set
   * @param {Number | BigNumber} k    Number of objects in the subset
   * @return {Number | BigNumber}     Returns the composition counts of n into k parts.
   */
</span>  var composition =  typed('composition', {
    'number | BigNumber, number | BigNumber': function (n, k) {
      if (!isInteger(n) || !isPositive(n) || !isInteger(k) || !isPositive(k)) {
        throw new TypeError('Positive integer value expected in function composition');
      }
      else if (larger(k, n)) {
        throw new TypeError('k must be less than or equal to n in function composition');
      }

      return combinations(add(n, -1), add(k, -1));
    }
  });

  composition.toTex = undefined; // use default template

  return composition;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.concat" id="apidoc.module.mathjs.concat">module mathjs.concat</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.concat.factory" id="apidoc.element.mathjs.concat.factory">
        function <span class="apidocSignatureSpan">mathjs.concat.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var matrix = load(require('../../type/matrix/function/matrix'));

<span class="apidocCodeCommentSpan">  /**
   * Concatenate two or more matrices.
   *
   * Syntax:
   *
   *     math.concat(A, B, C, ...)
   *     math.concat(A, B, C, ..., dim)
   *
   * Where:
   *
   * - `dim: number` is a zero-based dimension over which to concatenate the matrices.
   *   By default the last dimension of the matrices.
   *
   * Examples:
   *
   *    var A = [[1, 2], [5, 6]];
   *    var B = [[3, 4], [7, 8]];
   *
   *    math.concat(A, B);                  // returns [[1, 2, 3, 4], [5, 6, 7, 8]]
   *    math.concat(A, B, 0);               // returns [[1, 2], [5, 6], [3, 4], [7, 8]]
   *    math.concat('hello', ' ', 'world'); // returns 'hello world'
   *
   * See also:
   *
   *    size, squeeze, subset, transpose
   *
   * @param {... Array | Matrix} args     Two or more matrices
   * @return {Array | Matrix} Concatenated matrix
   */
</span>  var concat = typed('concat', {
    // TODO: change signature to '...Array | Matrix, dim?' when supported
    '...Array | Matrix | number | BigNumber': function (args) {
      var i;
      var len = args.length;
      var dim = -1;  // zero-based dimension
      var prevDim;
      var asMatrix = false;
      var matrices = [];  // contains multi dimensional arrays

      for (i = 0; i &lt; len; i++) {
        var arg = args[i];

        // test whether we need to return a Matrix (if not we return an Array)
        if (arg &amp;&amp; arg.isMatrix === true) {
          asMatrix = true;
        }

        if (typeof arg === 'number' || (arg &amp;&amp; arg.isBigNumber === true)) {
          if (i !== len - 1) {
            throw new Error('Dimension must be specified as last argument');
          }

          // last argument contains the dimension on which to concatenate
          prevDim = dim;
          dim = arg.valueOf(); // change BigNumber to number

          if (!isInteger(dim)) {
            throw new TypeError('Integer number expected for dimension');
          }

          if (dim &lt; 0 || (i &gt; 0 &amp;&amp; dim &gt; prevDim)) {
            // TODO: would be more clear when throwing a DimensionError here
            throw new IndexError(dim, prevDim + 1);
          }
        }
        else {
          // this is a matrix or array
          var m = clone(arg).valueOf();
          var size = array.size(m);
          matrices[i] = m;
          prevDim = dim;
          dim = size.length - 1;

          // verify whether each of the matrices has the same number of dimensions
          if (i &gt; 0 &amp;&amp; dim != prevDim) {
            throw new DimensionError(prevDim + 1, dim + 1);
          }
        }
      }

      if (matrices.length == 0) {
        throw new SyntaxError('At least one matrix expected');
      }

      var res = matrices.shift();
      while (matrices.length) {
        res = _concat(res, matrices.shift(), dim, 0);
      }

      return asMatrix ? matrix(res) : res;
    },

    '...string': function (args) {
      return args.join('');
    }
  });

  concat.toTex = undefined; // use default template

  return concat;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.concat_transform" id="apidoc.module.mathjs.concat_transform">module mathjs.concat_transform</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.concat_transform.factory" id="apidoc.element.mathjs.concat_transform.factory">
        function <span class="apidocSignatureSpan">mathjs.concat_transform.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var concat = load(require('../../function/matrix/concat'));

  // @see: comment of concat itself
 return typed('concat', {
    '...any': function (args) {
      // change last argument from one-based to zero-based
      var lastIndex = args.length - 1;
      var last = args[lastIndex];
      if (typeof last === 'number') {
        args[lastIndex] = last - 1;
      }
      else if (last &amp;&amp; last.isBigNumber === true) {
        args[lastIndex] = last.minus(1);
      }

      try {
        return concat.apply(null, args);
      }
      catch (err) {
        throw errorTransform(err);
      }
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.config" id="apidoc.module.mathjs.config">module mathjs.config</a></h1>




    <h2>
        <a href="#apidoc.element.mathjs.config.factory" id="apidoc.element.mathjs.config.factory">
        function <span class="apidocSignatureSpan">mathjs.config.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed, math)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed, math) {
  var MATRIX = ['Matrix', 'Array'];                   // valid values for option matrix
  var NUMBER = ['number', 'BigNumber', 'Fraction'];   // valid values for option number

<span class="apidocCodeCommentSpan">  /**
   * Set configuration options for math.js, and get current options.
   * Will emit a 'config' event, with arguments (curr, prev, changes).
   *
   * Syntax:
   *
   *     math.config(config: Object): Object
   *
   * Examples:
   *
   *     math.config().number;                // outputs 'number'
   *     math.eval('0.4');                    // outputs number 0.4
   *     math.config({number: 'Fraction'});
   *     math.eval('0.4');                    // outputs Fraction 2/5
   *
   * @param {Object} [options] Available options:
   *                            {number} epsilon
   *                              Minimum relative difference between two
   *                              compared values, used by all comparison functions.
   *                            {string} matrix
   *                              A string 'Matrix' (default) or 'Array'.
   *                            {string} number
   *                              A string 'number' (default), 'BigNumber', or 'Fraction'
   *                            {number} precision
   *                              The number of significant digits for BigNumbers.
   *                              Not applicable for Numbers.
   *                            {string} parenthesis
   *                              How to display parentheses in LaTeX and string
   *                              output.
   *                            {string} randomSeed
   *                              Random seed for seeded pseudo random number generator.
   *                              Set to null to randomly seed.
   * @return {Object} Returns the current configuration
   */
</span>  function _config(options) {
    if (options) {
      var prev = object.clone(config);

      // validate some of the options
      validateOption(options, 'matrix', MATRIX);
      validateOption(options, 'number', NUMBER);

      // merge options
      object.deepExtend(config, options);

      var curr = object.clone(config);

      var changes = object.clone(options);

      // emit 'config' event
      math.emit('config', curr, prev, changes);

      return curr;
    }
    else {
      return object.clone(config);
    }
  }

  // attach the valid options to the function so they can be extended
  _config.MATRIX = MATRIX;
  _config.NUMBER = NUMBER;

  return _config;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.conj" id="apidoc.module.mathjs.conj">module mathjs.conj</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.conj.factory" id="apidoc.element.mathjs.conj.factory">
        function <span class="apidocSignatureSpan">mathjs.conj.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
<span class="apidocCodeCommentSpan">  /**
   * Compute the complex conjugate of a complex value.
   * If `x = a+bi`, the complex conjugate of `x` is `a - bi`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.conj(x)
   *
   * Examples:
   *
   *    math.conj(math.complex('2 + 3i'));  // returns Complex 2 - 3i
   *    math.conj(math.complex('2 - 3i'));  // returns Complex 2 + 3i
   *    math.conj(math.complex('-5.2i'));  // returns Complex 5.2i
   *
   * See also:
   *
   *    re, im, arg, abs
   *
   * @param {number | BigNumber | Complex | Array | Matrix} x
   *            A complex number or array with complex numbers
   * @return {number | BigNumber | Complex | Array | Matrix}
   *            The complex conjugate of x
   */
</span>  var conj = typed('conj', {
    'number': function (x) {
      return x;
    },

    'BigNumber': function (x) {
      return x;
    },

    'Complex': function (x) {
      return x.conjugate();
    },

    'Array | Matrix': function (x) {
      return deepMap(x, conj);
    }
  });

  conj.toTex = {1: '\\left(${args[0]}\\right)^*'};

  return conj;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.constants" id="apidoc.module.mathjs.constants">module mathjs.constants</a></h1>






    <h2>
        <a href="#apidoc.element.mathjs.constants.factory" id="apidoc.element.mathjs.constants.factory">
        function <span class="apidocSignatureSpan">mathjs.constants.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed, math)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed, math) {
  // listen for changed in the configuration, automatically reload
  // constants when needed
  math.on('config', function (curr, prev) {
    if (curr.number !== prev.number) {
      factory(type, config, load, typed, math);
    }
  });

  setConstant(math, 'true', true);
  setConstant(math, 'false', false);
  setConstant(math, 'null', null);
  setConstant(math, 'uninitialized', require('./utils/array').UNINITIALIZED);

  if (config.number === 'BigNumber') {
    setConstant(math, 'Infinity', new type.BigNumber(Infinity));
    setConstant(math, 'NaN', new type.BigNumber(NaN));

    setLazyConstant(math, 'pi',  function () {return bigConstants.pi(type.BigNumber)});
    setLazyConstant(math, 'tau', function () {return bigConstants.tau(type.BigNumber)});
    setLazyConstant(math, 'e',   function () {return bigConstants.e(type.BigNumber)});
    setLazyConstant(math, 'phi', function () {return bigConstants.phi(type.BigNumber)}); // golden ratio, (1+sqrt(5))/2

    // uppercase constants (for compatibility with built-in Math)
    setLazyConstant(math, 'E',       function () {return math.e;});
    setLazyConstant(math, 'LN2',     function () {return new type.BigNumber(2).ln();});
    setLazyConstant(math, 'LN10',    function () {return new type.BigNumber(10).ln()});
    setLazyConstant(math, 'LOG2E',   function () {return new type.BigNumber(1).div(new type.BigNumber(2).ln());});
    setLazyConstant(math, 'LOG10E',  function () {return new type.BigNumber(1).div(new type.BigNumber(10).ln())});
    setLazyConstant(math, 'PI',      function () {return math.pi});
    setLazyConstant(math, 'SQRT1_2', function () {return new type.BigNumber('0.5').sqrt()});
    setLazyConstant(math, 'SQRT2',   function () {return new type.BigNumber(2).sqrt()});
  }
  else {
    setConstant(math, 'Infinity', Infinity);
    setConstant(math, 'NaN',      NaN);

    setConstant(math, 'pi',  Math.PI);
    setConstant(math, 'tau', Math.PI * 2);
    setConstant(math, 'e',   Math.E);
    setConstant(math, 'phi', 1.61803398874989484820458683436563811772030917980576286213545); // golden ratio, (1+sqrt(5))/2

    // uppercase constants (for compatibility with built-in Math)
    setConstant(math, 'E',           math.e);
    setConstant(math, 'LN2',         Math.LN2);
    setConstant(math, 'LN10',        Math.LN10);
    setConstant(math, 'LOG2E',       Math.LOG2E);
    setConstant(math, 'LOG10E',      Math.LOG10E);
    setConstant(math, 'PI',          math.pi);
    setConstant(math, 'SQRT1_2',     Math.SQRT1_2);
    setConstant(math, 'SQRT2',       Math.SQRT2);
  }

  // complex i
  setConstant(math, 'i', type.Complex.I);

  // meta information
  setConstant(math, 'version', require('./version'));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.core" id="apidoc.module.mathjs.core">module mathjs.core</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.core.create" id="apidoc.element.mathjs.core.create">
        function <span class="apidocSignatureSpan">mathjs.core.</span>create
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function create(options) {
  // simple test for ES5 support
  if (typeof Object.create !== 'function') {
    throw new Error('ES5 not supported by this JavaScript engine. ' +
    'Please load the es5-shim and es5-sham library for compatibility.');
  }

  // cached factories and instances
  var factories = [];
  var instances = [];

  // create a namespace for the mathjs instance, and attach emitter functions
  var math = emitter.mixin({});
  math.type = {};
  math.expression = {
    transform: {},
    mathWithTransform: {}
  };

  // create a new typed instance
  math.typed = typedFactory.create(math.type);

  // create configuration options. These are private
  var _config = {
    // minimum relative difference between two compared values,
    // used by all comparison functions
    epsilon: 1e-12,

    // type of default matrix output. Choose 'matrix' (default) or 'array'
    matrix: 'Matrix',

    // type of default number output. Choose 'number' (default) 'BigNumber', or 'Fraction
    number: 'number',

    // number of significant digits in BigNumbers
    precision: 64,

    // predictable output type of functions. When true, output type depends only
    // on the input types. When false (default), output type can vary depending
    // on input values. For example `math.sqrt(-4)` returns `complex('2i')` when
    // predictable is false, and returns `NaN` when true.
    predictable: false,

    // random seed for seeded pseudo random number generation
    // null = randomly seed
    randomSeed: null
  };

<span class="apidocCodeCommentSpan">  /**
   * Load a function or data type from a factory.
   * If the function or data type already exists, the existing instance is
   * returned.
   * @param {{type: string, name: string, factory: Function}} factory
   * @returns {*}
   */
</span>  function load (factory) {
    if (!isFactory(factory)) {
      throw new Error('Factory object with properties `type`, `name`, and `factory` expected');
    }

    var index = factories.indexOf(factory);
    var instance;
    if (index === -1) {
      // doesn't yet exist
      if (factory.math === true) {
        // pass with math namespace
        instance = factory.factory(math.type, _config, load, math.typed, math);
      }
      else {
        instance = factory.factory(math.type, _config, load, math.typed);
      }

      // append to the cache
      factories.push(factory);
      instances.push(instance);
    }
    else {
      // already existing function, return the cached instance
      instance = instances[index];
    }

    return instance;
  }

  // load the import and config functions
  math['import'] = load(importFactory);
  math['config'] = load(configFactory);
  math.expression.mathWithTransform['config'] = math['config']

  // apply options
  if (options) {
    math.config(options);
  }

  return math;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *                              false (default), output type can vary depending
 *                              on input values. For example `math.sqrt(-4)`
 *                              returns `complex('2i')` when predictable is false, and
 *                              returns `NaN` when true.
 */
function create (config) {
  // create a new math.js instance
  var math = core.<span class="apidocCodeKeywordSpan">create</span>(config);
  math.create = create;

  // import data types, functions, constants, expression parser, etc.
  math['import'](require('./lib'));

  return math;
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.cos" id="apidoc.module.mathjs.cos">module mathjs.cos</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.cos.factory" id="apidoc.element.mathjs.cos.factory">
        function <span class="apidocSignatureSpan">mathjs.cos.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {

<span class="apidocCodeCommentSpan">  /**
   * Calculate the cosine of a value.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.cos(x)
   *
   * Examples:
   *
   *    math.cos(2);                      // returns number -0.4161468365471422
   *    math.cos(math.pi / 4);            // returns number  0.7071067811865475
   *    math.cos(math.unit(180, 'deg'));  // returns number -1
   *    math.cos(math.unit(60, 'deg'));   // returns number  0.5
   *
   *    var angle = 0.2;
   *    math.pow(math.sin(angle), 2) + math.pow(math.cos(angle), 2); // returns number ~1
   *
   * See also:
   *
   *    cos, tan
   *
   * @param {number | BigNumber | Complex | Unit | Array | Matrix} x  Function input
   * @return {number | BigNumber | Complex | Array | Matrix} Cosine of x
   */
</span>  var cos = typed('cos', {
    'number': Math.cos,

    'Complex': function (x) {
      return x.cos();
    },

    'BigNumber': function (x) {
      return x.cos();
    },

    'Unit': function (x) {
      if (!x.hasBase(type.Unit.BASE_UNITS.ANGLE)) {
        throw new TypeError ('Unit in function cos is no angle');
      }
      return cos(x.value);
    },

    'Array | Matrix': function (x) {
      return deepMap(x, cos);
    }
  });

  cos.toTex = {1: '\\cos\\left(${args[0]}\\right)'};

  return cos;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.cosh" id="apidoc.module.mathjs.cosh">module mathjs.cosh</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.cosh.factory" id="apidoc.element.mathjs.cosh.factory">
        function <span class="apidocSignatureSpan">mathjs.cosh.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  /**
   * Calculate the hyperbolic cosine of a value,
   * defined as `cosh(x) = 1/2 * (exp(x) + exp(-x))`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.cosh(x)
   *
   * Examples:
   *
   *    math.cosh(0.5);       // returns number 1.1276259652063807
   *
   * See also:
   *
   *    sinh, tanh
   *
   * @param {number | BigNumber | Complex | Unit | Array | Matrix} x  Function input
   * @return {number | BigNumber | Complex | Array | Matrix} Hyperbolic cosine of x
   */
  var cosh = typed('cosh', {
    'number': _cosh,

    'Complex': function (x) {
      return x.cosh();
    },

    'BigNumber': function (x) {
      return x.cosh();
    },

    'Unit': function (x) {
      if (!x.hasBase(type.Unit.BASE_UNITS.ANGLE)) {
        throw new TypeError ('Unit in function cosh is no angle');
      }
      return cosh(x.value);
    },

    'Array | Matrix': function (x) {
      return deepMap(x, cosh);
    }
  });

  cosh.toTex = {1: '\\cosh\\left(${args[0]}\\right)'};

  return cosh;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.cot" id="apidoc.module.mathjs.cot">module mathjs.cot</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.cot.factory" id="apidoc.element.mathjs.cot.factory">
        function <span class="apidocSignatureSpan">mathjs.cot.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
<span class="apidocCodeCommentSpan">  /**
   * Calculate the cotangent of a value. Defined as `cot(x) = 1 / tan(x)`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.cot(x)
   *
   * Examples:
   *
   *    math.cot(2);      // returns number -0.45765755436028577
   *    1 / math.tan(2);  // returns number -0.45765755436028577
   *
   * See also:
   *
   *    tan, sec, csc
   *
   * @param {number | Complex | Unit | Array | Matrix} x  Function input
   * @return {number | Complex | Array | Matrix} Cotangent of x
   */
</span>  var cot = typed('cot', {
    'number': function (x) {
      return 1 / Math.tan(x);
    },

    'Complex': function (x) {
      return x.cot();
    },

    'BigNumber': function (x) {
      return new type.BigNumber(1).div(x.tan());
    },

    'Unit': function (x) {
      if (!x.hasBase(type.Unit.BASE_UNITS.ANGLE)) {
        throw new TypeError ('Unit in function cot is no angle');
      }
      return cot(x.value);
    },

    'Array | Matrix': function (x) {
      return deepMap(x, cot);
    }
  });

  cot.toTex = {1: '\\cot\\left(${args[0]}\\right)'};

  return cot;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.coth" id="apidoc.module.mathjs.coth">module mathjs.coth</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.coth.factory" id="apidoc.element.mathjs.coth.factory">
        function <span class="apidocSignatureSpan">mathjs.coth.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  /**
   * Calculate the hyperbolic cotangent of a value,
   * defined as `coth(x) = 1 / tanh(x)`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.coth(x)
   *
   * Examples:
   *
   *    // coth(x) = 1 / tanh(x)
   *    math.coth(2);         // returns 1.0373147207275482
   *    1 / math.tanh(2);     // returns 1.0373147207275482
   *
   * See also:
   *
   *    sinh, tanh, cosh
   *
   * @param {number | Complex | Unit | Array | Matrix} x  Function input
   * @return {number | Complex | Array | Matrix} Hyperbolic cotangent of x
   */
  var coth = typed('coth', {
    'number': _coth,

    'Complex': function (x) {
      return x.coth();
    },

    'BigNumber': function (x) {
      return new type.BigNumber(1).div(x.tanh());
    },

    'Unit': function (x) {
      if (!x.hasBase(type.Unit.BASE_UNITS.ANGLE)) {
        throw new TypeError ('Unit in function coth is no angle');
      }
      return coth(x.value);
    },

    'Array | Matrix': function (x) {
      return deepMap(x, coth);
    }
  });

  coth.toTex = {1: '\\coth\\left(${args[0]}\\right)'};

  return coth;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.cross" id="apidoc.module.mathjs.cross">module mathjs.cross</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.cross.factory" id="apidoc.element.mathjs.cross.factory">
        function <span class="apidocSignatureSpan">mathjs.cross.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var matrix   = load(require('../../type/matrix/function/matrix'));
  var subtract = load(require('../arithmetic/subtract'));
  var multiply = load(require('../arithmetic/multiply'));

<span class="apidocCodeCommentSpan">  /**
   * Calculate the cross product for two vectors in three dimensional space.
   * The cross product of `A = [a1, a2, a3]` and `B = [b1, b2, b3]` is defined
   * as:
   *
   *    cross(A, B) = [
   *      a2 * b3 - a3 * b2,
   *      a3 * b1 - a1 * b3,
   *      a1 * b2 - a2 * b1
   *    ]
   *
   * If one of the input vectors has a dimension greater than 1, the output
   * vector will be a 1x3 (2-dimensional) matrix.
   *
   * Syntax:
   *
   *    math.cross(x, y)
   *
   * Examples:
   *
   *    math.cross([1, 1, 0],   [0, 1, 1]);       // Returns [1, -1, 1]
   *    math.cross([3, -3, 1],  [4, 9, 2]);       // Returns [-15, -2, 39]
   *    math.cross([2, 3, 4],   [5, 6, 7]);       // Returns [-3, 6, -3]
   *    math.cross([[1, 2, 3]], [[4], [5], [6]]); // Returns [[-3, 6, -3]]
   *
   * See also:
   *
   *    dot, multiply
   *
   * @param  {Array | Matrix} x   First vector
   * @param  {Array | Matrix} y   Second vector
   * @return {Array | Matrix}     Returns the cross product of `x` and `y`
   */
</span>  var cross = typed('cross', {
    'Matrix, Matrix': function (x, y) {
      return matrix(_cross(x.toArray(), y.toArray()));
    },

    'Matrix, Array': function (x, y) {
      return matrix(_cross(x.toArray(), y));
    },

    'Array, Matrix': function (x, y) {
      return matrix(_cross(x, y.toArray()));
    },

    'Array, Array': _cross
  });

  cross.toTex = {
    2: '\\left(${args[0]}\\right)\\times\\left(${args[1]}\\right)'
  };

  return cross;

  /**
   * Calculate the cross product for two arrays
   * @param {Array} x  First vector
   * @param {Array} y  Second vector
   * @returns {Array} Returns the cross product of x and y
   * @private
   */
  function _cross(x, y) {
    var highestDimension = Math.max(array.size(x).length, array.size(y).length);

    x = array.squeeze(x);
    y = array.squeeze(y);

    var xSize = array.size(x);
    var ySize = array.size(y);

    if (xSize.length != 1 || ySize.length != 1 || xSize[0] != 3 || ySize[0] != 3) {
      throw new RangeError('Vectors with length 3 expected ' +
      '(Size A = [' + xSize.join(', ') + '], B = [' + ySize.join(', ') + '])');
    }

    var product = [
      subtract(multiply(x[1], y[2]), multiply(x[2], y[1])),
      subtract(multiply(x[2], y[0]), multiply(x[0], y[2])),
      subtract(multiply(x[0], y[1]), multiply(x[1], y[0]))
    ];

    if (highestDimension &gt; 1) {
      return [product];
    } else {
      return product;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.csc" id="apidoc.module.mathjs.csc">module mathjs.csc</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.csc.factory" id="apidoc.element.mathjs.csc.factory">
        function <span class="apidocSignatureSpan">mathjs.csc.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
<span class="apidocCodeCommentSpan">  /**
   * Calculate the cosecant of a value, defined as `csc(x) = 1/sin(x)`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.csc(x)
   *
   * Examples:
   *
   *    math.csc(2);      // returns number 1.099750170294617
   *    1 / math.sin(2);  // returns number 1.099750170294617
   *
   * See also:
   *
   *    sin, sec, cot
   *
   * @param {number | Complex | Unit | Array | Matrix} x  Function input
   * @return {number | Complex | Array | Matrix} Cosecant of x
   */
</span>  var csc = typed('csc', {
    'number': function (x) {
      return 1 / Math.sin(x);
    },

    'Complex': function (x) {
      return x.csc();
    },

    'BigNumber': function (x) {
      return new type.BigNumber(1).div(x.sin());
    },

    'Unit': function (x) {
      if (!x.hasBase(type.Unit.BASE_UNITS.ANGLE)) {
        throw new TypeError ('Unit in function csc is no angle');
      }
      return csc(x.value);
    },

    'Array | Matrix': function (x) {
      return deepMap(x, csc);
    }
  });

  csc.toTex = {1: '\\csc\\left(${args[0]}\\right)'};

  return csc;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.csch" id="apidoc.module.mathjs.csch">module mathjs.csch</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.csch.factory" id="apidoc.element.mathjs.csch.factory">
        function <span class="apidocSignatureSpan">mathjs.csch.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  /**
   * Calculate the hyperbolic cosecant of a value,
   * defined as `csch(x) = 1 / sinh(x)`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.csch(x)
   *
   * Examples:
   *
   *    // csch(x) = 1/ sinh(x)
   *    math.csch(0.5);       // returns 1.9190347513349437
   *    1 / math.sinh(0.5);   // returns 1.9190347513349437
   *
   * See also:
   *
   *    sinh, sech, coth
   *
   * @param {number | Complex | Unit | Array | Matrix} x  Function input
   * @return {number | Complex | Array | Matrix} Hyperbolic cosecant of x
   */
  var csch = typed('csch', {
    'number': _csch,

    'Complex': function (x) {
      return x.csch();
    },

    'BigNumber': function (x) {
      return new type.BigNumber(1).div(x.sinh());
    },

    'Unit': function (x) {
      if (!x.hasBase(type.Unit.BASE_UNITS.ANGLE)) {
        throw new TypeError ('Unit in function csch is no angle');
      }
      return csch(x.value);
    },

    'Array | Matrix': function (x) {
      return deepMap(x, csch);
    }
  });

  csch.toTex = {1: '\\mathrm{csch}\\left(${args[0]}\\right)'};

  return csch;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.cube" id="apidoc.module.mathjs.cube">module mathjs.cube</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.cube.factory" id="apidoc.element.mathjs.cube.factory">
        function <span class="apidocSignatureSpan">mathjs.cube.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {

<span class="apidocCodeCommentSpan">  /**
   * Compute the cube of a value, `x * x * x`.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.cube(x)
   *
   * Examples:
   *
   *    math.cube(2);            // returns number 8
   *    math.pow(2, 3);          // returns number 8
   *    math.cube(4);            // returns number 64
   *    4 * 4 * 4;               // returns number 64
   *
   *    math.cube([1, 2, 3, 4]); // returns Array [1, 8, 27, 64]
   *
   * See also:
   *
   *    multiply, square, pow, cbrt
   *
   * @param  {number | BigNumber | Fraction | Complex | Array | Matrix | Unit} x  Number for which to calculate the cube
   * @return {number | BigNumber | Fraction | Complex | Array | Matrix | Unit} Cube of x
   */
</span>  var cube = typed('cube', {
    'number': function (x) {
      return x * x * x;
    },

    'Complex': function (x) {
      return x.mul(x).mul(x); // Is faster than pow(x, 3)
    },

    'BigNumber': function (x) {
      return x.times(x).times(x);
    },

    'Fraction': function (x) {
      return x.pow(3); // Is faster than mul()mul()mul()
    },

    'Array | Matrix': function (x) {
      // deep map collection, skip zeros since cube(0) = 0
      return deepMap(x, cube, true);
    },

    'Unit': function(x) {
      return x.pow(3);
    }
  });

  cube.toTex = {1: '\\left(${args[0]}\\right)^3'};

  return cube;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.deepEqual" id="apidoc.module.mathjs.deepEqual">module mathjs.deepEqual</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.deepEqual.factory" id="apidoc.element.mathjs.deepEqual.factory">
        function <span class="apidocSignatureSpan">mathjs.deepEqual.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var equal = load(require('./equal'));

<span class="apidocCodeCommentSpan">  /**
   * Test element wise whether two matrices are equal.
   * The function accepts both matrices and scalar values.
   *
   * Syntax:
   *
   *    math.deepEqual(x, y)
   *
   * Examples:
   *
   *    math.deepEqual(2, 4);   // returns false
   *
   *    a = [2, 5, 1];
   *    b = [2, 7, 1];
   *
   *    math.deepEqual(a, b);   // returns false
   *    math.equal(a, b);       // returns [true, false, true]
   *
   * See also:
   *
   *    equal, unequal
   *
   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x First matrix to compare
   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} y Second matrix to compare
   * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix}
   *            Returns true when the input matrices have the same size and each of their elements is equal.
   */
</span>  var deepEqual = typed('deepEqual', {
    'any, any': function (x, y) {
      return _deepEqual(x.valueOf(), y.valueOf());
    }
  });

  deepEqual.toTex = undefined; // use default template

  return deepEqual;

  /**
   * Test whether two arrays have the same size and all elements are equal
   * @param {Array | *} x
   * @param {Array | *} y
   * @return {boolean} Returns true if both arrays are deep equal
   */
  function _deepEqual(x, y) {
    if (Array.isArray(x)) {
      if (Array.isArray(y)) {
        var len = x.length;
        if (len !== y.length) {
          return false;
        }

        for (var i = 0; i &lt; len; i++) {
          if (!_deepEqual(x[i], y[i])) {
            return false;
          }
        }

        return true;
      }
      else {
        return false;
      }
    }
    else {
      if (Array.isArray(y)) {
        return false;
      }
      else {
        return equal(x, y);
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.derivative" id="apidoc.module.mathjs.derivative">module mathjs.derivative</a></h1>




    <h2>
        <a href="#apidoc.element.mathjs.derivative.derivative" id="apidoc.element.mathjs.derivative.derivative">
        function <span class="apidocSignatureSpan">mathjs.</span>derivative
        <span class="apidocSignatureSpan">(arg0, arg1, arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function derivative(arg0, arg1, arg2) {
  "use strict";
  var name = 'derivative';
  if (test0(arg0)) { // type: string
    if (test0(arg1)) { // type: string
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: string, string
      }
      if (test1(arg2)) { // type: Object
        if (arguments.length === 3) {
          return signature1(arg0, arg1, arg2); // signature: string, string, Object
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      throw createError(name, arguments.length, 2, arguments[2], 'Object');
    }
    if (test2(arg1)) { // type: SymbolNode
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: string, SymbolNode
      }
      if (test1(arg2)) { // type: Object
        if (arguments.length === 3) {
          return signature3(arg0, arg1, arg2); // signature: string, SymbolNode, Object
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      throw createError(name, arguments.length, 2, arguments[2], 'Object');
    }
    if (test3(arg1)) { // type: number (convert to string)
      if (arguments.length === 2) {
        return signature0(arg0, convert0(arg1)); // signature: string, number
      }
      if (test1(arg2)) { // type: Object
        if (arguments.length === 3) {
          return signature1(arg0, convert0(arg1), arg2); // signature: string, number, Object
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      throw createError(name, arguments.length, 2, arguments[2], 'Object');
    }
    if (test4(arg1)) { // type: boolean (convert to string)
      if (arguments.length === 2) {
        return signature0(arg0, convert1(arg1)); // signature: string, boolean
      }
      if (test1(arg2)) { // type: Object
        if (arguments.length === 3) {
          return signature1(arg0, convert1(arg1), arg2); // signature: string, boolean, Object
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      throw createError(name, arguments.length, 2, arguments[2], 'Object');
    }
    if (test5(arg1)) { // type: null (convert to string)
      if (arguments.length === 2) {
        return signature0(arg0, convert2(arg1)); // signature: string, null
      }
      if (test1(arg2)) { // type: Object
        if (arguments.length === 3) {
          return signature1(arg0, convert2(arg1), arg2); // signature: string, null, Object
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      throw createError(name, arguments.length, 2, arguments[2], 'Object');
    }
    throw createError(name, arguments.length, 1, arguments[1], 'string,SymbolNode');
  }
  if (test6(arg0)) { // type: Node
    if (test0(arg1)) { // type: string
      if (arguments.length === 2) {
        return signature4(arg0, arg1); // signature: Node, string
      }
      if (test1(arg2)) { // type: Object
        if (arguments.length === 3) {
          return signature5(arg0, arg1, arg2); // signature: Node, string, Object
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      throw createError(name, arguments.length, 2, arguments[2], 'Object');
    }
    if (test2(arg1)) { // type: SymbolNode
      if (arguments.length === 2) {
        return signature6(arg0, arg1); // signature: Node, SymbolNode
      }
      if (test1(arg2)) { // type: Object
        if (arguments.length === 3) {
          return signature7(arg0, arg1, arg2); // signature: Node, SymbolNode, Object
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      throw createError(name, arguments.length, 2, arguments[2], 'Object');
    }
    if (t ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// functions and constants
math.round(math.e, 3);            // 2.718
math.atan2(3, -3) / math.pi;      // 0.75
math.log(1000, 10);               // 3
math.sqrt(-4);                    // 2i
math.pow([[-1, 2], [3, 1]], 2);   // [[7, 0], [0, 7]]
math.<span class="apidocCodeKeywordSpan">derivative</span>('x^2 + x', 'x');  // 2 * x + 1

// expressions
math.eval('12 / (2.3 + 0.7)');    // 4
math.eval('5.08 cm to inch');     // 2 inch
math.eval('sin(45 deg) ^ 2');     // 0.5
math.eval('9 / 3 + 2i');          // 3 + 2i
math.eval('det([-1, 2; 3, 1])');  // -7
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.derivative.toTex" id="apidoc.element.mathjs.derivative.toTex">
        function <span class="apidocSignatureSpan">mathjs.derivative.</span>toTex
        <span class="apidocSignatureSpan">(deriv)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toTex = function (deriv) {
  return _derivTex.apply(null, deriv.args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    catch (err) {
      console.log(err.toString());
    }
    break;

  case 'tex':
    try {
      var tex = math.parse(expr).<span class="apidocCodeKeywordSpan">toTex</span>({parenthesis: parenthesis});
      console.log(tex);
    }
    catch (err) {
      console.log(err.toString());
    }
    break;
}
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.derivative.signatures" id="apidoc.module.mathjs.derivative.signatures">module mathjs.derivative.signatures</a></h1>

</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.det" id="apidoc.module.mathjs.det">module mathjs.det</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.det.factory" id="apidoc.element.mathjs.det.factory">
        function <span class="apidocSignatureSpan">mathjs.det.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var matrix = load(require('../../type/matrix/function/matrix'));
  var add = load(require('../arithmetic/add'));
  var subtract = load(require('../arithmetic/subtract'));
  var multiply = load(require('../arithmetic/multiply'));
  var unaryMinus = load(require('../arithmetic/unaryMinus'));

<span class="apidocCodeCommentSpan">  /**
   * Calculate the determinant of a matrix.
   *
   * Syntax:
   *
   *    math.det(x)
   *
   * Examples:
   *
   *    math.det([[1, 2], [3, 4]]); // returns -2
   *
   *    var A = [
   *      [-2, 2, 3],
   *      [-1, 1, 3],
   *      [2, 0, -1]
   *    ]
   *    math.det(A); // returns 6
   *
   * See also:
   *
   *    inv
   *
   * @param {Array | Matrix} x  A matrix
   * @return {number} The determinant of `x`
   */
</span>  var det = typed('det', {
    'any': function (x) {
      return object.clone(x);
    },

    'Array | Matrix': function det (x) {
      var size;
      if (x &amp;&amp; x.isMatrix === true) {
        size = x.size();
      }
      else if (Array.isArray(x)) {
        x = matrix(x);
        size = x.size();
      }
      else {
        // a scalar
        size = [];
      }

      switch (size.length) {
        case 0:
          // scalar
          return object.clone(x);

        case 1:
          // vector
          if (size[0] == 1) {
            return object.clone(x.valueOf()[0]);
          }
          else {
            throw new RangeError('Matrix must be square ' +
            '(size: ' + string.format(size) + ')');
          }

        case 2:
          // two dimensional array
          var rows = size[0];
          var cols = size[1];
          if (rows == cols) {
            return _det(x.clone().valueOf(), rows, cols);
          }
          else {
            throw new RangeError('Matrix must be square ' +
            '(size: ' + string.format(size) + ')');
          }

        default:
          // multi dimensional array
          throw new RangeError('Matrix must be two dimensional ' +
          '(size: ' + string.format(size) + ')');
      }
    }
  });

  det.toTex = {1: '\\det\\left(${args[0]}\\right)'};

  return det;

  /**
   * Calculate the determinant of a matrix
   * @param {Array[]} matrix  A square, two dimensional matrix
   * @param {number} rows     Number of rows of the matrix (zero-based)
   * @param {number} cols     Number of columns of the matrix (zero-based)
   * @returns {number} det
   * @private
   */
  function _det (matrix, rows, cols) {
    if (rows == 1) {
      // this is a 1 x 1 matrix
      return object.clone(matrix[0][0]);
    }
    else if (rows == 2) {
      // this is a 2 x 2 matrix
      // the determinant of [a11,a12;a21,a22] is det = a11*a22-a21*a12
      return subtract(
          multiply(matrix[0][0], matrix[1][1]),
          multiply(matrix[1][0], matrix[0][1])
      );
    }
    else {
      // this is an n x n matrix
      var compute_mu = function (matrix) {
        var i, j;

        // Compute the matrix with zero lower triangle, same upper triangle,
        // and diagonals given by the negated sum of the below diagonal
        // elements.
        var mu = new Array(matrix.length);
        var sum = 0;
        for (i = 1; i &lt; matrix.length; i++) {
          sum = add(sum, matrix[i][i]);
        }

        for (i = 0; i &lt; matrix.length; i++) {
          mu[i] = new Array(matrix.length);
          mu[i][i] = unaryMinus(sum);

          for (j = 0; j &lt; i; j++) {
            mu[i][j] = 0; // TODO: make bignumber 0 in case of bignumber computation
          }

          for (j = i + 1; j &lt; matrix.length; j++) {
            mu[i][j] = matrix[i][j];
          }

          if (i+1 &lt; matrix.length) {
            sum = subtract(sum, matrix[i + 1][i + 1]);
          }
        }

        return mu;
      };

      var fa = matrix;
      for (var i = 0; i &lt; rows - 1; i++) {
        fa = multiply(compute_mu(fa), matrix);
      }

      if (rows % 2 == 0) {
        return unaryMinus(fa[0][0]);
      } else {
        return fa[0][0];
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.diag" id="apidoc.module.mathjs.diag">module mathjs.diag</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.diag.factory" id="apidoc.element.mathjs.diag.factory">
        function <span class="apidocSignatureSpan">mathjs.diag.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {

  var matrix = load(require('../../type/matrix/function/matrix'));

<span class="apidocCodeCommentSpan">  /**
   * Create a diagonal matrix or retrieve the diagonal of a matrix
   *
   * When `x` is a vector, a matrix with vector `x` on the diagonal will be returned.
   * When `x` is a two dimensional matrix, the matrixes `k`th diagonal will be returned as vector.
   * When k is positive, the values are placed on the super diagonal.
   * When k is negative, the values are placed on the sub diagonal.
   *
   * Syntax:
   *
   *     math.diag(X)
   *     math.diag(X, format)
   *     math.diag(X, k)
   *     math.diag(X, k, format)
   *
   * Examples:
   *
   *     // create a diagonal matrix
   *     math.diag([1, 2, 3]);      // returns [[1, 0, 0], [0, 2, 0], [0, 0, 3]]
   *     math.diag([1, 2, 3], 1);   // returns [[0, 1, 0, 0], [0, 0, 2, 0], [0, 0, 0, 3]]
   *     math.diag([1, 2, 3], -1);  // returns [[0, 0, 0], [1, 0, 0], [0, 2, 0], [0, 0, 3]]
   *
   *    // retrieve the diagonal from a matrix
   *    var a = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];
   *    math.diag(a);   // returns [1, 5, 9]
   *
   * See also:
   *
   *     ones, zeros, eye
   *
   * @param {Matrix | Array} x          A two dimensional matrix or a vector
   * @param {number | BigNumber} [k=0]  The diagonal where the vector will be filled
   *                                    in or retrieved.
   * @param {string} [format='dense']   The matrix storage format.
   *
   * @returns {Matrix | Array} Diagonal matrix from input vector, or diagonal from input matrix.
   */
</span>  var diag = typed('diag', {
    // FIXME: simplify this huge amount of signatures as soon as typed-function supports optional arguments

    'Array': function (x) {
      return _diag(x, 0, array.size(x), null);
    },

    'Array, number': function (x, k) {
      return _diag(x, k, array.size(x), null);
    },

    'Array, BigNumber': function (x, k) {
      return _diag(x, k.toNumber(), array.size(x), null);
    },

    'Array, string': function (x, format) {
      return _diag(x, 0, array.size(x), format);
    },

    'Array, number, string': function (x, k, format) {
      return _diag(x, k, array.size(x), format);
    },

    'Array, BigNumber, string': function (x, k, format) {
      return _diag(x, k.toNumber(), array.size(x), format);
    },

    'Matrix': function (x) {
      return _diag(x, 0, x.size(), x.storage());
    },

    'Matrix, number': function (x, k) {
      return _diag(x, k, x.size(), x.storage());
    },

    'Matrix, BigNumber': function (x, k) {
      return _diag(x, k.toNumber(), x.size(), x.storage());
    },

    'Matrix, string': function (x, format) {
      return _diag(x, 0, x.size(), format);
    },

    'Matrix, number, string': function (x, k, format) {
      return _diag(x, k, x.size(), format);
    },

    'Matrix, BigNumber, string': function (x, k, format) {
      return _diag(x, k.toNumber(), x.size(), format);
    }
  });

  diag.toTex = undefined; // use default template

  return diag;

  /**
   * Creeate diagonal matrix from a vector or vice versa
   * @param {Array | Matrix} x
   * @param {number} k
   * @param {string} format Storage format for matrix. If null,
   *                          an Array is returned
   * @returns {Array | Matrix}
   * @private
   */
  function _diag (x, k, size, format) {
    if (!isInteger(k)) {
      throw new TypeError ('Second parameter in function diag must be an integer');
    }

    var kSuper = k &gt; 0 ? k : 0;
    var kSub = k &lt; 0 ? -k : 0;

    // check dimensions
    switch (size.length) {
      case 1:
        return _createDiagonalMatrix(x, k, format, size[0], kSub, kSuper);
      case 2:
        return _getDiagonal(x, k, format, size, kSub, kSuper);
    }
    throw new RangeError('Matrix for function diag must be 2 dimensional');
  }

  function _createDiagonalMatrix(x, k, format, l, kSub, kSuper) {
    // matrix size
    var ms = [l + kSub, l + kSuper];
    // get matrix constructor
    var F = type.Matrix.storage(format || 'dense');
    // create diagonal matrix
    var m = F.di ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.distance" id="apidoc.module.mathjs.distance">module mathjs.distance</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.distance.factory" id="apidoc.element.mathjs.distance.factory">
        function <span class="apidocSignatureSpan">mathjs.distance.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var matrix = load(require('../../type/matrix/function/matrix'));

<span class="apidocCodeCommentSpan">  /**
    * Calculates:
    *    The eucledian distance between two points in 2 and 3 dimensional spaces.
    *    Distance between point and a line in 2 and 3 dimensional spaces.
    *    Pairwise distance between a set of 2D or 3D points
    * NOTE:
    *    When substituting coefficients of a line(a, b and c), use ax + by + c = 0 instead of ax + by = c
    *    For parametric equation of a 3D line, x0, y0, z0, a, b, c are from: (xâˆ’x0, yâˆ’y0, zâˆ’z0) = t(a, b, c)
    *
    * Syntax:
    *    math.distance([x1, y1], [x2, y2])
    *-   math.distance({pointOneX: 4, pointOneY: 5}, {pointTwoX: 2, pointTwoY: 7})
    *    math.distance([x1, y1, z1], [x2, y2, z2])
    *    math.distance({pointOneX: 4, pointOneY: 5, pointOneZ: 8}, {pointTwoX: 2, pointTwoY: 7, pointTwoZ: 9})
    *    math.distance([[A], [B], [C]...])
    *    math.distance([x1, y1], [LinePtX1, LinePtY1], [LinePtX2, LinePtY2])
    *    math.distance({pointX: 1, pointY: 4}, {lineOnePtX: 6, lineOnePtY: 3}, {lineTwoPtX: 2, lineTwoPtY: 8})
    *    math.distance([x1, y1, z1], [LinePtX1, LinePtY1, LinePtZ1], [LinePtX2, LinePtY2, LinePtZ2])
    *    math.distance({pointX: 1, pointY: 4, pointZ: 7}, {lineOnePtX: 6, lineOnePtY: 3, lineOnePtZ: 4}, {lineTwoPtX: 2, lineTwoPtY
: 8, lineTwoPtZ: 5})
    *    math.distance([x1, y1], [xCoeffLine, yCoeffLine, constant])
    *    math.distance({pointX: 10, pointY: 10}, {xCoeffLine: 8, yCoeffLine: 1, constant: 3})
    *    math.distance([x1, y1, z1], [x0, y0, z0, a-tCoeff, b-tCoeff, c-tCoeff]) point and parametric equation of 3D line
    *    math.distance([x, y, z], [x0, y0, z0, a, b, c])
    *    math.distance({pointX: 2, pointY: 5, pointZ: 9}, {x0: 4, y0: 6, z0: 3, a: 4, b: 2, c: 0})
    *
    * Examples:
    *    math.distance([0,0], [4,4])                     // Returns 5.6569
    *    math.distance(
    *     {pointOneX: 0, pointOneY: 0},
    *     {pointTwoX: 10, pointTwoY: 10})                // Returns 14.142135623730951
    *    math.distance([1, 0, 1], [4, -2, 2])            // Returns 3.74166
    *    math.distance(
    *     {pointOneX: 4, pointOneY: 5, pointOneZ: 8},
    *     {pointTwoX: 2, pointTwoY: 7, pointTwoZ: 9})    // Returns 3
    *    math.distance([[1, 2], [1, 2], [1, 3]])         // Returns [0, 1, 1]
    *    math.distance([[1,2,4], [1,2,6], [8,1,3]])      // Returns [2, 7.14142842854285, 7.681145747868608]
    *    math.distance([10, 10], [8, 1, 3])              // Returns 11.535230316796387
    *    math.distance([10, 10], [2, 3], [-8, 0])        // Returns 8.759953130362847
    *    math.distance(
    *     {pointX: 1, pointY: 4},
    *     {lineOnePtX: 6, lineOnePtY: 3},
    *     {lineTwoPtX: 2, lineTwoPtY: 8})                // Returns 2.720549372624744
    *    math.distance([2, 3, 1], [1, 1, 2, 5, 0, 1])    // Returns 2.3204774044612857
    *    math.distance(
    *     {pointX: 2, pointY: 3, pointZ: 1},
    *     {x0: 1, y0: 1, z0: 2, a: 5, b: 0, c: 1}        // Returns 2.3204774044612857
    *
    * @param {Array | Matrix | Object} x    Co-ordinates of first point
    * @param {Array | Matrix | Object} y    Co-ordinates of second point
    * @return {Number | BigNumber} Returns the distance from two/three points
  */
</span>
  var distance = typed('distance', {
    'Array, Array, Array': function(x, y, z){
      // Point to Line 2D; (x=Point, y=LinePoint1, z=LinePoint2)
      if (x.length == 2 &amp;&amp; y.length == 2 &amp;&amp; z.length == 2){
        if (!_2d(x)) { throw new TypeError('Array with 2 numbers expected for first argument'); }
        if (!_2d(y)) { throw new TypeError('Array with 2 numbers expected for second argument'); }
        if (!_2d(z)) { throw new TypeError('Array with 2 numbers expected for third argument'); }
        var m = (z[1]-z[0])/(y[1]-y[0]);
        var xCoeff = m*m*y[0];
        var yCoeff = -1*(m*y[0]);
        var constant = x[1];

        return _distancePointLine2D(x[0], x[1], xCoeff, yCoeff, constant);
      }
      else{
        throw new TypeError('Invalid Arguments: Try ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.distribution" id="apidoc.module.mathjs.distribution">module mathjs.distribution</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.distribution.factory" id="apidoc.element.mathjs.distribution.factory">
        function <span class="apidocSignatureSpan">mathjs.distribution.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed, math)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed, math) {
  var matrix = load(require('../../type/matrix/function/matrix'));
  var array = require('../../utils/array');

  // seeded pseudo random number generator
  var rng = load(require('./seededRNG'));

<span class="apidocCodeCommentSpan">  /**
   * Create a distribution object with a set of random functions for given
   * random distribution.
   *
   * Syntax:
   *
   *     math.distribution(name)
   *
   * Examples:
   *
   *     var normalDist = math.distribution('normal'); // create a normal distribution
   *     normalDist.random(0, 10);                     // get a random value between 0 and 10
   *
   * See also:
   *
   *     random, randomInt, pickRandom
   *
   * @param {string} name   Name of a distribution. Choose from 'uniform', 'normal'.
   * @return {Object}       Returns a distribution object containing functions:
   *                        `random([size] [, min] [, max])`,
   *                        `randomInt([min] [, max])`,
   *                        `pickRandom(array)`
   */
</span>  function distribution(name) {
    if (!distributions.hasOwnProperty(name))
      throw new Error('Unknown distribution ' + name);

    var args = Array.prototype.slice.call(arguments, 1),
        distribution = distributions[name].apply(this, args);

    return (function(distribution) {

      // This is the public API for all distributions
      var randFunctions = {

        random: function(arg1, arg2, arg3) {
          var size, min, max;

          if (arguments.length &gt; 3) {
            throw new ArgumentsError('random', arguments.length, 0, 3);
          } else if (arguments.length === 1) {
            // `random(max)` or `random(size)`
            if (isCollection(arg1)) {
              size = arg1;
            } else {
              max = arg1;
            }
          } else if (arguments.length === 2) {
            // `random(min, max)` or `random(size, max)`
            if (isCollection(arg1)) {
              size = arg1;
              max = arg2;
            } else {
              min = arg1;
              max = arg2;
            }
          } else {
            // `random(size, min, max)`
            size = arg1;
            min = arg2;
            max = arg3;
          }

          // TODO: validate type of size
          if ((min !== undefined &amp;&amp; !isNumber(min)) || (max !== undefined &amp;&amp; !isNumber(max))) {
            throw new TypeError('Invalid argument in function random');
          }

          if (max === undefined) max = 1;
          if (min === undefined) min = 0;
          if (size !== undefined) {
            var res = _randomDataForMatrix(size.valueOf(), min, max, _random);
            return (size &amp;&amp; size.isMatrix === true) ? matrix(res) : res;
          }
          return _random(min, max);
        },

        randomInt: typed({
          'number | Array': function(arg) {
            var min = 0;

            if (isCollection(arg)) {
              var size = arg;
              var max = 1;
              var res = _randomDataForMatrix(size.valueOf(), min, max, _randomInt);
              return (size &amp;&amp; size.isMatrix === true) ? matrix(res) : res;
            } else {
              var max = arg;
              return _randomInt(min, max);
            }
          },
          'number | Array, number': function(arg1, arg2) {
            if (isCollection(arg1)) {
              var size = arg1;
              var max = arg2;
              var min = 0;
              var res = _randomDataForMatrix(size.valueOf(), min, max, _randomInt);
              return (size &amp;&amp; size.isMatrix === true) ? matrix(res) : res;
            }
            else {
              var min = arg1;
              var max = arg2;
              return _randomInt(min, max);
            }
          },
          'Array, number, number': function(size, min, max) {
            var res = _randomDataForMatrix(size.valueOf(), min, max, _randomInt);
            return (size &amp;&amp; size.isMatrix === true) ? matrix(res) : res;
          }
        }),

        pickRandom: typed({
          'Array': function(possibles) {
            return _pi ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.divide" id="apidoc.module.mathjs.divide">module mathjs.divide</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.divide.factory" id="apidoc.element.mathjs.divide.factory">
        function <span class="apidocSignatureSpan">mathjs.divide.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {

  var divideScalar = load(require('./divideScalar'));
  var multiply     = load(require('./multiply'));
  var inv          = load(require('../matrix/inv'));
  var matrix       = load(require('../../type/matrix/function/matrix'));

  var algorithm11 = load(require('../../type/matrix/utils/algorithm11'));
  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));

<span class="apidocCodeCommentSpan">  /**
   * Divide two values, `x / y`.
   * To divide matrices, `x` is multiplied with the inverse of `y`: `x * inv(y)`.
   *
   * Syntax:
   *
   *    math.divide(x, y)
   *
   * Examples:
   *
   *    math.divide(2, 3);            // returns number 0.6666666666666666
   *
   *    var a = math.complex(5, 14);
   *    var b = math.complex(4, 1);
   *    math.divide(a, b);            // returns Complex 2 + 3i
   *
   *    var c = [[7, -6], [13, -4]];
   *    var d = [[1, 2], [4, 3]];
   *    math.divide(c, d);            // returns Array [[-9, 4], [-11, 6]]
   *
   *    var e = math.unit('18 km');
   *    math.divide(e, 4.5);          // returns Unit 4 km
   *
   * See also:
   *
   *    multiply
   *
   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x   Numerator
   * @param  {number | BigNumber | Fraction | Complex | Array | Matrix} y          Denominator
   * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix}                      Quotient, `x / y`
   */
</span>  var divide = typed('divide', extend({
    // we extend the signatures of divideScalar with signatures dealing with matrices

    'Array | Matrix, Array | Matrix': function (x, y) {
      // TODO: implement matrix right division using pseudo inverse
      // http://www.mathworks.nl/help/matlab/ref/mrdivide.html
      // http://www.gnu.org/software/octave/doc/interpreter/Arithmetic-Ops.html
      // http://stackoverflow.com/questions/12263932/how-does-gnu-octave-matrix-division-work-getting-unexpected-behaviour
      return multiply(x, inv(y));
    },

    'Matrix, any': function (x, y) {
      // result
      var c;

      // process storage format
      switch (x.storage()) {
        case 'sparse':
          c = algorithm11(x, y, divideScalar, false);
          break;
        case 'dense':
          c = algorithm14(x, y, divideScalar, false);
          break;
      }
      return c;
    },

    'Array, any': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(x), y, divideScalar, false).valueOf();
    },

    'any, Array | Matrix': function (x, y) {
      return multiply(x, inv(y));
    }
  }, divideScalar.signatures));

  divide.toTex = {2: '\\frac{${args[0]}}{${args[1]}}'};

  return divide;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.divideScalar" id="apidoc.module.mathjs.divideScalar">module mathjs.divideScalar</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.divideScalar.factory" id="apidoc.element.mathjs.divideScalar.factory">
        function <span class="apidocSignatureSpan">mathjs.divideScalar.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var multiplyScalar = load(require('./multiplyScalar'));

<span class="apidocCodeCommentSpan">  /**
   * Divide two scalar values, `x / y`.
   * This function is meant for internal use: it is used by the public functions
   * `divide` and `inv`.
   *
   * This function does not support collections (Array or Matrix), and does
   * not validate the number of of inputs.
   *
   * @param  {number | BigNumber | Fraction | Complex | Unit} x   Numerator
   * @param  {number | BigNumber | Fraction | Complex} y          Denominator
   * @return {number | BigNumber | Fraction | Complex | Unit}                      Quotient, `x / y`
   * @private
   */
</span>  var divideScalar = typed('divide', {
    'number, number': function (x, y) {
      return x / y;
    },

    'Complex, Complex': function (x, y) {
      return x.div(y);
    },

    'BigNumber, BigNumber': function (x, y) {
      return x.div(y);
    },

    'Fraction, Fraction': function (x, y) {
      return x.div(y);
    },

    'Unit, number | Fraction | BigNumber': function (x, y) {
      var res = x.clone();
      // TODO: move the divide function to Unit.js, it uses internals of Unit
      res.value = divideScalar(((res.value === null) ? res._normalize(1) : res.value), y);
      return res;
    },

    'number | Fraction | BigNumber, Unit': function (x, y) {
      var res = y.pow(-1);
      // TODO: move the divide function to Unit.js, it uses internals of Unit
      res.value = multiplyScalar(((res.value === null) ? res._normalize(1) : res.value), x);
      return res;
    },

    'Unit, Unit': function (x, y) {
      return x.divide(y);
    }

  });

  return divideScalar;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.dot" id="apidoc.module.mathjs.dot">module mathjs.dot</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.dot.factory" id="apidoc.element.mathjs.dot.factory">
        function <span class="apidocSignatureSpan">mathjs.dot.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var add      = load(require('../arithmetic/add'));
  var multiply = load(require('../arithmetic/multiply'));

<span class="apidocCodeCommentSpan">  /**
   * Calculate the dot product of two vectors. The dot product of
   * `A = [a1, a2, a3, ..., an]` and `B = [b1, b2, b3, ..., bn]` is defined as:
   *
   *    dot(A, B) = a1 * b1 + a2 * b2 + a3 * b3 + ... + an * bn
   *
   * Syntax:
   *
   *    math.dot(x, y)
   *
   * Examples:
   *
   *    math.dot([2, 4, 1], [2, 2, 3]);       // returns number 15
   *    math.multiply([2, 4, 1], [2, 2, 3]);  // returns number 15
   *
   * See also:
   *
   *    multiply, cross
   *
   * @param  {Array | Matrix} x     First vector
   * @param  {Array | Matrix} y     Second vector
   * @return {number}               Returns the dot product of `x` and `y`
   */
</span>  var dot = typed('dot', {
    'Matrix, Matrix': function (x, y) {
      return _dot(x.toArray(), y.toArray());
    },

    'Matrix, Array': function (x, y) {
      return _dot(x.toArray(), y);
    },

    'Array, Matrix': function (x, y) {
      return _dot(x, y.toArray());
    },

    'Array, Array': _dot
  });

  dot.toTex = {2: '\\left(${args[0]}\\cdot${args[1]}\\right)'};

  return dot;

  /**
   * Calculate the dot product for two arrays
   * @param {Array} x  First vector
   * @param {Array} y  Second vector
   * @returns {number} Returns the dot product of x and y
   * @private
   */
  // TODO: double code with math.multiply
  function _dot(x, y) {
    var xSize= size(x);
    var ySize = size(y);
    var len = xSize[0];

    if (xSize.length !== 1 || ySize.length !== 1) throw new RangeError('Vector expected'); // TODO: better error message
    if (xSize[0] != ySize[0]) throw new RangeError('Vectors must have equal length (' + xSize[0] + ' != ' + ySize[0] + ')');
    if (len == 0) throw new RangeError('Cannot calculate the dot product of empty vectors');

    var prod = 0;
    for (var i = 0; i &lt; len; i++) {
      prod = add(prod, multiply(x[i], y[i]));
    }

    return prod;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.dotDivide" id="apidoc.module.mathjs.dotDivide">module mathjs.dotDivide</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.dotDivide.factory" id="apidoc.element.mathjs.dotDivide.factory">
        function <span class="apidocSignatureSpan">mathjs.dotDivide.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {

  var matrix = load(require('../../type/matrix/function/matrix'));
  var divideScalar = load(require('./divideScalar'));
  var latex = require('../../utils/latex');

  var algorithm02 = load(require('../../type/matrix/utils/algorithm02'));
  var algorithm03 = load(require('../../type/matrix/utils/algorithm03'));
  var algorithm07 = load(require('../../type/matrix/utils/algorithm07'));
  var algorithm11 = load(require('../../type/matrix/utils/algorithm11'));
  var algorithm12 = load(require('../../type/matrix/utils/algorithm12'));
  var algorithm13 = load(require('../../type/matrix/utils/algorithm13'));
  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));

<span class="apidocCodeCommentSpan">  /**
   * Divide two matrices element wise. The function accepts both matrices and
   * scalar values.
   *
   * Syntax:
   *
   *    math.dotDivide(x, y)
   *
   * Examples:
   *
   *    math.dotDivide(2, 4);   // returns 0.5
   *
   *    a = [[9, 5], [6, 1]];
   *    b = [[3, 2], [5, 2]];
   *
   *    math.dotDivide(a, b);   // returns [[3, 2.5], [1.2, 0.5]]
   *    math.divide(a, b);      // returns [[1.75, 0.75], [-1.75, 2.25]]
   *
   * See also:
   *
   *    divide, multiply, dotMultiply
   *
   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x Numerator
   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} y Denominator
   * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix}                    Quotient, `x ./ y`
   */
</span>  var dotDivide = typed('dotDivide', {

    'any, any': divideScalar,

    'Matrix, Matrix': function (x, y) {
      // result
      var c;

      // process matrix storage
      switch (x.storage()) {
        case 'sparse':
          switch (y.storage()) {
            case 'sparse':
              // sparse ./ sparse
              c = algorithm07(x, y, divideScalar, false);
              break;
            default:
              // sparse ./ dense
              c = algorithm02(y, x, divideScalar, true);
              break;
          }
          break;
        default:
          switch (y.storage()) {
            case 'sparse':
              // dense ./ sparse
              c = algorithm03(x, y, divideScalar, false);
              break;
            default:
              // dense ./ dense
              c = algorithm13(x, y, divideScalar);
              break;
          }
          break;
      }
      return c;
    },

    'Array, Array': function (x, y) {
      // use matrix implementation
      return dotDivide(matrix(x), matrix(y)).valueOf();
    },

    'Array, Matrix': function (x, y) {
      // use matrix implementation
      return dotDivide(matrix(x), y);
    },

    'Matrix, Array': function (x, y) {
      // use matrix implementation
      return dotDivide(x, matrix(y));
    },

    'Matrix, any': function (x, y) {
      // result
      var c;
      // check storage format
      switch (x.storage()) {
        case 'sparse':
          c = algorithm11(x, y, divideScalar, false);
          break;
        default:
          c = algorithm14(x, y, divideScalar, false);
          break;
      }
      return c;
    },

    'any, Matrix': function (x, y) {
      // result
      var c;
      // check storage format
      switch (y.storage()) {
        case 'sparse':
          c = algorithm12(y, x, divideScalar, true);
          break;
        default:
          c = algorithm14(y, x, divideScalar, true);
          break;
      }
      return c;
    },

    'Array, any': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(x), y, divideScalar, false).valueOf();
    },

    'any, Array': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(y), x, divideScalar, true).valueOf();
    }
  });

  dotDivide.toTex = {
    2: '\\left(${args[0]}' + latex.operators['dotDivide'] + '${args[1]}\\right)'
  };

  return dotDivide;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.dotMultiply" id="apidoc.module.mathjs.dotMultiply">module mathjs.dotMultiply</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.dotMultiply.factory" id="apidoc.element.mathjs.dotMultiply.factory">
        function <span class="apidocSignatureSpan">mathjs.dotMultiply.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {

  var matrix = load(require('../../type/matrix/function/matrix'));
  var multiplyScalar = load(require('./multiplyScalar'));
  var latex = require('../../utils/latex');

  var algorithm02 = load(require('../../type/matrix/utils/algorithm02'));
  var algorithm09 = load(require('../../type/matrix/utils/algorithm09'));
  var algorithm11 = load(require('../../type/matrix/utils/algorithm11'));
  var algorithm13 = load(require('../../type/matrix/utils/algorithm13'));
  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));

<span class="apidocCodeCommentSpan">  /**
   * Multiply two matrices element wise. The function accepts both matrices and
   * scalar values.
   *
   * Syntax:
   *
   *    math.dotMultiply(x, y)
   *
   * Examples:
   *
   *    math.dotMultiply(2, 4); // returns 8
   *
   *    a = [[9, 5], [6, 1]];
   *    b = [[3, 2], [5, 2]];
   *
   *    math.dotMultiply(a, b); // returns [[27, 10], [30, 2]]
   *    math.multiply(a, b);    // returns [[52, 28], [23, 14]]
   *
   * See also:
   *
   *    multiply, divide, dotDivide
   *
   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x Left hand value
   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} y Right hand value
   * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix}                    Multiplication of `x` and `y`
   */
</span>  var dotMultiply = typed('dotMultiply', {

    'any, any': multiplyScalar,

    'Matrix, Matrix': function (x, y) {
      // result
      var c;

      // process matrix storage
      switch (x.storage()) {
        case 'sparse':
          switch (y.storage()) {
            case 'sparse':
              // sparse .* sparse
              c = algorithm09(x, y, multiplyScalar, false);
              break;
            default:
              // sparse .* dense
              c = algorithm02(y, x, multiplyScalar, true);
              break;
          }
          break;
        default:
          switch (y.storage()) {
            case 'sparse':
              // dense .* sparse
              c = algorithm02(x, y, multiplyScalar, false);
              break;
            default:
              // dense .* dense
              c = algorithm13(x, y, multiplyScalar);
              break;
          }
          break;
      }
      return c;
    },

    'Array, Array': function (x, y) {
      // use matrix implementation
      return dotMultiply(matrix(x), matrix(y)).valueOf();
    },

    'Array, Matrix': function (x, y) {
      // use matrix implementation
      return dotMultiply(matrix(x), y);
    },

    'Matrix, Array': function (x, y) {
      // use matrix implementation
      return dotMultiply(x, matrix(y));
    },

    'Matrix, any': function (x, y) {
      // result
      var c;
      // check storage format
      switch (x.storage()) {
        case 'sparse':
          c = algorithm11(x, y, multiplyScalar, false);
          break;
        default:
          c = algorithm14(x, y, multiplyScalar, false);
          break;
      }
      return c;
    },

    'any, Matrix': function (x, y) {
      // result
      var c;
      // check storage format
      switch (y.storage()) {
        case 'sparse':
          c = algorithm11(y, x, multiplyScalar, true);
          break;
        default:
          c = algorithm14(y, x, multiplyScalar, true);
          break;
      }
      return c;
    },

    'Array, any': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(x), y, multiplyScalar, false).valueOf();
    },

    'any, Array': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(y), x, multiplyScalar, true).valueOf();
    }
  });

  dotMultiply.toTex = {
    2: '\\left(${args[0]}' + latex.operators['dotMultiply'] + '${args[1]}\\right)'
  };

  return dotMultiply;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.dotPow" id="apidoc.module.mathjs.dotPow">module mathjs.dotPow</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.dotPow.factory" id="apidoc.element.mathjs.dotPow.factory">
        function <span class="apidocSignatureSpan">mathjs.dotPow.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {

  var matrix = load(require('../../type/matrix/function/matrix'));
  var pow = load(require('./pow'));
  var latex = require('../../utils/latex');

  var algorithm03 = load(require('../../type/matrix/utils/algorithm03'));
  var algorithm07 = load(require('../../type/matrix/utils/algorithm07'));
  var algorithm11 = load(require('../../type/matrix/utils/algorithm11'));
  var algorithm12 = load(require('../../type/matrix/utils/algorithm12'));
  var algorithm13 = load(require('../../type/matrix/utils/algorithm13'));
  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));

<span class="apidocCodeCommentSpan">  /**
   * Calculates the power of x to y element wise.
   *
   * Syntax:
   *
   *    math.dotPow(x, y)
   *
   * Examples:
   *
   *    math.dotPow(2, 3);            // returns number 8
   *
   *    var a = [[1, 2], [4, 3]];
   *    math.dotPow(a, 2);            // returns Array [[1, 4], [16, 9]]
   *    math.pow(a, 2);               // returns Array [[9, 8], [16, 17]]
   *
   * See also:
   *
   *    pow, sqrt, multiply
   *
   * @param  {number | BigNumber | Complex | Unit | Array | Matrix} x  The base
   * @param  {number | BigNumber | Complex | Unit | Array | Matrix} y  The exponent
   * @return {number | BigNumber | Complex | Unit | Array | Matrix}                     The value of `x` to the power `y`
   */
</span>  var dotPow = typed('dotPow', {

    'any, any': pow,

    'Matrix, Matrix': function (x, y) {
      // result
      var c;

      // process matrix storage
      switch (x.storage()) {
        case 'sparse':
          switch (y.storage()) {
            case 'sparse':
              // sparse .^ sparse
              c = algorithm07(x, y, pow, false);
              break;
            default:
              // sparse .^ dense
              c = algorithm03(y, x, pow, true);
              break;
          }
          break;
        default:
          switch (y.storage()) {
            case 'sparse':
              // dense .^ sparse
              c = algorithm03(x, y, pow, false);
              break;
            default:
              // dense .^ dense
              c = algorithm13(x, y, pow);
              break;
          }
          break;
      }
      return c;
    },

    'Array, Array': function (x, y) {
      // use matrix implementation
      return dotPow(matrix(x), matrix(y)).valueOf();
    },

    'Array, Matrix': function (x, y) {
      // use matrix implementation
      return dotPow(matrix(x), y);
    },

    'Matrix, Array': function (x, y) {
      // use matrix implementation
      return dotPow(x, matrix(y));
    },

    'Matrix, any': function (x, y) {
      // result
      var c;
      // check storage format
      switch (x.storage()) {
        case 'sparse':
          c = algorithm11(x, y, dotPow, false);
          break;
        default:
          c = algorithm14(x, y, dotPow, false);
          break;
      }
      return c;
    },

    'any, Matrix': function (x, y) {
      // result
      var c;
      // check storage format
      switch (y.storage()) {
        case 'sparse':
          c = algorithm12(y, x, dotPow, true);
          break;
        default:
          c = algorithm14(y, x, dotPow, true);
          break;
      }
      return c;
    },

    'Array, any': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(x), y, dotPow, false).valueOf();
    },

    'any, Array': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(y), x, dotPow, true).valueOf();
    }
  });

  dotPow.toTex = {
    2: '\\left(${args[0]}' + latex.operators['dotPow'] + '${args[1]}\\right)'
  };

  return dotPow;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.emitter" id="apidoc.module.mathjs.emitter">module mathjs.emitter</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.emitter.mixin" id="apidoc.element.mathjs.emitter.mixin">
        function <span class="apidocSignatureSpan">mathjs.emitter.</span>mixin
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mixin = function (obj) {
  // create event emitter
  var emitter = new Emitter();

  // bind methods to obj (we don't want to expose the emitter.e Array...)
  obj.on   = emitter.on.bind(emitter);
  obj.off  = emitter.off.bind(emitter);
  obj.once = emitter.once.bind(emitter);
  obj.emit = emitter.emit.bind(emitter);

  return obj;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.equal" id="apidoc.module.mathjs.equal">module mathjs.equal</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.equal.factory" id="apidoc.element.mathjs.equal.factory">
        function <span class="apidocSignatureSpan">mathjs.equal.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {

  var matrix = load(require('../../type/matrix/function/matrix'));
  var equalScalar = load(require('./equalScalar'));

  var algorithm03 = load(require('../../type/matrix/utils/algorithm03'));
  var algorithm07 = load(require('../../type/matrix/utils/algorithm07'));
  var algorithm12 = load(require('../../type/matrix/utils/algorithm12'));
  var algorithm13 = load(require('../../type/matrix/utils/algorithm13'));
  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));

  var latex = require('../../utils/latex');

<span class="apidocCodeCommentSpan">  /**
   * Test whether two values are equal.
   *
   * The function tests whether the relative difference between x and y is
   * smaller than the configured epsilon. The function cannot be used to
   * compare values smaller than approximately 2.22e-16.
   *
   * For matrices, the function is evaluated element wise.
   * In case of complex numbers, x.re must equal y.re, and x.im must equal y.im.
   *
   * Values `null` and `undefined` are compared strictly, thus `null` is only
   * equal to `null` and nothing else, and `undefined` is only equal to
   * `undefined` and nothing else.
   *
   * Syntax:
   *
   *    math.equal(x, y)
   *
   * Examples:
   *
   *    math.equal(2 + 2, 3);         // returns false
   *    math.equal(2 + 2, 4);         // returns true
   *
   *    var a = math.unit('50 cm');
   *    var b = math.unit('5 m');
   *    math.equal(a, b);             // returns true
   *
   *    var c = [2, 5, 1];
   *    var d = [2, 7, 1];
   *
   *    math.equal(c, d);             // returns [true, false, true]
   *    math.deepEqual(c, d);         // returns false
   *
   *    math.equal(0, null);          // returns false
   *
   * See also:
   *
   *    unequal, smaller, smallerEq, larger, largerEq, compare, deepEqual
   *
   * @param  {number | BigNumber | boolean | Complex | Unit | string | Array | Matrix} x First value to compare
   * @param  {number | BigNumber | boolean | Complex | Unit | string | Array | Matrix} y Second value to compare
   * @return {boolean | Array | Matrix} Returns true when the compared values are equal, else returns false
   */
</span>  var equal = typed('equal', {

    'any, any': function (x, y) {
      // strict equality for null and undefined?
      if (x === null) { return y === null; }
      if (y === null) { return x === null; }
      if (x === undefined) { return y === undefined; }
      if (y === undefined) { return x === undefined; }

      return equalScalar(x, y);
    },

    'Matrix, Matrix': function (x, y) {
      // result
      var c;

      // process matrix storage
      switch (x.storage()) {
        case 'sparse':
          switch (y.storage()) {
            case 'sparse':
              // sparse + sparse
              c = algorithm07(x, y, equalScalar);
              break;
            default:
              // sparse + dense
              c = algorithm03(y, x, equalScalar, true);
              break;
          }
          break;
        default:
          switch (y.storage()) {
            case 'sparse':
              // dense + sparse
              c = algorithm03(x, y, equalScalar, false);
              break;
            default:
              // dense + dense
              c = algorithm13(x, y, equalScalar);
              break;
          }
          break;
      }
      return c;
    },

    'Array, Array': function (x, y) {
      // use matrix implementation
      return equal(matrix(x), matrix(y)).valueOf();
    },

    'Array, Matrix': function (x, y) {
      // use matrix implementation
      return equal(matrix(x), y);
    },

    'Matrix, Array': function (x, y) {
      // use matrix implementation
      return equal(x, matrix(y));
    },

    'Matrix, any': function (x, y) {
      // result
      var c;
      // check storage format
      switch (x.storage()) {
        case 'sparse':
          c = algorithm12(x, y, equalScalar, false);
          break;
        default:
          c = algorithm14(x, y, equalScalar, false);
          break;
      }
      return c;
    }, ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.equalScalar" id="apidoc.module.mathjs.equalScalar">module mathjs.equalScalar</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.equalScalar.factory" id="apidoc.element.mathjs.equalScalar.factory">
        function <span class="apidocSignatureSpan">mathjs.equalScalar.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {

<span class="apidocCodeCommentSpan">  /**
   * Test whether two values are equal.
   *
   * @param  {number | BigNumber | Fraction | boolean | Complex | Unit} x   First value to compare
   * @param  {number | BigNumber | Fraction | boolean | Complex} y          Second value to compare
   * @return {boolean}                                                  Returns true when the compared values are equal, else returns
 false
   * @private
   */
</span>  var equalScalar = typed('equalScalar', {

    'boolean, boolean': function (x, y) {
      return x === y;
    },

    'number, number': function (x, y) {
      return x === y || nearlyEqual(x, y, config.epsilon);
    },

    'BigNumber, BigNumber': function (x, y) {
      return x.eq(y) || bigNearlyEqual(x, y, config.epsilon);
    },

    'Fraction, Fraction': function (x, y) {
      return x.equals(y);
    },

    'Complex, Complex': function (x, y) {
      return x.equals(y);
    },

    'Unit, Unit': function (x, y) {
      if (!x.equalBase(y)) {
        throw new Error('Cannot compare units with different base');
      }
      return equalScalar(x.value, y.value);
    },

    'string, string': function (x, y) {
      return x === y;
    }
  });

  return equalScalar;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.erf" id="apidoc.module.mathjs.erf">module mathjs.erf</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.erf.factory" id="apidoc.element.mathjs.erf.factory">
        function <span class="apidocSignatureSpan">mathjs.erf.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
<span class="apidocCodeCommentSpan">  /**
   * Compute the erf function of a value using a rational Chebyshev
   * approximations for different intervals of x.
   *
   * This is a translation of W. J. Cody's Fortran implementation from 1987
   * ( http://www.netlib.org/specfun/erf ). See the AMS publication
   * "Rational Chebyshev Approximations for the Error Function" by W. J. Cody
   * for an explanation of this process.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.erf(x)
   *
   * Examples:
   *
   *    math.erf(0.2);    // returns 0.22270258921047847
   *    math.erf(-0.5);   // returns -0.5204998778130465
   *    math.erf(4);      // returns 0.9999999845827421
   *
   * @param {number | Array | Matrix} x   A real number
   * @return {number | Array | Matrix}    The erf of `x`
   */
</span>  var erf = typed('erf', {
    'number': function (x) {
      var y = Math.abs(x);

      if (y &gt;= MAX_NUM) {
        return sign(x);
      }
      if (y &lt;= THRESH) {
        return sign(x) * erf1(y);
      }
      if (y &lt;= 4.0) {
        return sign(x) * (1 - erfc2(y));
      }
      return sign(x) * (1 - erfc3(y));
    },

    // TODO: Not sure if there's a way to guarantee some degree of accuracy here.
    //  Perhaps it would be best to set the precision of the number to that which
    //  is guaranteed by erf()
    'BigNumber': function (n) {
      return new type.BigNumber(erf(n.toNumber()));
    },

    'Array | Matrix': function (n) {
      return deepMap(n, erf);
    }

    // TODO: For complex numbers, use the approximation for the Faddeeva function
    //  from "More Efficient Computation of the Complex Error Function" (AMS)

  });

  /**
   * Approximates the error function erf() for x &lt;= 0.46875 using this function:
   *               n
   * erf(x) = x * sum (p_j * x^(2j)) / (q_j * x^(2j))
   *              j=0
   */
  function erf1(y) {
    var ysq = y * y;
    var xnum = P[0][4]*ysq;
    var xden = ysq;
    var i;

    for (i = 0; i &lt; 3; i += 1) {
      xnum = (xnum + P[0][i]) * ysq;
      xden = (xden + Q[0][i]) * ysq;
    }
    return y * (xnum + P[0][3]) / (xden + Q[0][3]);
  }

  /**
   * Approximates the complement of the error function erfc() for
   * 0.46875 &lt;= x &lt;= 4.0 using this function:
   *                       n
   * erfc(x) = e^(-x^2) * sum (p_j * x^j) / (q_j * x^j)
   *                      j=0
   */
  function erfc2(y) {
    var xnum = P[1][8] * y;
    var xden = y;
    var i;

    for (i = 0; i &lt; 7; i += 1) {
      xnum = (xnum + P[1][i]) * y;
      xden = (xden + Q[1][i]) * y;
    }
    var result = (xnum + P[1][7]) / (xden + Q[1][7]);
    var ysq = parseInt(y * 16) / 16;
    var del = (y - ysq) * (y + ysq);
    return Math.exp(-ysq*ysq) * Math.exp(-del) * result;
  }

  /**
   * Approximates the complement of the error function erfc() for x &gt; 4.0 using
   * this function:
   *
   * erfc(x) = (e^(-x^2) / x) * [ 1/sqrt(pi) +
   *               n
   *    1/(x^2) * sum (p_j * x^(-2j)) / (q_j * x^(-2j)) ]
   *              j=0
   */
  function erfc3(y) {
    var ysq = 1 / (y * y);
    var xnum = P[2][5] * ysq;
    var xden = ysq;
    var i;

    for (i = 0; i &lt; 4; i += 1) {
      xnum = (xnum + P[2][i]) * ysq;
      xden = (xden + Q[2][i]) * ysq;
    }
    var result = ysq * (xnum + P[2][4]) / (xden + Q[2][4]);
    result = (SQRPI - result) / y;
    ysq = parseInt(y * 16) / 16;
    var del = (y - ysq) * (y + ysq);
    return Math.exp(-ysq*ysq) * Math.exp(-del) * result;
  }

  erf.toTex = {1: 'erf\\left(${args[0]}\\right)'};

  return erf;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.error" id="apidoc.module.mathjs.error">module mathjs.error</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.error.ArgumentsError" id="apidoc.element.mathjs.error.ArgumentsError">
        function <span class="apidocSignatureSpan">mathjs.error.</span>ArgumentsError
        <span class="apidocSignatureSpan">(fn, count, min, max)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ArgumentsError(fn, count, min, max) {
  if (!(this instanceof ArgumentsError)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  this.fn = fn;
  this.count = count;
  this.min = min;
  this.max = max;

  this.message = 'Wrong number of arguments in function ' + fn +
      ' (' + count + ' provided, ' +
      min + ((max != undefined) ? ('-' + max) : '') + ' expected)';

  this.stack = (new Error()).stack;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.error.DimensionError" id="apidoc.element.mathjs.error.DimensionError">
        function <span class="apidocSignatureSpan">mathjs.error.</span>DimensionError
        <span class="apidocSignatureSpan">(actual, expected, relation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DimensionError(actual, expected, relation) {
  if (!(this instanceof DimensionError)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  this.actual   = actual;
  this.expected = expected;
  this.relation = relation;

  this.message = 'Dimension mismatch (' +
      (Array.isArray(actual) ? ('[' + actual.join(', ') + ']') : actual) +
      ' ' + (this.relation || '!=') + ' ' +
      (Array.isArray(expected) ? ('[' + expected.join(', ') + ']') : expected) +
      ')';

  this.stack = (new Error()).stack;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.error.IndexError" id="apidoc.element.mathjs.error.IndexError">
        function <span class="apidocSignatureSpan">mathjs.error.</span>IndexError
        <span class="apidocSignatureSpan">(index, min, max)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function IndexError(index, min, max) {
  if (!(this instanceof IndexError)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  this.index = index;
  if (arguments.length &lt; 3) {
    this.min = 0;
    this.max = min;
  }
  else {
    this.min = min;
    this.max = max;
  }

  if (this.min !== undefined &amp;&amp; this.index &lt; this.min) {
    this.message = 'Index out of range (' + this.index + ' &lt; ' + this.min + ')';
  }
  else if (this.max !== undefined &amp;&amp; this.index &gt;= this.max) {
    this.message = 'Index out of range (' + this.index + ' &gt; ' + (this.max - 1) + ')';
  }
  else {
    this.message = 'Index out of range (' + this.index + ')';
  }

  this.stack = (new Error()).stack;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.error.ArgumentsError" id="apidoc.module.mathjs.error.ArgumentsError">module mathjs.error.ArgumentsError</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.error.ArgumentsError.ArgumentsError" id="apidoc.element.mathjs.error.ArgumentsError.ArgumentsError">
        function <span class="apidocSignatureSpan">mathjs.error.</span>ArgumentsError
        <span class="apidocSignatureSpan">(fn, count, min, max)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ArgumentsError(fn, count, min, max) {
  if (!(this instanceof ArgumentsError)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  this.fn = fn;
  this.count = count;
  this.min = min;
  this.max = max;

  this.message = 'Wrong number of arguments in function ' + fn +
      ' (' + count + ' provided, ' +
      min + ((max != undefined) ? ('-' + max) : '') + ' expected)';

  this.stack = (new Error()).stack;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.error.ArgumentsError.prototype" id="apidoc.module.mathjs.error.ArgumentsError.prototype">module mathjs.error.ArgumentsError.prototype</a></h1>




    <h2>
        <a href="#apidoc.element.mathjs.error.ArgumentsError.prototype.constructor" id="apidoc.element.mathjs.error.ArgumentsError.prototype.constructor">
        function <span class="apidocSignatureSpan">mathjs.error.ArgumentsError.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Error() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        }

        if (probOrN &amp;&amp; probOrN.isBigNumber) {
if (probOrN.isNegative()) {
  throw new Error('N/prob must be non-negative');
}

one = new probOrN.<span class="apidocCodeKeywordSpan">constructor</span>(1);

if (probOrN.lte(one)) {
  // quantileSeq([a, b, c, d, ...], prob[,sorted])
  return _quantileSeq(dataArr, probOrN, sorted);
}

if (probOrN.gt(one)) {
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.error.ArgumentsError.prototype.constructor" id="apidoc.module.mathjs.error.ArgumentsError.prototype.constructor">module mathjs.error.ArgumentsError.prototype.constructor</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.error.ArgumentsError.prototype.constructor.constructor" id="apidoc.element.mathjs.error.ArgumentsError.prototype.constructor.constructor">
        function <span class="apidocSignatureSpan">mathjs.error.ArgumentsError.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Function() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        }

        if (probOrN &amp;&amp; probOrN.isBigNumber) {
if (probOrN.isNegative()) {
  throw new Error('N/prob must be non-negative');
}

one = new probOrN.<span class="apidocCodeKeywordSpan">constructor</span>(1);

if (probOrN.lte(one)) {
  // quantileSeq([a, b, c, d, ...], prob[,sorted])
  return _quantileSeq(dataArr, probOrN, sorted);
}

if (probOrN.gt(one)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.error.ArgumentsError.prototype.constructor.captureStackTrace" id="apidoc.element.mathjs.error.ArgumentsError.prototype.constructor.captureStackTrace">
        function <span class="apidocSignatureSpan">mathjs.error.ArgumentsError.prototype.constructor.</span>captureStackTrace
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function captureStackTrace() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.error.DimensionError" id="apidoc.module.mathjs.error.DimensionError">module mathjs.error.DimensionError</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.error.DimensionError.DimensionError" id="apidoc.element.mathjs.error.DimensionError.DimensionError">
        function <span class="apidocSignatureSpan">mathjs.error.</span>DimensionError
        <span class="apidocSignatureSpan">(actual, expected, relation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DimensionError(actual, expected, relation) {
  if (!(this instanceof DimensionError)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  this.actual   = actual;
  this.expected = expected;
  this.relation = relation;

  this.message = 'Dimension mismatch (' +
      (Array.isArray(actual) ? ('[' + actual.join(', ') + ']') : actual) +
      ' ' + (this.relation || '!=') + ' ' +
      (Array.isArray(expected) ? ('[' + expected.join(', ') + ']') : expected) +
      ')';

  this.stack = (new Error()).stack;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.error.DimensionError.prototype" id="apidoc.module.mathjs.error.DimensionError.prototype">module mathjs.error.DimensionError.prototype</a></h1>




    <h2>
        <a href="#apidoc.element.mathjs.error.DimensionError.prototype.constructor" id="apidoc.element.mathjs.error.DimensionError.prototype.constructor">
        function <span class="apidocSignatureSpan">mathjs.error.DimensionError.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RangeError() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        }

        if (probOrN &amp;&amp; probOrN.isBigNumber) {
if (probOrN.isNegative()) {
  throw new Error('N/prob must be non-negative');
}

one = new probOrN.<span class="apidocCodeKeywordSpan">constructor</span>(1);

if (probOrN.lte(one)) {
  // quantileSeq([a, b, c, d, ...], prob[,sorted])
  return _quantileSeq(dataArr, probOrN, sorted);
}

if (probOrN.gt(one)) {
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.error.IndexError" id="apidoc.module.mathjs.error.IndexError">module mathjs.error.IndexError</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.error.IndexError.IndexError" id="apidoc.element.mathjs.error.IndexError.IndexError">
        function <span class="apidocSignatureSpan">mathjs.error.</span>IndexError
        <span class="apidocSignatureSpan">(index, min, max)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function IndexError(index, min, max) {
  if (!(this instanceof IndexError)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  this.index = index;
  if (arguments.length &lt; 3) {
    this.min = 0;
    this.max = min;
  }
  else {
    this.min = min;
    this.max = max;
  }

  if (this.min !== undefined &amp;&amp; this.index &lt; this.min) {
    this.message = 'Index out of range (' + this.index + ' &lt; ' + this.min + ')';
  }
  else if (this.max !== undefined &amp;&amp; this.index &gt;= this.max) {
    this.message = 'Index out of range (' + this.index + ' &gt; ' + (this.max - 1) + ')';
  }
  else {
    this.message = 'Index out of range (' + this.index + ')';
  }

  this.stack = (new Error()).stack;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.error.IndexError.prototype" id="apidoc.module.mathjs.error.IndexError.prototype">module mathjs.error.IndexError.prototype</a></h1>




    <h2>
        <a href="#apidoc.element.mathjs.error.IndexError.prototype.constructor" id="apidoc.element.mathjs.error.IndexError.prototype.constructor">
        function <span class="apidocSignatureSpan">mathjs.error.IndexError.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RangeError() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        }

        if (probOrN &amp;&amp; probOrN.isBigNumber) {
if (probOrN.isNegative()) {
  throw new Error('N/prob must be non-negative');
}

one = new probOrN.<span class="apidocCodeKeywordSpan">constructor</span>(1);

if (probOrN.lte(one)) {
  // quantileSeq([a, b, c, d, ...], prob[,sorted])
  return _quantileSeq(dataArr, probOrN, sorted);
}

if (probOrN.gt(one)) {
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.error_transform" id="apidoc.module.mathjs.error_transform">module mathjs.error_transform</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.error_transform.transform" id="apidoc.element.mathjs.error_transform.transform">
        function <span class="apidocSignatureSpan">mathjs.error_transform.</span>transform
        <span class="apidocSignatureSpan">(err)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">transform = function (err) {
  if (err &amp;&amp; err.isIndexError) {
    return new IndexError(
        err.index + 1,
        err.min + 1,
        err.max !== undefined ? err.max + 1 : undefined);
  }

  return err;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  /**
* Recursively transform a node tree via a transform function.
*
* For example, to replace all nodes of type SymbolNode having name 'x' with a
* ConstantNode with value 2:
*
*     var res = Node.<span class="apidocCodeKeywordSpan">transform</span>(function (node, path, parent) {
*       if (node &amp;&amp; node.isSymbolNode) &amp;&amp; (node.name == 'x')) {
*         return new ConstantNode(2);
*       }
*       else {
*         return node;
*       }
*     });
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.eval" id="apidoc.module.mathjs.eval">module mathjs.eval</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.eval.factory" id="apidoc.element.mathjs.eval.factory">
        function <span class="apidocSignatureSpan">mathjs.eval.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var parse = load(require('../parse'));

<span class="apidocCodeCommentSpan">  /**
   * Evaluate an expression.
   *
   * Note the evaluating arbitrary expressions may involve security risks,
   * see [http://mathjs.org/docs/expressions/security.html](http://mathjs.org/docs/expressions/security.html) for more information
.
   *
   * Syntax:
   *
   *     math.eval(expr)
   *     math.eval(expr, scope)
   *     math.eval([expr1, expr2, expr3, ...])
   *     math.eval([expr1, expr2, expr3, ...], scope)
   *
   * Example:
   *
   *     math.eval('(2+3)/4');                // 1.25
   *     math.eval('sqrt(3^2 + 4^2)');        // 5
   *     math.eval('sqrt(-4)');               // 2i
   *     math.eval(['a=3', 'b=4', 'a*b']);,   // [3, 4, 12]
   *
   *     var scope = {a:3, b:4};
   *     math.eval('a * b', scope);           // 12
   *
   * See also:
   *
   *    parse, compile
   *
   * @param {string | string[] | Matrix} expr   The expression to be evaluated
   * @param {Object} [scope]                    Scope to read/write variables
   * @return {*} The result of the expression
   * @throws {Error}
   */
</span>  return typed('compile', {
    'string': function (expr) {
      var scope = {};
      return parse(expr).compile().eval(scope);
    },

    'string, Object': function (expr, scope) {
      return parse(expr).compile().eval(scope);
    },

    'Array | Matrix': function (expr) {
      var scope = {};
      return deepMap(expr, function (entry) {
        return parse(entry).compile().eval(scope);
      });
    },

    'Array | Matrix, Object': function (expr, scope) {
      return deepMap(expr, function (entry) {
        return parse(entry).compile().eval(scope);
      });
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.exp" id="apidoc.module.mathjs.exp">module mathjs.exp</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.exp.factory" id="apidoc.element.mathjs.exp.factory">
        function <span class="apidocSignatureSpan">mathjs.exp.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
<span class="apidocCodeCommentSpan">  /**
   * Calculate the exponent of a value.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.exp(x)
   *
   * Examples:
   *
   *    math.exp(2);                  // returns number 7.3890560989306495
   *    math.pow(math.e, 2);          // returns number 7.3890560989306495
   *    math.log(math.exp(2));        // returns number 2
   *
   *    math.exp([1, 2, 3]);
   *    // returns Array [
   *    //   2.718281828459045,
   *    //   7.3890560989306495,
   *    //   20.085536923187668
   *    // ]
   *
   * See also:
   *
   *    log, pow
   *
   * @param {number | BigNumber | Complex | Array | Matrix} x  A number or matrix to exponentiate
   * @return {number | BigNumber | Complex | Array | Matrix} Exponent of `x`
   */
</span>  var exp = typed('exp', {
    'number': Math.exp,

    'Complex': function (x) {
      return x.exp();
    },

    'BigNumber': function (x) {
      return x.exp();
    },

    'Array | Matrix': function (x) {
      // TODO: exp(sparse) should return a dense matrix since exp(0)==1
      return deepMap(x, exp);
    }
  });

  exp.toTex = {1: '\\exp\\left(${args[0]}\\right)'};

  return exp;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.expression" id="apidoc.module.mathjs.expression">module mathjs.expression</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.expression.Parser" id="apidoc.element.mathjs.expression.Parser">
        function <span class="apidocSignatureSpan">mathjs.expression.</span>Parser
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Parser() {
  if (!(this instanceof Parser)) {
    throw new SyntaxError(
        'Constructor must be called with the new operator');
  }
  this.scope = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.parse" id="apidoc.element.mathjs.expression.parse">
        function <span class="apidocSignatureSpan">mathjs.expression.</span>parse
        <span class="apidocSignatureSpan">(expr, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parse(expr, options) {
  if (arguments.length != 1 &amp;&amp; arguments.length != 2) {
    throw new ArgumentsError('parse', arguments.length, 1, 2);
  }

  // pass extra nodes
  extra_nodes = (options &amp;&amp; options.nodes) ? options.nodes : {};

  if (typeof expr === 'string') {
    // parse a single expression
    expression = expr;
    return parseStart();
  }
  else if (Array.isArray(expr) || expr instanceof type.Matrix) {
    // parse an array or matrix with expressions
    return deepMap(expr, function (elem) {
      if (typeof elem !== 'string') throw new TypeError('String expected');

      expression = elem;
      return parseStart();
    });
  }
  else {
    // oops
    throw new TypeError('String or matrix expected');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        if (!expr) {
          break;
        }
        switch (mode) {
          case 'eval':
            // evaluate expression
            try {
var node = math.<span class="apidocCodeKeywordSpan">parse</span>(expr);
var res = node.eval(scope);

if (res &amp;&amp; res.isResultSet) {
  // we can have 0 or 1 results in the ResultSet, as the CLI
  // does not allow multiple expressions separated by a return
  res = res.entries[0];
  node = node.blocks
...</pre></li>
    </ul>










</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.expression.Parser" id="apidoc.module.mathjs.expression.Parser">module mathjs.expression.Parser</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.expression.Parser.Parser" id="apidoc.element.mathjs.expression.Parser.Parser">
        function <span class="apidocSignatureSpan">mathjs.expression.</span>Parser
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Parser() {
  if (!(this instanceof Parser)) {
    throw new SyntaxError(
        'Constructor must be called with the new operator');
  }
  this.scope = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.expression.Parser.prototype" id="apidoc.module.mathjs.expression.Parser.prototype">module mathjs.expression.Parser.prototype</a></h1>




    <h2>
        <a href="#apidoc.element.mathjs.expression.Parser.prototype.clear" id="apidoc.element.mathjs.expression.Parser.prototype.clear">
        function <span class="apidocSignatureSpan">mathjs.expression.Parser.prototype.</span>clear
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clear = function () {
  for (var name in this.scope) {
    if (this.scope.hasOwnProperty(name)) {
      delete this.scope[name];
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Methods:
*    var result = parser.eval(expr);    // evaluate an expression
*    var value = parser.get(name);      // retrieve a variable from the parser
*    var values = parser.getAll();      // retrieve all defined variables
*    parser.set(name, value);           // set a variable in the parser
*    parser.remove(name);               // clear a variable from the
*                                       // parsers scope
*    parser.<span class="apidocCodeKeywordSpan">clear</span>();                    // clear the parsers scope
*
* Example usage:
*    var parser = new Parser();
*    // Note: there is a convenience method which can be used instead:
*    // var parser = new math.parser();
*
*    // evaluate expressions
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.Parser.prototype.compile" id="apidoc.element.mathjs.expression.Parser.prototype.compile">
        function <span class="apidocSignatureSpan">mathjs.expression.Parser.prototype.</span>compile
        <span class="apidocSignatureSpan">(expr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (expr) {
  throw new Error('Parser.compile is deprecated. Use math.compile instead.');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*     parse(expr, options)
*     parse([expr1, expr2, expr3, ...])
*     parse([expr1, expr2, expr3, ...], options)
*
* Example:
*
*     var node = parse('sqrt(3^2 + 4^2)');
*     node.<span class="apidocCodeKeywordSpan">compile</span>(math).eval(); // 5
*
*     var scope = {a:3, b:4}
*     var node = parse('a * b'); // 12
*     var code = node.compile(math);
*     code.eval(scope); // 12
*     scope.a = 5;
*     code.eval(scope); // 20
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.Parser.prototype.eval" id="apidoc.element.mathjs.expression.Parser.prototype.eval">
        function <span class="apidocSignatureSpan">mathjs.expression.Parser.prototype.</span>eval
        <span class="apidocSignatureSpan">(expr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eval = function (expr) {
  // TODO: validate arguments
  return _parse(expr)
      .compile()
      .eval(this.scope);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
math.atan2(3, -3) / math.pi;      // 0.75
math.log(1000, 10);               // 3
math.sqrt(-4);                    // 2i
math.pow([[-1, 2], [3, 1]], 2);   // [[7, 0], [0, 7]]
math.derivative('x^2 + x', 'x');  // 2 * x + 1

// expressions
math.<span class="apidocCodeKeywordSpan">eval</span>('12 / (2.3 + 0.7)');    // 4
math.eval('5.08 cm to inch');     // 2 inch
math.eval('sin(45 deg) ^ 2');     // 0.5
math.eval('9 / 3 + 2i');          // 3 + 2i
math.eval('det([-1, 2; 3, 1])');  // -7

// chaining
math.chain(3)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.Parser.prototype.get" id="apidoc.element.mathjs.expression.Parser.prototype.get">
        function <span class="apidocSignatureSpan">mathjs.expression.Parser.prototype.</span>get
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get = function (name) {
  // TODO: validate arguments
  return name in this.scope
      ? customs.getSafeProperty(this.scope, name)
      : undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Parser contains methods to evaluate or parse expressions, and has a number
* of convenience methods to get, set, and remove variables from memory. Parser
* keeps a scope containing variables in memory, which is used for all
* evaluations.
*
* Methods:
*    var result = parser.eval(expr);    // evaluate an expression
*    var value = parser.<span class="apidocCodeKeywordSpan">get</span>(name);      // retrieve a variable from the parser
*    var values = parser.getAll();      // retrieve all defined variables
*    parser.set(name, value);           // set a variable in the parser
*    parser.remove(name);               // clear a variable from the
*                                       // parsers scope
*    parser.clear();                    // clear the parsers scope
*
* Example usage:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.Parser.prototype.getAll" id="apidoc.element.mathjs.expression.Parser.prototype.getAll">
        function <span class="apidocSignatureSpan">mathjs.expression.Parser.prototype.</span>getAll
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getAll = function () {
  return extend({}, this.scope);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* of convenience methods to get, set, and remove variables from memory. Parser
* keeps a scope containing variables in memory, which is used for all
* evaluations.
*
* Methods:
*    var result = parser.eval(expr);    // evaluate an expression
*    var value = parser.get(name);      // retrieve a variable from the parser
*    var values = parser.<span class="apidocCodeKeywordSpan">getAll</span>();      // retrieve all defined variables
*    parser.set(name, value);           // set a variable in the parser
*    parser.remove(name);               // clear a variable from the
*                                       // parsers scope
*    parser.clear();                    // clear the parsers scope
*
* Example usage:
*    var parser = new Parser();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.Parser.prototype.parse" id="apidoc.element.mathjs.expression.Parser.prototype.parse">
        function <span class="apidocSignatureSpan">mathjs.expression.Parser.prototype.</span>parse
        <span class="apidocSignatureSpan">(expr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function (expr) {
  throw new Error('Parser.parse is deprecated. Use math.parse instead.');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        if (!expr) {
          break;
        }
        switch (mode) {
          case 'eval':
            // evaluate expression
            try {
var node = math.<span class="apidocCodeKeywordSpan">parse</span>(expr);
var res = node.eval(scope);

if (res &amp;&amp; res.isResultSet) {
  // we can have 0 or 1 results in the ResultSet, as the CLI
  // does not allow multiple expressions separated by a return
  res = res.entries[0];
  node = node.blocks
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.Parser.prototype.remove" id="apidoc.element.mathjs.expression.Parser.prototype.remove">
        function <span class="apidocSignatureSpan">mathjs.expression.Parser.prototype.</span>remove
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">remove = function (name) {
  // TODO: validate arguments
  delete this.scope[name];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* evaluations.
*
* Methods:
*    var result = parser.eval(expr);    // evaluate an expression
*    var value = parser.get(name);      // retrieve a variable from the parser
*    var values = parser.getAll();      // retrieve all defined variables
*    parser.set(name, value);           // set a variable in the parser
*    parser.<span class="apidocCodeKeywordSpan">remove</span>(name);               // clear a variable from the
*                                       // parsers scope
*    parser.clear();                    // clear the parsers scope
*
* Example usage:
*    var parser = new Parser();
*    // Note: there is a convenience method which can be used instead:
*    // var parser = new math.parser();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.Parser.prototype.set" id="apidoc.element.mathjs.expression.Parser.prototype.set">
        function <span class="apidocSignatureSpan">mathjs.expression.Parser.prototype.</span>set
        <span class="apidocSignatureSpan">(name, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">set = function (name, value) {
  // TODO: validate arguments
  return customs.setSafeProperty(this.scope, name, value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* keeps a scope containing variables in memory, which is used for all
* evaluations.
*
* Methods:
*    var result = parser.eval(expr);    // evaluate an expression
*    var value = parser.get(name);      // retrieve a variable from the parser
*    var values = parser.getAll();      // retrieve all defined variables
*    parser.<span class="apidocCodeKeywordSpan">set</span>(name, value);           // set a variable in the parser
*    parser.remove(name);               // clear a variable from the
*                                       // parsers scope
*    parser.clear();                    // clear the parsers scope
*
* Example usage:
*    var parser = new Parser();
*    // Note: there is a convenience method which can be used instead:
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.expression.mathWithTransform" id="apidoc.module.mathjs.expression.mathWithTransform">module mathjs.expression.mathWithTransform</a></h1>






    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.AccessorNode" id="apidoc.element.mathjs.expression.mathWithTransform.AccessorNode">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>AccessorNode
        <span class="apidocSignatureSpan">(object, index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AccessorNode(object, index) {
  if (!(this instanceof AccessorNode)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  if (!(object &amp;&amp; object.isNode)) {
    throw new TypeError('Node expected for parameter "object"');
  }
  if (!(index &amp;&amp; index.isIndexNode)) {
    throw new TypeError('IndexNode expected for parameter "index"');
  }

  this.object = object || null;
  this.index = index;

  // readonly property name
  Object.defineProperty(this, 'name', {
    get: function () {
      if (this.index) {
        return (this.index.isObjectProperty())
            ? this.index.getObjectProperty()
            : '';
      }
      else {
        return this.object.name || '';
      }
    }.bind(this),
    set: function () {
      throw new Error('Cannot assign a new name, name is read-only');
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.ArgumentsError" id="apidoc.element.mathjs.expression.mathWithTransform.ArgumentsError">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>ArgumentsError
        <span class="apidocSignatureSpan">(fn, count, min, max)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ArgumentsError(fn, count, min, max) {
  if (!(this instanceof ArgumentsError)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  this.fn = fn;
  this.count = count;
  this.min = min;
  this.max = max;

  this.message = 'Wrong number of arguments in function ' + fn +
      ' (' + count + ' provided, ' +
      min + ((max != undefined) ? ('-' + max) : '') + ' expected)';

  this.stack = (new Error()).stack;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.ArrayNode" id="apidoc.element.mathjs.expression.mathWithTransform.ArrayNode">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>ArrayNode
        <span class="apidocSignatureSpan">(items)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ArrayNode(items) {
  if (!(this instanceof ArrayNode)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  this.items = items || [];

  // validate input
  if (!Array.isArray(this.items)
      || !this.items.every(function (item) {return item &amp;&amp; item.isNode;})) {
    throw new TypeError('Array containing Nodes expected');
  }

  // TODO: deprecated since v3, remove some day
  var deprecated = function () {
    throw new Error('Property `ArrayNode.nodes` is deprecated, use `ArrayNode.items` instead');
  };
  Object.defineProperty(this, 'nodes', { get: deprecated, set: deprecated });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.AssignmentNode" id="apidoc.element.mathjs.expression.mathWithTransform.AssignmentNode">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>AssignmentNode
        <span class="apidocSignatureSpan">(object, index, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AssignmentNode(object, index, value) {
  if (!(this instanceof AssignmentNode)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  this.object = object;
  this.index = value ? index : null;
  this.value = value ? value : index;

  // validate input
  if (!object || !(object.isSymbolNode || object.isAccessorNode)) {
    throw new TypeError('SymbolNode or AccessorNode expected as "object"');
  }
  if (object &amp;&amp; object.isSymbolNode &amp;&amp; object.name === 'end') {
    throw new Error('Cannot assign to symbol "end"');
  }
  if (this.index &amp;&amp; !this.index.isIndexNode) {
    throw new TypeError('IndexNode expected as "index"');
  }
  if (!this.value || !this.value.isNode) {
    throw new TypeError('Node expected as "value"');
  }

  // readonly property name
  Object.defineProperty(this, 'name', {
    get: function () {
      if (this.index) {
        return (this.index.isObjectProperty())
            ? this.index.getObjectProperty()
            : '';
      }
      else {
        return this.object.name || '';
      }
    }.bind(this),
    set: function () {
      throw new Error('Cannot assign a new name, name is read-only');
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.BigNumber" id="apidoc.element.mathjs.expression.mathWithTransform.BigNumber">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>BigNumber
        <span class="apidocSignatureSpan">(v)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Decimal(v) {
  var e, i, t,
    x = this;

  // Decimal called without new.
  if (!(x instanceof Decimal)) return new Decimal(v);

  // Retain a reference to this Decimal constructor, and shadow Decimal.prototype.constructor
  // which points to Object.
  x.constructor = Decimal;

  // Duplicate.
  if (v instanceof Decimal) {
    x.s = v.s;
    x.e = v.e;
    x.d = (v = v.d) ? v.slice() : v;
    return;
  }

  t = typeof v;

  if (t === 'number') {
    if (v === 0) {
      x.s = 1 / v &lt; 0 ? -1 : 1;
      x.e = 0;
      x.d = [0];
      return;
    }

    if (v &lt; 0) {
      v = -v;
      x.s = -1;
    } else {
      x.s = 1;
    }

    // Fast path for small integers.
    if (v === ~~v &amp;&amp; v &lt; 1e7) {
      for (e = 0, i = v; i &gt;= 10; i /= 10) e++;
      x.e = e;
      x.d = [v];
      return;

    // Infinity, NaN.
    } else if (v * 0 !== 0) {
      if (!v) x.s = NaN;
      x.e = NaN;
      x.d = null;
      return;
    }

    return parseDecimal(x, v.toString());

  } else if (t !== 'string') {
    throw Error(invalidArgument + v);
  }

  // Minus sign?
  if (v.charCodeAt(0) === 45) {
    v = v.slice(1);
    x.s = -1;
  } else {
    x.s = 1;
  }

  return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  setConstant(math, 'true', true);
  setConstant(math, 'false', false);
  setConstant(math, 'null', null);
  setConstant(math, 'uninitialized', require('./utils/array').UNINITIALIZED);

  if (config.number === 'BigNumber') {
setConstant(math, 'Infinity', new type.<span class="apidocCodeKeywordSpan">BigNumber</span>(Infinity));
setConstant(math, 'NaN', new type.BigNumber(NaN));

setLazyConstant(math, 'pi',  function () {return bigConstants.pi(type.BigNumber)});
setLazyConstant(math, 'tau', function () {return bigConstants.tau(type.BigNumber)});
setLazyConstant(math, 'e',   function () {return bigConstants.e(type.BigNumber)});
setLazyConstant(math, 'phi', function () {return bigConstants.phi(type.BigNumber)}); // golden ratio, (1+sqrt(5))/2
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.BlockNode" id="apidoc.element.mathjs.expression.mathWithTransform.BlockNode">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>BlockNode
        <span class="apidocSignatureSpan">(blocks)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BlockNode(blocks) {
  if (!(this instanceof BlockNode)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  // validate input, copy blocks
  if (!Array.isArray(blocks)) throw new Error('Array expected');
  this.blocks = blocks.map(function (block) {
    var node = block &amp;&amp; block.node;
    var visible = block &amp;&amp; block.visible !== undefined ? block.visible : true;

    if (!(node &amp;&amp; node.isNode))      throw new TypeError('Property "node" must be a Node');
    if (typeof visible !== 'boolean') throw new TypeError('Property "visible" must be a boolean');

    return {
      node: node,
      visible: visible
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.Chain" id="apidoc.element.mathjs.expression.mathWithTransform.Chain">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>Chain
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Chain(value) {
  if (!(this instanceof Chain)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  if (value &amp;&amp; value.isChain) {
    this.value = value.value;
  }
  else {
    this.value = value;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.Complex" id="apidoc.element.mathjs.expression.mathWithTransform.Complex">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>Complex
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Complex(a, b) {

  if (!(this instanceof Complex)) {
    return new Complex(a, b);
  }

  parse(a, b); // mutates P

  this["re"] = P["re"];
  this["im"] = P["im"];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
    return new type.BigNumber(x);
  }
}, {
  from: 'number',
  to: 'Complex',
  convert: function (x) {
    return new type.<span class="apidocCodeKeywordSpan">Complex</span>(x, 0);
  }
}, {
  from: 'number',
  to: 'string',
  convert: function (x) {
    return x + '';
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.ConditionalNode" id="apidoc.element.mathjs.expression.mathWithTransform.ConditionalNode">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>ConditionalNode
        <span class="apidocSignatureSpan">(condition, trueExpr, falseExpr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ConditionalNode(condition, trueExpr, falseExpr) {
  if (!(this instanceof ConditionalNode)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }
  if (!(condition &amp;&amp; condition.isNode)) throw new TypeError('Parameter condition must be a Node');
  if (!(trueExpr &amp;&amp; trueExpr.isNode))  throw new TypeError('Parameter trueExpr must be a Node');
  if (!(falseExpr &amp;&amp; falseExpr.isNode)) throw new TypeError('Parameter falseExpr must be a Node');

  this.condition = condition;
  this.trueExpr = trueExpr;
  this.falseExpr = falseExpr;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.ConstantNode" id="apidoc.element.mathjs.expression.mathWithTransform.ConstantNode">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>ConstantNode
        <span class="apidocSignatureSpan">(value, valueType)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ConstantNode(value, valueType) {
  if (!(this instanceof ConstantNode)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  if (valueType) {
    if (typeof valueType !== 'string') {
      throw new TypeError('String expected for parameter "valueType"');
    }
    if (typeof value !== 'string') {
      throw new TypeError('String expected for parameter "value"');
    }

    this.value = value;
    this.valueType = valueType;
  }
  else {
    // stringify the value and determine the type
    this.value = value + '';
    this.valueType = getType(value);
  }

  if (!SUPPORTED_TYPES[this.valueType]) {
    throw new TypeError('Unsupported type of value "' + this.valueType + '"');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.DenseMatrix" id="apidoc.element.mathjs.expression.mathWithTransform.DenseMatrix">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>DenseMatrix
        <span class="apidocSignatureSpan">(data, datatype)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DenseMatrix(data, datatype) {
  if (!(this instanceof DenseMatrix))
    throw new SyntaxError('Constructor must be called with the new operator');
  if (datatype &amp;&amp; !isString(datatype))
    throw new Error('Invalid datatype: ' + datatype);

  if (data &amp;&amp; data.isMatrix === true) {
    // check data is a DenseMatrix
    if (data.type === 'DenseMatrix') {
      // clone data &amp; size
      this._data = object.clone(data._data);
      this._size = object.clone(data._size);
      this._datatype = datatype || data._datatype;
    }
    else {
      // build data from existing matrix
      this._data = data.toArray();
      this._size = data.size();
      this._datatype = datatype || data._datatype;
    }
  }
  else if (data &amp;&amp; isArray(data.data) &amp;&amp; isArray(data.size)) {
    // initialize fields from JSON representation
    this._data = data.data;
    this._size = data.size;
    this._datatype = datatype || data.datatype;
  }
  else if (isArray(data)) {
    // replace nested Matrices with Arrays
    this._data = preprocess(data);
    // get the dimensions of the array
    this._size = array.size(this._data);
    // verify the dimensions of the array, TODO: compute size while processing array
    array.validate(this._data, this._size);
    // data type unknown
    this._datatype = datatype;
  }
  else if (data) {
    // unsupported type
    throw new TypeError('Unsupported type of data (' + util.types.type(data) + ')');
  }
  else {
    // nothing provided
    this._data = [];
    this._size = [0];
    this._datatype = datatype;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return new type.Fraction(0);
  }
}, {
  from: 'Array',
  to: 'Matrix',
  convert: function (array) {
    // TODO: how to decide on the right type of matrix to create?
    return new type.<span class="apidocCodeKeywordSpan">DenseMatrix</span>(array);
  }
}, {
  from: 'Matrix',
  to: 'Array',
  convert: function (matrix) {
    return matrix.valueOf();
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.DimensionError" id="apidoc.element.mathjs.expression.mathWithTransform.DimensionError">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>DimensionError
        <span class="apidocSignatureSpan">(actual, expected, relation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DimensionError(actual, expected, relation) {
  if (!(this instanceof DimensionError)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  this.actual   = actual;
  this.expected = expected;
  this.relation = relation;

  this.message = 'Dimension mismatch (' +
      (Array.isArray(actual) ? ('[' + actual.join(', ') + ']') : actual) +
      ' ' + (this.relation || '!=') + ' ' +
      (Array.isArray(expected) ? ('[' + expected.join(', ') + ']') : expected) +
      ')';

  this.stack = (new Error()).stack;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.FibonacciHeap" id="apidoc.element.mathjs.expression.mathWithTransform.FibonacciHeap">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>FibonacciHeap
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function FibonacciHeap() {
  if (!(this instanceof FibonacciHeap))
    throw new SyntaxError('Constructor must be called with the new operator');

  // initialize fields
  this._minimum = null;
  this._size = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
function Spa() {
  if (!(this instanceof Spa))
    throw new SyntaxError('Constructor must be called with the new operator');

  // allocate vector, TODO use typed arrays
  this._values = [];
  this._heap = new type.<span class="apidocCodeKeywordSpan">FibonacciHeap</span>();
}

/**
 * Attach type information
 */
Spa.prototype.type = 'Spa';
Spa.prototype.isSpa = true;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.Fraction" id="apidoc.element.mathjs.expression.mathWithTransform.Fraction">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>Fraction
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Fraction(a, b) {

  if (!(this instanceof Fraction)) {
    return new Fraction(a, b);
  }

  parse(a, b);

  if (Fraction['REDUCE']) {
    a = gcd(P["d"], P["n"]); // Abuse a
  } else {
    a = 1;
  }

  this["s"] = P["s"];
  this["n"] = P["n"] / a;
  this["d"] = P["d"] / a;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  to: 'Fraction',
  convert: function (x) {
    if (digits(x) &gt; 15) {
      throw new TypeError('Cannot implicitly convert a number with &gt;15 significant digits to Fraction ' +
          '(value: ' + x + '). ' +
          'Use function fraction(x) to convert to Fraction.');
    }
    return new type.<span class="apidocCodeKeywordSpan">Fraction</span>(x);
  }
}, {
// FIXME: add conversion from Fraction to number, for example for `sqrt(fraction(1,3))`
//  from: 'Fraction',
//  to: 'number',
//  convert: function (x) {
//    return x.valueOf();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.FunctionAssignmentNode" id="apidoc.element.mathjs.expression.mathWithTransform.FunctionAssignmentNode">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>FunctionAssignmentNode
        <span class="apidocSignatureSpan">(name, params, expr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function FunctionAssignmentNode(name, params, expr) {
  if (!(this instanceof FunctionAssignmentNode)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  // validate input
  if (typeof name !== 'string') throw new TypeError('String expected for parameter "name"');
  if (!Array.isArray(params))  throw new TypeError('Array containing strings or objects expected for parameter "params"');
  if (!(expr &amp;&amp; expr.isNode)) throw new TypeError('Node expected for parameter "expr"');
  if (name in keywords) throw new Error('Illegal function name, "' + name + '" is a reserved keyword');

  this.name = name;
  this.params = params.map(function (param) {
    return param &amp;&amp; param.name || param;
  });
  this.types = params.map(function (param) {
    return param &amp;&amp; param.type || 'any'
  });
  this.expr = expr;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.FunctionNode" id="apidoc.element.mathjs.expression.mathWithTransform.FunctionNode">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>FunctionNode
        <span class="apidocSignatureSpan">(fn, args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function FunctionNode(fn, args) {
  if (!(this instanceof FunctionNode)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  if (typeof fn === 'string') {
    fn = new SymbolNode(fn);
  }

  // validate input
  if (!fn || !fn.isNode) throw new TypeError('Node expected as parameter "fn"');
  if (!Array.isArray(args)
      || !args.every(function (arg) {return arg &amp;&amp; arg.isNode;})) {
    throw new TypeError('Array containing Nodes expected for parameter "args"');
  }

  this.fn = fn;
  this.args = args || [];

  // readonly property name
  Object.defineProperty(this, 'name', {
    get: function () {
      return this.fn.name || '';
    }.bind(this),
    set: function () {
      throw new Error('Cannot assign a new name, name is read-only');
    }
  });

  // TODO: deprecated since v3, remove some day
  var deprecated = function () {
    throw new Error('Property `FunctionNode.object` is deprecated, use `FunctionNode.fn` instead');
  };
  Object.defineProperty(this, 'object', { get: deprecated, set: deprecated });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.Help" id="apidoc.element.mathjs.expression.mathWithTransform.Help">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>Help
        <span class="apidocSignatureSpan">(doc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Help(doc) {
  if (!(this instanceof Help)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  if (!doc)  throw new Error('Argument "doc" missing');

  this.doc = doc;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.ImmutableDenseMatrix" id="apidoc.element.mathjs.expression.mathWithTransform.ImmutableDenseMatrix">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>ImmutableDenseMatrix
        <span class="apidocSignatureSpan">(data, datatype)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ImmutableDenseMatrix(data, datatype) {
  if (!(this instanceof ImmutableDenseMatrix))
    throw new SyntaxError('Constructor must be called with the new operator');
  if (datatype &amp;&amp; !isString(datatype))
    throw new Error('Invalid datatype: ' + datatype);

  if ((data &amp;&amp; data.isMatrix === true) || isArray(data)) {
    // use DenseMatrix implementation
    var matrix = new DenseMatrix(data, datatype);
    // internal structures
    this._data = matrix._data;
    this._size = matrix._size;
    this._datatype = matrix._datatype;
    this._min = null;
    this._max = null;
  }
  else if (data &amp;&amp; isArray(data.data) &amp;&amp; isArray(data.size)) {
    // initialize fields from JSON representation
    this._data = data.data;
    this._size = data.size;
    this._datatype = data.datatype;
    this._min = typeof data.min !== 'undefined' ? data.min : null;
    this._max = typeof data.max !== 'undefined' ? data.max : null;
  }
  else if (data) {
    // unsupported type
    throw new TypeError('Unsupported type of data (' + util.types.type(data) + ')');
  }
  else {
    // nothing provided
    this._data = [];
    this._size = [0];
    this._datatype = datatype;
    this._min = null;
    this._max = null;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // loop array elements
  for (var i = 0, l = arg.length; i &lt; l; i++) {
    if (typeof arg[i] !== 'number' || !isInteger(arg[i])) {
      throw new TypeError('Index parameters must be positive integer numbers');
    }
  }
  // create matrix
  return new type.<span class="apidocCodeKeywordSpan">ImmutableDenseMatrix</span>(arg);
}

/**
 * Create a clone of the index
 * @memberof Index
 * @return {Index} clone
 */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.Index" id="apidoc.element.mathjs.expression.mathWithTransform.Index">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>Index
        <span class="apidocSignatureSpan">(ranges)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Index(ranges) {
  if (!(this instanceof Index)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  this._dimensions = [];
  this._isScalar = true;

  for (var i = 0, ii = arguments.length; i &lt; ii; i++) {
    var arg = arguments[i];

    if (arg &amp;&amp; (arg.isRange === true)) {
      this._dimensions.push(arg);
      this._isScalar = false;
    }
    else if (arg &amp;&amp; (Array.isArray(arg) || arg.isMatrix === true)) {
      // create matrix
      var m = _createImmutableMatrix(arg.valueOf());
      this._dimensions.push(m);
      // size
      var size = m.size();
      // scalar
      if (size.length !== 1 || size[0] !== 1) {
        this._isScalar = false;
      }
    }
    else if (typeof arg === 'number') {
      this._dimensions.push(_createImmutableMatrix([arg]));
    }
    else if (typeof arg === 'string') {
      // object property (arguments.count should be 1)
      this._dimensions.push(arg);
    }
    // TODO: implement support for wildcard '*'
    else {
      throw new TypeError('Dimension must be an Array, Matrix, number, string, or Range');
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      else {
        throw new TypeError('Dimension must be an Array, Matrix, number, string, or Range');
      }

      args[i] = arg;
    }

    var res = new type.<span class="apidocCodeKeywordSpan">Index</span>();
    type.Index.apply(res, args);
    return res;
  };
}

exports.name = 'index';
exports.path = 'expression.transform';
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.IndexError" id="apidoc.element.mathjs.expression.mathWithTransform.IndexError">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>IndexError
        <span class="apidocSignatureSpan">(index, min, max)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function IndexError(index, min, max) {
  if (!(this instanceof IndexError)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  this.index = index;
  if (arguments.length &lt; 3) {
    this.min = 0;
    this.max = min;
  }
  else {
    this.min = min;
    this.max = max;
  }

  if (this.min !== undefined &amp;&amp; this.index &lt; this.min) {
    this.message = 'Index out of range (' + this.index + ' &lt; ' + this.min + ')';
  }
  else if (this.max !== undefined &amp;&amp; this.index &gt;= this.max) {
    this.message = 'Index out of range (' + this.index + ' &gt; ' + (this.max - 1) + ')';
  }
  else {
    this.message = 'Index out of range (' + this.index + ')';
  }

  this.stack = (new Error()).stack;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.IndexNode" id="apidoc.element.mathjs.expression.mathWithTransform.IndexNode">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>IndexNode
        <span class="apidocSignatureSpan">(dimensions, dotNotation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function IndexNode(dimensions, dotNotation) {
  if (!(this instanceof IndexNode)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  this.dimensions = dimensions;
  this.dotNotation = dotNotation || false;

  // validate input
  if (!isArray(dimensions)
      || !dimensions.every(function (range) {return range &amp;&amp; range.isNode;})) {
    throw new TypeError('Array containing Nodes expected for parameter "dimensions"');
  }
  if (this.dotNotation &amp;&amp; !this.isObjectProperty()) {
    throw new Error('dotNotation only applicable for object properties');
  }

  // TODO: deprecated since v3, remove some day
  var deprecated = function () {
    throw new Error('Property `IndexNode.object` is deprecated, use `IndexNode.fn` instead');
  };
  Object.defineProperty(this, 'object', { get: deprecated, set: deprecated });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.Matrix" id="apidoc.element.mathjs.expression.mathWithTransform.Matrix">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>Matrix
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Matrix() {
  if (!(this instanceof Matrix)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.Node" id="apidoc.element.mathjs.expression.mathWithTransform.Node">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>Node
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Node() {
  if (!(this instanceof Node)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.ObjectNode" id="apidoc.element.mathjs.expression.mathWithTransform.ObjectNode">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>ObjectNode
        <span class="apidocSignatureSpan">(properties)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ObjectNode(properties) {
  if (!(this instanceof ObjectNode)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  this.properties = properties || {};

  // validate input
  if (properties) {
    if (!(typeof properties === 'object') || Object.keys(properties).some(function (key) {
          return !properties[key] || !properties[key].isNode;
        })) {
      throw new TypeError('Object containing Nodes expected');
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.OperatorNode" id="apidoc.element.mathjs.expression.mathWithTransform.OperatorNode">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>OperatorNode
        <span class="apidocSignatureSpan">(op, fn, args, implicit)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function OperatorNode(op, fn, args, implicit) {
  if (!(this instanceof OperatorNode)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  //validate input
  if (typeof op !== 'string') {
    throw new TypeError('string expected for parameter "op"');
  }
  if (typeof fn !== 'string') {
    throw new TypeError('string expected for parameter "fn"');
  }
  if (!Array.isArray(args)
      || !args.every(function (node) {return node &amp;&amp; node.isNode;})) {
    throw new TypeError('Array containing Nodes expected for parameter "args"');
  }

  this.implicit = (implicit === true);
  this.op = op;
  this.fn = fn;
  this.args = args || [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.ParenthesisNode" id="apidoc.element.mathjs.expression.mathWithTransform.ParenthesisNode">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>ParenthesisNode
        <span class="apidocSignatureSpan">(content)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ParenthesisNode(content) {
  if (!(this instanceof ParenthesisNode)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  // validate input
  if (!(content &amp;&amp; content.isNode)) {
    throw new TypeError('Node expected for parameter "content"');
  }

  this.content = content;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.Parser" id="apidoc.element.mathjs.expression.mathWithTransform.Parser">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>Parser
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Parser() {
  if (!(this instanceof Parser)) {
    throw new SyntaxError(
        'Constructor must be called with the new operator');
  }
  this.scope = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.Range" id="apidoc.element.mathjs.expression.mathWithTransform.Range">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>Range
        <span class="apidocSignatureSpan">(start, end, step)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Range(start, end, step) {
  if (!(this instanceof Range)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  if (start != null) {
    if (start.isBigNumber === true)
      start = start.toNumber();
    else if (typeof start !== 'number')
      throw new TypeError('Parameter start must be a number');
  }
  if (end != null) {
    if (end.isBigNumber === true)
      end = end.toNumber();
    else if (typeof end !== 'number')
      throw new TypeError('Parameter end must be a number');
  }
  if (step != null) {
    if (step.isBigNumber === true)
      step = step.toNumber();
    else if (typeof step !== 'number')
      throw new TypeError('Parameter step must be a number');
  }

  this.start = (start != null) ? parseFloat(start) : 0;
  this.end   = (end != null)   ? parseFloat(end)   : 0;
  this.step  = (step != null)  ? parseFloat(step)  : 1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.RangeNode" id="apidoc.element.mathjs.expression.mathWithTransform.RangeNode">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>RangeNode
        <span class="apidocSignatureSpan">(start, end, step)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RangeNode(start, end, step) {
  if (!(this instanceof RangeNode)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  // validate inputs
  if (!(start &amp;&amp; start.isNode)) throw new TypeError('Node expected');
  if (!(end &amp;&amp; end.isNode)) throw new TypeError('Node expected');
  if (step &amp;&amp; !(step &amp;&amp; step.isNode)) throw new TypeError('Node expected');
  if (arguments.length &gt; 3) throw new Error('Too many arguments');

  this.start = start;         // included lower-bound
  this.end = end;           // included upper-bound
  this.step = step || null;  // optional step
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.ResultSet" id="apidoc.element.mathjs.expression.mathWithTransform.ResultSet">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>ResultSet
        <span class="apidocSignatureSpan">(entries)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ResultSet(entries) {
  if (!(this instanceof ResultSet)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  this.entries = entries || [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.Spa" id="apidoc.element.mathjs.expression.mathWithTransform.Spa">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>Spa
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Spa() {
  if (!(this instanceof Spa))
    throw new SyntaxError('Constructor must be called with the new operator');

  // allocate vector, TODO use typed arrays
  this._values = [];
  this._heap = new type.FibonacciHeap();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.SparseMatrix" id="apidoc.element.mathjs.expression.mathWithTransform.SparseMatrix">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>SparseMatrix
        <span class="apidocSignatureSpan">(data, datatype)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SparseMatrix(data, datatype) {
  if (!(this instanceof SparseMatrix))
    throw new SyntaxError('Constructor must be called with the new operator');
  if (datatype &amp;&amp; !isString(datatype))
    throw new Error('Invalid datatype: ' + datatype);

  if (data &amp;&amp; data.isMatrix === true) {
    // create from matrix
    _createFromMatrix(this, data, datatype);
  }
  else if (data &amp;&amp; isArray(data.index) &amp;&amp; isArray(data.ptr) &amp;&amp; isArray(data.size)) {
    // initialize fields
    this._values = data.values;
    this._index = data.index;
    this._ptr = data.ptr;
    this._size = data.size;
    this._datatype = datatype || data.datatype;
  }
  else if (isArray(data)) {
    // create from array
    _createFromArray(this, data, datatype);
  }
  else if (data) {
    // unsupported type
    throw new TypeError('Unsupported type of data (' + util.types.type(data) + ')');
  }
  else {
    // nothing provided
    this._values = [];
    this._index = [];
    this._ptr = [0];
    this._size = [0, 0];
    this._datatype = datatype;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.SymbolNode" id="apidoc.element.mathjs.expression.mathWithTransform.SymbolNode">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>SymbolNode
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SymbolNode(name) {
  if (!(this instanceof SymbolNode)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  // validate input
  if (typeof name !== 'string')  throw new TypeError('String expected for parameter "name"');

  this.name = name;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.Unit" id="apidoc.element.mathjs.expression.mathWithTransform.Unit">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>Unit
        <span class="apidocSignatureSpan">(value, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Unit(value, name) {
  if (!(this instanceof Unit)) {
    throw new Error('Constructor must be called with the new operator');
  }

  if (!(value === undefined || isNumeric(value) || value.isComplex)) {
    throw new TypeError('First parameter in Unit constructor must be number, BigNumber, Fraction, Complex, or undefined');
  }
  if (name != undefined &amp;&amp; (typeof name !== 'string' || name == '')) {
    throw new TypeError('Second parameter in Unit constructor must be a string');
  }

  if (name != undefined) {
    var u = Unit.parse(name);
    this.units = u.units;
    this.dimensions = u.dimensions;
  }
  else {
    this.units = [
      {
        unit: UNIT_NONE,
        prefix: PREFIXES.NONE,  // link to a list with supported prefixes
        power: 0
      }
    ];
    this.dimensions = [];
    for(var i=0; i&lt;BASE_DIMENSIONS.length; i++) {
      this.dimensions[i] = 0;
    }
  }

  this.value = (value != undefined) ? this._normalize(value) : null;

  this.fixPrefix = false; // if true, function format will not search for the
                          // best prefix but leave it as initially provided.
                          // fixPrefix is set true by the method Unit.to

  // The justification behind this is that if the constructor is explicitly called,
  // the caller wishes the units to be returned exactly as he supplied.
  this.isUnitListSimplified = true;

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.UpdateNode" id="apidoc.element.mathjs.expression.mathWithTransform.UpdateNode">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>UpdateNode
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function UpdateNode() {
  // TODO: deprecated since v3. Cleanup some day
  throw new Error('UpdateNode is deprecated. Use AssignmentNode instead.');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.abs" id="apidoc.element.mathjs.expression.mathWithTransform.abs">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>abs
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function abs(arg0) {
  "use strict";
  var name = 'abs';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Fraction
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Unit
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Unit
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature5(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature5(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert0(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test9(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Fraction,Unit,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function factory (type, config, load, typed) {
/**
 * Calculate the absolute value of a number. For matrices, the function is
 * evaluated element wise.
 *
 * Syntax:
 *
 *    math.<span class="apidocCodeKeywordSpan">abs</span>(x)
 *
 * Examples:
 *
 *    math.abs(3.5);                // returns number 3.5
 *    math.abs(-4.2);               // returns number 4.2
 *
 *    math.abs([3, -5, -1, 0, 2]);  // returns Array [3, 5, 1, 0, 2]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.acos" id="apidoc.element.mathjs.expression.mathWithTransform.acos">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>acos
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function acos(arg0) {
  "use strict";
  var name = 'acos';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature2(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Calculate the inverse cosine of a value.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">acos</span>(x)
*
* Examples:
*
*    math.acos(0.5);           // returns number 1.0471975511965979
*    math.acos(math.cos(1.5)); // returns number 1.5
*
*    math.acos(2);             // returns Complex 0 + 1.3169578969248166 i
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.acosh" id="apidoc.element.mathjs.expression.mathWithTransform.acosh">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>acosh
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function acosh(arg0) {
  "use strict";
  var name = 'acosh';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature2(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Calculate the hyperbolic arccos of a value,
* defined as `acosh(x) = ln(sqrt(x^2 - 1) + x)`.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">acosh</span>(x)
*
* Examples:
*
*    math.acosh(1.5);       // returns 0.9624236501192069
*
* See also:
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.acot" id="apidoc.element.mathjs.expression.mathWithTransform.acot">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>acot
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function acot(arg0) {
  "use strict";
  var name = 'acot';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature2(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Calculate the inverse cotangent of a value, defined as `acot(x) = atan(1/x)`.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">acot</span>(x)
*
* Examples:
*
*    math.acot(0.5);           // returns number 0.4636476090008061
*    math.acot(math.cot(1.5)); // returns number 1.5
*
*    math.acot(2);             // returns Complex 1.5707963267948966 -1.3169578969248166 i
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.acoth" id="apidoc.element.mathjs.expression.mathWithTransform.acoth">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>acoth
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function acoth(arg0) {
  "use strict";
  var name = 'acoth';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature2(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Calculate the hyperbolic arccotangent of a value,
* defined as `acoth(x) = atanh(1/x) = (ln((x+1)/x) + ln(x/(x-1))) / 2`.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">acoth</span>(x)
*
* Examples:
*
*    math.acoth(0.5);       // returns 0.8047189562170503
*
* See also:
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.acsc" id="apidoc.element.mathjs.expression.mathWithTransform.acsc">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>acsc
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function acsc(arg0) {
  "use strict";
  var name = 'acsc';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature2(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Calculate the inverse cosecant of a value, defined as `acsc(x) = asin(1/x)`.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">acsc</span>(x)
*
* Examples:
*
*    math.acsc(0.5);           // returns number 0.5235987755982989
*    math.acsc(math.csc(1.5)); // returns number ~1.5
*
*    math.acsc(2);             // returns Complex 1.5707963267948966 -1.3169578969248166 i
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.acsch" id="apidoc.element.mathjs.expression.mathWithTransform.acsch">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>acsch
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function acsch(arg0) {
  "use strict";
  var name = 'acsch';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature2(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Calculate the hyperbolic arccosecant of a value,
* defined as `acsch(x) = asinh(1/x) = ln(1/x + sqrt(1/x^2 + 1))`.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">acsch</span>(x)
*
* Examples:
*
*    math.acsch(0.5);       // returns 1.4436354751788103
*
* See also:
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.add" id="apidoc.element.mathjs.expression.mathWithTransform.add">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>add
        <span class="apidocSignatureSpan">(arg0, arg1, arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function add(arg0, arg1, arg2) {
  "use strict";
  var name = 'add';
  if (test0(arg0)) { // type: number
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: number, number
      }
    }
    if (test1(arg1)) { // type: Complex
      if (arguments.length === 2) {
        return signature1(convert0(arg0), arg1); // signature: number, Complex
      }
    }
    if (test2(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature2(convert1(arg0), arg1); // signature: number, BigNumber
      }
    }
    if (test3(arg1)) { // type: Fraction
      if (arguments.length === 2) {
        return signature3(convert2(arg0), arg1); // signature: number, Fraction
      }
    }
    if (test4(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert3(arg1)); // signature: number, string
      }
    }
    if (test5(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert4(arg1)); // signature: number, boolean
      }
    }
    if (test6(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert5(arg1)); // signature: number, null
      }
    }
  }
  if (test1(arg0)) { // type: Complex
    if (test1(arg1)) { // type: Complex
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Complex, Complex
      }
    }
    if (test0(arg1)) { // type: number (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: Complex, number
      }
    }
    if (test2(arg1)) { // type: BigNumber (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert6(arg1)); // signature: Complex, BigNumber
      }
    }
    if (test3(arg1)) { // type: Fraction (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert7(arg1)); // signature: Complex, Fraction
      }
    }
    if (test4(arg1)) { // type: string (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert8(arg1)); // signature: Complex, string
      }
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (test1(arg1)) { // type: Complex
      if (arguments.length === 2) {
        return signature1(convert6(arg0), arg1); // signature: BigNumber, Complex
      }
    }
    if (test2(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: BigNumber, BigNumber
      }
    }
    if (test0(arg1)) { // type: number (convert to BigNumber)
      if (arguments.length === 2) {
        return signature2(arg0, convert1(arg1)); // signature: BigNumber, number
      }
    }
    if (test3(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature2(arg0, convert9(arg1)); // signature: BigNumber, Fraction
      }
    }
    if (test4(arg1)) { // type: string (convert to BigNumber)
      if (arguments.length === 2) {
        return signature2(arg0, convert10(arg1)); // signature: BigNumber, string
      }
    }
    if (test5(arg1)) { // type: boolean (convert to BigNumber)
      if (arguments.length === 2) {
        return signature2(arg0, convert11(arg1)); // signature: BigNumber, boolean
      }
    }
    if (test6(arg1)) { // type: null (convert to BigNumber)
      if (arguments.length === 2) {
        return signature2(arg0, convert12(arg1)); // signature: BigNumber, null
      }
    }
  }
  if (test3(arg0)) { // type: Fraction
    if (test1(arg1)) { // type: Complex
      if (arguments.length === 2) {
        return signature1(convert7(arg0), arg1); // signature: Fraction, Complex
      }
    }
    if (test2(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature2(convert9(arg0), arg1); // signature: Fraction, BigNumber
      }
    }
    if (test3(arg1)) { // type: Fraction
      if (a ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
math.eval('5.08 cm to inch');     // 2 inch
math.eval('sin(45 deg) ^ 2');     // 0.5
math.eval('9 / 3 + 2i');          // 3 + 2i
math.eval('det([-1, 2; 3, 1])');  // -7

// chaining
math.chain(3)
    .<span class="apidocCodeKeywordSpan">add</span>(4)
    .multiply(2)
    .done(); // 14
```

## Browser support

Math.js works on any ES5 compatible JavaScript engine: node.js 0.10, and Internet Explorer 9 and newer, and all other browsers (
Chrome, Firefox, Safari). If support for old browsers like Internet Explorer 8 is required, the [es5-shim](https://github.com/kriskowal
/es5-shim) library has to be loaded.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.and" id="apidoc.element.mathjs.expression.mathWithTransform.and">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>and
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function and(arg0, arg1) {
  "use strict";
  var name = 'and';
  if (test0(arg0)) { // type: number
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: number, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: Complex
      if (arguments.length === 2) {
        return signature1(convert0(arg0), arg1); // signature: number, Complex
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature2(convert1(arg0), arg1); // signature: number, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature2(convert1(arg0), convert2(arg1)); // signature: number, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert3(arg1)); // signature: number, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert4(arg1)); // signature: number, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test6(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert5(arg1)); // signature: number, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
  }
  if (test1(arg0)) { // type: Complex
    if (test1(arg1)) { // type: Complex
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Complex, Complex
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test0(arg1)) { // type: number (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: Complex, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: BigNumber (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert6(arg1)); // signature: Complex, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: Fraction (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert7(arg1)); // signature: Complex, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: string (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert8(arg1)); // signature: Complex, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (test1(arg1)) { // type: Complex
      if (arguments.length === 2) {
        return signature1(convert6(arg0), arg1); // signature: BigNumber, Complex
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  /**
* Logical `and`. Test whether two values are both defined with a nonzero/nonempty value.
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">and</span>(x, y)
*
* Examples:
*
*    math.and(2, 4);   // returns true
*
*    a = [2, 0, 0];
*    b = [3, 7, 0];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.arg" id="apidoc.element.mathjs.expression.mathWithTransform.arg">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>arg
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function arg(arg0) {
  "use strict";
  var name = 'arg';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature2(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   *                               the principal root is returned.
   * @returns {Complex | Array.&lt;Complex&gt; | Matrix.&lt;Complex&gt;} Returns the cubic root(s) of x
   * @private
   */
  function _cbrtComplex(x, allRoots) {
// https://www.wikiwand.com/en/Cube_root#/Complex_numbers

var arg_3 = x.<span class="apidocCodeKeywordSpan">arg</span>() / 3;
var abs = x.abs();

// principal root:
var principal = new type.Complex(_cbrtNumber(abs), 0).mul(
    new type.Complex(0, arg_3).exp());

if (allRoots) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.asec" id="apidoc.element.mathjs.expression.mathWithTransform.asec">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>asec
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function asec(arg0) {
  "use strict";
  var name = 'asec';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature2(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Calculate the inverse secant of a value. Defined as `asec(x) = acos(1/x)`.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">asec</span>(x)
*
* Examples:
*
*    math.asec(0.5);           // returns 1.0471975511965979
*    math.asec(math.sec(1.5)); // returns 1.5
*
*    math.asec(2);             // returns 0 + 1.3169578969248166 i
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.asech" id="apidoc.element.mathjs.expression.mathWithTransform.asech">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>asech
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function asech(arg0) {
  "use strict";
  var name = 'asech';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature2(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Calculate the hyperbolic arcsecant of a value,
* defined as `asech(x) = acosh(1/x) = ln(sqrt(1/x^2 - 1) + 1/x)`.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">asech</span>(x)
*
* Examples:
*
*    math.asech(0.5);       // returns 1.3169578969248166
*
* See also:
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.asin" id="apidoc.element.mathjs.expression.mathWithTransform.asin">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>asin
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function asin(arg0) {
  "use strict";
  var name = 'asin';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature2(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   *
   * @param {number | Complex | Array | Matrix} x   Function input
   * @return {number | Complex | Array | Matrix} The arc cosecant of x
   */
  var acsc = typed('acsc', {
'number': function (x) {
  if (x &lt;= -1 || x &gt;= 1 || config.predictable) {
    return Math.<span class="apidocCodeKeywordSpan">asin</span>(1 / x);
  }
  return new type.Complex(x, 0).acsc();
},

'Complex': function (x) {
  return x.acsc();
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.asinh" id="apidoc.element.mathjs.expression.mathWithTransform.asinh">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>asinh
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function asinh(arg0) {
  "use strict";
  var name = 'asinh';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature2(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  },

  'Complex': function (x) {
    return x.acsch();
  },

  'BigNumber': function (x) {
    return new type.BigNumber(1).div(x).<span class="apidocCodeKeywordSpan">asinh</span>();
  },

  'Array | Matrix': function (x) {
    return deepMap(x, acsch);
  }
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.atan" id="apidoc.element.mathjs.expression.mathWithTransform.atan">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>atan
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function atan(arg0) {
  "use strict";
  var name = 'atan';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature2(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   *    cot, atan
   *
   * @param {number | Complex | Array | Matrix} x   Function input
   * @return {number | Complex | Array | Matrix} The arc cotangent of x
   */
  var acot = typed('acot', {
'number': function (x) {
  return Math.<span class="apidocCodeKeywordSpan">atan</span>(1 / x);
},

'Complex': function (x) {
  return x.acot();
},

'BigNumber': function (x) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.atan2" id="apidoc.element.mathjs.expression.mathWithTransform.atan2">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>atan2
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function atan2(arg0, arg1) {
  "use strict";
  var name = 'atan2';
  if (test0(arg0)) { // type: number
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: number, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature1(convert0(arg0), arg1); // signature: number, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: number, Array
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature3(arg0, arg1); // signature: number, Matrix
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(convert0(arg0), convert1(arg1)); // signature: number, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert2(arg1)); // signature: number, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test6(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert3(arg1)); // signature: number, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test7(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert4(arg1)); // signature: number, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'number,BigNumber,Array,Matrix');
  }
  if (test1(arg0)) { // type: BigNumber
    if (test1(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: BigNumber, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: BigNumber, Array
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature3(arg0, arg1); // signature: BigNumber, Matrix
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test0(arg1)) { // type: number (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: BigNumber, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert1(arg1)); // signature: BigNumber, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: string (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert5(arg ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```js
// load math.js
var math = require('mathjs');

// functions and constants
math.round(math.e, 3);            // 2.718
math.<span class="apidocCodeKeywordSpan">atan2</span>(3, -3) / math.pi;      // 0.75
math.log(1000, 10);               // 3
math.sqrt(-4);                    // 2i
math.pow([[-1, 2], [3, 1]], 2);   // [[7, 0], [0, 7]]
math.derivative('x^2 + x', 'x');  // 2 * x + 1

// expressions
math.eval('12 / (2.3 + 0.7)');    // 4
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.atanh" id="apidoc.element.mathjs.expression.mathWithTransform.atanh">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>atanh
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function atanh(arg0) {
  "use strict";
  var name = 'atanh';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature2(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  },

  'Complex': function (x) {
    return x.acoth();
  },

  'BigNumber': function (x) {
    return new type.BigNumber(1).div(x).<span class="apidocCodeKeywordSpan">atanh</span>();
  },

  'Array | Matrix': function (x) {
    return deepMap(x, acoth);
  }
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.bellNumbers" id="apidoc.element.mathjs.expression.mathWithTransform.bellNumbers">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>bellNumbers
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bellNumbers(arg0) {
  "use strict";
  var name = 'bellNumbers';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature0(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature0(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,BigNumber');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* The Bell Numbers count the number of partitions of a set. A partition is a pairwise disjoint subset of S whose union is S.
* bellNumbers only takes integer arguments.
* The following condition must be enforced: n &gt;= 0
*
* Syntax:
*
*   math.<span class="apidocCodeKeywordSpan">bellNumbers</span>(n)
*
* Examples:
*
*    math.bellNumbers(3); // returns 5;
*    math.bellNumbers(8); // returns 4140;
*
* See also:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.bignumber" id="apidoc.element.mathjs.expression.mathWithTransform.bignumber">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>bignumber
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bignumber(arg0) {
  "use strict";
  var name = 'bignumber';
  if (arguments.length === 0) {
    return signature0(); // signature:
  }
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature1(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: Fraction
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: string
    if (arguments.length === 1) {
      return signature4(arg0); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature5(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature5(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature1(convert0(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature1(convert1(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,BigNumber,Fraction,string,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
ConstantNode.prototype._compile = function (defs, args) {
  switch (this.valueType) {
    case 'number':
      // TODO: replace this with using config.number
      var numConfig = defs.math.config().number;
      if (numConfig === 'BigNumber') {
        return 'math.<span class="apidocCodeKeywordSpan">bignumber</span>("' + this.value + '")';
      }
      else if (numConfig === 'Fraction') {
        return 'math.fraction("' + this.value + '")';
      }
      else {
        // remove leading zeros like '003.2' which are not allowed by JavaScript
        return this.value.replace(/^(0*)[0-9]/, function (match, zeros) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.bitAnd" id="apidoc.element.mathjs.expression.mathWithTransform.bitAnd">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>bitAnd
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bitAnd(arg0, arg1) {
  "use strict";
  var name = 'bitAnd';
  if (test0(arg0)) { // type: number
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: number, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature1(convert0(arg0), arg1); // signature: number, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(convert0(arg0), convert1(arg1)); // signature: number, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert2(arg1)); // signature: number, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert3(arg1)); // signature: number, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert4(arg1)); // signature: number, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
  }
  if (test1(arg0)) { // type: BigNumber
    if (test1(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: BigNumber, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test0(arg1)) { // type: number (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: BigNumber, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert1(arg1)); // signature: BigNumber, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: string (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert5(arg1)); // signature: BigNumber, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: boolean (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert6(arg1)); // signature: BigNumber, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: null (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert7(arg1)); // signature: BigNumber, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
  }
  if (test6(arg0)) { // type: Array
    if (test6(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: Array, Array
      }
    }
    if (test7(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature3(arg0, arg1); // signature: Array, Matrix
      }
    }
    // type: any
    if (arguments.length === 2) { ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  /**
* Bitwise AND two values, `x &amp; y`.
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">bitAnd</span>(x, y)
*
* Examples:
*
*    math.bitAnd(53, 131);               // returns number 1
*
*    math.bitAnd([1, 12, 31], 42);       // returns Array [0, 8, 10]
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.bitNot" id="apidoc.element.mathjs.expression.mathWithTransform.bitNot">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>bitNot
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bitNot(arg0) {
  "use strict";
  var name = 'bitNot';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature1(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature2(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature2(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature1(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,BigNumber,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Bitwise NOT value, `~x`.
* For matrices, the function is evaluated element wise.
* For units, the function is evaluated on the best prefix base.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">bitNot</span>(x)
*
* Examples:
*
*    math.bitNot(1);               // returns number -2
*
*    math.bitNot([2, -3, 4]);      // returns Array [-3, 2, 5]
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.bitOr" id="apidoc.element.mathjs.expression.mathWithTransform.bitOr">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>bitOr
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bitOr(arg0, arg1) {
  "use strict";
  var name = 'bitOr';
  if (test0(arg0)) { // type: number
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: number, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature1(convert0(arg0), arg1); // signature: number, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(convert0(arg0), convert1(arg1)); // signature: number, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert2(arg1)); // signature: number, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert3(arg1)); // signature: number, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert4(arg1)); // signature: number, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
  }
  if (test1(arg0)) { // type: BigNumber
    if (test1(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: BigNumber, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test0(arg1)) { // type: number (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: BigNumber, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert1(arg1)); // signature: BigNumber, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: string (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert5(arg1)); // signature: BigNumber, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: boolean (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert6(arg1)); // signature: BigNumber, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: null (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert7(arg1)); // signature: BigNumber, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
  }
  if (test6(arg0)) { // type: Array
    if (test6(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: Array, Array
      }
    }
    if (test7(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature3(arg0, arg1); // signature: Array, Matrix
      }
    }
    // type: any
    if (arguments.length === 2) { ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Bitwise OR two values, `x | y`.
* For matrices, the function is evaluated element wise.
* For units, the function is evaluated on the lowest print base.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">bitOr</span>(x, y)
*
* Examples:
*
*    math.bitOr(1, 2);               // returns number 3
*
*    math.bitOr([1, 2, 3], 4);       // returns Array [5, 6, 7]
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.bitXor" id="apidoc.element.mathjs.expression.mathWithTransform.bitXor">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>bitXor
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bitXor(arg0, arg1) {
  "use strict";
  var name = 'bitXor';
  if (test0(arg0)) { // type: number
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: number, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature1(convert0(arg0), arg1); // signature: number, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(convert0(arg0), convert1(arg1)); // signature: number, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert2(arg1)); // signature: number, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert3(arg1)); // signature: number, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert4(arg1)); // signature: number, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
  }
  if (test1(arg0)) { // type: BigNumber
    if (test1(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: BigNumber, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test0(arg1)) { // type: number (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: BigNumber, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert1(arg1)); // signature: BigNumber, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: string (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert5(arg1)); // signature: BigNumber, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: boolean (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert6(arg1)); // signature: BigNumber, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: null (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert7(arg1)); // signature: BigNumber, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
  }
  if (test6(arg0)) { // type: Array
    if (test6(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: Array, Array
      }
    }
    if (test7(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature3(arg0, arg1); // signature: Array, Matrix
      }
    }
    // type: any
    if (arguments.length === 2) { ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  /**
* Bitwise XOR two values, `x ^ y`.
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">bitXor</span>(x, y)
*
* Examples:
*
*    math.bitXor(1, 2);               // returns number 3
*
*    math.bitXor([2, 3, 4], 4);       // returns Array [6, 7, 0]
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.boolean" id="apidoc.element.mathjs.expression.mathWithTransform.boolean">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>boolean
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bool(arg0) {
  "use strict";
  var name = 'bool';
  if (arguments.length === 0) {
    return signature0(); // signature:
  }
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature1(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: string
    if (arguments.length === 1) {
      return signature3(arg0); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: boolean
    if (arguments.length === 1) {
      return signature5(arg0); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature2(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature1(convert1(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,BigNumber,string,Array,Matrix,boolean');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* In case of a number, `true` is returned for non-zero numbers, and `false` in
* case of zero.
* Strings can be `'true'` or `'false'`, or can contain a number.
* When value is a matrix, all elements will be converted to boolean.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">boolean</span>(x)
*
* Examples:
*
*    math.boolean(0);     // returns false
*    math.boolean(1);     // returns true
*    math.boolean(-3);     // returns true
*    math.boolean('true');     // returns true
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.catalan" id="apidoc.element.mathjs.expression.mathWithTransform.catalan">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>catalan
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function catalan(arg0) {
  "use strict";
  var name = 'catalan';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature0(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature0(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,BigNumber');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* The Catalan Numbers enumerate combinatorial structures of many different types.
* catalan only takes integer arguments.
* The following condition must be enforced: n &gt;= 0
*
* Syntax:
*
*   math.<span class="apidocCodeKeywordSpan">catalan</span>(n)
*
* Examples:
*
*    math.catalan(3); // returns 5;
*    math.catalan(8); // returns 1430;
*
* See also:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.cbrt" id="apidoc.element.mathjs.expression.mathWithTransform.cbrt">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>cbrt
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cbrt(arg0, arg1) {
  "use strict";
  var name = 'cbrt';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (test1(arg1)) { // type: boolean
      if (arguments.length === 2) {
        return signature1(convert0(arg0), arg1); // signature: number, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'boolean');
  }
  if (test2(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (test1(arg1)) { // type: boolean
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Complex, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'boolean');
  }
  if (test3(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (test1(arg1)) { // type: boolean
      if (arguments.length === 2) {
        return signature1(convert1(arg0), arg1); // signature: BigNumber, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'boolean');
  }
  if (test4(arg0)) { // type: Unit
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Unit
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature2(convert2(arg0)); // signature: Fraction
    }
    if (test1(arg1)) { // type: boolean
      if (arguments.length === 2) {
        return signature1(convert3(arg0), arg1); // signature: Fraction, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'boolean');
  }
  if (test8(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert4(arg0)); // signature: string
    }
    if (test1(arg1)) { // type: boolean
      if (arguments.length === 2) {
        return signature1(convert5(arg0), arg1); // signature: string, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'boolean');
  }
  if (test1(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert6(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test9(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert7(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Unit,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Calculate the cubic root of a value.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">cbrt</span>(x)
*    math.cbrt(x, allRoots)
*
* Examples:
*
*    math.cbrt(27);                  // returns 3
*    math.cube(3);                   // returns 27
*    math.cbrt(-64);                 // returns -4
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.ceil" id="apidoc.element.mathjs.expression.mathWithTransform.ceil">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>ceil
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ceil(arg0) {
  "use strict";
  var name = 'ceil';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Fraction
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert0(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Fraction,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Round a value towards plus infinity
* If `x` is complex, both real and imaginary part are rounded towards plus infinity.
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">ceil</span>(x)
*
* Examples:
*
*    math.ceil(3.2);               // returns number 4
*    math.ceil(3.8);               // returns number 4
*    math.ceil(-4.2);              // returns number -4
*    math.ceil(-4.7);              // returns number -4
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.chain" id="apidoc.element.mathjs.expression.mathWithTransform.chain">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>chain
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function chain(arg0) {
  "use strict";
  var name = 'chain';
  if (arguments.length === 0) {
    return signature0(); // signature:
  }
  // type: any
  if (arguments.length === 1) {
    return signature1(arg0); // signature: any
  }
  if (arguments.length &gt; 1) {
    throw createError(name, arguments.length, 1, arguments[1]);
  }
  throw createError(name, arguments.length, 0, arguments[0], 'any');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
math.eval('12 / (2.3 + 0.7)');    // 4
math.eval('5.08 cm to inch');     // 2 inch
math.eval('sin(45 deg) ^ 2');     // 0.5
math.eval('9 / 3 + 2i');          // 3 + 2i
math.eval('det([-1, 2; 3, 1])');  // -7

// chaining
math.<span class="apidocCodeKeywordSpan">chain</span>(3)
    .add(4)
    .multiply(2)
    .done(); // 14
```

## Browser support
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.clone" id="apidoc.element.mathjs.expression.mathWithTransform.clone">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>clone
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function clone(arg0) {
  "use strict";
  var name = 'clone';
  // type: any
  if (arguments.length === 1) {
    return signature0(arg0); // signature: any
  }
  if (arguments.length &gt; 1) {
    throw createError(name, arguments.length, 1, arguments[1]);
  }
  throw createError(name, arguments.length, 0, arguments[0], 'any');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return desc;
};

/**
 * Export the help object to JSON
 */
Help.prototype.toJSON = function () {
  var obj = object.<span class="apidocCodeKeywordSpan">clone</span>(this.doc);
  obj.mathjs = 'Help';
  return obj;
};

/**
 * Instantiate a Help object from a JSON object
 * @param {Object} json
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.combinations" id="apidoc.element.mathjs.expression.mathWithTransform.combinations">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>combinations
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function combinations(arg0, arg1) {
  "use strict";
  var name = 'combinations';
  if (test0(arg0)) { // type: number
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: number, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature1(convert0(arg0), arg1); // signature: number, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(convert0(arg0), convert1(arg1)); // signature: number, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert2(arg1)); // signature: number, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert3(arg1)); // signature: number, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert4(arg1)); // signature: number, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'number,BigNumber');
  }
  if (test1(arg0)) { // type: BigNumber
    if (test1(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: BigNumber, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test0(arg1)) { // type: number (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: BigNumber, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert1(arg1)); // signature: BigNumber, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: string (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert5(arg1)); // signature: BigNumber, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: boolean (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert6(arg1)); // signature: BigNumber, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: null (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert7(arg1)); // signature: BigNumber, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'BigNumber');
  }
  if (test2(arg0)) { // type: Fraction (convert to BigNumber)
    if (test1(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature1(convert1(arg0), arg1); // signature: Fraction, BigNumber ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* possibilities.
*
* Combinations only takes integer arguments.
* The following condition must be enforced: k &lt;= n.
*
* Syntax:
*
*     math.<span class="apidocCodeKeywordSpan">combinations</span>(n, k)
*
* Examples:
*
*    math.combinations(7, 5); // returns 21
*
* See also:
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.compare" id="apidoc.element.mathjs.expression.mathWithTransform.compare">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>compare
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function compare(arg0, arg1) {
  "use strict";
  var name = 'compare';
  if (test0(arg0)) { // type: number
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: number, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: Complex
      if (arguments.length === 2) {
        return signature1(convert0(arg0), arg1); // signature: number, Complex
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature2(convert1(arg0), arg1); // signature: number, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: Fraction
      if (arguments.length === 2) {
        return signature3(convert2(arg0), arg1); // signature: number, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert3(arg1)); // signature: number, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert4(arg1)); // signature: number, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test6(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert5(arg1)); // signature: number, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
  }
  if (test1(arg0)) { // type: Complex
    if (test1(arg1)) { // type: Complex
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Complex, Complex
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test0(arg1)) { // type: number (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: Complex, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: BigNumber (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert6(arg1)); // signature: Complex, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: Fraction (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert7(arg1)); // signature: Complex, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: string (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert8(arg1)); // signature: Complex, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (test1(arg1)) { // type: Complex
      if (arguments.length === 2) {
        return signature1(convert6(arg0), arg1); // signature: BigNumber, Complex
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: BigNumber, Big ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* is smaller than the configured epsilon. The function cannot be used to
* compare values smaller than approximately 2.22e-16.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">compare</span>(x, y)
*
* Examples:
*
*    math.compare(6, 1);           // returns 1
*    math.compare(2, 3);           // returns -1
*    math.compare(7, 7);           // returns 0
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.compile" id="apidoc.element.mathjs.expression.mathWithTransform.compile">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>compile
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function compile(arg0) {
  "use strict";
  var name = 'compile';
  if (test0(arg0)) { // type: string
    if (arguments.length === 1) {
      return signature0(arg0); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: number (convert to string)
    if (arguments.length === 1) {
      return signature0(convert0(arg0)); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: boolean (convert to string)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: null (convert to string)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'string,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*     parse(expr, options)
*     parse([expr1, expr2, expr3, ...])
*     parse([expr1, expr2, expr3, ...], options)
*
* Example:
*
*     var node = parse('sqrt(3^2 + 4^2)');
*     node.<span class="apidocCodeKeywordSpan">compile</span>(math).eval(); // 5
*
*     var scope = {a:3, b:4}
*     var node = parse('a * b'); // 12
*     var code = node.compile(math);
*     code.eval(scope); // 12
*     scope.a = 5;
*     code.eval(scope); // 20
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.complex" id="apidoc.element.mathjs.expression.mathWithTransform.complex">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>complex
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function complex(arg0, arg1) {
  "use strict";
  var name = 'complex';
  if (arguments.length === 0) {
    return signature0(); // signature:
  }
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature1(arg0); // signature: number
    }
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: number, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature3(convert0(arg0), arg1); // signature: number, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature3(convert0(arg0), convert1(arg1)); // signature: number, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature2(arg0, convert2(arg1)); // signature: number, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature2(arg0, convert3(arg1)); // signature: number, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature2(arg0, convert4(arg1)); // signature: number, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'number,BigNumber');
  }
  if (test6(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature4(convert5(arg0)); // signature: BigNumber
    }
    if (test1(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature3(arg0, arg1); // signature: BigNumber, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test0(arg1)) { // type: number (convert to BigNumber)
      if (arguments.length === 2) {
        return signature3(arg0, convert0(arg1)); // signature: BigNumber, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature3(arg0, convert1(arg1)); // signature: BigNumber, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: string (convert to BigNumber)
      if (arguments.length === 2) {
        return signature3(arg0, convert6(arg1)); // signature: BigNumber, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: boolean (convert to BigNumber)
      if (arguments.length === 2) {
        return signature3(arg0, convert7(arg1)); // signature: BigNumber, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: null (convert to BigNumber)
      if (arguments.length === 2) { ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Syntax:
*
*    math.string(value)
*
* Examples:
*
*    math.string(4.2);               // returns string '4.2'
*    math.string(math.<span class="apidocCodeKeywordSpan">complex</span>(3, 2); // returns string '3 + 2i'
*
*    var u = math.unit(5, 'km');
*    math.string(u.to('m'));         // returns string '5000 m'
*
*    math.string([true, false]);     // returns ['true', 'false']
*
* See also:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.composition" id="apidoc.element.mathjs.expression.mathWithTransform.composition">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>composition
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function composition(arg0, arg1) {
  "use strict";
  var name = 'composition';
  if (test0(arg0)) { // type: number
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: number, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: number, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature0(arg0, convert0(arg1)); // signature: number, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert1(arg1)); // signature: number, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert2(arg1)); // signature: number, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert3(arg1)); // signature: number, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'number,BigNumber');
  }
  if (test1(arg0)) { // type: BigNumber
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: BigNumber, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: BigNumber, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature0(arg0, convert0(arg1)); // signature: BigNumber, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert1(arg1)); // signature: BigNumber, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert2(arg1)); // signature: BigNumber, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert3(arg1)); // signature: BigNumber, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'number,BigNumber');
  }
  if (test2(arg0)) { // type: Fraction (convert to BigNumber)
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature0(convert0(arg0), arg1); // signature: Fraction, number
      }
      if (arguments.length &gt; 2) {
        throw createE ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* The composition counts of n into k parts.
*
* composition only takes integer arguments.
* The following condition must be enforced: k &lt;= n.
*
* Syntax:
*
*   math.<span class="apidocCodeKeywordSpan">composition</span>(n, k)
*
* Examples:
*
*    math.composition(5, 3); // returns 6
*
* See also:
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.concat" id="apidoc.element.mathjs.expression.mathWithTransform.concat">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>concat
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function concat(arg0) {
  "use strict";
  var name = 'concat';
  if (arguments.length &gt; 0) {
    var varArgs = [];
    for (var i = 0; i &lt; arguments.length; i++) {
      varArgs.push(arguments[i]);
    }
    return signature0(varArgs); // signature: ...any
  }
  throw createError(name, arguments.length, 0, arguments[0], 'any');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// figure out what number of arguments the callback function expects
var args = maxArgumentCount(callback);

var recurse = function (value, index) {
  if (Array.isArray(value)) {
    value.forEach(function (child, i) {
      // we create a copy of the index array and append the new index value
      recurse(child, index.<span class="apidocCodeKeywordSpan">concat</span>(i + 1)); // one based index, hence i+1
    });
  }
  else {
    // invoke the callback function with the right number of arguments
    if (args === 1) {
      callback(value);
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.config" id="apidoc.element.mathjs.expression.mathWithTransform.config">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>config
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _config(options) {
  if (options) {
    var prev = object.clone(config);

    // validate some of the options
    validateOption(options, 'matrix', MATRIX);
    validateOption(options, 'number', NUMBER);

    // merge options
    object.deepExtend(config, options);

    var curr = object.clone(config);

    var changes = object.clone(options);

    // emit 'config' event
    math.emit('config', curr, prev, changes);

    return curr;
  }
  else {
    return object.clone(config);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  /**
* Set configuration options for math.js, and get current options.
* Will emit a 'config' event, with arguments (curr, prev, changes).
*
* Syntax:
*
*     math.<span class="apidocCodeKeywordSpan">config</span>(config: Object): Object
*
* Examples:
*
*     math.config().number;                // outputs 'number'
*     math.eval('0.4');                    // outputs number 0.4
*     math.config({number: 'Fraction'});
*     math.eval('0.4');                    // outputs Fraction 2/5
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.conj" id="apidoc.element.mathjs.expression.mathWithTransform.conj">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>conj
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function conj(arg0) {
  "use strict";
  var name = 'conj';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature2(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Compute the complex conjugate of a complex value.
* If `x = a+bi`, the complex conjugate of `x` is `a - bi`.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">conj</span>(x)
*
* Examples:
*
*    math.conj(math.complex('2 + 3i'));  // returns Complex 2 - 3i
*    math.conj(math.complex('2 - 3i'));  // returns Complex 2 + 3i
*    math.conj(math.complex('-5.2i'));  // returns Complex 5.2i
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.cos" id="apidoc.element.mathjs.expression.mathWithTransform.cos">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>cos
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cos(arg0) {
  "use strict";
  var name = 'cos';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Unit
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Unit
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature2(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test9(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Unit,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      var u1, u2,
          picked = -1;
      // We reject values outside of the interval [0, 1]
      // TODO: check if it is ok to do that?
      while (picked &lt; 0 || picked &gt; 1) {
        u1 = rng();
        u2 = rng();
        picked = 1/6 * Math.pow(-2 * Math.log(u1), 0.5) * Math.<span class="apidocCodeKeywordSpan">cos</span>(2 * Math.PI * u2) +
0.5;
      }
      return picked;
    }
  }
};

distribution.toTex = undefined; // use default template
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.cosh" id="apidoc.element.mathjs.expression.mathWithTransform.cosh">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>cosh
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cosh(arg0) {
  "use strict";
  var name = 'cosh';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Unit
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Unit
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature2(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test9(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Unit,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Calculate the hyperbolic cosine of a value,
* defined as `cosh(x) = 1/2 * (exp(x) + exp(-x))`.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">cosh</span>(x)
*
* Examples:
*
*    math.cosh(0.5);       // returns number 1.1276259652063807
*
* See also:
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.cot" id="apidoc.element.mathjs.expression.mathWithTransform.cot">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>cot
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cot(arg0) {
  "use strict";
  var name = 'cot';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Unit
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Unit
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature2(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test9(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Unit,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Syntax:
*
*    math.acot(x)
*
* Examples:
*
*    math.acot(0.5);           // returns number 0.4636476090008061
*    math.acot(math.<span class="apidocCodeKeywordSpan">cot</span>(1.5)); // returns number 1.5
*
*    math.acot(2);             // returns Complex 1.5707963267948966 -1.3169578969248166 i
*
* See also:
*
*    cot, atan
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.coth" id="apidoc.element.mathjs.expression.mathWithTransform.coth">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>coth
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function coth(arg0) {
  "use strict";
  var name = 'coth';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Unit
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Unit
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature2(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test9(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Unit,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Calculate the hyperbolic cotangent of a value,
* defined as `coth(x) = 1 / tanh(x)`.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">coth</span>(x)
*
* Examples:
*
*    // coth(x) = 1 / tanh(x)
*    math.coth(2);         // returns 1.0373147207275482
*    1 / math.tanh(2);     // returns 1.0373147207275482
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.createUnit" id="apidoc.element.mathjs.expression.mathWithTransform.createUnit">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>createUnit
        <span class="apidocSignatureSpan">(arg0, arg1, arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createUnit(arg0, arg1, arg2) {
  "use strict";
  var name = 'createUnit';
  if (test0(arg0)) { // type: string
    if (arguments.length === 1) {
      return signature0(arg0); // signature: string
    }
    if (test1(arg1)) { // type: Unit
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: string, Unit
      }
      if (test2(arg2)) { // type: Object
        if (arguments.length === 3) {
          return signature2(arg0, arg1, arg2); // signature: string, Unit, Object
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      throw createError(name, arguments.length, 2, arguments[2], 'Object');
    }
    if (test0(arg1)) { // type: string
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: string, string
      }
      if (test2(arg2)) { // type: Object
        if (arguments.length === 3) {
          return signature2(arg0, arg1, arg2); // signature: string, string, Object
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      throw createError(name, arguments.length, 2, arguments[2], 'Object');
    }
    if (test3(arg1)) { // type: number (convert to string)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: string, number
      }
      if (test2(arg2)) { // type: Object
        if (arguments.length === 3) {
          return signature2(arg0, convert0(arg1), arg2); // signature: string, number, Object
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      throw createError(name, arguments.length, 2, arguments[2], 'Object');
    }
    if (test4(arg1)) { // type: boolean (convert to string)
      if (arguments.length === 2) {
        return signature1(arg0, convert1(arg1)); // signature: string, boolean
      }
      if (test2(arg2)) { // type: Object
        if (arguments.length === 3) {
          return signature2(arg0, convert1(arg1), arg2); // signature: string, boolean, Object
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      throw createError(name, arguments.length, 2, arguments[2], 'Object');
    }
    if (test5(arg1)) { // type: null (convert to string)
      if (arguments.length === 2) {
        return signature1(arg0, convert2(arg1)); // signature: string, null
      }
      if (test2(arg2)) { // type: Object
        if (arguments.length === 3) {
          return signature2(arg0, convert2(arg1), arg2); // signature: string, null, Object
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      throw createError(name, arguments.length, 2, arguments[2], 'Object');
    }
    if (test2(arg1)) { // type: Object
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: string, Object
      }
      if (test2(arg2)) { // type: Object
        if (arguments.length === 3) {
          return signature2(arg0, arg1, arg2); // signature: string, Object, Object
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      throw createError(name, arguments.length, 2, arguments[2], 'Object');
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Unit,string,Object');
  }
  if (test3(arg0)) { // type: number (convert to string)
    if (arguments.length === 1) {
      return signature0(convert0(arg0)); // signature: number
    }
    if (test1(arg1)) { // type: Unit
      if (arguments.length === 2) {
        return signature1(convert0(arg0), arg1); // signature: number, Unit
      }
      if (test2(arg2)) { // type: Object
        if (arguments.length === 3) {
          return signature2(convert0(arg0), arg1, arg2); // signature: number, Unit, Object
        } ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.cross" id="apidoc.element.mathjs.expression.mathWithTransform.cross">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>cross
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cross(arg0, arg1) {
  "use strict";
  var name = 'cross';
  if (test0(arg0)) { // type: Array
    if (test0(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: Array, Array
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Array, Matrix
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Array,Matrix');
  }
  if (test1(arg0)) { // type: Matrix
    if (test0(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: Matrix, Array
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature3(arg0, arg1); // signature: Matrix, Matrix
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Array,Matrix');
  }
  throw createError(name, arguments.length, 0, arguments[0], 'Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*    ]
*
* If one of the input vectors has a dimension greater than 1, the output
* vector will be a 1x3 (2-dimensional) matrix.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">cross</span>(x, y)
*
* Examples:
*
*    math.cross([1, 1, 0],   [0, 1, 1]);       // Returns [1, -1, 1]
*    math.cross([3, -3, 1],  [4, 9, 2]);       // Returns [-15, -2, 39]
*    math.cross([2, 3, 4],   [5, 6, 7]);       // Returns [-3, 6, -3]
*    math.cross([[1, 2, 3]], [[4], [5], [6]]); // Returns [[-3, 6, -3]]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.csc" id="apidoc.element.mathjs.expression.mathWithTransform.csc">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>csc
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function csc(arg0) {
  "use strict";
  var name = 'csc';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Unit
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Unit
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature2(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test9(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Unit,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Syntax:
*
*    math.acsc(x)
*
* Examples:
*
*    math.acsc(0.5);           // returns number 0.5235987755982989
*    math.acsc(math.<span class="apidocCodeKeywordSpan">csc</span>(1.5)); // returns number ~1.5
*
*    math.acsc(2);             // returns Complex 1.5707963267948966 -1.3169578969248166 i
*
* See also:
*
*    csc, asin, asec
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.csch" id="apidoc.element.mathjs.expression.mathWithTransform.csch">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>csch
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function csch(arg0) {
  "use strict";
  var name = 'csch';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Unit
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Unit
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature2(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test9(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Unit,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Calculate the hyperbolic cosecant of a value,
* defined as `csch(x) = 1 / sinh(x)`.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">csch</span>(x)
*
* Examples:
*
*    // csch(x) = 1/ sinh(x)
*    math.csch(0.5);       // returns 1.9190347513349437
*    1 / math.sinh(0.5);   // returns 1.9190347513349437
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.cube" id="apidoc.element.mathjs.expression.mathWithTransform.cube">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>cube
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cube(arg0) {
  "use strict";
  var name = 'cube';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Fraction
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Unit
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Unit
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature5(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature5(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert0(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test9(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Fraction,Unit,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
*    math.cbrt(x)
*    math.cbrt(x, allRoots)
*
* Examples:
*
*    math.cbrt(27);                  // returns 3
*    math.<span class="apidocCodeKeywordSpan">cube</span>(3);                   // returns 27
*    math.cbrt(-64);                 // returns -4
*    math.cbrt(math.unit('27 m^3')); // returns Unit 3 m
*    math.cbrt([27, 64, 125]);       // returns [3, 4, 5]
*
*    var x = math.complex('8i');
*    math.cbrt(x);                   // returns Complex 1.7320508075689 + i
*    math.cbrt(x, true);             // returns Matrix [
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.deepEqual" id="apidoc.element.mathjs.expression.mathWithTransform.deepEqual">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>deepEqual
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deepEqual(arg0, arg1) {
  "use strict";
  var name = 'deepEqual';
  // type: any
  // type: any
  if (arguments.length === 2) {
    return signature0(arg0, arg1); // signature: any, any
  }
  if (arguments.length &gt; 2) {
    throw createError(name, arguments.length, 2, arguments[2]);
  }
  throw createError(name, arguments.length, 1, arguments[1], 'any');
  throw createError(name, arguments.length, 0, arguments[0], 'any');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (a.length != b.length) {
    return false;
  }

  for (i = 0, len = a.length; i &lt; len; i++) {
    if (!exports.<span class="apidocCodeKeywordSpan">deepEqual</span>(a[i], b[i])) {
      return false;
    }
  }
  return true;
}
else if (a instanceof Object) {
  if (Array.isArray(b) || !(b instanceof Object)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.derivative" id="apidoc.element.mathjs.expression.mathWithTransform.derivative">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>derivative
        <span class="apidocSignatureSpan">(arg0, arg1, arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function derivative(arg0, arg1, arg2) {
  "use strict";
  var name = 'derivative';
  if (test0(arg0)) { // type: string
    if (test0(arg1)) { // type: string
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: string, string
      }
      if (test1(arg2)) { // type: Object
        if (arguments.length === 3) {
          return signature1(arg0, arg1, arg2); // signature: string, string, Object
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      throw createError(name, arguments.length, 2, arguments[2], 'Object');
    }
    if (test2(arg1)) { // type: SymbolNode
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: string, SymbolNode
      }
      if (test1(arg2)) { // type: Object
        if (arguments.length === 3) {
          return signature3(arg0, arg1, arg2); // signature: string, SymbolNode, Object
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      throw createError(name, arguments.length, 2, arguments[2], 'Object');
    }
    if (test3(arg1)) { // type: number (convert to string)
      if (arguments.length === 2) {
        return signature0(arg0, convert0(arg1)); // signature: string, number
      }
      if (test1(arg2)) { // type: Object
        if (arguments.length === 3) {
          return signature1(arg0, convert0(arg1), arg2); // signature: string, number, Object
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      throw createError(name, arguments.length, 2, arguments[2], 'Object');
    }
    if (test4(arg1)) { // type: boolean (convert to string)
      if (arguments.length === 2) {
        return signature0(arg0, convert1(arg1)); // signature: string, boolean
      }
      if (test1(arg2)) { // type: Object
        if (arguments.length === 3) {
          return signature1(arg0, convert1(arg1), arg2); // signature: string, boolean, Object
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      throw createError(name, arguments.length, 2, arguments[2], 'Object');
    }
    if (test5(arg1)) { // type: null (convert to string)
      if (arguments.length === 2) {
        return signature0(arg0, convert2(arg1)); // signature: string, null
      }
      if (test1(arg2)) { // type: Object
        if (arguments.length === 3) {
          return signature1(arg0, convert2(arg1), arg2); // signature: string, null, Object
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      throw createError(name, arguments.length, 2, arguments[2], 'Object');
    }
    throw createError(name, arguments.length, 1, arguments[1], 'string,SymbolNode');
  }
  if (test6(arg0)) { // type: Node
    if (test0(arg1)) { // type: string
      if (arguments.length === 2) {
        return signature4(arg0, arg1); // signature: Node, string
      }
      if (test1(arg2)) { // type: Object
        if (arguments.length === 3) {
          return signature5(arg0, arg1, arg2); // signature: Node, string, Object
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      throw createError(name, arguments.length, 2, arguments[2], 'Object');
    }
    if (test2(arg1)) { // type: SymbolNode
      if (arguments.length === 2) {
        return signature6(arg0, arg1); // signature: Node, SymbolNode
      }
      if (test1(arg2)) { // type: Object
        if (arguments.length === 3) {
          return signature7(arg0, arg1, arg2); // signature: Node, SymbolNode, Object
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      throw createError(name, arguments.length, 2, arguments[2], 'Object');
    }
    if (t ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// functions and constants
math.round(math.e, 3);            // 2.718
math.atan2(3, -3) / math.pi;      // 0.75
math.log(1000, 10);               // 3
math.sqrt(-4);                    // 2i
math.pow([[-1, 2], [3, 1]], 2);   // [[7, 0], [0, 7]]
math.<span class="apidocCodeKeywordSpan">derivative</span>('x^2 + x', 'x');  // 2 * x + 1

// expressions
math.eval('12 / (2.3 + 0.7)');    // 4
math.eval('5.08 cm to inch');     // 2 inch
math.eval('sin(45 deg) ^ 2');     // 0.5
math.eval('9 / 3 + 2i');          // 3 + 2i
math.eval('det([-1, 2; 3, 1])');  // -7
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.det" id="apidoc.element.mathjs.expression.mathWithTransform.det">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>det
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function det(arg0) {
  "use strict";
  var name = 'det';
  if (test0(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature0(arg0); // signature: Array
    }
  }
  if (test1(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature0(arg0); // signature: Matrix
    }
  }
  // type: any
  if (arguments.length === 1) {
    return signature1(arg0); // signature: any
  }
  if (arguments.length &gt; 1) {
    throw createError(name, arguments.length, 1, arguments[1]);
  }
  throw createError(name, arguments.length, 0, arguments[0], 'Array,Matrix,any');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var unaryMinus = load(require('../arithmetic/unaryMinus'));

/**
 * Calculate the determinant of a matrix.
 *
 * Syntax:
 *
 *    math.<span class="apidocCodeKeywordSpan">det</span>(x)
 *
 * Examples:
 *
 *    math.det([[1, 2], [3, 4]]); // returns -2
 *
 *    var A = [
 *      [-2, 2, 3],
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.diag" id="apidoc.element.mathjs.expression.mathWithTransform.diag">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>diag
        <span class="apidocSignatureSpan">(arg0, arg1, arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function diag(arg0, arg1, arg2) {
  "use strict";
  var name = 'diag';
  if (test0(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature0(arg0); // signature: Array
    }
    if (test1(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Array, number
      }
      if (test2(arg2)) { // type: string
        if (arguments.length === 3) {
          return signature2(arg0, arg1, arg2); // signature: Array, number, string
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test1(arg2)) { // type: number (convert to string)
        if (arguments.length === 3) {
          return signature2(arg0, arg1, convert0(arg2)); // signature: Array, number, number
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test3(arg2)) { // type: boolean (convert to string)
        if (arguments.length === 3) {
          return signature2(arg0, arg1, convert1(arg2)); // signature: Array, number, boolean
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test4(arg2)) { // type: null (convert to string)
        if (arguments.length === 3) {
          return signature2(arg0, arg1, convert2(arg2)); // signature: Array, number, null
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      throw createError(name, arguments.length, 2, arguments[2], 'string');
    }
    if (test5(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature3(arg0, arg1); // signature: Array, BigNumber
      }
      if (test2(arg2)) { // type: string
        if (arguments.length === 3) {
          return signature4(arg0, arg1, arg2); // signature: Array, BigNumber, string
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test1(arg2)) { // type: number (convert to string)
        if (arguments.length === 3) {
          return signature4(arg0, arg1, convert0(arg2)); // signature: Array, BigNumber, number
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test3(arg2)) { // type: boolean (convert to string)
        if (arguments.length === 3) {
          return signature4(arg0, arg1, convert1(arg2)); // signature: Array, BigNumber, boolean
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test4(arg2)) { // type: null (convert to string)
        if (arguments.length === 3) {
          return signature4(arg0, arg1, convert2(arg2)); // signature: Array, BigNumber, null
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      throw createError(name, arguments.length, 2, arguments[2], 'string');
    }
    if (test2(arg1)) { // type: string
      if (arguments.length === 2) {
        return signature5(arg0, arg1); // signature: Array, string
      }
      if (test2(arg2)) { // type: string
        if (arguments.length === 3) {
          return signature2(arg0, convert3(arg1), arg2); // signature: Array, string, string
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test1(arg2)) { // type: number (convert to string)
        if (arguments.length === 3) {
          return signature2(arg0, convert3(arg1), convert0(arg2)); // signature: Array, string, number
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test3(arg2)) { // type: boolean (convert to string)
        if (argume ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* When `x` is a vector, a matrix with vector `x` on the diagonal will be returned.
* When `x` is a two dimensional matrix, the matrixes `k`th diagonal will be returned as vector.
* When k is positive, the values are placed on the super diagonal.
* When k is negative, the values are placed on the sub diagonal.
*
* Syntax:
*
*     math.<span class="apidocCodeKeywordSpan">diag</span>(X)
*     math.diag(X, format)
*     math.diag(X, k)
*     math.diag(X, k, format)
*
* Examples:
*
*     // create a diagonal matrix
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.distance" id="apidoc.element.mathjs.expression.mathWithTransform.distance">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>distance
        <span class="apidocSignatureSpan">(arg0, arg1, arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function distance(arg0, arg1, arg2) {
  "use strict";
  var name = 'distance';
  if (test0(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature0(arg0); // signature: Array
    }
    if (test0(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Array, Array
      }
      if (test0(arg2)) { // type: Array
        if (arguments.length === 3) {
          return signature2(arg0, arg1, arg2); // signature: Array, Array, Array
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test1(arg2)) { // type: Matrix (convert to Array)
        if (arguments.length === 3) {
          return signature2(arg0, arg1, convert0(arg2)); // signature: Array, Array, Matrix
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      throw createError(name, arguments.length, 2, arguments[2], 'Array');
    }
    if (test1(arg1)) { // type: Matrix (convert to Array)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: Array, Matrix
      }
      if (test0(arg2)) { // type: Array
        if (arguments.length === 3) {
          return signature2(arg0, convert0(arg1), arg2); // signature: Array, Matrix, Array
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test1(arg2)) { // type: Matrix (convert to Array)
        if (arguments.length === 3) {
          return signature2(arg0, convert0(arg1), convert0(arg2)); // signature: Array, Matrix, Matrix
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      throw createError(name, arguments.length, 2, arguments[2], 'Array');
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Array');
  }
  if (test1(arg0)) { // type: Matrix (convert to Array)
    if (arguments.length === 1) {
      return signature0(convert0(arg0)); // signature: Matrix
    }
    if (test0(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature1(convert0(arg0), arg1); // signature: Matrix, Array
      }
      if (test0(arg2)) { // type: Array
        if (arguments.length === 3) {
          return signature2(convert0(arg0), arg1, arg2); // signature: Matrix, Array, Array
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test1(arg2)) { // type: Matrix (convert to Array)
        if (arguments.length === 3) {
          return signature2(convert0(arg0), arg1, convert0(arg2)); // signature: Matrix, Array, Matrix
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      throw createError(name, arguments.length, 2, arguments[2], 'Array');
    }
    if (test1(arg1)) { // type: Matrix (convert to Array)
      if (arguments.length === 2) {
        return signature1(convert0(arg0), convert0(arg1)); // signature: Matrix, Matrix
      }
      if (test0(arg2)) { // type: Array
        if (arguments.length === 3) {
          return signature2(convert0(arg0), convert0(arg1), arg2); // signature: Matrix, Matrix, Array
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test1(arg2)) { // type: Matrix (convert to Array)
        if (arguments.length === 3) {
          return signature2(convert0(arg0), convert0(arg1), convert0(arg2)); // signature: Matrix, Matrix, Matrix
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      throw createError(name, arguments.length, 2, arguments[2], 'Array');
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Array');
  }
  if (test2(arg0)) { / ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*    Distance between point and a line in 2 and 3 dimensional spaces.
*    Pairwise distance between a set of 2D or 3D points
* NOTE:
*    When substituting coefficients of a line(a, b and c), use ax + by + c = 0 instead of ax + by = c
*    For parametric equation of a 3D line, x0, y0, z0, a, b, c are from: (xâˆ’x0, yâˆ’y0, zâˆ’z0) = t(a, b, c)
*
* Syntax:
*    math.<span class="apidocCodeKeywordSpan">distance</span>([x1, y1], [x2, y2])
*-   math.distance({pointOneX: 4, pointOneY: 5}, {pointTwoX: 2, pointTwoY: 7})
*    math.distance([x1, y1, z1], [x2, y2, z2])
*    math.distance({pointOneX: 4, pointOneY: 5, pointOneZ: 8}, {pointTwoX: 2, pointTwoY: 7, pointTwoZ: 9})
*    math.distance([[A], [B], [C]...])
*    math.distance([x1, y1], [LinePtX1, LinePtY1], [LinePtX2, LinePtY2])
*    math.distance({pointX: 1, pointY: 4}, {lineOnePtX: 6, lineOnePtY: 3}, {lineTwoPtX: 2, lineTwoPtY: 8})
*    math.distance([x1, y1, z1], [LinePtX1, LinePtY1, LinePtZ1], [LinePtX2, LinePtY2, LinePtZ2])
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.divide" id="apidoc.element.mathjs.expression.mathWithTransform.divide">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>divide
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function divide(arg0, arg1) {
  "use strict";
  var name = 'divide';
  if (test0(arg0)) { // type: number
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: number, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: Complex
      if (arguments.length === 2) {
        return signature1(convert0(arg0), arg1); // signature: number, Complex
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature2(convert1(arg0), arg1); // signature: number, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: Fraction
      if (arguments.length === 2) {
        return signature3(convert2(arg0), arg1); // signature: number, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: Unit
      if (arguments.length === 2) {
        return signature4(arg0, arg1); // signature: number, Unit
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert3(arg1)); // signature: number, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test6(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert4(arg1)); // signature: number, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test7(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert5(arg1)); // signature: number, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
  }
  if (test1(arg0)) { // type: Complex
    if (test1(arg1)) { // type: Complex
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Complex, Complex
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test0(arg1)) { // type: number (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: Complex, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: BigNumber (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert6(arg1)); // signature: Complex, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: Fraction (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert7(arg1)); // signature: Complex, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: string (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert8(arg1)); // signature: Complex, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (test1(arg1)) { // type: Complex
      if (arguments.length === 2) {
        return signature1(convert6(arg0), arg1); // signature: BigNumber, Complex
      } ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  /**
* Divide two values, `x / y`.
* To divide matrices, `x` is multiplied with the inverse of `y`: `x * inv(y)`.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">divide</span>(x, y)
*
* Examples:
*
*    math.divide(2, 3);            // returns number 0.6666666666666666
*
*    var a = math.complex(5, 14);
*    var b = math.complex(4, 1);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.dot" id="apidoc.element.mathjs.expression.mathWithTransform.dot">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>dot
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dot(arg0, arg1) {
  "use strict";
  var name = 'dot';
  if (test0(arg0)) { // type: Array
    if (test0(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: Array, Array
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Array, Matrix
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Array,Matrix');
  }
  if (test1(arg0)) { // type: Matrix
    if (test0(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: Matrix, Array
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature3(arg0, arg1); // signature: Matrix, Matrix
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Array,Matrix');
  }
  throw createError(name, arguments.length, 0, arguments[0], 'Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Calculate the dot product of two vectors. The dot product of
* `A = [a1, a2, a3, ..., an]` and `B = [b1, b2, b3, ..., bn]` is defined as:
*
*    dot(A, B) = a1 * b1 + a2 * b2 + a3 * b3 + ... + an * bn
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">dot</span>(x, y)
*
* Examples:
*
*    math.dot([2, 4, 1], [2, 2, 3]);       // returns number 15
*    math.multiply([2, 4, 1], [2, 2, 3]);  // returns number 15
*
* See also:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.dotDivide" id="apidoc.element.mathjs.expression.mathWithTransform.dotDivide">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>dotDivide
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dotDivide(arg0, arg1) {
  "use strict";
  var name = 'dotDivide';
  if (test0(arg0)) { // type: Array
    if (test0(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: Array, Array
      }
    }
    if (test1(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Array, Matrix
      }
    }
    // type: any
    if (arguments.length === 2) {
      return signature2(arg0, arg1); // signature: Array, any
    }
    if (arguments.length &gt; 2) {
      throw createError(name, arguments.length, 2, arguments[2]);
    }
  }
  if (test1(arg0)) { // type: Matrix
    if (test0(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature3(arg0, arg1); // signature: Matrix, Array
      }
    }
    if (test1(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature4(arg0, arg1); // signature: Matrix, Matrix
      }
    }
    // type: any
    if (arguments.length === 2) {
      return signature5(arg0, arg1); // signature: Matrix, any
    }
    if (arguments.length &gt; 2) {
      throw createError(name, arguments.length, 2, arguments[2]);
    }
  }
  // type: any
  if (test0(arg1)) { // type: Array
    if (arguments.length === 2) {
      return signature6(arg0, arg1); // signature: any, Array
    }
  }
  if (test1(arg1)) { // type: Matrix
    if (arguments.length === 2) {
      return signature7(arg0, arg1); // signature: any, Matrix
    }
  }
  // type: any
  if (arguments.length === 2) {
    return signature8(arg0, arg1); // signature: any, any
  }
  if (arguments.length &gt; 2) {
    throw createError(name, arguments.length, 2, arguments[2]);
  }
  throw createError(name, arguments.length, 1, arguments[1], 'Array,Matrix,any');
  throw createError(name, arguments.length, 0, arguments[0], 'Array,Matrix,any');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  /**
* Divide two matrices element wise. The function accepts both matrices and
* scalar values.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">dotDivide</span>(x, y)
*
* Examples:
*
*    math.dotDivide(2, 4);   // returns 0.5
*
*    a = [[9, 5], [6, 1]];
*    b = [[3, 2], [5, 2]];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.dotMultiply" id="apidoc.element.mathjs.expression.mathWithTransform.dotMultiply">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>dotMultiply
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dotMultiply(arg0, arg1) {
  "use strict";
  var name = 'dotMultiply';
  if (test0(arg0)) { // type: Array
    if (test0(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: Array, Array
      }
    }
    if (test1(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Array, Matrix
      }
    }
    // type: any
    if (arguments.length === 2) {
      return signature2(arg0, arg1); // signature: Array, any
    }
    if (arguments.length &gt; 2) {
      throw createError(name, arguments.length, 2, arguments[2]);
    }
  }
  if (test1(arg0)) { // type: Matrix
    if (test0(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature3(arg0, arg1); // signature: Matrix, Array
      }
    }
    if (test1(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature4(arg0, arg1); // signature: Matrix, Matrix
      }
    }
    // type: any
    if (arguments.length === 2) {
      return signature5(arg0, arg1); // signature: Matrix, any
    }
    if (arguments.length &gt; 2) {
      throw createError(name, arguments.length, 2, arguments[2]);
    }
  }
  // type: any
  if (test0(arg1)) { // type: Array
    if (arguments.length === 2) {
      return signature6(arg0, arg1); // signature: any, Array
    }
  }
  if (test1(arg1)) { // type: Matrix
    if (arguments.length === 2) {
      return signature7(arg0, arg1); // signature: any, Matrix
    }
  }
  // type: any
  if (arguments.length === 2) {
    return signature8(arg0, arg1); // signature: any, any
  }
  if (arguments.length &gt; 2) {
    throw createError(name, arguments.length, 2, arguments[2]);
  }
  throw createError(name, arguments.length, 1, arguments[1], 'Array,Matrix,any');
  throw createError(name, arguments.length, 0, arguments[0], 'Array,Matrix,any');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  /**
* Multiply two matrices element wise. The function accepts both matrices and
* scalar values.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">dotMultiply</span>(x, y)
*
* Examples:
*
*    math.dotMultiply(2, 4); // returns 8
*
*    a = [[9, 5], [6, 1]];
*    b = [[3, 2], [5, 2]];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.dotPow" id="apidoc.element.mathjs.expression.mathWithTransform.dotPow">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>dotPow
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dotPow(arg0, arg1) {
  "use strict";
  var name = 'dotPow';
  if (test0(arg0)) { // type: Array
    if (test0(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: Array, Array
      }
    }
    if (test1(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Array, Matrix
      }
    }
    // type: any
    if (arguments.length === 2) {
      return signature2(arg0, arg1); // signature: Array, any
    }
    if (arguments.length &gt; 2) {
      throw createError(name, arguments.length, 2, arguments[2]);
    }
  }
  if (test1(arg0)) { // type: Matrix
    if (test0(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature3(arg0, arg1); // signature: Matrix, Array
      }
    }
    if (test1(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature4(arg0, arg1); // signature: Matrix, Matrix
      }
    }
    // type: any
    if (arguments.length === 2) {
      return signature5(arg0, arg1); // signature: Matrix, any
    }
    if (arguments.length &gt; 2) {
      throw createError(name, arguments.length, 2, arguments[2]);
    }
  }
  // type: any
  if (test0(arg1)) { // type: Array
    if (arguments.length === 2) {
      return signature6(arg0, arg1); // signature: any, Array
    }
  }
  if (test1(arg1)) { // type: Matrix
    if (arguments.length === 2) {
      return signature7(arg0, arg1); // signature: any, Matrix
    }
  }
  // type: any
  if (arguments.length === 2) {
    return signature8(arg0, arg1); // signature: any, any
  }
  if (arguments.length &gt; 2) {
    throw createError(name, arguments.length, 2, arguments[2]);
  }
  throw createError(name, arguments.length, 1, arguments[1], 'Array,Matrix,any');
  throw createError(name, arguments.length, 0, arguments[0], 'Array,Matrix,any');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));

/**
 * Calculates the power of x to y element wise.
 *
 * Syntax:
 *
 *    math.<span class="apidocCodeKeywordSpan">dotPow</span>(x, y)
 *
 * Examples:
 *
 *    math.dotPow(2, 3);            // returns number 8
 *
 *    var a = [[1, 2], [4, 3]];
 *    math.dotPow(a, 2);            // returns Array [[1, 4], [16, 9]]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.equal" id="apidoc.element.mathjs.expression.mathWithTransform.equal">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>equal
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function equal(arg0, arg1) {
  "use strict";
  var name = 'equal';
  if (test0(arg0)) { // type: Array
    if (test0(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: Array, Array
      }
    }
    if (test1(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Array, Matrix
      }
    }
    // type: any
    if (arguments.length === 2) {
      return signature2(arg0, arg1); // signature: Array, any
    }
    if (arguments.length &gt; 2) {
      throw createError(name, arguments.length, 2, arguments[2]);
    }
  }
  if (test1(arg0)) { // type: Matrix
    if (test0(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature3(arg0, arg1); // signature: Matrix, Array
      }
    }
    if (test1(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature4(arg0, arg1); // signature: Matrix, Matrix
      }
    }
    // type: any
    if (arguments.length === 2) {
      return signature5(arg0, arg1); // signature: Matrix, any
    }
    if (arguments.length &gt; 2) {
      throw createError(name, arguments.length, 2, arguments[2]);
    }
  }
  // type: any
  if (test0(arg1)) { // type: Array
    if (arguments.length === 2) {
      return signature6(arg0, arg1); // signature: any, Array
    }
  }
  if (test1(arg1)) { // type: Matrix
    if (arguments.length === 2) {
      return signature7(arg0, arg1); // signature: any, Matrix
    }
  }
  // type: any
  if (arguments.length === 2) {
    return signature8(arg0, arg1); // signature: any, any
  }
  if (arguments.length &gt; 2) {
    throw createError(name, arguments.length, 2, arguments[2]);
  }
  throw createError(name, arguments.length, 1, arguments[1], 'Array,Matrix,any');
  throw createError(name, arguments.length, 0, arguments[0], 'Array,Matrix,any');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
*    math.deepEqual(2, 4);   // returns false
*
*    a = [2, 5, 1];
*    b = [2, 7, 1];
*
*    math.deepEqual(a, b);   // returns false
*    math.<span class="apidocCodeKeywordSpan">equal</span>(a, b);       // returns [true, false, true]
*
* See also:
*
*    equal, unequal
*
* @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x First matrix to compare
* @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} y Second matrix to compare
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.erf" id="apidoc.element.mathjs.expression.mathWithTransform.erf">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>erf
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function erf(arg0) {
  "use strict";
  var name = 'erf';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature1(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature2(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature2(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature1(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,BigNumber,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* "Rational Chebyshev Approximations for the Error Function" by W. J. Cody
* for an explanation of this process.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">erf</span>(x)
*
* Examples:
*
*    math.erf(0.2);    // returns 0.22270258921047847
*    math.erf(-0.5);   // returns -0.5204998778130465
*    math.erf(4);      // returns 0.9999999845827421
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.eval" id="apidoc.element.mathjs.expression.mathWithTransform.eval">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>eval
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function compile(arg0, arg1) {
  "use strict";
  var name = 'compile';
  if (test0(arg0)) { // type: string
    if (arguments.length === 1) {
      return signature0(arg0); // signature: string
    }
    if (test1(arg1)) { // type: Object
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: string, Object
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Object');
  }
  if (test2(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature2(arg0); // signature: Array
    }
    if (test1(arg1)) { // type: Object
      if (arguments.length === 2) {
        return signature3(arg0, arg1); // signature: Array, Object
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Object');
  }
  if (test3(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature2(arg0); // signature: Matrix
    }
    if (test1(arg1)) { // type: Object
      if (arguments.length === 2) {
        return signature3(arg0, arg1); // signature: Matrix, Object
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Object');
  }
  if (test4(arg0)) { // type: number (convert to string)
    if (arguments.length === 1) {
      return signature0(convert0(arg0)); // signature: number
    }
    if (test1(arg1)) { // type: Object
      if (arguments.length === 2) {
        return signature1(convert0(arg0), arg1); // signature: number, Object
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Object');
  }
  if (test5(arg0)) { // type: boolean (convert to string)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: boolean
    }
    if (test1(arg1)) { // type: Object
      if (arguments.length === 2) {
        return signature1(convert1(arg0), arg1); // signature: boolean, Object
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Object');
  }
  if (test6(arg0)) { // type: null (convert to string)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: null
    }
    if (test1(arg1)) { // type: Object
      if (arguments.length === 2) {
        return signature1(convert2(arg0), arg1); // signature: null, Object
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Object');
  }
  throw createError(name, arguments.length, 0, arguments[0], 'string,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
math.atan2(3, -3) / math.pi;      // 0.75
math.log(1000, 10);               // 3
math.sqrt(-4);                    // 2i
math.pow([[-1, 2], [3, 1]], 2);   // [[7, 0], [0, 7]]
math.derivative('x^2 + x', 'x');  // 2 * x + 1

// expressions
math.<span class="apidocCodeKeywordSpan">eval</span>('12 / (2.3 + 0.7)');    // 4
math.eval('5.08 cm to inch');     // 2 inch
math.eval('sin(45 deg) ^ 2');     // 0.5
math.eval('9 / 3 + 2i');          // 3 + 2i
math.eval('det([-1, 2; 3, 1])');  // -7

// chaining
math.chain(3)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.exp" id="apidoc.element.mathjs.expression.mathWithTransform.exp">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>exp
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function exp(arg0) {
  "use strict";
  var name = 'exp';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature2(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// https://www.wikiwand.com/en/Cube_root#/Complex_numbers

var arg_3 = x.arg() / 3;
var abs = x.abs();

// principal root:
var principal = new type.Complex(_cbrtNumber(abs), 0).mul(
    new type.Complex(0, arg_3).<span class="apidocCodeKeywordSpan">exp</span>());

if (allRoots) {
  var all = [
      principal,
      new type.Complex(_cbrtNumber(abs), 0).mul(
        new type.Complex(0, arg_3 + Math.PI * 2 / 3).exp()),
      new type.Complex(_cbrtNumber(abs), 0).mul(
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.eye" id="apidoc.element.mathjs.expression.mathWithTransform.eye">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>eye
        <span class="apidocSignatureSpan">(arg0, arg1, arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function eye(arg0, arg1, arg2) {
  "use strict";
  var name = 'eye';
  if (arguments.length === 0) {
    return signature0(); // signature:
  }
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature1(arg0); // signature: number
    }
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: number, number
      }
      if (test1(arg2)) { // type: string
        if (arguments.length === 3) {
          return signature3(arg0, arg1, arg2); // signature: number, number, string
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test0(arg2)) { // type: number (convert to string)
        if (arguments.length === 3) {
          return signature3(arg0, arg1, convert0(arg2)); // signature: number, number, number
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test2(arg2)) { // type: boolean (convert to string)
        if (arguments.length === 3) {
          return signature3(arg0, arg1, convert1(arg2)); // signature: number, number, boolean
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test3(arg2)) { // type: null (convert to string)
        if (arguments.length === 3) {
          return signature3(arg0, arg1, convert2(arg2)); // signature: number, number, null
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      throw createError(name, arguments.length, 2, arguments[2], 'string');
    }
    if (test4(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: number, BigNumber
      }
      if (test1(arg2)) { // type: string
        if (arguments.length === 3) {
          return signature3(arg0, arg1, arg2); // signature: number, BigNumber, string
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test0(arg2)) { // type: number (convert to string)
        if (arguments.length === 3) {
          return signature3(arg0, arg1, convert0(arg2)); // signature: number, BigNumber, number
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test2(arg2)) { // type: boolean (convert to string)
        if (arguments.length === 3) {
          return signature3(arg0, arg1, convert1(arg2)); // signature: number, BigNumber, boolean
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test3(arg2)) { // type: null (convert to string)
        if (arguments.length === 3) {
          return signature3(arg0, arg1, convert2(arg2)); // signature: number, BigNumber, null
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      throw createError(name, arguments.length, 2, arguments[2], 'string');
    }
    if (test1(arg1)) { // type: string
      if (arguments.length === 2) {
        return signature4(arg0, arg1); // signature: number, string
      }
      if (test1(arg2)) { // type: string
        if (arguments.length === 3) {
          return signature3(arg0, convert3(arg1), arg2); // signature: number, string, string
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test0(arg2)) { // type: number (convert to string)
        if (arguments.length === 3) {
          return signature3(arg0, convert3(arg1), convert0(arg2)); // signature: number, string, number
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        } ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  /**
* Create a 2-dimensional identity matrix with size m x n or n x n.
* The matrix has ones on the diagonal and zeros elsewhere.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">eye</span>(n)
*    math.eye(n, format)
*    math.eye(m, n)
*    math.eye(m, n, format)
*    math.eye([m, n])
*    math.eye([m, n], format)
*
* Examples:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.factorial" id="apidoc.element.mathjs.expression.mathWithTransform.factorial">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>factorial
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factorial(arg0) {
  "use strict";
  var name = 'factorial';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature1(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature2(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature2(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature1(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,BigNumber,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Compute the factorial of a value
*
* Factorial only supports an integer value as argument.
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">factorial</span>(n)
*
* Examples:
*
*    math.factorial(5);    // returns 120
*    math.factorial(3);    // returns 6
*
* See also:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.filter" id="apidoc.element.mathjs.expression.mathWithTransform.filter">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>filter
        <span class="apidocSignatureSpan">(args, math, scope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function filterTransform(args, math, scope) {
  var x, test;

  if (args[0]) {
    x = args[0].compile().eval(scope);
  }

  if (args[1]) {
    if (args[1] &amp;&amp; args[1].isSymbolNode) {
      // a function pointer, like filter([3, -2, 5], myTestFunction);
      test = args[1].compile().eval(scope);
    }
    else {
      // an equation like filter([3, -2, 5], x &gt; 0)

      // find an undefined symbol
      var _scope = scope || {};
      var symbol = args[1]
          .filter(function (node) {
            return (node &amp;&amp; node.isSymbolNode) &amp;&amp;
                !(node.name in math) &amp;&amp;
                !(node.name in _scope);
          })[0];

      // create a test function for this equation
      var sub = Object.create(_scope);
      var eq = args[1].compile();
      if (symbol) {
        var name = symbol.name;
        test = function (x) {
          sub[name] = x;
          return eq.eval(sub);
        }
      }
      else {
        throw new Error('No undefined variable found in filter equation');
      }
    }
  }

  return filter(x, test);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            }
          }
        }
      }
    }

    // remove duplicates
    matches = matches.<span class="apidocCodeKeywordSpan">filter</span>(function(elem, pos, arr) {
      return arr.indexOf(elem) == pos;
    });
  }

  return [matches, keyword];
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.fix" id="apidoc.element.mathjs.expression.mathWithTransform.fix">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>fix
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fix(arg0) {
  "use strict";
  var name = 'fix';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Fraction
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert0(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Fraction,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function factory (type, config, load, typed) {
/**
 * Round a value towards zero.
 * For matrices, the function is evaluated element wise.
 *
 * Syntax:
 *
 *    math.<span class="apidocCodeKeywordSpan">fix</span>(x)
 *
 * Examples:
 *
 *    math.fix(3.2);                // returns number 3
 *    math.fix(3.8);                // returns number 3
 *    math.fix(-4.2);               // returns number -4
 *    math.fix(-4.7);               // returns number -4
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.flatten" id="apidoc.element.mathjs.expression.mathWithTransform.flatten">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>flatten
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function flatten(arg0) {
  "use strict";
  var name = 'flatten';
  if (test0(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature0(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @returns {Array}               Array whose data has been formatted to fit the
 *                                specified dimensions
 *
 * @throws {DimensionError}       If the product of the new dimension sizes does
 *                                not equal that of the old ones
 */
exports.reshape = function(array, sizes) {
var flatArray = exports.<span class="apidocCodeKeywordSpan">flatten</span>(array);
var newArray;

var product = function (arr) {
  return arr.reduce(function (prev, curr) {
    return prev * curr;
  });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.floor" id="apidoc.element.mathjs.expression.mathWithTransform.floor">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>floor
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function floor(arg0) {
  "use strict";
  var name = 'floor';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Fraction
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert0(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Fraction,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   *    ceil, floor, round
   *
   * @param {number | BigNumber | Fraction | Complex | Array | Matrix} x Number to be rounded
   * @return {number | BigNumber | Fraction | Complex | Array | Matrix}            Rounded value
   */
  var fix = typed('fix', {
'number': function (x) {
  return (x &gt; 0) ? Math.<span class="apidocCodeKeywordSpan">floor</span>(x) : Math.ceil(x);
},

'Complex': function (x) {
  return new type.Complex(
      (x.re &gt; 0) ? Math.floor(x.re) : Math.ceil(x.re),
      (x.im &gt; 0) ? Math.floor(x.im) : Math.ceil(x.im)
  );
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.forEach" id="apidoc.element.mathjs.expression.mathWithTransform.forEach">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>forEach
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function forEach(arg0, arg1) {
  "use strict";
  var name = 'forEach';
  if (test0(arg0)) { // type: Array
    if (test1(arg1)) { // type: function
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: Array, function
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'function');
  }
  if (test2(arg0)) { // type: Matrix
    if (test1(arg1)) { // type: function
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: Matrix, function
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'function');
  }
  throw createError(name, arguments.length, 0, arguments[0], 'Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (def.indexOf(keyword) == 0) {
      matches.push(def);
    }
  }
}

// commandline keywords
['exit', 'quit', 'clear'].<span class="apidocCodeKeywordSpan">forEach</span>(function (cmd) {
  if (cmd.indexOf(keyword) == 0) {
    matches.push(cmd);
  }
});

// math functions and constants
var ignore = ['expr', 'type'];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.format" id="apidoc.element.mathjs.expression.mathWithTransform.format">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>format
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function format(arg0, arg1) {
  "use strict";
  var name = 'format';
  // type: any
  if (arguments.length === 1) {
    return signature0(arg0); // signature: any
  }
  if (test0(arg1)) { // type: number
    if (arguments.length === 2) {
      return signature0(arg0, arg1); // signature: any, number
    }
    if (arguments.length &gt; 2) {
      throw createError(name, arguments.length, 2, arguments[2]);
    }
  }
  if (test1(arg1)) { // type: function
    if (arguments.length === 2) {
      return signature0(arg0, arg1); // signature: any, function
    }
    if (arguments.length &gt; 2) {
      throw createError(name, arguments.length, 2, arguments[2]);
    }
  }
  if (test2(arg1)) { // type: string (convert to number)
    if (arguments.length === 2) {
      return signature0(arg0, convert0(arg1)); // signature: any, string
    }
    if (arguments.length &gt; 2) {
      throw createError(name, arguments.length, 2, arguments[2]);
    }
  }
  if (test3(arg1)) { // type: boolean (convert to number)
    if (arguments.length === 2) {
      return signature0(arg0, convert1(arg1)); // signature: any, boolean
    }
    if (arguments.length &gt; 2) {
      throw createError(name, arguments.length, 2, arguments[2]);
    }
  }
  if (test4(arg1)) { // type: null (convert to number)
    if (arguments.length === 2) {
      return signature0(arg0, convert2(arg1)); // signature: any, null
    }
    if (arguments.length &gt; 2) {
      throw createError(name, arguments.length, 2, arguments[2]);
    }
  }
  if (test5(arg1)) { // type: Object
    if (arguments.length === 2) {
      return signature0(arg0, arg1); // signature: any, Object
    }
    if (arguments.length &gt; 2) {
      throw createError(name, arguments.length, 2, arguments[2]);
    }
  }
  throw createError(name, arguments.length, 1, arguments[1], 'number,function,Object');
  throw createError(name, arguments.length, 0, arguments[0], 'any');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Helper function to format a value. Regular numbers will be rounded
 * to 14 digits to prevent round-off errors from showing up.
 * @param {*} value
 */
function format(value) {
var math = getMath();

return math.<span class="apidocCodeKeywordSpan">format</span>(value, {
  fn: function (value) {
    if (typeof value === 'number') {
      // round numbers
      return math.format(value, PRECISION);
    }
    else {
      return math.format(value);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.fraction" id="apidoc.element.mathjs.expression.mathWithTransform.fraction">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>fraction
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fraction(arg0, arg1) {
  "use strict";
  var name = 'fraction';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: number, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: number, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert1(arg1)); // signature: number, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert2(arg1)); // signature: number, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'number');
  }
  if (test4(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Fraction
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: string
    if (arguments.length === 1) {
      return signature4(arg0); // signature: string
    }
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature1(convert0(arg0), arg1); // signature: string, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature1(convert0(arg0), convert0(arg1)); // signature: string, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature1(convert0(arg0), convert1(arg1)); // signature: string, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature1(convert0(arg0), convert2(arg1)); // signature: string, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'number');
  }
  if (test6(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature5(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature5(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: boolean
    }
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature1(convert1(arg0), arg1); // signature: bo ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      case 'number':
// TODO: replace this with using config.number
var numConfig = defs.math.config().number;
if (numConfig === 'BigNumber') {
  return 'math.bignumber("' + this.value + '")';
}
else if (numConfig === 'Fraction') {
  return 'math.<span class="apidocCodeKeywordSpan">fraction</span>("' + this.value + '")';
}
else {
  // remove leading zeros like '003.2' which are not allowed by JavaScript
  return this.value.replace(/^(0*)[0-9]/, function (match, zeros) {
    return match.substring(zeros.length);
  });
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.gamma" id="apidoc.element.mathjs.expression.mathWithTransform.gamma">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>gamma
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function gamma(arg0) {
  "use strict";
  var name = 'gamma';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature2(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Compute the gamma function of a value using Lanczos approximation for
* small values, and an extended Stirling approximation for large values.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">gamma</span>(n)
*
* Examples:
*
*    math.gamma(5);       // returns 24
*    math.gamma(-0.5);    // returns -3.5449077018110335
*    math.gamma(math.i);  // returns -0.15494982830180973 - 0.49801566811835596i
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.gcd" id="apidoc.element.mathjs.expression.mathWithTransform.gcd">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>gcd
        <span class="apidocSignatureSpan">(arg0, arg1, arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function gcd(arg0, arg1, arg2) {
  "use strict";
  var name = 'gcd';
  if (test0(arg0)) { // type: number
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: number, number
      }
      if (test1(arg2) || test2(arg2) || test0(arg2) || test3(arg2)) { // type: ...Array|Matrix|number|BigNumber
        var varArgs = [arg2];
        for (var i = 3; i &lt; arguments.length; i++) {
          if (test1(arguments[i]) || test2(arguments[i]) || test0(arguments[i]) || test3(arguments[i])) {
            varArgs.push(arguments[i]);
          } else {
            throw createError(name, arguments.length, i, arguments[i], 'Array,Matrix,number,BigNumber');
          }
        }
        return signature1(arg0, arg1, varArgs); // signature: number, number, ...Array|Matrix|number|BigNumber
      }
      throw createError(name, arguments.length, 2, arguments[2], 'Array,Matrix,number,BigNumber');
    }
    if (test3(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature2(convert0(arg0), arg1); // signature: number, BigNumber
      }
      if (test1(arg2) || test2(arg2) || test0(arg2) || test3(arg2)) { // type: ...Array|Matrix|number|BigNumber
        var varArgs = [arg2];
        for (var i = 3; i &lt; arguments.length; i++) {
          if (test1(arguments[i]) || test2(arguments[i]) || test0(arguments[i]) || test3(arguments[i])) {
            varArgs.push(arguments[i]);
          } else {
            throw createError(name, arguments.length, i, arguments[i], 'Array,Matrix,number,BigNumber');
          }
        }
        return signature1(arg0, arg1, varArgs); // signature: number, BigNumber, ...Array|Matrix|number|BigNumber
      }
      throw createError(name, arguments.length, 2, arguments[2], 'Array,Matrix,number,BigNumber');
    }
    if (test4(arg1)) { // type: Fraction
      if (arguments.length === 2) {
        return signature3(convert1(arg0), arg1); // signature: number, Fraction
      }
      if (test1(arg2) || test2(arg2) || test0(arg2) || test3(arg2)) { // type: ...Array|Matrix|number|BigNumber
        var varArgs = [arg2];
        for (var i = 3; i &lt; arguments.length; i++) {
          if (test1(arguments[i]) || test2(arguments[i]) || test0(arguments[i]) || test3(arguments[i])) {
            varArgs.push(arguments[i]);
          } else {
            throw createError(name, arguments.length, i, arguments[i], 'Array,Matrix,number,BigNumber');
          }
        }
        return signature1(arg0, convert2(arg1), varArgs); // signature: number, Fraction, ...Array|Matrix|number|BigNumber
      }
      throw createError(name, arguments.length, 2, arguments[2], 'Array,Matrix,number,BigNumber');
    }
    if (test1(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature4(arg0, arg1); // signature: number, Array
      }
      if (test1(arg2) || test2(arg2) || test0(arg2) || test3(arg2)) { // type: ...Array|Matrix|number|BigNumber
        var varArgs = [arg2];
        for (var i = 3; i &lt; arguments.length; i++) {
          if (test1(arguments[i]) || test2(arguments[i]) || test0(arguments[i]) || test3(arguments[i])) {
            varArgs.push(arguments[i]);
          } else {
            throw createError(name, arguments.length, i, arguments[i], 'Array,Matrix,number,BigNumber');
          }
        }
        return signature1(arg0, arg1, varArgs); // signature: number, Array, ...Array|Matrix|number|BigNumber
      }
      throw createError(name, arguments.length, 2, arguments[2], 'Array,Matrix,number,BigNumber');
    }
    if (test2(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature5(arg0, arg1); // signature: number, Matrix
      }
      if (test1(arg2) || test2(arg2) || test0(arg2) || test3(arg2)) { // type: ...Array|Matrix|number|BigNumber
        var varArgs = [arg2];
        for (var i = 3; i &lt; arguments.length; i++) {
          if (test1(arguments[i]) || test2(arguments[i]) || test0(arguments[i]) || test3(arguments[i])) {
            varArgs.push(arguments[i]); ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Calculate the greatest common divisor for two or more values or arrays.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">gcd</span>(a, b)
*    math.gcd(a, b, c, ...)
*
* Examples:
*
*    math.gcd(8, 12);              // returns 4
*    math.gcd(-4, 6);              // returns 2
*    math.gcd(25, 15, -10);        // returns 5
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.help" id="apidoc.element.mathjs.expression.mathWithTransform.help">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>help
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function help(arg0) {
  "use strict";
  var name = 'help';
  // type: any
  if (arguments.length === 1) {
    return signature0(arg0); // signature: any
  }
  if (arguments.length &gt; 1) {
    throw createError(name, arguments.length, 1, arguments[1]);
  }
  throw createError(name, arguments.length, 0, arguments[0], 'any');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Object                 | `'Object'`    | `math.typeof ({a: 2, b: 3})`
* RegExp                 | `'RegExp'`    | `math.typeof (/a regexp/)`
* undefined              | `'undefined'` | `math.typeof(undefined)`
* math.type.BigNumber    | `'BigNumber'` | `math.typeof (math.bignumber('2.3e500'))`
* math.type.Chain        | `'Chain'`     | `math.typeof (math.chain(2))`
* math.type.Complex      | `'Complex'`   | `math.typeof (math.complex(2, 3))`
* math.type.Fraction     | `'Fraction'`  | `math.typeof (math.fraction(1, 3))`
* math.type.Help         | `'Help'`      | `math.typeof (math.<span class="apidocCodeKeywordSpan">help</span>('sqrt
'))`
* math.type.Index        | `'Index'`     | `math.typeof (math.index(1, 3))`
* math.type.Matrix       | `'Matrix'`    | `math.typeof (math.matrix([[1,2], [3, 4]]))`
* math.type.Range        | `'Range'`     | `math.typeof (math.range(0, 10))`
* math.type.Unit         | `'Unit'`      | `math.typeof (math.unit('45 deg'))`
*
* Syntax:
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.hypot" id="apidoc.element.mathjs.expression.mathWithTransform.hypot">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>hypot
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hypot(arg0) {
  "use strict";
  var name = 'hypot';
  if (test0(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature0(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0) || test3(arg0) || test4(arg0) || test5(arg0) || test5(arg0) || test6(arg0) || test6(arg0) || test7(arg0) || test7
(arg0)) { // type: ...number|BigNumber|Fraction|string|boolean|null
    var varArgs = [arg0];
    for (var i = 1; i &lt; arguments.length; i++) {
      if (test2(arguments[i]) || test3(arguments[i])) {
        varArgs.push(arguments[i]);
      }
      else if (test4(arguments[i])) {
        varArgs.push(convert0(arguments[i]));
      }
      else if (test5(arguments[i])) {
        varArgs.push(convert1(arguments[i]));
      }
      else if (test5(arguments[i])) {
        varArgs.push(convert2(arguments[i]));
      }
      else if (test6(arguments[i])) {
        varArgs.push(convert3(arguments[i]));
      }
      else if (test6(arguments[i])) {
        varArgs.push(convert4(arguments[i]));
      }
      else if (test7(arguments[i])) {
        varArgs.push(convert5(arguments[i]));
      }
      else if (test7(arguments[i])) {
        varArgs.push(convert6(arguments[i]));
      } else {
        throw createError(name, arguments.length, i, arguments[i], 'number,BigNumber');
      }
    }
    return signature2(varArgs); // signature: ...number|BigNumber|Fraction|string|boolean|null
  }
  throw createError(name, arguments.length, 0, arguments[0], 'Array,Matrix,number,BigNumber');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
*     hypot(a, b, c, ...) = sqrt(a^2 + b^2 + c^2 + ...)
*
* For matrix input, the hypotenusa is calculated for all values in the matrix.
*
* Syntax:
*
*     math.<span class="apidocCodeKeywordSpan">hypot</span>(a, b, ...)
*     math.hypot([a, b, c, ...])
*
* Examples:
*
*     math.hypot(3, 4);      // 5
*     math.hypot(3, 4, 5);   // 7.0710678118654755
*     math.hypot([3, 4, 5]); // 7.0710678118654755
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.im" id="apidoc.element.mathjs.expression.mathWithTransform.im">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>im
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function im(arg0) {
  "use strict";
  var name = 'im';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature2(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Get the imaginary part of a complex number.
* For a complex number `a + bi`, the function returns `b`.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">im</span>(x)
*
* Examples:
*
*    var a = math.complex(2, 3);
*    math.re(a);                     // returns number 2
*    math.im(a);                     // returns number 3
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.index" id="apidoc.element.mathjs.expression.mathWithTransform.index">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>index
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function indexTransform() {
  var args = [];
  for (var i = 0, ii = arguments.length; i &lt; ii; i++) {
    var arg = arguments[i];

    // change from one-based to zero based, and convert BigNumber to number
    if (arg &amp;&amp; arg.isRange === true) {
      arg.start--;
      arg.end -= (arg.step &gt; 0 ? 0 : 2);
    }
    else if (arg &amp;&amp; arg.isSet === true) {
      arg = arg.map(function (v) { return v - 1; });
    }
    else if (arg &amp;&amp; (arg.isArray === true || arg.isMatrix)) {
      arg = arg.map(function (v) { return v - 1; });
    }
    else if (typeof arg === 'number') {
      arg--;
    }
    else if (arg &amp;&amp; arg.isBigNumber === true) {
      arg = arg.toNumber() - 1;
    }
    else if (typeof arg === 'string') {
      // leave as is
    }
    else {
      throw new TypeError('Dimension must be an Array, Matrix, number, string, or Range');
    }

    args[i] = arg;
  }

  var res = new type.Index();
  type.Index.apply(res, args);
  return res;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
          '})()'
    }
    else { // ConstantNode
      return range._compile(defs, childArgs);
    }
  });

  return 'math.<span class="apidocCodeKeywordSpan">index</span>(' + dimensions.join(', ') + ')';
};

/**
 * Execute a callback for each of the child nodes of this node
 * @param {function(child: Node, path: string, parent: Node)} callback
 */
IndexNode.prototype.forEach = function (callback) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.intersect" id="apidoc.element.mathjs.expression.mathWithTransform.intersect">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>intersect
        <span class="apidocSignatureSpan">(arg0, arg1, arg2, arg3)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function intersect(arg0, arg1, arg2, arg3) {
  "use strict";
  var name = 'intersect';
  if (test0(arg0)) { // type: Array
    if (test0(arg1)) { // type: Array
      if (test0(arg2)) { // type: Array
        if (arguments.length === 3) {
          return signature0(arg0, arg1, arg2); // signature: Array, Array, Array
        }
        if (test0(arg3)) { // type: Array
          if (arguments.length === 4) {
            return signature1(arg0, arg1, arg2, arg3); // signature: Array, Array, Array, Array
          }
          if (arguments.length &gt; 4) {
            throw createError(name, arguments.length, 4, arguments[4]);
          }
        }
        if (test1(arg3)) { // type: Matrix (convert to Array)
          if (arguments.length === 4) {
            return signature1(arg0, arg1, arg2, convert0(arg3)); // signature: Array, Array, Array, Matrix
          }
          if (arguments.length &gt; 4) {
            throw createError(name, arguments.length, 4, arguments[4]);
          }
        }
        throw createError(name, arguments.length, 3, arguments[3], 'Array');
      }
      if (test1(arg2)) { // type: Matrix (convert to Array)
        if (arguments.length === 3) {
          return signature0(arg0, arg1, convert0(arg2)); // signature: Array, Array, Matrix
        }
        if (test0(arg3)) { // type: Array
          if (arguments.length === 4) {
            return signature1(arg0, arg1, convert0(arg2), arg3); // signature: Array, Array, Matrix, Array
          }
          if (arguments.length &gt; 4) {
            throw createError(name, arguments.length, 4, arguments[4]);
          }
        }
        if (test1(arg3)) { // type: Matrix (convert to Array)
          if (arguments.length === 4) {
            return signature1(arg0, arg1, convert0(arg2), convert0(arg3)); // signature: Array, Array, Matrix, Matrix
          }
          if (arguments.length &gt; 4) {
            throw createError(name, arguments.length, 4, arguments[4]);
          }
        }
        throw createError(name, arguments.length, 3, arguments[3], 'Array');
      }
      throw createError(name, arguments.length, 2, arguments[2], 'Array');
    }
    if (test1(arg1)) { // type: Matrix
      if (test0(arg2)) { // type: Array
        if (arguments.length === 3) {
          return signature0(arg0, convert0(arg1), arg2); // signature: Array, Matrix, Array
        }
        if (test0(arg3)) { // type: Array
          if (arguments.length === 4) {
            return signature1(arg0, convert0(arg1), arg2, arg3); // signature: Array, Matrix, Array, Array
          }
          if (arguments.length &gt; 4) {
            throw createError(name, arguments.length, 4, arguments[4]);
          }
        }
        if (test1(arg3)) { // type: Matrix (convert to Array)
          if (arguments.length === 4) {
            return signature1(arg0, convert0(arg1), arg2, convert0(arg3)); // signature: Array, Matrix, Array, Matrix
          }
          if (arguments.length &gt; 4) {
            throw createError(name, arguments.length, 4, arguments[4]);
          }
        }
        throw createError(name, arguments.length, 3, arguments[3], 'Array');
      }
      if (test1(arg2)) { // type: Matrix
        if (arguments.length === 3) {
          return signature2(convert1(arg0), arg1, arg2); // signature: Array, Matrix, Matrix
        }
        if (test0(arg3)) { // type: Array
          if (arguments.length === 4) {
            return signature1(arg0, convert0(arg1), convert0(arg2), arg3); // signature: Array, Matrix, Matrix, Array
          }
          if (arguments.length &gt; 4) {
            throw createError(name, arguments.length, 4, arguments[4]);
          }
        }
        if (test1(arg3)) { // type: Matrix
          if (arguments.length === 4) {
            return signature3(convert1(arg0), arg1, arg2, arg3); // signature: Array, Matrix, Matrix, Matrix
          }
          if (arguments.length &gt; 4) {
            throw createError(name, arguments.length, 4, arguments[4]);
          }
        }
        throw createError(name, arguments.length, 3, arguments[3], 'Array,Matrix ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* arrays or 1 dimensional matrices. The line intersection functions return null
* if the lines do not meet.
*
* Note: Fill the plane coefficients as `x + y + z = c` and not as `x + y + z + c = 0`.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">intersect</span>(endPoint1Line1, endPoint2Line1, endPoint1Line2, endPoint2Line2)
*    math.intersect(endPoint1, endPoint2, planeCoefficients)
*
* Examples:
*
*    math.intersect([0, 0], [10, 10], [10, 0], [0, 10]);              // Returns [5, 5]
*    math.intersect([0, 0, 0], [10, 10, 0], [10, 0, 0], [0, 10, 0]);  // Returns [5, 5, 0]
*    math.intersect([1, 0, 1],  [4, -2, 2], [1, 1, 1, 6]);            // Returns [7, -4, 3]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.inv" id="apidoc.element.mathjs.expression.mathWithTransform.inv">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>inv
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function inv(arg0) {
  "use strict";
  var name = 'inv';
  if (test0(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature0(arg0); // signature: Array
    }
  }
  if (test1(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature0(arg0); // signature: Matrix
    }
  }
  // type: any
  if (arguments.length === 1) {
    return signature1(arg0); // signature: any
  }
  if (arguments.length &gt; 1) {
    throw createError(name, arguments.length, 1, arguments[1]);
  }
  throw createError(name, arguments.length, 0, arguments[0], 'Array,Matrix,any');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var eye          = load(require('./eye'));

/**
 * Calculate the inverse of a square matrix.
 *
 * Syntax:
 *
 *     math.<span class="apidocCodeKeywordSpan">inv</span>(x)
 *
 * Examples:
 *
 *     math.inv([[1, 2], [3, 4]]);  // returns [[-2, 1], [1.5, -0.5]]
 *     math.inv(4);                 // returns 0.25
 *     1 / 4;                       // returns 0.25
 *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.isInteger" id="apidoc.element.mathjs.expression.mathWithTransform.isInteger">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>isInteger
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isInteger(arg0) {
  "use strict";
  var name = 'isInteger';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature1(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: Fraction
    if (arguments.length === 1) {
      return signature2(arg0); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert0(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,BigNumber,Fraction,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * Test whether index is an integer number with index &gt;= 0 and index &lt; length
 * when length is provided
 * @param {number} index    Zero-based index
 * @param {number} [length] Length of the array
 */
exports.validateIndex = function(index, length) {
  if (!number.isNumber(index) || !number.<span class="apidocCodeKeywordSpan">isInteger</span>(index)) {
    throw new TypeError('Index must be an integer (value: ' + index + ')');
  }
  if (index &lt; 0 || (typeof length === 'number' &amp;&amp; index &gt;= length)) {
    throw new IndexError(index, length);
  }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.isNaN" id="apidoc.element.mathjs.expression.mathWithTransform.isNaN">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>isNaN
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isNaN(arg0) {
  "use strict";
  var name = 'isNaN';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Fraction
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Unit
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Unit
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature5(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature5(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert0(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test9(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Fraction,Unit,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
},

'Complex, Complex': function (x, y) {
  return (x.re !== 0 || x.im !== 0) &amp;&amp; (y.re !== 0 || y.im !== 0);
},

'BigNumber, BigNumber': function (x, y) {
  return !x.isZero() &amp;&amp; !y.isZero() &amp;&amp; !x.<span class="apidocCodeKeywordSpan">isNaN</span>() &amp;&amp; !y
.isNaN();
},

'Unit, Unit': function (x, y) {
  return and(x.value, y.value);
},

'Matrix, Matrix': function (x, y) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.isNegative" id="apidoc.element.mathjs.expression.mathWithTransform.isNegative">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>isNegative
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isNegative(arg0) {
  "use strict";
  var name = 'isNegative';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature1(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: Fraction
    if (arguments.length === 1) {
      return signature2(arg0); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Unit
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Unit
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert0(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,BigNumber,Fraction,Unit,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return new type.Complex(
      (x.re &gt; 0) ? Math.floor(x.re) : Math.ceil(x.re),
      (x.im &gt; 0) ? Math.floor(x.im) : Math.ceil(x.im)
  );
},

'BigNumber': function (x) {
  return x.<span class="apidocCodeKeywordSpan">isNegative</span>() ? x.ceil() : x.floor();
},

'Fraction': function (x) {
  return x.s &lt; 0 ? x.ceil() : x.floor();
},

'Array | Matrix': function (x) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.isNumeric" id="apidoc.element.mathjs.expression.mathWithTransform.isNumeric">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>isNumeric
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isNumeric(arg0) {
  "use strict";
  var name = 'isNumeric';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature0(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Fraction
    if (arguments.length === 1) {
      return signature0(arg0); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Unit
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Unit
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: string
    if (arguments.length === 1) {
      return signature1(arg0); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature2(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature2(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: boolean
    if (arguments.length === 1) {
      return signature0(arg0); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test9(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert0(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Fraction,Unit,string,Array,Matrix,boolean
');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Test whether a value is an numeric value.
*
* The function is evaluated element-wise in case of Array or Matrix input.
*
* Syntax:
*
*     math.<span class="apidocCodeKeywordSpan">isNumeric</span>(x)
*
* Examples:
*
*    math.isNumeric(2);                     // returns true
*    math.isNumeric(0);                     // returns true
*    math.isNumeric(math.bignumber(500));   // returns true
*    math.isNumeric(math.fraction(4));      // returns true
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.isPositive" id="apidoc.element.mathjs.expression.mathWithTransform.isPositive">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>isPositive
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isPositive(arg0) {
  "use strict";
  var name = 'isPositive';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature1(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: Fraction
    if (arguments.length === 1) {
      return signature2(arg0); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Unit
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Unit
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert0(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,BigNumber,Fraction,Unit,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Test whether a value is positive: larger than zero.
* The function supports types `number`, `BigNumber`, `Fraction`, and `Unit`.
*
* The function is evaluated element-wise in case of Array or Matrix input.
*
* Syntax:
*
*     math.<span class="apidocCodeKeywordSpan">isPositive</span>(x)
*
* Examples:
*
*    math.isPositive(3);                     // returns true
*    math.isPositive(-2);                    // returns false
*    math.isPositive(0);                     // returns false
*    math.isPositive(-0);                    // returns false
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.isPrime" id="apidoc.element.mathjs.expression.mathWithTransform.isPrime">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>isPrime
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isPrime(arg0) {
  "use strict";
  var name = 'isPrime';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature1(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature2(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature2(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature1(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,BigNumber,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Test whether a value is prime: has no divisors other than itself and one.
* The function supports type `number`, `bignumber`.
*
* The function is evaluated element-wise in case of Array or Matrix input.
*
* Syntax:
*
*     math.<span class="apidocCodeKeywordSpan">isPrime</span>(x)
*
* Examples:
*
*    math.isPrime(3);                     // returns true
*    math.isPrime(-2);                    // returns false
*    math.isPrime(0);                     // returns false
*    math.isPrime(-0);                    // returns false
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.isZero" id="apidoc.element.mathjs.expression.mathWithTransform.isZero">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>isZero
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isZero(arg0) {
  "use strict";
  var name = 'isZero';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Fraction
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Unit
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Unit
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature5(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature5(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert0(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test9(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Fraction,Unit,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
},

'number': function (x) {
  return !!x;
},

'BigNumber': function (x) {
  return !x.<span class="apidocCodeKeywordSpan">isZero</span>();
},

'string': function (x) {
  // try case insensitive
  var lcase = x.toLowerCase();
  if (lcase === 'true') {
    return true;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.kldivergence" id="apidoc.element.mathjs.expression.mathWithTransform.kldivergence">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>kldivergence
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function kldivergence(arg0, arg1) {
  "use strict";
  var name = 'kldivergence';
  if (test0(arg0)) { // type: Array
    if (test0(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: Array, Array
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Array, Matrix
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Array,Matrix');
  }
  if (test1(arg0)) { // type: Matrix
    if (test0(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: Matrix, Array
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature3(arg0, arg1); // signature: Matrix, Matrix
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Array,Matrix');
  }
  throw createError(name, arguments.length, 0, arguments[0], 'Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var isNumeric = load(require('../utils/isNumeric'));

/**
 * Calculate the Kullback-Leibler (KL) divergence  between two distributions
 *
 * Syntax:
 *
 *     math.<span class="apidocCodeKeywordSpan">kldivergence</span>(x, y)
 *
 * Examples:
 *
 *     math.kldivergence([0.7,0.5,0.4], [0.2,0.9,0.5]);   //returns 0.24376698773121153
 *
 *
 * @param  {Array | Matrix} q    First vector
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.kron" id="apidoc.element.mathjs.expression.mathWithTransform.kron">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>kron
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function kron(arg0, arg1) {
  "use strict";
  var name = 'kron';
  if (test0(arg0)) { // type: Array
    if (test0(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: Array, Array
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Array, Matrix
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Array,Matrix');
  }
  if (test1(arg0)) { // type: Matrix
    if (test0(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: Matrix, Array
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature3(arg0, arg1); // signature: Matrix, Matrix
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Array,Matrix');
  }
  throw createError(name, arguments.length, 0, arguments[0], 'Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* NOTE: If a one dimensional vector / matrix is given, it will be
* wrapped so its two dimensions.
* See the examples.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">kron</span>(x, y)
*
* Examples:
*
*    math.kron([[1, 0], [0, 1]], [[1, 2], [3, 4]]);
*    // returns [ [ 1, 2, 0, 0 ], [ 3, 4, 0, 0 ], [ 0, 0, 1, 2 ], [ 0, 0, 3, 4 ] ]
*
*    math.kron([1,1], [2,3,4]);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.larger" id="apidoc.element.mathjs.expression.mathWithTransform.larger">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>larger
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function larger(arg0, arg1) {
  "use strict";
  var name = 'larger';
  if (test0(arg0)) { // type: number
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: number, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: Complex
      if (arguments.length === 2) {
        return signature1(convert0(arg0), arg1); // signature: number, Complex
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature2(convert1(arg0), arg1); // signature: number, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: Fraction
      if (arguments.length === 2) {
        return signature3(convert2(arg0), arg1); // signature: number, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert3(arg1)); // signature: number, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert4(arg1)); // signature: number, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test6(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert5(arg1)); // signature: number, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
  }
  if (test1(arg0)) { // type: Complex
    if (test1(arg1)) { // type: Complex
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Complex, Complex
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test0(arg1)) { // type: number (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: Complex, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: BigNumber (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert6(arg1)); // signature: Complex, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: Fraction (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert7(arg1)); // signature: Complex, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: string (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert8(arg1)); // signature: Complex, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (test1(arg1)) { // type: Complex
      if (arguments.length === 2) {
        return signature1(convert6(arg0), arg1); // signature: BigNumber, Complex
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: BigNumber, BigNu ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* Syntax:
*
*    math.largerEq(x, y)
*
* Examples:
*
*    math.<span class="apidocCodeKeywordSpan">larger</span>(2, 1 + 1);         // returns false
*    math.largerEq(2, 1 + 1);       // returns true
*
* See also:
*
*    equal, unequal, smaller, smallerEq, larger, compare
*
* @param  {number | BigNumber | Fraction | boolean | Unit | string | Array | Matrix} x First value to compare
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.largerEq" id="apidoc.element.mathjs.expression.mathWithTransform.largerEq">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>largerEq
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function largerEq(arg0, arg1) {
  "use strict";
  var name = 'largerEq';
  if (test0(arg0)) { // type: number
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: number, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: Complex
      if (arguments.length === 2) {
        return signature1(convert0(arg0), arg1); // signature: number, Complex
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature2(convert1(arg0), arg1); // signature: number, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: Fraction
      if (arguments.length === 2) {
        return signature3(convert2(arg0), arg1); // signature: number, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert3(arg1)); // signature: number, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert4(arg1)); // signature: number, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test6(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert5(arg1)); // signature: number, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
  }
  if (test1(arg0)) { // type: Complex
    if (test1(arg1)) { // type: Complex
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Complex, Complex
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test0(arg1)) { // type: number (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: Complex, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: BigNumber (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert6(arg1)); // signature: Complex, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: Fraction (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert7(arg1)); // signature: Complex, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: string (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert8(arg1)); // signature: Complex, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (test1(arg1)) { // type: Complex
      if (arguments.length === 2) {
        return signature1(convert6(arg0), arg1); // signature: BigNumber, Complex
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: BigNumber, B ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* difference between x and y is smaller than the configured epsilon. The
* function cannot be used to compare values smaller than approximately 2.22e-16.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">largerEq</span>(x, y)
*
* Examples:
*
*    math.larger(2, 1 + 1);         // returns false
*    math.largerEq(2, 1 + 1);       // returns true
*
* See also:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.lcm" id="apidoc.element.mathjs.expression.mathWithTransform.lcm">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>lcm
        <span class="apidocSignatureSpan">(arg0, arg1, arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function lcm(arg0, arg1, arg2) {
  "use strict";
  var name = 'lcm';
  if (test0(arg0)) { // type: number
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: number, number
      }
      if (test1(arg2) || test2(arg2) || test0(arg2) || test3(arg2)) { // type: ...Array|Matrix|number|BigNumber
        var varArgs = [arg2];
        for (var i = 3; i &lt; arguments.length; i++) {
          if (test1(arguments[i]) || test2(arguments[i]) || test0(arguments[i]) || test3(arguments[i])) {
            varArgs.push(arguments[i]);
          } else {
            throw createError(name, arguments.length, i, arguments[i], 'Array,Matrix,number,BigNumber');
          }
        }
        return signature1(arg0, arg1, varArgs); // signature: number, number, ...Array|Matrix|number|BigNumber
      }
      throw createError(name, arguments.length, 2, arguments[2], 'Array,Matrix,number,BigNumber');
    }
    if (test3(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature2(convert0(arg0), arg1); // signature: number, BigNumber
      }
      if (test1(arg2) || test2(arg2) || test0(arg2) || test3(arg2)) { // type: ...Array|Matrix|number|BigNumber
        var varArgs = [arg2];
        for (var i = 3; i &lt; arguments.length; i++) {
          if (test1(arguments[i]) || test2(arguments[i]) || test0(arguments[i]) || test3(arguments[i])) {
            varArgs.push(arguments[i]);
          } else {
            throw createError(name, arguments.length, i, arguments[i], 'Array,Matrix,number,BigNumber');
          }
        }
        return signature1(arg0, arg1, varArgs); // signature: number, BigNumber, ...Array|Matrix|number|BigNumber
      }
      throw createError(name, arguments.length, 2, arguments[2], 'Array,Matrix,number,BigNumber');
    }
    if (test4(arg1)) { // type: Fraction
      if (arguments.length === 2) {
        return signature3(convert1(arg0), arg1); // signature: number, Fraction
      }
      if (test1(arg2) || test2(arg2) || test0(arg2) || test3(arg2)) { // type: ...Array|Matrix|number|BigNumber
        var varArgs = [arg2];
        for (var i = 3; i &lt; arguments.length; i++) {
          if (test1(arguments[i]) || test2(arguments[i]) || test0(arguments[i]) || test3(arguments[i])) {
            varArgs.push(arguments[i]);
          } else {
            throw createError(name, arguments.length, i, arguments[i], 'Array,Matrix,number,BigNumber');
          }
        }
        return signature1(arg0, convert2(arg1), varArgs); // signature: number, Fraction, ...Array|Matrix|number|BigNumber
      }
      throw createError(name, arguments.length, 2, arguments[2], 'Array,Matrix,number,BigNumber');
    }
    if (test1(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature4(arg0, arg1); // signature: number, Array
      }
      if (test1(arg2) || test2(arg2) || test0(arg2) || test3(arg2)) { // type: ...Array|Matrix|number|BigNumber
        var varArgs = [arg2];
        for (var i = 3; i &lt; arguments.length; i++) {
          if (test1(arguments[i]) || test2(arguments[i]) || test0(arguments[i]) || test3(arguments[i])) {
            varArgs.push(arguments[i]);
          } else {
            throw createError(name, arguments.length, i, arguments[i], 'Array,Matrix,number,BigNumber');
          }
        }
        return signature1(arg0, arg1, varArgs); // signature: number, Array, ...Array|Matrix|number|BigNumber
      }
      throw createError(name, arguments.length, 2, arguments[2], 'Array,Matrix,number,BigNumber');
    }
    if (test2(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature5(arg0, arg1); // signature: number, Matrix
      }
      if (test1(arg2) || test2(arg2) || test0(arg2) || test3(arg2)) { // type: ...Array|Matrix|number|BigNumber
        var varArgs = [arg2];
        for (var i = 3; i &lt; arguments.length; i++) {
          if (test1(arguments[i]) || test2(arguments[i]) || test0(arguments[i]) || test3(arguments[i])) {
            varArgs.push(arguments[i]); ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
*     lcm(a, b) = abs(a * b) / gcd(a, b)
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">lcm</span>(a, b)
*    math.lcm(a, b, c, ...)
*
* Examples:
*
*    math.lcm(4, 6);               // returns 12
*    math.lcm(6, 21);              // returns 42
*    math.lcm(6, 21, 5);           // returns 210
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.leftShift" id="apidoc.element.mathjs.expression.mathWithTransform.leftShift">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>leftShift
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function leftShift(arg0, arg1) {
  "use strict";
  var name = 'leftShift';
  if (test0(arg0)) { // type: number
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: number, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature1(convert0(arg0), arg1); // signature: number, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: number, Array
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature3(arg0, arg1); // signature: number, Matrix
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(convert0(arg0), convert1(arg1)); // signature: number, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert2(arg1)); // signature: number, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test6(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert3(arg1)); // signature: number, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test7(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert4(arg1)); // signature: number, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'number,BigNumber,Array,Matrix');
  }
  if (test1(arg0)) { // type: BigNumber
    if (test1(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: BigNumber, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: BigNumber, Array
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature3(arg0, arg1); // signature: BigNumber, Matrix
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test0(arg1)) { // type: number (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: BigNumber, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert1(arg1)); // signature: BigNumber, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: string (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, conv ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Bitwise left logical shift of a value x by y number of bits, `x &lt;&lt; y`.
* For matrices, the function is evaluated element wise.
* For units, the function is evaluated on the best prefix base.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">leftShift</span>(x, y)
*
* Examples:
*
*    math.leftShift(1, 2);               // returns number 4
*
*    math.leftShift([1, 2, 3], 4);       // returns Array [16, 32, 64]
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.log" id="apidoc.element.mathjs.expression.mathWithTransform.log">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>log
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function log(arg0, arg1) {
  "use strict";
  var name = 'log';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
  }
  if (test3(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Array
    }
  }
  if (test4(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Matrix
    }
  }
  if (test5(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature2(convert0(arg0)); // signature: Fraction
    }
  }
  if (test6(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: string
    }
  }
  if (test7(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
  }
  if (test8(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
  }
  // type: any
  // type: any
  if (arguments.length === 2) {
    return signature4(arg0, arg1); // signature: any, any
  }
  if (arguments.length &gt; 2) {
    throw createError(name, arguments.length, 2, arguments[2]);
  }
  throw createError(name, arguments.length, 1, arguments[1], 'any');
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Array,Matrix,any');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
// load math.js
var math = require('mathjs');

// functions and constants
math.round(math.e, 3);            // 2.718
math.atan2(3, -3) / math.pi;      // 0.75
math.<span class="apidocCodeKeywordSpan">log</span>(1000, 10);               // 3
math.sqrt(-4);                    // 2i
math.pow([[-1, 2], [3, 1]], 2);   // [[7, 0], [0, 7]]
math.derivative('x^2 + x', 'x');  // 2 * x + 1

// expressions
math.eval('12 / (2.3 + 0.7)');    // 4
math.eval('5.08 cm to inch');     // 2 inch
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.log10" id="apidoc.element.mathjs.expression.mathWithTransform.log10">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>log10
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function log10(arg0) {
  "use strict";
  var name = 'log10';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature2(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Calculate the 10-base logarithm of a value. This is the same as calculating `log(x, 10)`.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">log10</span>(x)
*
* Examples:
*
*    math.log10(0.00001);            // returns -5
*    math.log10(10000);              // returns 4
*    math.log(10000) / math.log(10); // returns 4
*    math.pow(10, 4);                // returns 10000
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.lsolve" id="apidoc.element.mathjs.expression.mathWithTransform.lsolve">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>lsolve
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function lsolve(arg0, arg1) {
  "use strict";
  var name = 'lsolve';
  if (test0(arg0)) { // type: Array
    if (test0(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: Array, Array
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: Array, Matrix
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Array,Matrix');
  }
  if (test2(arg0)) { // type: DenseMatrix
    if (test0(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: DenseMatrix, Array
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: DenseMatrix, Matrix
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Array,Matrix');
  }
  if (test3(arg0)) { // type: SparseMatrix
    if (test0(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: SparseMatrix, Array
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: SparseMatrix, Matrix
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Array,Matrix');
  }
  if (test1(arg0)) { // type: Matrix (convert to Array)
    if (test0(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature0(convert0(arg0), arg1); // signature: Matrix, Array
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature0(convert0(arg0), arg1); // signature: Matrix, Matrix
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Array,Matrix');
  }
  throw createError(name, arguments.length, 0, arguments[0], 'Array,DenseMatrix,SparseMatrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.lup" id="apidoc.element.mathjs.expression.mathWithTransform.lup">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>lup
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function lup(arg0) {
  "use strict";
  var name = 'lup';
  if (test0(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature0(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: DenseMatrix
    if (arguments.length === 1) {
      return signature1(arg0); // signature: DenseMatrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: SparseMatrix
    if (arguments.length === 1) {
      return signature2(arg0); // signature: SparseMatrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Matrix (convert to Array)
    if (arguments.length === 1) {
      return signature0(convert0(arg0)); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'Array,DenseMatrix,SparseMatrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.lusolve" id="apidoc.element.mathjs.expression.mathWithTransform.lusolve">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>lusolve
        <span class="apidocSignatureSpan">(arg0, arg1, arg2, arg3)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function lusolve(arg0, arg1, arg2, arg3) {
  "use strict";
  var name = 'lusolve';
  if (test0(arg0)) { // type: Array
    if (test0(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: Array, Array
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: Array, Matrix
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Array,Matrix');
  }
  if (test2(arg0)) { // type: DenseMatrix
    if (test0(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: DenseMatrix, Array
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: DenseMatrix, Matrix
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Array,Matrix');
  }
  if (test3(arg0)) { // type: SparseMatrix
    if (test0(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: SparseMatrix, Array
      }
      if (test4(arg2)) { // type: number
        if (test4(arg3)) { // type: number
          if (arguments.length === 4) {
            return signature3(arg0, arg1, arg2, arg3); // signature: SparseMatrix, Array, number, number
          }
          if (arguments.length &gt; 4) {
            throw createError(name, arguments.length, 4, arguments[4]);
          }
        }
        if (test5(arg3)) { // type: string (convert to number)
          if (arguments.length === 4) {
            return signature3(arg0, arg1, arg2, convert0(arg3)); // signature: SparseMatrix, Array, number, string
          }
          if (arguments.length &gt; 4) {
            throw createError(name, arguments.length, 4, arguments[4]);
          }
        }
        if (test6(arg3)) { // type: boolean (convert to number)
          if (arguments.length === 4) {
            return signature3(arg0, arg1, arg2, convert1(arg3)); // signature: SparseMatrix, Array, number, boolean
          }
          if (arguments.length &gt; 4) {
            throw createError(name, arguments.length, 4, arguments[4]);
          }
        }
        if (test7(arg3)) { // type: null (convert to number)
          if (arguments.length === 4) {
            return signature3(arg0, arg1, arg2, convert2(arg3)); // signature: SparseMatrix, Array, number, null
          }
          if (arguments.length &gt; 4) {
            throw createError(name, arguments.length, 4, arguments[4]);
          }
        }
        throw createError(name, arguments.length, 3, arguments[3], 'number');
      }
      if (test5(arg2)) { // type: string (convert to number)
        if (test4(arg3)) { // type: number
          if (arguments.length === 4) {
            return signature3(arg0, arg1, convert0(arg2), arg3); // signature: SparseMatrix, Array, string, number
          }
          if (arguments.length &gt; 4) {
            throw createError(name, arguments.length, 4, arguments[4]);
          }
        }
        if (test5(arg3)) { // type: string (convert to number)
          if (arguments.length === 4) {
            return signature3(arg0, arg1, convert0(arg2), convert0(arg3)); // signature: SparseMatrix, Array, string, string
          }
          if (arguments.length &gt; 4) {
            throw createError(name, arguments.length, 4, arguments[4]);
          }
        }
        if (test6(arg3)) { // type: boolean (convert to number)
          if (arguments.length === 4) {
            return signature3(arg0, arg1, convert0(arg2), convert1(arg3)); ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.mad" id="apidoc.element.mathjs.expression.mathWithTransform.mad">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>mad
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mad(arg0) {
  "use strict";
  var name = 'mad';
  if (test0(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature0(arg0); // signature: Array
    }
  }
  if (test1(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature0(arg0); // signature: Matrix
    }
  }
  if (arguments.length &gt; 0) {
    var varArgs = [];
    for (var i = 0; i &lt; arguments.length; i++) {
      varArgs.push(arguments[i]);
    }
    return signature1(varArgs); // signature: ...any
  }
  throw createError(name, arguments.length, 0, arguments[0], 'Array,Matrix,any');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Compute the median absolute deviation of a matrix or a list with values.
* The median absolute deviation is defined as the median of the absolute
* deviations from the median.
*
* Syntax:
*
*     math.<span class="apidocCodeKeywordSpan">mad</span>(a, b, c, ...)
*     math.mad(A)
*
* Examples:
*
*     math.mad(10, 20, 30);             // returns 10
*     math.mad([1, 2, 3]);              // returns 1
*     math.mad([[1, 2, 3], [4, 5, 6]]); // returns 1.5
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.map" id="apidoc.element.mathjs.expression.mathWithTransform.map">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>map
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function max(arg0, arg1) {
  "use strict";
  var name = 'max';
  if (test0(arg0)) { // type: Array
    if (test1(arg1)) { // type: function
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: Array, function
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'function');
  }
  if (test2(arg0)) { // type: Matrix
    if (test1(arg1)) { // type: function
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Matrix, function
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'function');
  }
  throw createError(name, arguments.length, 0, arguments[0], 'Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (res &amp;&amp; res.isResultSet) {
  // we can have 0 or 1 results in the ResultSet, as the CLI
  // does not allow multiple expressions separated by a return
  res = res.entries[0];
  node = node.blocks
      .filter(function (entry) { return entry.visible; })
      .<span class="apidocCodeKeywordSpan">map</span>(function (entry) { return entry.node })[0];
}

if (node) {
  if (node.isAssignmentNode) {
    var name = findSymbolName(node);
    if (name != null) {
      scope.ans = scope[name];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.matrix" id="apidoc.element.mathjs.expression.mathWithTransform.matrix">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>matrix
        <span class="apidocSignatureSpan">(arg0, arg1, arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function matrix(arg0, arg1, arg2) {
  "use strict";
  var name = 'matrix';
  if (arguments.length === 0) {
    return signature0(); // signature:
  }
  if (test0(arg0)) { // type: string
    if (arguments.length === 1) {
      return signature1(arg0); // signature: string
    }
    if (test0(arg1)) { // type: string
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: string, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: number (convert to string)
      if (arguments.length === 2) {
        return signature2(arg0, convert0(arg1)); // signature: string, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: boolean (convert to string)
      if (arguments.length === 2) {
        return signature2(arg0, convert1(arg1)); // signature: string, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: null (convert to string)
      if (arguments.length === 2) {
        return signature2(arg0, convert2(arg1)); // signature: string, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'string');
  }
  if (test4(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Array
    }
    if (test0(arg1)) { // type: string
      if (arguments.length === 2) {
        return signature4(arg0, arg1); // signature: Array, string
      }
      if (test0(arg2)) { // type: string
        if (arguments.length === 3) {
          return signature4(arg0, arg1, arg2); // signature: Array, string, string
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test1(arg2)) { // type: number (convert to string)
        if (arguments.length === 3) {
          return signature4(arg0, arg1, convert0(arg2)); // signature: Array, string, number
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test2(arg2)) { // type: boolean (convert to string)
        if (arguments.length === 3) {
          return signature4(arg0, arg1, convert1(arg2)); // signature: Array, string, boolean
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test3(arg2)) { // type: null (convert to string)
        if (arguments.length === 3) {
          return signature4(arg0, arg1, convert2(arg2)); // signature: Array, string, null
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      throw createError(name, arguments.length, 2, arguments[2], 'string');
    }
    if (test1(arg1)) { // type: number (convert to string)
      if (arguments.length === 2) {
        return signature4(arg0, convert0(arg1)); // signature: Array, number
      }
      if (test0(arg2)) { // type: string
        if (arguments.length === 3) {
          return signature4(arg0, convert0(arg1), arg2); // signature: Array, number, string
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test1(arg2)) { // type: number (convert to string)
        if (arguments.length === 3) {
          return signature4(arg0, convert0(arg1), convert0(arg2)); // signature: Array, number, number
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test2(arg2)) { // type: boolean (convert to string)
        if (arguments.length === 3) {
          return signature4(a ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
ArrayNode.prototype._compile = function (defs, args) {
  var asMatrix = (defs.math.config().matrix !== 'Array');

  var items = this.items.map(function (node) {
    return node._compile(defs, args);
  });

  return (asMatrix ? 'math.<span class="apidocCodeKeywordSpan">matrix</span>([' : '[') +
      items.join(',') +
      (asMatrix ? '])' : ']');
};

/**
 * Execute a callback for each of the child nodes of this node
 * @param {function(child: Node, path: string, parent: Node)} callback
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.max" id="apidoc.element.mathjs.expression.mathWithTransform.max">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>max
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function max(arg0) {
  "use strict";
  var name = 'max';
  if (arguments.length &gt; 0) {
    var varArgs = [];
    for (var i = 0; i &lt; arguments.length; i++) {
      varArgs.push(arguments[i]);
    }
    return signature0(varArgs); // signature: ...any
  }
  throw createError(name, arguments.length, 0, arguments[0], 'any');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @return {number} Returns the maximum number of expected arguments.
 *                  Returns -1 when no signatures where found on the function.
 */
exports.maxArgumentCount = function (fn) {
  return Object.keys(fn.signatures || {})
      .reduce(function (args, signature) {
        var count = (signature.match(/,/g) || []).length + 1;
        return Math.<span class="apidocCodeKeywordSpan">max</span>(args, count);
      }, -1);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.mean" id="apidoc.element.mathjs.expression.mathWithTransform.mean">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>mean
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mean(arg0) {
  "use strict";
  var name = 'mean';
  if (arguments.length &gt; 0) {
    var varArgs = [];
    for (var i = 0; i &lt; arguments.length; i++) {
      varArgs.push(arguments[i]);
    }
    return signature0(varArgs); // signature: ...any
  }
  throw createError(name, arguments.length, 0, arguments[0], 'any');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Compute the mean value of matrix or a list with values.
* In case of a multi dimensional array, the mean of the flattened array
* will be calculated. When `dim` is provided, the maximum over the selected
* dimension will be calculated. Parameter `dim` is zero-based.
*
* Syntax:
*
*     math.<span class="apidocCodeKeywordSpan">mean</span>(a, b, c, ...)
*     math.mean(A)
*     math.mean(A, dim)
*
* Examples:
*
*     math.mean(2, 1, 4, 3);                     // returns 2.5
*     math.mean([1, 2.7, 3.2, 4]);               // returns 2.725
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.median" id="apidoc.element.mathjs.expression.mathWithTransform.median">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>median
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function median(arg0, arg1) {
  "use strict";
  var name = 'median';
  if (test0(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature0(arg0); // signature: Array
    }
    if (test1(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Array, number
      }
    }
    if (test2(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Array, BigNumber
      }
    }
    if (test3(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: Array, Fraction
      }
    }
    if (test4(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert1(arg1)); // signature: Array, string
      }
    }
    if (test5(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert2(arg1)); // signature: Array, boolean
      }
    }
    if (test6(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert3(arg1)); // signature: Array, null
      }
    }
  }
  if (test7(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature0(arg0); // signature: Matrix
    }
    if (test1(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Matrix, number
      }
    }
    if (test2(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Matrix, BigNumber
      }
    }
    if (test3(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: Matrix, Fraction
      }
    }
    if (test4(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert1(arg1)); // signature: Matrix, string
      }
    }
    if (test5(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert2(arg1)); // signature: Matrix, boolean
      }
    }
    if (test6(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert3(arg1)); // signature: Matrix, null
      }
    }
  }
  if (arguments.length &gt; 0) {
    var varArgs = [];
    for (var i = 0; i &lt; arguments.length; i++) {
      varArgs.push(arguments[i]);
    }
    return signature2(varArgs); // signature: ...any
  }
  throw createError(name, arguments.length, 0, arguments[0], 'Array,Matrix,any');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Supported types of values are: Number, BigNumber, Unit
*
* In case of a (multi dimensional) array or matrix, the median of all
* elements will be calculated.
*
* Syntax:
*
*     math.<span class="apidocCodeKeywordSpan">median</span>(a, b, c, ...)
*     math.median(A)
*
* Examples:
*
*     math.median(5, 2, 7);        // returns 5
*     math.median([3, -1, 5, 7]);  // returns 4
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.min" id="apidoc.element.mathjs.expression.mathWithTransform.min">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>min
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function min(arg0) {
  "use strict";
  var name = 'min';
  if (arguments.length &gt; 0) {
    var varArgs = [];
    for (var i = 0; i &lt; arguments.length; i++) {
      varArgs.push(arguments[i]);
    }
    return signature0(varArgs); // signature: ...any
  }
  throw createError(name, arguments.length, 0, arguments[0], 'any');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @private
 */
function _resize (array, size, dim, defaultValue) {
var i;
var elem;
var oldLen = array.length;
var newLen = size[dim];
var minLen = Math.<span class="apidocCodeKeywordSpan">min</span>(oldLen, newLen);

// apply new length
array.length = newLen;

if (dim &lt; size.length - 1) {
  // non-last dimension
  var dimNext = dim + 1;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.mod" id="apidoc.element.mathjs.expression.mathWithTransform.mod">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>mod
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mod(arg0, arg1) {
  "use strict";
  var name = 'mod';
  if (test0(arg0)) { // type: number
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: number, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature1(convert0(arg0), arg1); // signature: number, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: Fraction
      if (arguments.length === 2) {
        return signature2(convert1(arg0), arg1); // signature: number, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert2(arg1)); // signature: number, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert3(arg1)); // signature: number, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert4(arg1)); // signature: number, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
  }
  if (test1(arg0)) { // type: BigNumber
    if (test1(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: BigNumber, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test0(arg1)) { // type: number (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: BigNumber, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert5(arg1)); // signature: BigNumber, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: string (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert6(arg1)); // signature: BigNumber, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: boolean (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert7(arg1)); // signature: BigNumber, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: null (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert8(arg1)); // signature: BigNumber, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
  }
  if (test2(arg0)) { // type: Fraction
    if (test1(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature1(convert5(arg0), arg1); // signature: Fraction, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: Fraction
      if (arguments.length === 2) {
        return signature2(arg0, ar ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (!a.isInt() || !b.isInt()) {
      throw new Error('Parameters in function gcd must be integer numbers');
    }

    // http://en.wikipedia.org/wiki/Euclidean_algorithm
    var zero = new type.BigNumber(0);
    while (!b.isZero()) {
      var r = a.<span class="apidocCodeKeywordSpan">mod</span>(b);
      a = b;
      b = r;
    }
    return a.lt(zero) ? a.neg() : a;
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.mode" id="apidoc.element.mathjs.expression.mathWithTransform.mode">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>mode
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mode(arg0) {
  "use strict";
  var name = 'mode';
  if (test0(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature0(arg0); // signature: Array
    }
  }
  if (test1(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature0(arg0); // signature: Matrix
    }
  }
  if (arguments.length &gt; 0) {
    var varArgs = [];
    for (var i = 0; i &lt; arguments.length; i++) {
      varArgs.push(arguments[i]);
    }
    return signature1(varArgs); // signature: ...any
  }
  throw createError(name, arguments.length, 0, arguments[0], 'Array,Matrix,any');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
* Computes the mode of a set of numbers or a list with values(numbers or characters).
* If there are more than one modes, it returns a list of those values.
*
* Syntax:
*
*     math.<span class="apidocCodeKeywordSpan">mode</span>(a, b, c, ...)
*     math.mode(A)
*
* Examples:
*
*     math.mode(2, 1, 4, 3, 1);                            // returns [1]
*     math.mode([1, 2.7, 3.2, 4, 2.7]);                    // returns [2.7]
*     math.mode(1, 4, 6, 1, 6)                             // returns [1, 6]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.multinomial" id="apidoc.element.mathjs.expression.mathWithTransform.multinomial">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>multinomial
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function multinomial(arg0) {
  "use strict";
  var name = 'multinomial';
  if (test0(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature0(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature0(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Multinomial Coefficients compute the number of ways of picking a1, a2, ..., ai unordered outcomes from `n` possibilities.
*
* multinomial takes one array of integers as an argument.
* The following condition must be enforced: every ai &lt;= 0
*
* Syntax:
*
*     math.<span class="apidocCodeKeywordSpan">multinomial</span>(a) // a is an array type
*
* Examples:
*
*    math.multinomial([1,2,1]); // returns 12
*
* See also:
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.multiply" id="apidoc.element.mathjs.expression.mathWithTransform.multiply">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>multiply
        <span class="apidocSignatureSpan">(arg0, arg1, arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function multiply(arg0, arg1, arg2) {
  "use strict";
  var name = 'multiply';
  if (test0(arg0)) { // type: number
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: number, number
      }
    }
    if (test1(arg1)) { // type: Complex
      if (arguments.length === 2) {
        return signature1(convert0(arg0), arg1); // signature: number, Complex
      }
    }
    if (test2(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature2(convert1(arg0), arg1); // signature: number, BigNumber
      }
    }
    if (test3(arg1)) { // type: Fraction
      if (arguments.length === 2) {
        return signature3(convert2(arg0), arg1); // signature: number, Fraction
      }
    }
    if (test4(arg1)) { // type: Unit
      if (arguments.length === 2) {
        return signature4(arg0, arg1); // signature: number, Unit
      }
    }
    if (test5(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert3(arg1)); // signature: number, string
      }
    }
    if (test6(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert4(arg1)); // signature: number, boolean
      }
    }
    if (test7(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert5(arg1)); // signature: number, null
      }
    }
  }
  if (test1(arg0)) { // type: Complex
    if (test1(arg1)) { // type: Complex
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Complex, Complex
      }
    }
    if (test4(arg1)) { // type: Unit
      if (arguments.length === 2) {
        return signature4(arg0, arg1); // signature: Complex, Unit
      }
    }
    if (test0(arg1)) { // type: number (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: Complex, number
      }
    }
    if (test2(arg1)) { // type: BigNumber (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert6(arg1)); // signature: Complex, BigNumber
      }
    }
    if (test3(arg1)) { // type: Fraction (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert7(arg1)); // signature: Complex, Fraction
      }
    }
    if (test5(arg1)) { // type: string (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert8(arg1)); // signature: Complex, string
      }
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (test1(arg1)) { // type: Complex
      if (arguments.length === 2) {
        return signature1(convert6(arg0), arg1); // signature: BigNumber, Complex
      }
    }
    if (test2(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: BigNumber, BigNumber
      }
    }
    if (test4(arg1)) { // type: Unit
      if (arguments.length === 2) {
        return signature4(arg0, arg1); // signature: BigNumber, Unit
      }
    }
    if (test0(arg1)) { // type: number (convert to BigNumber)
      if (arguments.length === 2) {
        return signature2(arg0, convert1(arg1)); // signature: BigNumber, number
      }
    }
    if (test3(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature2(arg0, convert9(arg1)); // signature: BigNumber, Fraction
      }
    }
    if (test5(arg1)) { // type: string (convert to BigNumber)
      if (arguments.length === 2) {
        return signature2(arg0, convert10(arg1)); // signature: BigNumber, string
      }
    }
    if (test6(arg1)) { // type: boolean (convert to BigNumber)
      if (arguments.length === 2) {
        return signature2(arg0, convert11(arg1)); // signature: BigNumber, boolean
      }
    }
    if (test7(arg1)) { // type: null (convert to BigNumber)
      if (arguments.length === 2) {
        return signature2(arg0, convert12(arg1)); // signature ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
math.eval('sin(45 deg) ^ 2');     // 0.5
math.eval('9 / 3 + 2i');          // 3 + 2i
math.eval('det([-1, 2; 3, 1])');  // -7

// chaining
math.chain(3)
    .add(4)
    .<span class="apidocCodeKeywordSpan">multiply</span>(2)
    .done(); // 14
```

## Browser support

Math.js works on any ES5 compatible JavaScript engine: node.js 0.10, and Internet Explorer 9 and newer, and all other browsers (
Chrome, Firefox, Safari). If support for old browsers like Internet Explorer 8 is required, the [es5-shim](https://github.com/kriskowal
/es5-shim) library has to be loaded.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.norm" id="apidoc.element.mathjs.expression.mathWithTransform.norm">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>norm
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function norm(arg0, arg1) {
  "use strict";
  var name = 'norm';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: number, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: number, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: string
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: number, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: number, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert1(arg1)); // signature: number, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert2(arg1)); // signature: number, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'number,BigNumber,string');
  }
  if (test6(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature2(arg0); // signature: Complex
    }
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Complex, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Complex, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: string
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Complex, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: Complex, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert1(arg1)); // signature: Complex, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert2(arg1)); // signature: Complex, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'number,BigNumber,string');
  }
  if (test1(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature3(arg0); // signature: BigNumber
    }
    if (test0(arg1)) { // type: nu ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Calculate the norm of a number, vector or matrix.
*
* The second parameter p is optional. If not provided, it defaults to 2.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">norm</span>(x)
*    math.norm(x, p)
*
* Examples:
*
*    math.abs(-3.5);                         // returns 3.5
*    math.norm(-3.5);                        // returns 3.5
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.not" id="apidoc.element.mathjs.expression.mathWithTransform.not">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>not
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function not(arg0) {
  "use strict";
  var name = 'not';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Unit
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Unit
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature2(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test9(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Unit,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  /**
* Logical `not`. Flips boolean value of a given parameter.
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">not</span>(x)
*
* Examples:
*
*    math.not(2);      // returns false
*    math.not(0);      // returns true
*    math.not(true);   // returns false
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.nthRoot" id="apidoc.element.mathjs.expression.mathWithTransform.nthRoot">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>nthRoot
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function nthRoot(arg0, arg1) {
  "use strict";
  var name = 'nthRoot';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: number, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature2(convert0(arg0), arg1); // signature: number, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature3(arg0, arg1); // signature: number, Array
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature4(arg0, arg1); // signature: number, Matrix
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature2(convert0(arg0), convert1(arg1)); // signature: number, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert2(arg1)); // signature: number, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test6(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert3(arg1)); // signature: number, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test7(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert4(arg1)); // signature: number, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'number,BigNumber,Array,Matrix');
  }
  if (test8(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature5(arg0); // signature: Complex
    }
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature6(arg0, arg1); // signature: Complex, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature6(arg0, convert2(arg1)); // signature: Complex, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test6(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature6(arg0, convert3(arg1)); // signature: Complex, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test7(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature6(arg0, convert4(arg1)); // signature: Complex, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'number');
  }
  if (test1(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature7(arg0); // signature: BigNumber
    }
    if ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
*     x^root = A
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*     math.<span class="apidocCodeKeywordSpan">nthRoot</span>(a)
*     math.nthRoot(a, root)
*
* Examples:
*
*     math.nthRoot(9, 2);    // returns 3, as 3^2 == 9
*     math.sqrt(9);          // returns 3, as 3^2 == 9
*     math.nthRoot(64, 3);   // returns 4, as 4^3 == 64
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.number" id="apidoc.element.mathjs.expression.mathWithTransform.number">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>number
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function number(arg0, arg1) {
  "use strict";
  var name = 'number';
  if (arguments.length === 0) {
    return signature0(); // signature:
  }
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature1(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: Fraction
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Unit
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Unit
    }
    if (test3(arg1)) { // type: Unit
      if (arguments.length === 2) {
        return signature5(arg0, arg1); // signature: Unit, Unit
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: string
      if (arguments.length === 2) {
        return signature5(arg0, arg1); // signature: Unit, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test0(arg1)) { // type: number (convert to string)
      if (arguments.length === 2) {
        return signature5(arg0, convert0(arg1)); // signature: Unit, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: boolean (convert to string)
      if (arguments.length === 2) {
        return signature5(arg0, convert1(arg1)); // signature: Unit, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test6(arg1)) { // type: null (convert to string)
      if (arguments.length === 2) {
        return signature5(arg0, convert2(arg1)); // signature: Unit, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Unit,string');
  }
  if (test4(arg0)) { // type: string
    if (arguments.length === 1) {
      return signature6(arg0); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature7(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature7(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature1(convert3(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature1(convert4(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,BigNumber,Fraction,Unit,string,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function factory (type, config, load, typed) {
/**
 * Create a number or convert a string, boolean, or unit to a number.
 * When value is a matrix, all elements will be converted to number.
 *
 * Syntax:
 *
 *    math.<span class="apidocCodeKeywordSpan">number</span>(value)
 *    math.number(unit, valuelessUnit)
 *
 * Examples:
 *
 *    math.number(2);                         // returns number 2
 *    math.number('7.2');                     // returns number 7.2
 *    math.number(true);                      // returns number 1
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.ones" id="apidoc.element.mathjs.expression.mathWithTransform.ones">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>ones
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ones(arg0, arg1) {
  "use strict";
  var name = 'ones';
  if (arguments.length === 0) {
    return signature0(); // signature:
  }
  if (test0(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Array
    }
    if (test1(arg1)) { // type: string
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: Array, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: number (convert to string)
      if (arguments.length === 2) {
        return signature2(arg0, convert0(arg1)); // signature: Array, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: boolean (convert to string)
      if (arguments.length === 2) {
        return signature2(arg0, convert1(arg1)); // signature: Array, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: null (convert to string)
      if (arguments.length === 2) {
        return signature2(arg0, convert2(arg1)); // signature: Array, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'string');
  }
  if (test5(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Matrix
    }
    if (test1(arg1)) { // type: string
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: Matrix, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: number (convert to string)
      if (arguments.length === 2) {
        return signature2(arg0, convert0(arg1)); // signature: Matrix, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: boolean (convert to string)
      if (arguments.length === 2) {
        return signature2(arg0, convert1(arg1)); // signature: Matrix, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: null (convert to string)
      if (arguments.length === 2) {
        return signature2(arg0, convert2(arg1)); // signature: Matrix, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'string');
  }
  if (test2(arg0) || test6(arg0) || test1(arg0) || test7(arg0) || test3(arg0) || test3(arg0) || test3(arg0) || test4(arg0) || test4
(arg0) || test4(arg0)) { // type: ...number|BigNumber|string|Fraction|boolean|null
    var varArgs = [arg0];
    for (var i = 1; i &lt; arguments.length; i++) {
      if (test2(arguments[i]) || test6(arguments[i]) || test1(arguments[i])) {
        varArgs.push(arguments[i]);
      }
      else if (test7(arguments[i])) {
        varArgs.push(convert3(arguments[i]));
      }
      else if (test3(arguments[i])) {
        varArgs.push(convert4(arguments[i]));
      }
      else if (test3(arguments[i])) {
        varArgs.push(convert5(arguments[i]));
      }
      else if (test3(arguments[i])) {
        varArgs.push(convert1(arguments[i]));
      }
      else if (test4(arguments[i])) {
        varArgs.push(convert6(arguments[i]));
      }
      else if (test4(arguments[i])) {
        varArgs.push(convert2(arguments[i]));
      }
      else if (test4(arguments[i])) {
        varArgs.push(convert7(arguments[i]));
      } else {
        throw createError(name, arguments.length, i, arguments[i], 'number,BigNumber,string');
      }
    }
    return signature4(varArgs); // signature: ...number|BigNum ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  /**
* Create a matrix filled with ones. The created matrix can have one or
* multiple dimensions.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">ones</span>(m)
*    math.ones(m, format)
*    math.ones(m, n)
*    math.ones(m, n, format)
*    math.ones([m, n])
*    math.ones([m, n], format)
*    math.ones([m, n, p, ...])
*    math.ones([m, n, p, ...], format)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.or" id="apidoc.element.mathjs.expression.mathWithTransform.or">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>or
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function or(arg0, arg1) {
  "use strict";
  var name = 'or';
  if (test0(arg0)) { // type: number
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: number, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: Complex
      if (arguments.length === 2) {
        return signature1(convert0(arg0), arg1); // signature: number, Complex
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature2(convert1(arg0), arg1); // signature: number, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature2(convert1(arg0), convert2(arg1)); // signature: number, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert3(arg1)); // signature: number, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert4(arg1)); // signature: number, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test6(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert5(arg1)); // signature: number, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
  }
  if (test1(arg0)) { // type: Complex
    if (test1(arg1)) { // type: Complex
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Complex, Complex
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test0(arg1)) { // type: number (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: Complex, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: BigNumber (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert6(arg1)); // signature: Complex, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: Fraction (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert7(arg1)); // signature: Complex, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: string (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert8(arg1)); // signature: Complex, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (test1(arg1)) { // type: Complex
      if (arguments.length === 2) {
        return signature1(convert6(arg0), arg1); // signature: BigNumber, Complex
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // si ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  /**
* Logical `or`. Test if at least one value is defined with a nonzero/nonempty value.
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">or</span>(x, y)
*
* Examples:
*
*    math.or(2, 4);   // returns true
*
*    a = [2, 5, 0];
*    b = [0, 22, 0];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.parse" id="apidoc.element.mathjs.expression.mathWithTransform.parse">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>parse
        <span class="apidocSignatureSpan">(expr, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parse(expr, options) {
  if (arguments.length != 1 &amp;&amp; arguments.length != 2) {
    throw new ArgumentsError('parse', arguments.length, 1, 2);
  }

  // pass extra nodes
  extra_nodes = (options &amp;&amp; options.nodes) ? options.nodes : {};

  if (typeof expr === 'string') {
    // parse a single expression
    expression = expr;
    return parseStart();
  }
  else if (Array.isArray(expr) || expr instanceof type.Matrix) {
    // parse an array or matrix with expressions
    return deepMap(expr, function (elem) {
      if (typeof elem !== 'string') throw new TypeError('String expected');

      expression = elem;
      return parseStart();
    });
  }
  else {
    // oops
    throw new TypeError('String or matrix expected');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        if (!expr) {
          break;
        }
        switch (mode) {
          case 'eval':
            // evaluate expression
            try {
var node = math.<span class="apidocCodeKeywordSpan">parse</span>(expr);
var res = node.eval(scope);

if (res &amp;&amp; res.isResultSet) {
  // we can have 0 or 1 results in the ResultSet, as the CLI
  // does not allow multiple expressions separated by a return
  res = res.entries[0];
  node = node.blocks
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.parser" id="apidoc.element.mathjs.expression.mathWithTransform.parser">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>parser
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parser() {
  "use strict";
  var name = 'parser';
  if (arguments.length === 0) {
    return signature0(); // signature:
  }
  if (arguments.length &gt; 0) {
    throw createError(name, arguments.length, 0, arguments[0]);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*    parser.remove(name);               // clear a variable from the
*                                       // parsers scope
*    parser.clear();                    // clear the parsers scope
*
* Example usage:
*    var parser = new Parser();
*    // Note: there is a convenience method which can be used instead:
*    // var parser = new math.<span class="apidocCodeKeywordSpan">parser</span>();
*
*    // evaluate expressions
*    parser.eval('sqrt(3^2 + 4^2)');         // 5
*    parser.eval('sqrt(-4)');                // 2i
*    parser.eval('2 inch in cm');            // 5.08 cm
*    parser.eval('cos(45 deg)');             // 0.7071067811865476
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.partitionSelect" id="apidoc.element.mathjs.expression.mathWithTransform.partitionSelect">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>partitionSelect
        <span class="apidocSignatureSpan">(arg0, arg1, arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function partitionSelect(arg0, arg1, arg2) {
  "use strict";
  var name = 'partitionSelect';
  if (test0(arg0)) { // type: Array
    if (test1(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: Array, number
      }
      if (test2(arg2)) { // type: string
        if (arguments.length === 3) {
          return signature1(arg0, arg1, arg2); // signature: Array, number, string
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test3(arg2)) { // type: function
        if (arguments.length === 3) {
          return signature2(arg0, arg1, arg2); // signature: Array, number, function
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test1(arg2)) { // type: number (convert to string)
        if (arguments.length === 3) {
          return signature1(arg0, arg1, convert0(arg2)); // signature: Array, number, number
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test4(arg2)) { // type: boolean (convert to string)
        if (arguments.length === 3) {
          return signature1(arg0, arg1, convert1(arg2)); // signature: Array, number, boolean
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test5(arg2)) { // type: null (convert to string)
        if (arguments.length === 3) {
          return signature1(arg0, arg1, convert2(arg2)); // signature: Array, number, null
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      throw createError(name, arguments.length, 2, arguments[2], 'string,function');
    }
    if (test2(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert3(arg1)); // signature: Array, string
      }
      if (test2(arg2)) { // type: string
        if (arguments.length === 3) {
          return signature1(arg0, convert3(arg1), arg2); // signature: Array, string, string
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test3(arg2)) { // type: function
        if (arguments.length === 3) {
          return signature2(arg0, convert3(arg1), arg2); // signature: Array, string, function
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test1(arg2)) { // type: number (convert to string)
        if (arguments.length === 3) {
          return signature1(arg0, convert3(arg1), convert0(arg2)); // signature: Array, string, number
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test4(arg2)) { // type: boolean (convert to string)
        if (arguments.length === 3) {
          return signature1(arg0, convert3(arg1), convert1(arg2)); // signature: Array, string, boolean
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test5(arg2)) { // type: null (convert to string)
        if (arguments.length === 3) {
          return signature1(arg0, convert3(arg1), convert2(arg2)); // signature: Array, string, null
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      throw createError(name, arguments.length, 2, arguments[2], 'string,function');
    }
    if (test4(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert4(arg1)); // signature: Array, boolean
      }
      if (test2(arg2)) { // type: string
        if (arguments.length === 3) { ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Partition-based selection of an array or 1D matrix.
* Will find the kth smallest value, and mutates the input array.
* Uses Quickselect.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">partitionSelect</span>(x, k)
*    math.partitionSelect(x, k, compare)
*
* Examples:
*
*    math.partitionSelect([5, 10, 1], 2);           // returns 10
*    math.partitionSelect(['C', 'B', 'A', 'D'], 1); // returns 'B'
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.permutations" id="apidoc.element.mathjs.expression.mathWithTransform.permutations">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>permutations
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function permutations(arg0, arg1) {
  "use strict";
  var name = 'permutations';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: number, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature2(convert0(arg0), arg1); // signature: number, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature2(convert0(arg0), convert1(arg1)); // signature: number, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert2(arg1)); // signature: number, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert3(arg1)); // signature: number, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert4(arg1)); // signature: number, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'number,BigNumber');
  }
  if (test1(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature0(arg0); // signature: BigNumber
    }
    if (test1(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: BigNumber, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test0(arg1)) { // type: number (convert to BigNumber)
      if (arguments.length === 2) {
        return signature2(arg0, convert0(arg1)); // signature: BigNumber, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature2(arg0, convert1(arg1)); // signature: BigNumber, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: string (convert to BigNumber)
      if (arguments.length === 2) {
        return signature2(arg0, convert5(arg1)); // signature: BigNumber, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: boolean (convert to BigNumber)
      if (arguments.length === 2) {
        return signature2(arg0, convert6(arg1)); // signature: BigNumber, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: null (convert to BigNumber)
      if (arguments.length === 2) {
        return signature2(arg0, convert7(arg1)); // signature: BigNumber, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'BigNumber');
  }
  if (test2(arg0)) { // type: Fracti ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* from a set of `n` elements.
*
* Permutations only takes integer arguments.
* The following condition must be enforced: k &lt;= n.
*
* Syntax:
*
*     math.<span class="apidocCodeKeywordSpan">permutations</span>(n)
*     math.permutations(n, k)
*
* Examples:
*
*    math.permutations(5);     // 120
*    math.permutations(5, 3);  // 60
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.pow" id="apidoc.element.mathjs.expression.mathWithTransform.pow">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>pow
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function pow(arg0, arg1) {
  "use strict";
  var name = 'pow';
  if (test0(arg0)) { // type: number
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: number, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: Complex
      if (arguments.length === 2) {
        return signature1(convert0(arg0), arg1); // signature: number, Complex
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature2(convert1(arg0), arg1); // signature: number, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: Fraction
      if (arguments.length === 2) {
        return signature3(convert2(arg0), arg1); // signature: number, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert3(arg1)); // signature: number, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert4(arg1)); // signature: number, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test6(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert5(arg1)); // signature: number, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'number,Complex,BigNumber,Fraction');
  }
  if (test1(arg0)) { // type: Complex
    if (test1(arg1)) { // type: Complex
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Complex, Complex
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test0(arg1)) { // type: number (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: Complex, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: BigNumber (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert6(arg1)); // signature: Complex, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: Fraction (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert7(arg1)); // signature: Complex, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: string (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert8(arg1)); // signature: Complex, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Complex');
  }
  if (test2(arg0)) { // type: BigNumber
    if (test1(arg1)) { // type: Complex
      if (arguments.length === 2) {
        return signature1(convert6(arg0), arg1); // signature: BigNumber, Complex
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, argume ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var math = require('mathjs');

// functions and constants
math.round(math.e, 3);            // 2.718
math.atan2(3, -3) / math.pi;      // 0.75
math.log(1000, 10);               // 3
math.sqrt(-4);                    // 2i
math.<span class="apidocCodeKeywordSpan">pow</span>([[-1, 2], [3, 1]], 2);   // [[7, 0], [0, 7]]
math.derivative('x^2 + x', 'x');  // 2 * x + 1

// expressions
math.eval('12 / (2.3 + 0.7)');    // 4
math.eval('5.08 cm to inch');     // 2 inch
math.eval('sin(45 deg) ^ 2');     // 0.5
math.eval('9 / 3 + 2i');          // 3 + 2i
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.print" id="apidoc.element.mathjs.expression.mathWithTransform.print">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>print
        <span class="apidocSignatureSpan">(arg0, arg1, arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function print(arg0, arg1, arg2) {
  "use strict";
  var name = 'print';
  if (test0(arg0)) { // type: string
    if (test1(arg1)) { // type: Object
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: string, Object
      }
      if (test2(arg2)) { // type: number
        if (arguments.length === 3) {
          return signature0(arg0, arg1, arg2); // signature: string, Object, number
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test0(arg2)) { // type: string (convert to number)
        if (arguments.length === 3) {
          return signature0(arg0, arg1, convert0(arg2)); // signature: string, Object, string
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test3(arg2)) { // type: boolean (convert to number)
        if (arguments.length === 3) {
          return signature0(arg0, arg1, convert1(arg2)); // signature: string, Object, boolean
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test4(arg2)) { // type: null (convert to number)
        if (arguments.length === 3) {
          return signature0(arg0, arg1, convert2(arg2)); // signature: string, Object, null
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test1(arg2)) { // type: Object
        if (arguments.length === 3) {
          return signature0(arg0, arg1, arg2); // signature: string, Object, Object
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      throw createError(name, arguments.length, 2, arguments[2], 'number,Object');
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Object');
  }
  if (test2(arg0)) { // type: number (convert to string)
    if (test1(arg1)) { // type: Object
      if (arguments.length === 2) {
        return signature0(convert3(arg0), arg1); // signature: number, Object
      }
      if (test2(arg2)) { // type: number
        if (arguments.length === 3) {
          return signature0(convert3(arg0), arg1, arg2); // signature: number, Object, number
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test0(arg2)) { // type: string (convert to number)
        if (arguments.length === 3) {
          return signature0(convert3(arg0), arg1, convert0(arg2)); // signature: number, Object, string
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test3(arg2)) { // type: boolean (convert to number)
        if (arguments.length === 3) {
          return signature0(convert3(arg0), arg1, convert1(arg2)); // signature: number, Object, boolean
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test4(arg2)) { // type: null (convert to number)
        if (arguments.length === 3) {
          return signature0(convert3(arg0), arg1, convert2(arg2)); // signature: number, Object, null
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test1(arg2)) { // type: Object
        if (arguments.length === 3) {
          return signature0(convert3(arg0), arg1, arg2); // signature: number, Object, Object
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      throw createError(name, arguments.length, 2, arguments[2], 'number,Object');
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Object');
  }
  if (test3(arg0)) { // type: boolean (convert to string)
    if (test1(arg1)) { // typ ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

function factory (type, config, load, typed) {
/**
 * Interpolate values into a string template.
 *
 * Syntax:
 *
 *     math.<span class="apidocCodeKeywordSpan">print</span>(template, values)
 *     math.print(template, values, precision)
 *     math.print(template, values, options)
 *
 * Example usage:
 *
 *     // the following outputs: 'Lucy is 5 years old'
 *     math.print('Lucy is $age years old', {age: 5});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.prod" id="apidoc.element.mathjs.expression.mathWithTransform.prod">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>prod
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function prod(arg0, arg1) {
  "use strict";
  var name = 'prod';
  if (test0(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature0(arg0); // signature: Array
    }
    if (test1(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Array, number
      }
    }
    if (test2(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Array, BigNumber
      }
    }
    if (test3(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: Array, Fraction
      }
    }
    if (test4(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert1(arg1)); // signature: Array, string
      }
    }
    if (test5(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert2(arg1)); // signature: Array, boolean
      }
    }
    if (test6(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert3(arg1)); // signature: Array, null
      }
    }
  }
  if (test7(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature0(arg0); // signature: Matrix
    }
    if (test1(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Matrix, number
      }
    }
    if (test2(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Matrix, BigNumber
      }
    }
    if (test3(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: Matrix, Fraction
      }
    }
    if (test4(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert1(arg1)); // signature: Matrix, string
      }
    }
    if (test5(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert2(arg1)); // signature: Matrix, boolean
      }
    }
    if (test6(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert3(arg1)); // signature: Matrix, null
      }
    }
  }
  if (arguments.length &gt; 0) {
    var varArgs = [];
    for (var i = 0; i &lt; arguments.length; i++) {
      varArgs.push(arguments[i]);
    }
    return signature2(varArgs); // signature: ...any
  }
  throw createError(name, arguments.length, 0, arguments[0], 'Array,Matrix,any');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Compute the product of a matrix or a list with values.
* In case of a (multi dimensional) array or matrix, the sum of all
* elements will be calculated.
*
* Syntax:
*
*     math.<span class="apidocCodeKeywordSpan">prod</span>(a, b, c, ...)
*     math.prod(A)
*
* Examples:
*
*     math.multiply(2, 3);           // returns 6
*     math.prod(2, 3);               // returns 6
*     math.prod(2, 3, 4);            // returns 24
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.qr" id="apidoc.element.mathjs.expression.mathWithTransform.qr">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>qr
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function qr(arg0) {
  "use strict";
  var name = 'qr';
  if (test0(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature0(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: DenseMatrix
    if (arguments.length === 1) {
      return signature1(arg0); // signature: DenseMatrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: SparseMatrix
    if (arguments.length === 1) {
      return signature2(arg0); // signature: SparseMatrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Matrix (convert to Array)
    if (arguments.length === 1) {
      return signature0(convert0(arg0)); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'Array,DenseMatrix,SparseMatrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.quantileSeq" id="apidoc.element.mathjs.expression.mathWithTransform.quantileSeq">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>quantileSeq
        <span class="apidocSignatureSpan">(data, probOrN, sorted)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function quantileSeq(data, probOrN, sorted) {
  var probArr, dataArr, one;

  if (arguments.length &lt; 2 || arguments.length &gt; 3) {
    throw new SyntaxError('Function quantileSeq requires two or three parameters');
  }

  if (isCollection(data)) {
    sorted = sorted || false;
    if (typeof sorted === 'boolean') {
      dataArr = data.valueOf();
      if (isNumber(probOrN)) {
        if (probOrN &lt; 0) {
          throw new Error('N/prob must be non-negative');
        }

        if (probOrN &lt;= 1) {
          // quantileSeq([a, b, c, d, ...], prob[,sorted])
          return _quantileSeq(dataArr, probOrN, sorted);
        }

        if (probOrN &gt; 1) {
          // quantileSeq([a, b, c, d, ...], N[,sorted])
          if (!isInteger(probOrN)) {
            throw new Error('N must be a positive integer');
          }

          var nPlusOne = probOrN + 1;
          probArr = new Array(probOrN);
          for (var i = 0; i &lt; probOrN;) {
            probArr[i] = _quantileSeq(dataArr, (++i) / nPlusOne, sorted);
          }
          return probArr;
        }
      }

      if (probOrN &amp;&amp; probOrN.isBigNumber) {
        if (probOrN.isNegative()) {
          throw new Error('N/prob must be non-negative');
        }

        one = new probOrN.constructor(1);

        if (probOrN.lte(one)) {
          // quantileSeq([a, b, c, d, ...], prob[,sorted])
          return _quantileSeq(dataArr, probOrN, sorted);
        }

        if (probOrN.gt(one)) {
          // quantileSeq([a, b, c, d, ...], N[,sorted])
          if (!probOrN.isInteger()) {
            throw new Error('N must be a positive integer');
          }

          // largest possible Array length is 2^32-1;
          // 2^32 &lt; 10^15, thus safe conversion guaranteed
          var intN = probOrN.toNumber();
          if (intN &gt; 4294967295) {
            throw new Error('N must be less than or equal to 2^32-1, as that is the maximum length of an Array');
          }

          var nPlusOne = new type.BigNumber(intN + 1);
          probArr = new Array(intN);
          for (var i = 0; i &lt; intN;) {
            probArr[i] = _quantileSeq(dataArr, new type.BigNumber(++i).div(nPlusOne), sorted);
          }
          return probArr;
        }
      }

      if (Array.isArray(probOrN)) {
        // quantileSeq([a, b, c, d, ...], [prob1, prob2, ...][,sorted])
        probArr = new Array(probOrN.length);
        for (var i = 0; i &lt; probArr.length; ++i) {
          var currProb = probOrN[i];
          if (isNumber(currProb)) {
            if (currProb &lt; 0 || currProb &gt; 1) {
              throw new Error('Probability must be between 0 and 1, inclusive');
            }
          } else if (currProb &amp;&amp; currProb.isBigNumber) {
            one = new currProb.constructor(1);
            if (currProb.isNegative() || currProb.gt(one)) {
              throw new Error('Probability must be between 0 and 1, inclusive');
            }
          } else {
            throw new TypeError('Unexpected type of argument in function quantileSeq'); // FIXME: becomes redundant when converted
 to typed-function
          }

          probArr[i] = _quantileSeq(dataArr, currProb, sorted);
        }
        return probArr;
      }

      throw new TypeError('Unexpected type of argument in function quantileSeq'); // FIXME: becomes redundant when converted to
typed-function
    }

    throw new TypeError('Unexpected type of argument in function quantileSeq'); // FIXME: becomes redundant when converted to typed
-function
  }

  throw new TypeError('Unexpected type of argument in function quantileSeq'); // FIXME: becomes redundant when converted to typed
-function
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Supported types of probability are: Number, BigNumber
*
* In case of a (multi dimensional) array or matrix, the prob order quantile
* of all elements will be calculated.
*
* Syntax:
*
*     math.<span class="apidocCodeKeywordSpan">quantileSeq</span>(A, prob[, sorted])
*     math.quantileSeq(A, [prob1, prob2, ...][, sorted])
*     math.quantileSeq(A, N[, sorted])
*
* Examples:
*
*     math.quantileSeq([3, -1, 5, 7], 0.5);         // returns 4
*     math.quantileSeq([3, -1, 5, 7], [1/3, 2/3]);  // returns [3, 5]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.range" id="apidoc.element.mathjs.expression.mathWithTransform.range">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>range
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function range(arg0) {
  "use strict";
  var name = 'range';
  if (arguments.length &gt; 0) {
    var varArgs = [];
    for (var i = 0; i &lt; arguments.length; i++) {
      varArgs.push(arguments[i]);
    }
    return signature0(varArgs); // signature: ...any
  }
  throw createError(name, arguments.length, 0, arguments[0], 'any');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *                          the name of the argument, and the value is `true`.
 *                          The object may not be mutated, but must be
 *                          extended instead.
 * @return {string} js
 * @private
 */
RangeNode.prototype._compile = function (defs, args) {
  return 'math.<span class="apidocCodeKeywordSpan">range</span>(' +
      this.start._compile(defs, args) + ', ' +
      this.end._compile(defs, args) +
      (this.step ? (', ' + this.step._compile(defs, args)) : '') +
      ')';
};

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.re" id="apidoc.element.mathjs.expression.mathWithTransform.re">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>re
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function re(arg0) {
  "use strict";
  var name = 're';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature2(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Syntax:
*
*    math.im(x)
*
* Examples:
*
*    var a = math.complex(2, 3);
*    math.<span class="apidocCodeKeywordSpan">re</span>(a);                     // returns number 2
*    math.im(a);                     // returns number 3
*
*    math.re(math.complex('-5.2i')); // returns number -5.2
*    math.re(math.complex(2.4));     // returns number 0
*
* See also:
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.reshape" id="apidoc.element.mathjs.expression.mathWithTransform.reshape">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>reshape
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reshape(arg0, arg1) {
  "use strict";
  var name = 'reshape';
  if (test0(arg0)) { // type: Array
    if (test0(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: Array, Array
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: Matrix (convert to Array)
      if (arguments.length === 2) {
        return signature0(arg0, convert0(arg1)); // signature: Array, Matrix
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Array');
  }
  if (test1(arg0)) { // type: Matrix
    if (test0(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Matrix, Array
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: Matrix (convert to Array)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: Matrix, Matrix
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Array');
  }
  throw createError(name, arguments.length, 0, arguments[0], 'Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var matrix = load(require('../../type/matrix/function/matrix'));

/**
 * Reshape a multi dimensional array to fit the specified dimensions
 *
 * Syntax:
 *
 *     math.<span class="apidocCodeKeywordSpan">reshape</span>(x, sizes)
 *
 * Examples:
 *
 *     math.reshape([1, 2, 3, 4, 5, 6], [2, 3]);
 *     // returns Array  [[1, 2, 3], [4, 5, 6]]
 *
 *     math.reshape([[1, 2], [3, 4]], [1, 4]);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.resize" id="apidoc.element.mathjs.expression.mathWithTransform.resize">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>resize
        <span class="apidocSignatureSpan">(x, size, defaultValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function resize(x, size, defaultValue) {
  if (arguments.length != 2 &amp;&amp; arguments.length != 3) {
    throw new ArgumentsError('resize', arguments.length, 2, 3);
  }

  if (size &amp;&amp; size.isMatrix === true) {
    size = size.valueOf(); // get Array
  }

  if (size.length &amp;&amp; size[0] &amp;&amp; size[0].isBigNumber === true) {
    // convert bignumbers to numbers
    size = size.map(function (value) {
      return (value &amp;&amp; value.isBigNumber === true) ? value.toNumber() : value;
    });
  }

  // check x is a Matrix
  if (x &amp;&amp; x.isMatrix === true) {
    // use optimized matrix implementation, return copy
    return x.resize(size, defaultValue, true);
  }

  if (typeof x === 'string') {
    // resize string
    return _resizeString(x, size, defaultValue);
  }

  // check result should be a matrix
  var asMatrix = Array.isArray(x) ? false : (config.matrix !== 'Array');

  if (size.length == 0) {
    // output a scalar
    while (Array.isArray(x)) {
      x = x[0];
    }

    return clone(x);
  }
  else {
    // output an array/matrix
    if (!Array.isArray(x)) {
      x = [x];
    }
    x = clone(x);

    var res = array.resize(x, size, defaultValue);
    return asMatrix ? matrix(res) : res;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // get matrix storage constructor
  var F = type.Matrix.storage(format);
  // create diagonal matrix (use optimized implementation for storage format)
  return F.diagonal(size, one, 0, defaultValue);
}

// create and resize array
var res = array.<span class="apidocCodeKeywordSpan">resize</span>([], size, defaultValue);
// fill in ones on the diagonal
var minimum = rows &lt; cols ? rows : cols;
// fill diagonal
for (var d = 0; d &lt; minimum; d++) {
  res[d][d] = one;
}
return res;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.reviver" id="apidoc.element.mathjs.expression.mathWithTransform.reviver">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>reviver
        <span class="apidocSignatureSpan">(key, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reviver(key, value) {
  var constructor = type[value &amp;&amp; value.mathjs];
  if (constructor &amp;&amp; typeof constructor.fromJSON === 'function') {
    return constructor.fromJSON(value);
  }

  return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.rightArithShift" id="apidoc.element.mathjs.expression.mathWithTransform.rightArithShift">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>rightArithShift
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function rightArithShift(arg0, arg1) {
  "use strict";
  var name = 'rightArithShift';
  if (test0(arg0)) { // type: number
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: number, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature1(convert0(arg0), arg1); // signature: number, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: number, Array
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature3(arg0, arg1); // signature: number, Matrix
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(convert0(arg0), convert1(arg1)); // signature: number, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert2(arg1)); // signature: number, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test6(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert3(arg1)); // signature: number, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test7(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert4(arg1)); // signature: number, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'number,BigNumber,Array,Matrix');
  }
  if (test1(arg0)) { // type: BigNumber
    if (test1(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: BigNumber, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: BigNumber, Array
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature3(arg0, arg1); // signature: BigNumber, Matrix
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test0(arg1)) { // type: number (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: BigNumber, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert1(arg1)); // signature: BigNumber, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: string (convert to BigNumber)
      if (arguments.length === 2) {
        return signature ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Bitwise right arithmetic shift of a value x by y number of bits, `x &gt;&gt; y`.
* For matrices, the function is evaluated element wise.
* For units, the function is evaluated on the best prefix base.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">rightArithShift</span>(x, y)
*
* Examples:
*
*    math.rightArithShift(4, 2);               // returns number 1
*
*    math.rightArithShift([16, -32, 64], 4);   // returns Array [1, -2, 3]
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.rightLogShift" id="apidoc.element.mathjs.expression.mathWithTransform.rightLogShift">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>rightLogShift
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function rightLogShift(arg0, arg1) {
  "use strict";
  var name = 'rightLogShift';
  if (test0(arg0)) { // type: number
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: number, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: number, Array
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: number, Matrix
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert0(arg1)); // signature: number, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert1(arg1)); // signature: number, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert2(arg1)); // signature: number, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'number,Array,Matrix');
  }
  if (test6(arg0)) { // type: BigNumber
    if (test1(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: BigNumber, Array
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: BigNumber, Matrix
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Array,Matrix');
  }
  if (test1(arg0)) { // type: Array
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature3(arg0, arg1); // signature: Array, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test6(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature3(arg0, arg1); // signature: Array, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature4(arg0, arg1); // signature: Array, Array
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature5(arg0, arg1); // signature: Array, Matrix
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test7(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature3(arg0, convert3(arg1)); // signature: Array, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature3(arg0, c ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Bitwise right logical shift of value x by y number of bits, `x &gt;&gt;&gt; y`.
* For matrices, the function is evaluated element wise.
* For units, the function is evaluated on the best prefix base.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">rightLogShift</span>(x, y)
*
* Examples:
*
*    math.rightLogShift(4, 2);               // returns number 1
*
*    math.rightLogShift([16, -32, 64], 4);   // returns Array [1, 2, 3]
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.round" id="apidoc.element.mathjs.expression.mathWithTransform.round">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>round
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function round(arg0, arg1) {
  "use strict";
  var name = 'round';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: number, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: number, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature3(arg0, arg1); // signature: number, Array
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature4(arg0, arg1); // signature: number, Matrix
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature2(arg0, convert0(arg1)); // signature: number, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert1(arg1)); // signature: number, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test6(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert2(arg1)); // signature: number, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test7(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert3(arg1)); // signature: number, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'number,BigNumber,Array,Matrix');
  }
  if (test8(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature5(arg0); // signature: Complex
    }
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature6(arg0, arg1); // signature: Complex, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature7(arg0, arg1); // signature: Complex, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature3(arg0, arg1); // signature: Complex, Array
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature4(arg0, arg1); // signature: Complex, Matrix
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature7(arg0, convert0(arg1)); // signature: Complex, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
[chained operations](http://mathjs.org/docs/chained_operations.html).

```js
// load math.js
var math = require('mathjs');

// functions and constants
math.<span class="apidocCodeKeywordSpan">round</span>(math.e, 3);            // 2.718
math.atan2(3, -3) / math.pi;      // 0.75
math.log(1000, 10);               // 3
math.sqrt(-4);                    // 2i
math.pow([[-1, 2], [3, 1]], 2);   // [[7, 0], [0, 7]]
math.derivative('x^2 + x', 'x');  // 2 * x + 1

// expressions
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.sec" id="apidoc.element.mathjs.expression.mathWithTransform.sec">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>sec
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sec(arg0) {
  "use strict";
  var name = 'sec';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Unit
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Unit
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature2(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test9(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Unit,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Syntax:
*
*    math.asec(x)
*
* Examples:
*
*    math.asec(0.5);           // returns 1.0471975511965979
*    math.asec(math.<span class="apidocCodeKeywordSpan">sec</span>(1.5)); // returns 1.5
*
*    math.asec(2);             // returns 0 + 1.3169578969248166 i
*
* See also:
*
*    acos, acot, acsc
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.sech" id="apidoc.element.mathjs.expression.mathWithTransform.sech">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>sech
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sech(arg0) {
  "use strict";
  var name = 'sech';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Unit
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Unit
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature2(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test9(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Unit,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Calculate the hyperbolic secant of a value,
* defined as `sech(x) = 1 / cosh(x)`.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">sech</span>(x)
*
* Examples:
*
*    // sech(x) = 1/ cosh(x)
*    math.sech(0.5);       // returns 0.886818883970074
*    1 / math.cosh(0.5);   // returns 0.886818883970074
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.sign" id="apidoc.element.mathjs.expression.mathWithTransform.sign">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>sign
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sign(arg0) {
  "use strict";
  var name = 'sign';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Fraction
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Unit
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Unit
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature5(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature5(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert0(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test9(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Fraction,Unit,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* - -1 when x &lt; 0
* -  0 when x == 0
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">sign</span>(x)
*
* Examples:
*
*    math.sign(3.5);               // returns 1
*    math.sign(-4.2);              // returns -1
*    math.sign(0);                 // returns 0
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.simplify" id="apidoc.element.mathjs.expression.mathWithTransform.simplify">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>simplify
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function simplify(arg0, arg1) {
  "use strict";
  var name = 'simplify';
  if (test0(arg0)) { // type: string
    if (arguments.length === 1) {
      return signature0(arg0); // signature: string
    }
    if (test1(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: string, Array
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: Matrix (convert to Array)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: string, Matrix
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Array');
  }
  if (test3(arg0)) { // type: Node
    if (arguments.length === 1) {
      return signature2(arg0); // signature: Node
    }
    if (test1(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature3(arg0, arg1); // signature: Node, Array
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: Matrix (convert to Array)
      if (arguments.length === 2) {
        return signature3(arg0, convert0(arg1)); // signature: Node, Matrix
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Array');
  }
  if (test4(arg0)) { // type: number (convert to string)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: number
    }
    if (test1(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature1(convert1(arg0), arg1); // signature: number, Array
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: Matrix (convert to Array)
      if (arguments.length === 2) {
        return signature1(convert1(arg0), convert0(arg1)); // signature: number, Matrix
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Array');
  }
  if (test5(arg0)) { // type: boolean (convert to string)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
    if (test1(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature1(convert2(arg0), arg1); // signature: boolean, Array
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: Matrix (convert to Array)
      if (arguments.length === 2) {
        return signature1(convert2(arg0), convert0(arg1)); // signature: boolean, Matrix
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Array');
  }
  if (test6(arg0)) { // type: null (convert to string)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
    if (test1(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature1(convert3(arg0), arg1); // signature: null, Array
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: Matrix (convert to Array)
      if (arguments.length === 2) {
        return signature1(convert3(arg0), convert0(arg1)); // signature: null, Matrix
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Array');
  }
  throw createError(name, arguments.length, 0, arg ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Syntax:
*
*     simplify(expr)
*     simplify(expr, rules)
*
* Examples:
*
*     math.<span class="apidocCodeKeywordSpan">simplify</span>('2 * 1 * x ^ (2 - 1)');      // Node {2 * x}
*     var f = math.parse('2 * 1 * x ^ (2 - 1)');
*     math.simplify(f);                          // Node {2 * x}
*
* See also:
*
*     derivative, parse, eval
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.sin" id="apidoc.element.mathjs.expression.mathWithTransform.sin">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>sin
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sin(arg0) {
  "use strict";
  var name = 'sin';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Unit
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Unit
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature2(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test9(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Unit,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    res = 1;                          // 0! is per definition 1
  }

  return res;
}

if (n &lt; 0.5) {
  return Math.PI / (Math.<span class="apidocCodeKeywordSpan">sin</span>(Math.PI * n) * gamma(1-n));
}

if (n &gt;= 171.35) {
  return Infinity;                    // will overflow
}

if (n &gt; 85.0) {                       // Extended Stirling Approx
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.sinh" id="apidoc.element.mathjs.expression.mathWithTransform.sinh">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>sinh
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sinh(arg0) {
  "use strict";
  var name = 'sinh';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Unit
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Unit
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature2(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test9(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Unit,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
*    math.csch(x)
*
* Examples:
*
*    // csch(x) = 1/ sinh(x)
*    math.csch(0.5);       // returns 1.9190347513349437
*    1 / math.<span class="apidocCodeKeywordSpan">sinh</span>(0.5);   // returns 1.9190347513349437
*
* See also:
*
*    sinh, sech, coth
*
* @param {number | Complex | Unit | Array | Matrix} x  Function input
* @return {number | Complex | Array | Matrix} Hyperbolic cosecant of x
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.size" id="apidoc.element.mathjs.expression.mathWithTransform.size">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>size
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function size(arg0) {
  "use strict";
  var name = 'size';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature0(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature0(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Unit
    if (arguments.length === 1) {
      return signature0(arg0); // signature: Unit
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: string
    if (arguments.length === 1) {
      return signature1(arg0); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature2(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: boolean
    if (arguments.length === 1) {
      return signature0(arg0); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: null
    if (arguments.length === 1) {
      return signature0(arg0); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test9(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature0(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Unit,string,Array,Matrix,boolean,null');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

if (!Array.isArray(array) || !Array.isArray(sizes)) {
  throw new TypeError('Array expected');
}

if (sizes.length === 0) {
  throw new DimensionError(0, product(exports.<span class="apidocCodeKeywordSpan">size</span>(array)), '!=');
}

try {
  newArray  = _reshape(flatArray, sizes);
} catch (e) {
  if (e instanceof DimensionError) {
    throw new DimensionError(
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.slu" id="apidoc.element.mathjs.expression.mathWithTransform.slu">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>slu
        <span class="apidocSignatureSpan">(arg0, arg1, arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function slu(arg0, arg1, arg2) {
  "use strict";
  var name = 'slu';
  if (test0(arg0)) { // type: SparseMatrix
    if (test1(arg1)) { // type: number
      if (test1(arg2)) { // type: number
        if (arguments.length === 3) {
          return signature0(arg0, arg1, arg2); // signature: SparseMatrix, number, number
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test2(arg2)) { // type: string (convert to number)
        if (arguments.length === 3) {
          return signature0(arg0, arg1, convert0(arg2)); // signature: SparseMatrix, number, string
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test3(arg2)) { // type: boolean (convert to number)
        if (arguments.length === 3) {
          return signature0(arg0, arg1, convert1(arg2)); // signature: SparseMatrix, number, boolean
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test4(arg2)) { // type: null (convert to number)
        if (arguments.length === 3) {
          return signature0(arg0, arg1, convert2(arg2)); // signature: SparseMatrix, number, null
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      throw createError(name, arguments.length, 2, arguments[2], 'number');
    }
    if (test2(arg1)) { // type: string (convert to number)
      if (test1(arg2)) { // type: number
        if (arguments.length === 3) {
          return signature0(arg0, convert0(arg1), arg2); // signature: SparseMatrix, string, number
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test2(arg2)) { // type: string (convert to number)
        if (arguments.length === 3) {
          return signature0(arg0, convert0(arg1), convert0(arg2)); // signature: SparseMatrix, string, string
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test3(arg2)) { // type: boolean (convert to number)
        if (arguments.length === 3) {
          return signature0(arg0, convert0(arg1), convert1(arg2)); // signature: SparseMatrix, string, boolean
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test4(arg2)) { // type: null (convert to number)
        if (arguments.length === 3) {
          return signature0(arg0, convert0(arg1), convert2(arg2)); // signature: SparseMatrix, string, null
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      throw createError(name, arguments.length, 2, arguments[2], 'number');
    }
    if (test3(arg1)) { // type: boolean (convert to number)
      if (test1(arg2)) { // type: number
        if (arguments.length === 3) {
          return signature0(arg0, convert1(arg1), arg2); // signature: SparseMatrix, boolean, number
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test2(arg2)) { // type: string (convert to number)
        if (arguments.length === 3) {
          return signature0(arg0, convert1(arg1), convert0(arg2)); // signature: SparseMatrix, boolean, string
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test3(arg2)) { // type: boolean (convert to number)
        if (arguments.length === 3) {
          return signature0(arg0, convert1(arg1), convert1(arg2)); // signature: SparseMatrix, boolean, boolean
        }
        if (arguments.length &gt; 3) {
          throw createError(name, arguments.length, 3, arguments[3]);
        }
      }
      if (test4(ar ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.smaller" id="apidoc.element.mathjs.expression.mathWithTransform.smaller">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>smaller
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function smaller(arg0, arg1) {
  "use strict";
  var name = 'smaller';
  if (test0(arg0)) { // type: number
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: number, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: Complex
      if (arguments.length === 2) {
        return signature1(convert0(arg0), arg1); // signature: number, Complex
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature2(convert1(arg0), arg1); // signature: number, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: Fraction
      if (arguments.length === 2) {
        return signature3(convert2(arg0), arg1); // signature: number, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert3(arg1)); // signature: number, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert4(arg1)); // signature: number, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test6(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert5(arg1)); // signature: number, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
  }
  if (test1(arg0)) { // type: Complex
    if (test1(arg1)) { // type: Complex
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Complex, Complex
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test0(arg1)) { // type: number (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: Complex, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: BigNumber (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert6(arg1)); // signature: Complex, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: Fraction (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert7(arg1)); // signature: Complex, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: string (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert8(arg1)); // signature: Complex, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (test1(arg1)) { // type: Complex
      if (arguments.length === 2) {
        return signature1(convert6(arg0), arg1); // signature: BigNumber, Complex
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: BigNumber, Big ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* Syntax:
*
*    math.smallerEq(x, y)
*
* Examples:
*
*    math.<span class="apidocCodeKeywordSpan">smaller</span>(1 + 2, 3);        // returns false
*    math.smallerEq(1 + 2, 3);      // returns true
*
* See also:
*
*    equal, unequal, smaller, larger, largerEq, compare
*
* @param  {number | BigNumber | Fraction | boolean | Unit | string | Array | Matrix} x First value to compare
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.smallerEq" id="apidoc.element.mathjs.expression.mathWithTransform.smallerEq">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>smallerEq
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function smallerEq(arg0, arg1) {
  "use strict";
  var name = 'smallerEq';
  if (test0(arg0)) { // type: number
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: number, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: Complex
      if (arguments.length === 2) {
        return signature1(convert0(arg0), arg1); // signature: number, Complex
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature2(convert1(arg0), arg1); // signature: number, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: Fraction
      if (arguments.length === 2) {
        return signature3(convert2(arg0), arg1); // signature: number, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert3(arg1)); // signature: number, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert4(arg1)); // signature: number, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test6(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert5(arg1)); // signature: number, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
  }
  if (test1(arg0)) { // type: Complex
    if (test1(arg1)) { // type: Complex
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Complex, Complex
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test0(arg1)) { // type: number (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: Complex, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: BigNumber (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert6(arg1)); // signature: Complex, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: Fraction (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert7(arg1)); // signature: Complex, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: string (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert8(arg1)); // signature: Complex, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (test1(arg1)) { // type: Complex
      if (arguments.length === 2) {
        return signature1(convert6(arg0), arg1); // signature: BigNumber, Complex
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: BigNumber, ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* The function returns true when x is smaller than y or the relative
* difference between x and y is smaller than the configured epsilon. The
* function cannot be used to compare values smaller than approximately 2.22e-16.
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">smallerEq</span>(x, y)
*
* Examples:
*
*    math.smaller(1 + 2, 3);        // returns false
*    math.smallerEq(1 + 2, 3);      // returns true
*
* See also:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.sort" id="apidoc.element.mathjs.expression.mathWithTransform.sort">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>sort
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sort(arg0, arg1) {
  "use strict";
  var name = 'sort';
  if (test0(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature0(arg0); // signature: Array
    }
    if (test1(arg1)) { // type: string
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Array, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: function
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: Array, function
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: number (convert to string)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: Array, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: boolean (convert to string)
      if (arguments.length === 2) {
        return signature1(arg0, convert1(arg1)); // signature: Array, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: null (convert to string)
      if (arguments.length === 2) {
        return signature1(arg0, convert2(arg1)); // signature: Array, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'string,function');
  }
  if (test6(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Matrix
    }
    if (test1(arg1)) { // type: string
      if (arguments.length === 2) {
        return signature4(arg0, arg1); // signature: Matrix, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: function
      if (arguments.length === 2) {
        return signature5(arg0, arg1); // signature: Matrix, function
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: number (convert to string)
      if (arguments.length === 2) {
        return signature4(arg0, convert0(arg1)); // signature: Matrix, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: boolean (convert to string)
      if (arguments.length === 2) {
        return signature4(arg0, convert1(arg1)); // signature: Matrix, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: null (convert to string)
      if (arguments.length === 2) {
        return signature4(arg0, convert2(arg1)); // signature: Matrix, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'string,function');
  }
  throw createError(name, arguments.length, 0, arguments[0], 'Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

/**
 * Sort the items in a matrix.
 *
 * Syntax:
 *
 *    math.<span class="apidocCodeKeywordSpan">sort</span>(x)
 *    math.sort(x, compare)
 *
 * Examples:
 *
 *    math.sort([5, 10, 1]); // returns [1, 5, 10]
 *    math.sort(['C', 'B', 'A', 'D']); // returns ['A', 'B', 'C
', 'D']
 *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.sparse" id="apidoc.element.mathjs.expression.mathWithTransform.sparse">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>sparse
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sparse(arg0, arg1) {
  "use strict";
  var name = 'sparse';
  if (arguments.length === 0) {
    return signature0(); // signature:
  }
  if (test0(arg0)) { // type: string
    if (arguments.length === 1) {
      return signature1(arg0); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature2(arg0); // signature: Array
    }
    if (test0(arg1)) { // type: string
      if (arguments.length === 2) {
        return signature3(arg0, arg1); // signature: Array, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: number (convert to string)
      if (arguments.length === 2) {
        return signature3(arg0, convert0(arg1)); // signature: Array, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: boolean (convert to string)
      if (arguments.length === 2) {
        return signature3(arg0, convert1(arg1)); // signature: Array, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: null (convert to string)
      if (arguments.length === 2) {
        return signature3(arg0, convert2(arg1)); // signature: Array, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'string');
  }
  if (test5(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature2(arg0); // signature: Matrix
    }
    if (test0(arg1)) { // type: string
      if (arguments.length === 2) {
        return signature3(arg0, arg1); // signature: Matrix, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: number (convert to string)
      if (arguments.length === 2) {
        return signature3(arg0, convert0(arg1)); // signature: Matrix, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: boolean (convert to string)
      if (arguments.length === 2) {
        return signature3(arg0, convert1(arg1)); // signature: Matrix, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: null (convert to string)
      if (arguments.length === 2) {
        return signature3(arg0, convert2(arg1)); // signature: Matrix, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'string');
  }
  if (test2(arg0)) { // type: number (convert to string)
    if (arguments.length === 1) {
      return signature1(convert0(arg0)); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: boolean (convert to string)
    if (arguments.length === 1) {
      return signature1(convert1(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: null (convert to string)
    if (arguments.length === 1) {
      return signature1(convert2(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'string,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.splitUnit" id="apidoc.element.mathjs.expression.mathWithTransform.splitUnit">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>splitUnit
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function splitUnit(arg0, arg1) {
  "use strict";
  var name = 'splitUnit';
  if (test0(arg0)) { // type: Unit
    if (test1(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: Unit, Array
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: Matrix (convert to Array)
      if (arguments.length === 2) {
        return signature0(arg0, convert0(arg1)); // signature: Unit, Matrix
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Array');
  }
  throw createError(name, arguments.length, 0, arguments[0], 'Unit');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * Returns an array of units whose sum is equal to this unit
   * @memberof Unit
   * @param {Array} [parts] An array of strings or valueless units.
   *
   *   Example:
   *
   *   var u = new Unit(1, 'm');
   *   u.<span class="apidocCodeKeywordSpan">splitUnit</span>(['feet', 'inch']);
   *     [ 3 feet, 3.3700787401575 inch ]
   *
   * @return {Array} An array of units.
   */
  Unit.prototype.splitUnit = function(parts) {

var x = this.clone();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.sqrt" id="apidoc.element.mathjs.expression.mathWithTransform.sqrt">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>sqrt
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sqrt(arg0) {
  "use strict";
  var name = 'sqrt';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Unit
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Unit
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature2(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test9(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Unit,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// load math.js
var math = require('mathjs');

// functions and constants
math.round(math.e, 3);            // 2.718
math.atan2(3, -3) / math.pi;      // 0.75
math.log(1000, 10);               // 3
math.<span class="apidocCodeKeywordSpan">sqrt</span>(-4);                    // 2i
math.pow([[-1, 2], [3, 1]], 2);   // [[7, 0], [0, 7]]
math.derivative('x^2 + x', 'x');  // 2 * x + 1

// expressions
math.eval('12 / (2.3 + 0.7)');    // 4
math.eval('5.08 cm to inch');     // 2 inch
math.eval('sin(45 deg) ^ 2');     // 0.5
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.square" id="apidoc.element.mathjs.expression.mathWithTransform.square">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>square
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function square(arg0) {
  "use strict";
  var name = 'square';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Fraction
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Unit
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Unit
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature5(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature5(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert0(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test9(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Fraction,Unit,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Syntax:
*
*    math.sqrt(x)
*
* Examples:
*
*    math.sqrt(25);                // returns 5
*    math.<span class="apidocCodeKeywordSpan">square</span>(5);               // returns 25
*    math.sqrt(-4);                // returns Complex 2i
*
* See also:
*
*    square, multiply, cube, cbrt
*
* @param {number | BigNumber | Complex | Array | Matrix | Unit} x
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.squeeze" id="apidoc.element.mathjs.expression.mathWithTransform.squeeze">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>squeeze
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function squeeze(arg0) {
  "use strict";
  var name = 'squeeze';
  if (test0(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature0(arg0); // signature: Array
    }
  }
  if (test1(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Matrix
    }
  }
  // type: any
  if (arguments.length === 1) {
    return signature2(arg0); // signature: any
  }
  if (arguments.length &gt; 1) {
    throw createError(name, arguments.length, 1, arguments[1]);
  }
  throw createError(name, arguments.length, 0, arguments[0], 'Array,Matrix,any');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * @param {Array} y  Second vector
   * @returns {Array} Returns the cross product of x and y
   * @private
   */
  function _cross(x, y) {
var highestDimension = Math.max(array.size(x).length, array.size(y).length);

x = array.<span class="apidocCodeKeywordSpan">squeeze</span>(x);
y = array.squeeze(y);

var xSize = array.size(x);
var ySize = array.size(y);

if (xSize.length != 1 || ySize.length != 1 || xSize[0] != 3 || ySize[0] != 3) {
  throw new RangeError('Vectors with length 3 expected ' +
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.std" id="apidoc.element.mathjs.expression.mathWithTransform.std">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>std
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function std(arg0, arg1) {
  "use strict";
  var name = 'std';
  if (test0(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature0(arg0); // signature: Array
    }
    if (test1(arg1)) { // type: string
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: Array, string
      }
    }
    if (test2(arg1)) { // type: number (convert to string)
      if (arguments.length === 2) {
        return signature0(arg0, convert0(arg1)); // signature: Array, number
      }
    }
    if (test3(arg1)) { // type: boolean (convert to string)
      if (arguments.length === 2) {
        return signature0(arg0, convert1(arg1)); // signature: Array, boolean
      }
    }
    if (test4(arg1)) { // type: null (convert to string)
      if (arguments.length === 2) {
        return signature0(arg0, convert2(arg1)); // signature: Array, null
      }
    }
  }
  if (test5(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature0(arg0); // signature: Matrix
    }
    if (test1(arg1)) { // type: string
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: Matrix, string
      }
    }
    if (test2(arg1)) { // type: number (convert to string)
      if (arguments.length === 2) {
        return signature0(arg0, convert0(arg1)); // signature: Matrix, number
      }
    }
    if (test3(arg1)) { // type: boolean (convert to string)
      if (arguments.length === 2) {
        return signature0(arg0, convert1(arg1)); // signature: Matrix, boolean
      }
    }
    if (test4(arg1)) { // type: null (convert to string)
      if (arguments.length === 2) {
        return signature0(arg0, convert2(arg1)); // signature: Matrix, null
      }
    }
  }
  if (arguments.length &gt; 0) {
    var varArgs = [];
    for (var i = 0; i &lt; arguments.length; i++) {
      varArgs.push(arguments[i]);
    }
    return signature1(varArgs); // signature: ...any
  }
  throw createError(name, arguments.length, 0, arguments[0], 'Array,Matrix,any');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* - 'unbiased' (default) The sum of squared errors is divided by (n - 1)
* - 'uncorrected'        The sum of squared errors is divided by n
* - 'biased'             The sum of squared errors is divided by (n + 1)
*
* Syntax:
*
*     math.<span class="apidocCodeKeywordSpan">std</span>(a, b, c, ...)
*     math.std(A)
*     math.std(A, normalization)
*
* Examples:
*
*     math.std(2, 4, 6);                     // returns 2
*     math.std([2, 4, 6, 8]);                // returns 2.581988897471611
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.stirlingS2" id="apidoc.element.mathjs.expression.mathWithTransform.stirlingS2">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>stirlingS2
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function stirlingS2(arg0, arg1) {
  "use strict";
  var name = 'stirlingS2';
  if (test0(arg0)) { // type: number
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: number, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: number, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature0(arg0, convert0(arg1)); // signature: number, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert1(arg1)); // signature: number, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert2(arg1)); // signature: number, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert3(arg1)); // signature: number, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'number,BigNumber');
  }
  if (test1(arg0)) { // type: BigNumber
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: BigNumber, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: BigNumber, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature0(arg0, convert0(arg1)); // signature: BigNumber, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert1(arg1)); // signature: BigNumber, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert2(arg1)); // signature: BigNumber, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert3(arg1)); // signature: BigNumber, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'number,BigNumber');
  }
  if (test2(arg0)) { // type: Fraction (convert to BigNumber)
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature0(convert0(arg0), arg1); // signature: Fraction, number
      }
      if (arguments.length &gt; 2) {
        throw createErr ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* stirlingS2 only takes integer arguments.
* The following condition must be enforced: k &lt;= n.
*
*  If n = k or k = 1, then s(n,k) = 1
*
* Syntax:
*
*   math.<span class="apidocCodeKeywordSpan">stirlingS2</span>(n, k)
*
* Examples:
*
*    math.stirlingS2(5, 3); //returns 25
*
* See also:
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.string" id="apidoc.element.mathjs.expression.mathWithTransform.string">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>string
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function string(arg0) {
  "use strict";
  var name = 'string';
  if (arguments.length === 0) {
    return signature0(); // signature:
  }
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature1(arg0); // signature: number
    }
  }
  if (test1(arg0)) { // type: string
    if (arguments.length === 1) {
      return signature2(arg0); // signature: string
    }
  }
  if (test2(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Array
    }
  }
  if (test3(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Matrix
    }
  }
  if (test4(arg0)) { // type: boolean
    if (arguments.length === 1) {
      return signature4(arg0); // signature: boolean
    }
  }
  if (test5(arg0)) { // type: null
    if (arguments.length === 1) {
      return signature5(arg0); // signature: null
    }
  }
  // type: any
  if (arguments.length === 1) {
    return signature6(arg0); // signature: any
  }
  if (arguments.length &gt; 1) {
    throw createError(name, arguments.length, 1, arguments[1]);
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,string,Array,Matrix,boolean,null,any');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function factory (type, config, load, typed) {
/**
 * Create a string or convert any object into a string.
 * Elements of Arrays and Matrices are processed element wise.
 *
 * Syntax:
 *
 *    math.<span class="apidocCodeKeywordSpan">string</span>(value)
 *
 * Examples:
 *
 *    math.string(4.2);               // returns string '4.2'
 *    math.string(math.complex(3, 2); // returns string '3 + 2i'
 *
 *    var u = math.unit(5, 'km');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.subset" id="apidoc.element.mathjs.expression.mathWithTransform.subset">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>subset
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function subset(arg0) {
  "use strict";
  var name = 'subset';
  if (arguments.length &gt; 0) {
    var varArgs = [];
    for (var i = 0; i &lt; arguments.length; i++) {
      varArgs.push(arguments[i]);
    }
    return signature0(varArgs); // signature: ...any
  }
  throw createError(name, arguments.length, 0, arguments[0], 'any');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function factory (type, config, load, typed) {
var matrix = load(require('../../type/matrix/function/matrix'));

/**
 * Get or set a subset of a matrix or string.
 *
 * Syntax:
 *     math.<span class="apidocCodeKeywordSpan">subset</span>(value, index)                                // retrieve a subset
 *     math.subset(value, index, replacement [, defaultValue])  // replace a subset
 *
 * Examples:
 *
 *     // get a subset
 *     var d = [[1, 2], [3, 4]];
 *     math.subset(d, math.index(1, 0));        // returns 3
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.subtract" id="apidoc.element.mathjs.expression.mathWithTransform.subtract">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>subtract
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function subtract(arg0, arg1) {
  "use strict";
  var name = 'subtract';
  if (test0(arg0)) { // type: number
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: number, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: Complex
      if (arguments.length === 2) {
        return signature1(convert0(arg0), arg1); // signature: number, Complex
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature2(convert1(arg0), arg1); // signature: number, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: Fraction
      if (arguments.length === 2) {
        return signature3(convert2(arg0), arg1); // signature: number, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert3(arg1)); // signature: number, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert4(arg1)); // signature: number, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test6(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert5(arg1)); // signature: number, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
  }
  if (test1(arg0)) { // type: Complex
    if (test1(arg1)) { // type: Complex
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Complex, Complex
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test0(arg1)) { // type: number (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: Complex, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: BigNumber (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert6(arg1)); // signature: Complex, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: Fraction (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert7(arg1)); // signature: Complex, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: string (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert8(arg1)); // signature: Complex, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (test1(arg1)) { // type: Complex
      if (arguments.length === 2) {
        return signature1(convert6(arg0), arg1); // signature: BigNumber, Complex
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: BigNumber, B ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  /**
* Subtract two values, `x - y`.
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">subtract</span>(x, y)
*
* Examples:
*
*    math.subtract(5.3, 2);        // returns number 3.3
*
*    var a = math.complex(2, 3);
*    var b = math.complex(4, 1);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.sum" id="apidoc.element.mathjs.expression.mathWithTransform.sum">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>sum
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sum(arg0, arg1) {
  "use strict";
  var name = 'sum';
  if (test0(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature0(arg0); // signature: Array
    }
    if (test1(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Array, number
      }
    }
    if (test2(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Array, BigNumber
      }
    }
    if (test3(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: Array, Fraction
      }
    }
    if (test4(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert1(arg1)); // signature: Array, string
      }
    }
    if (test5(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert2(arg1)); // signature: Array, boolean
      }
    }
    if (test6(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert3(arg1)); // signature: Array, null
      }
    }
  }
  if (test7(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature0(arg0); // signature: Matrix
    }
    if (test1(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Matrix, number
      }
    }
    if (test2(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Matrix, BigNumber
      }
    }
    if (test3(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: Matrix, Fraction
      }
    }
    if (test4(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert1(arg1)); // signature: Matrix, string
      }
    }
    if (test5(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert2(arg1)); // signature: Matrix, boolean
      }
    }
    if (test6(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature1(arg0, convert3(arg1)); // signature: Matrix, null
      }
    }
  }
  if (arguments.length &gt; 0) {
    var varArgs = [];
    for (var i = 0; i &lt; arguments.length; i++) {
      varArgs.push(arguments[i]);
    }
    return signature2(varArgs); // signature: ...any
  }
  throw createError(name, arguments.length, 0, arguments[0], 'Array,Matrix,any');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Compute the sum of a matrix or a list with values.
* In case of a (multi dimensional) array or matrix, the sum of all
* elements will be calculated.
*
* Syntax:
*
*     math.<span class="apidocCodeKeywordSpan">sum</span>(a, b, c, ...)
*     math.sum(A)
*
* Examples:
*
*     math.sum(2, 1, 4, 3);               // returns 10
*     math.sum([2, 1, 4, 3]);             // returns 10
*     math.sum([[2, 5], [4, 3], [1, 7]]); // returns 22
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.tan" id="apidoc.element.mathjs.expression.mathWithTransform.tan">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>tan
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function tan(arg0) {
  "use strict";
  var name = 'tan';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Unit
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Unit
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature2(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test9(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Unit,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Syntax:
*
*    math.atan(x)
*
* Examples:
*
*    math.atan(0.5);           // returns number 0.4636476090008061
*    math.atan(math.<span class="apidocCodeKeywordSpan">tan</span>(1.5)); // returns number 1.5
*
*    math.atan(2);             // returns Complex 1.5707963267948966 -1.3169578969248166 i
*
* See also:
*
*    tan, asin, acos
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.tanh" id="apidoc.element.mathjs.expression.mathWithTransform.tanh">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>tanh
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function tanh(arg0) {
  "use strict";
  var name = 'tanh';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Unit
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Unit
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: Fraction (convert to BigNumber)
    if (arguments.length === 1) {
      return signature2(convert0(arg0)); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test9(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert3(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Unit,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
*    math.coth(x)
*
* Examples:
*
*    // coth(x) = 1 / tanh(x)
*    math.coth(2);         // returns 1.0373147207275482
*    1 / math.<span class="apidocCodeKeywordSpan">tanh</span>(2);     // returns 1.0373147207275482
*
* See also:
*
*    sinh, tanh, cosh
*
* @param {number | Complex | Unit | Array | Matrix} x  Function input
* @return {number | Complex | Array | Matrix} Hyperbolic cotangent of x
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.to" id="apidoc.element.mathjs.expression.mathWithTransform.to">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>to
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function to(arg0, arg1) {
  "use strict";
  var name = 'to';
  if (test0(arg0)) { // type: Unit
    if (test0(arg1)) { // type: Unit
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: Unit, Unit
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: string
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: Unit, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: number (convert to string)
      if (arguments.length === 2) {
        return signature0(arg0, convert0(arg1)); // signature: Unit, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: boolean (convert to string)
      if (arguments.length === 2) {
        return signature0(arg0, convert1(arg1)); // signature: Unit, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: null (convert to string)
      if (arguments.length === 2) {
        return signature0(arg0, convert2(arg1)); // signature: Unit, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
  }
  if (test5(arg0)) { // type: Array
    if (test5(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Array, Array
      }
    }
    if (test6(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: Array, Matrix
      }
    }
    // type: any
    if (arguments.length === 2) {
      return signature3(arg0, arg1); // signature: Array, any
    }
    if (arguments.length &gt; 2) {
      throw createError(name, arguments.length, 2, arguments[2]);
    }
  }
  if (test6(arg0)) { // type: Matrix
    if (test5(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature4(arg0, arg1); // signature: Matrix, Array
      }
    }
    if (test6(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature5(arg0, arg1); // signature: Matrix, Matrix
      }
    }
    // type: any
    if (arguments.length === 2) {
      return signature6(arg0, arg1); // signature: Matrix, any
    }
    if (arguments.length &gt; 2) {
      throw createError(name, arguments.length, 2, arguments[2]);
    }
  }
  // type: any
  if (test5(arg1)) { // type: Array
    if (arguments.length === 2) {
      return signature7(arg0, arg1); // signature: any, Array
    }
  }
  if (test6(arg1)) { // type: Matrix
    if (arguments.length === 2) {
      return signature8(arg0, arg1); // signature: any, Matrix
    }
  }
  throw createError(name, arguments.length, 1, arguments[1], 'Array,Matrix');
  throw createError(name, arguments.length, 0, arguments[0], 'Unit,Array,Matrix,any');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* Examples:
*
*    math.string(4.2);               // returns string '4.2'
*    math.string(math.complex(3, 2); // returns string '3 + 2i'
*
*    var u = math.unit(5, 'km');
*    math.string(u.<span class="apidocCodeKeywordSpan">to</span>('m'));         // returns string '5000 m'
*
*    math.string([true, false]);     // returns ['true', 'false']
*
* See also:
*
*    bignumber, boolean, complex, index, matrix, number, unit
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.trace" id="apidoc.element.mathjs.expression.mathWithTransform.trace">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>trace
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function trace(arg0) {
  "use strict";
  var name = 'trace';
  if (test0(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature0(arg0); // signature: Array
    }
  }
  if (test1(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Matrix
    }
  }
  // type: any
  if (arguments.length === 1) {
    return signature2(arg0); // signature: any
  }
  if (arguments.length &gt; 1) {
    throw createError(name, arguments.length, 1, arguments[1]);
  }
  throw createError(name, arguments.length, 0, arguments[0], 'Array,Matrix,any');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  /**
* Calculate the trace of a matrix: the sum of the elements on the main
* diagonal of a square matrix.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">trace</span>(x)
*
* Examples:
*
*    math.trace([[1, 2], [3, 4]]); // returns 5
*
*    var A = [
*      [1, 2, 3],
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.transpose" id="apidoc.element.mathjs.expression.mathWithTransform.transpose">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>transpose
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function transpose(arg0) {
  "use strict";
  var name = 'transpose';
  if (test0(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature0(arg0); // signature: Array
    }
  }
  if (test1(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Matrix
    }
  }
  // type: any
  if (arguments.length === 1) {
    return signature2(arg0); // signature: any
  }
  if (arguments.length &gt; 1) {
    throw createError(name, arguments.length, 1, arguments[1]);
  }
  throw createError(name, arguments.length, 0, arguments[0], 'Array,Matrix,any');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Transpose a matrix. All values of the matrix are reflected over its
* main diagonal. Only applicable to two dimensional matrices containing
* a vector (i.e. having size `[1,n]` or `[n,1]`). One dimensional
* vectors and scalars return the input unchanged.
*
* Syntax:
*
*     math.<span class="apidocCodeKeywordSpan">transpose</span>(x)
*
* Examples:
*
*     var A = [[1, 2, 3], [4, 5, 6]];
*     math.transpose(A);               // returns [[1, 4], [2, 5], [3, 6]]
*
* See also:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.typeof" id="apidoc.element.mathjs.expression.mathWithTransform.typeof">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>typeof
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _typeof(arg0) {
  "use strict";
  var name = '_typeof';
  // type: any
  if (arguments.length === 1) {
    return signature0(arg0); // signature: any
  }
  if (arguments.length &gt; 1) {
    throw createError(name, arguments.length, 1, arguments[1]);
  }
  throw createError(name, arguments.length, 0, arguments[0], 'any');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Determine the type of a variable.
*
* Function `typeof` recognizes the following types of objects:
*
* Object                 | Returns       | Example
* ---------------------- | ------------- | ------------------------------------------
* null                   | `'null'`      | `math.<span class="apidocCodeKeywordSpan">typeof</span>(null)`
* number                 | `'number'`    | `math.typeof(3.5)`
* boolean                | `'boolean'`   | `math.typeof (true)`
* string                 | `'string'`    | `math.typeof ('hello world')`
* Array                  | `'Array'`     | `math.typeof ([1, 2, 3])`
* Date                   | `'Date'`      | `math.typeof (new Date())`
* Function               | `'Function'`  | `math.typeof (function () {})`
* Object                 | `'Object'`    | `math.typeof ({a: 2, b: 3})`
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.unaryMinus" id="apidoc.element.mathjs.expression.mathWithTransform.unaryMinus">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>unaryMinus
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function unaryMinus(arg0) {
  "use strict";
  var name = 'unaryMinus';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Fraction
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Unit
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Unit
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature5(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature5(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: string (convert to number)
    if (arguments.length === 1) {
      return signature0(convert0(arg0)); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: boolean (convert to number)
    if (arguments.length === 1) {
      return signature0(convert1(arg0)); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test9(arg0)) { // type: null (convert to number)
    if (arguments.length === 1) {
      return signature0(convert2(arg0)); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Fraction,Unit,Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* For matrices, the function is evaluated element wise. Boolean values and
* strings will be converted to a number. For complex numbers, both real and
* complex value are inverted.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">unaryMinus</span>(x)
*
* Examples:
*
*    math.unaryMinus(3.5);      // returns -3.5
*    math.unaryMinus(-4.2);     // returns 4.2
*
* See also:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.unaryPlus" id="apidoc.element.mathjs.expression.mathWithTransform.unaryPlus">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>unaryPlus
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function unaryPlus(arg0) {
  "use strict";
  var name = 'unaryPlus';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(arg0); // signature: number
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test1(arg0)) { // type: Complex
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Complex
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (arguments.length === 1) {
      return signature2(arg0); // signature: BigNumber
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test3(arg0)) { // type: Fraction
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Fraction
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test4(arg0)) { // type: Unit
    if (arguments.length === 1) {
      return signature4(arg0); // signature: Unit
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test5(arg0)) { // type: string
    if (arguments.length === 1) {
      return signature5(arg0); // signature: string
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test6(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature6(arg0); // signature: Array
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test7(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature6(arg0); // signature: Matrix
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test8(arg0)) { // type: boolean
    if (arguments.length === 1) {
      return signature5(arg0); // signature: boolean
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  if (test9(arg0)) { // type: null
    if (arguments.length === 1) {
      return signature5(arg0); // signature: null
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'number,Complex,BigNumber,Fraction,Unit,string,Array,Matrix,boolean
,null');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Unary plus operation.
* Boolean values and strings will be converted to a number, numeric values will be returned as is.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">unaryPlus</span>(x)
*
* Examples:
*
*    math.unaryPlus(3.5);      // returns 3.5
*    math.unaryPlus(1);     // returns 1
*
* See also:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.unequal" id="apidoc.element.mathjs.expression.mathWithTransform.unequal">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>unequal
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function unequal(arg0, arg1) {
  "use strict";
  var name = 'unequal';
  if (test0(arg0)) { // type: Array
    if (test0(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: Array, Array
      }
    }
    if (test1(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Array, Matrix
      }
    }
    // type: any
    if (arguments.length === 2) {
      return signature2(arg0, arg1); // signature: Array, any
    }
    if (arguments.length &gt; 2) {
      throw createError(name, arguments.length, 2, arguments[2]);
    }
  }
  if (test1(arg0)) { // type: Matrix
    if (test0(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature3(arg0, arg1); // signature: Matrix, Array
      }
    }
    if (test1(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature4(arg0, arg1); // signature: Matrix, Matrix
      }
    }
    // type: any
    if (arguments.length === 2) {
      return signature5(arg0, arg1); // signature: Matrix, any
    }
    if (arguments.length &gt; 2) {
      throw createError(name, arguments.length, 2, arguments[2]);
    }
  }
  // type: any
  if (test0(arg1)) { // type: Array
    if (arguments.length === 2) {
      return signature6(arg0, arg1); // signature: any, Array
    }
  }
  if (test1(arg1)) { // type: Matrix
    if (arguments.length === 2) {
      return signature7(arg0, arg1); // signature: any, Matrix
    }
  }
  // type: any
  if (arguments.length === 2) {
    return signature8(arg0, arg1); // signature: any, any
  }
  if (arguments.length &gt; 2) {
    throw createError(name, arguments.length, 2, arguments[2]);
  }
  throw createError(name, arguments.length, 1, arguments[1], 'Array,Matrix,any');
  throw createError(name, arguments.length, 0, arguments[0], 'Array,Matrix,any');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* Values `null` and `undefined` are compared strictly, thus `null` is unequal
* with everything except `null`, and `undefined` is unequal with everying
* except. `undefined`.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">unequal</span>(x, y)
*
* Examples:
*
*    math.unequal(2 + 2, 3);       // returns true
*    math.unequal(2 + 2, 4);       // returns false
*
*    var a = math.unit('50 cm');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.unit" id="apidoc.element.mathjs.expression.mathWithTransform.unit">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>unit
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function unit(arg0, arg1) {
  "use strict";
  var name = 'unit';
  if (test0(arg0)) { // type: number
    if (arguments.length === 1) {
      return signature0(convert0(arg0)); // signature: number
    }
    if (test1(arg1)) { // type: string
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: number, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test0(arg1)) { // type: number (convert to string)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: number, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: boolean (convert to string)
      if (arguments.length === 2) {
        return signature1(arg0, convert1(arg1)); // signature: number, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: null (convert to string)
      if (arguments.length === 2) {
        return signature1(arg0, convert2(arg1)); // signature: number, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'string');
  }
  if (test4(arg0)) { // type: Complex
    if (test1(arg1)) { // type: string
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Complex, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test0(arg1)) { // type: number (convert to string)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: Complex, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: boolean (convert to string)
      if (arguments.length === 2) {
        return signature1(arg0, convert1(arg1)); // signature: Complex, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: null (convert to string)
      if (arguments.length === 2) {
        return signature1(arg0, convert2(arg1)); // signature: Complex, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'string');
  }
  if (test5(arg0)) { // type: BigNumber
    if (test1(arg1)) { // type: string
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: BigNumber, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test0(arg1)) { // type: number (convert to string)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: BigNumber, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: boolean (convert to string)
      if (arguments.length === 2) {
        return signature1(arg0, convert1(arg1)); // signature: BigNumber, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: null (convert to string)
      if (arguments.length === 2) {
        return signature1(arg0, convert2(arg1)); // signature: BigNumber, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'string');
  }
  if (test6(arg0)) { // type: Fraction
    if (test1(arg1)) { // type: string
      if (argument ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* Examples:
*
*    math.number(2);                         // returns number 2
*    math.number('7.2');                     // returns number 7.2
*    math.number(true);                      // returns number 1
*    math.number([true, false, true, true]); // returns [1, 0, 1, 1]
*    math.number(math.<span class="apidocCodeKeywordSpan">unit</span>('52cm'), 'm');    // returns 0.52
*
* See also:
*
*    bignumber, boolean, complex, index, matrix, string, unit
*
* @param {string | number | BigNumber | Fraction | boolean | Array | Matrix | Unit | null} [value]  Value to be converted
* @param {Unit | string} [valuelessUnit] A valueless unit, used to convert a unit to a number
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.usolve" id="apidoc.element.mathjs.expression.mathWithTransform.usolve">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>usolve
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function usolve(arg0, arg1) {
  "use strict";
  var name = 'usolve';
  if (test0(arg0)) { // type: Array
    if (test0(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: Array, Array
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: Array, Matrix
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Array,Matrix');
  }
  if (test2(arg0)) { // type: DenseMatrix
    if (test0(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: DenseMatrix, Array
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: DenseMatrix, Matrix
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Array,Matrix');
  }
  if (test3(arg0)) { // type: SparseMatrix
    if (test0(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: SparseMatrix, Array
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: SparseMatrix, Matrix
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Array,Matrix');
  }
  if (test1(arg0)) { // type: Matrix (convert to Array)
    if (test0(arg1)) { // type: Array
      if (arguments.length === 2) {
        return signature0(convert0(arg0), arg1); // signature: Matrix, Array
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: Matrix
      if (arguments.length === 2) {
        return signature0(convert0(arg0), arg1); // signature: Matrix, Matrix
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Array,Matrix');
  }
  throw createError(name, arguments.length, 0, arguments[0], 'Array,DenseMatrix,SparseMatrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.var" id="apidoc.element.mathjs.expression.mathWithTransform.var">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>var
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function variance(arg0, arg1) {
  "use strict";
  var name = 'variance';
  if (test0(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature0(arg0); // signature: Array
    }
    if (test1(arg1)) { // type: string
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Array, string
      }
    }
    if (test2(arg1)) { // type: number (convert to string)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: Array, number
      }
    }
    if (test3(arg1)) { // type: boolean (convert to string)
      if (arguments.length === 2) {
        return signature1(arg0, convert1(arg1)); // signature: Array, boolean
      }
    }
    if (test4(arg1)) { // type: null (convert to string)
      if (arguments.length === 2) {
        return signature1(arg0, convert2(arg1)); // signature: Array, null
      }
    }
  }
  if (test5(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature0(arg0); // signature: Matrix
    }
    if (test1(arg1)) { // type: string
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Matrix, string
      }
    }
    if (test2(arg1)) { // type: number (convert to string)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: Matrix, number
      }
    }
    if (test3(arg1)) { // type: boolean (convert to string)
      if (arguments.length === 2) {
        return signature1(arg0, convert1(arg1)); // signature: Matrix, boolean
      }
    }
    if (test4(arg1)) { // type: null (convert to string)
      if (arguments.length === 2) {
        return signature1(arg0, convert2(arg1)); // signature: Matrix, null
      }
    }
  }
  if (arguments.length &gt; 0) {
    var varArgs = [];
    for (var i = 0; i &lt; arguments.length; i++) {
      varArgs.push(arguments[i]);
    }
    return signature2(varArgs); // signature: ...any
  }
  throw createError(name, arguments.length, 0, arguments[0], 'Array,Matrix,any');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* - 'unbiased' (default) The sum of squared errors is divided by (n - 1)
* - 'uncorrected'        The sum of squared errors is divided by n
* - 'biased'             The sum of squared errors is divided by (n + 1)
*
* Note that older browser may not like the variable name `var`. In that
* case, the function can be called as `math['var'](...)` instead of
* `math.<span class="apidocCodeKeywordSpan">var</span>(...)`.
*
* Syntax:
*
*     math.var(a, b, c, ...)
*     math.var(A)
*     math.var(A, normalization)
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.xgcd" id="apidoc.element.mathjs.expression.mathWithTransform.xgcd">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>xgcd
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function xgcd(arg0, arg1) {
  "use strict";
  var name = 'xgcd';
  if (test0(arg0)) { // type: number
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: number, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature1(convert0(arg0), arg1); // signature: number, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(convert0(arg0), convert1(arg1)); // signature: number, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert2(arg1)); // signature: number, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert3(arg1)); // signature: number, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert4(arg1)); // signature: number, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'number,BigNumber');
  }
  if (test1(arg0)) { // type: BigNumber
    if (test1(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: BigNumber, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test0(arg1)) { // type: number (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: BigNumber, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert1(arg1)); // signature: BigNumber, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: string (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert5(arg1)); // signature: BigNumber, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: boolean (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert6(arg1)); // signature: BigNumber, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: null (convert to BigNumber)
      if (arguments.length === 2) {
        return signature1(arg0, convert7(arg1)); // signature: BigNumber, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'BigNumber');
  }
  if (test2(arg0)) { // type: Fraction (convert to BigNumber)
    if (test1(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature1(convert1(arg0), arg1); // signature: Fraction, BigNumber
      }
      if ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  /**
* Calculate the extended greatest common divisor for two values.
* See http://en.wikipedia.org/wiki/Extended_Euclidean_algorithm.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">xgcd</span>(a, b)
*
* Examples:
*
*    math.xgcd(8, 12);             // returns [4, -1, 1]
*    math.gcd(8, 12);              // returns 4
*    math.xgcd(36163, 21199);      // returns [1247, -7, 12]
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.xor" id="apidoc.element.mathjs.expression.mathWithTransform.xor">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>xor
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function xor(arg0, arg1) {
  "use strict";
  var name = 'xor';
  if (test0(arg0)) { // type: number
    if (test0(arg1)) { // type: number
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: number, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test1(arg1)) { // type: Complex
      if (arguments.length === 2) {
        return signature1(convert0(arg0), arg1); // signature: number, Complex
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature2(convert1(arg0), arg1); // signature: number, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: Fraction (convert to BigNumber)
      if (arguments.length === 2) {
        return signature2(convert1(arg0), convert2(arg1)); // signature: number, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: string (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert3(arg1)); // signature: number, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test5(arg1)) { // type: boolean (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert4(arg1)); // signature: number, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test6(arg1)) { // type: null (convert to number)
      if (arguments.length === 2) {
        return signature0(arg0, convert5(arg1)); // signature: number, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
  }
  if (test1(arg0)) { // type: Complex
    if (test1(arg1)) { // type: Complex
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Complex, Complex
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test0(arg1)) { // type: number (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert0(arg1)); // signature: Complex, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: BigNumber (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert6(arg1)); // signature: Complex, BigNumber
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: Fraction (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert7(arg1)); // signature: Complex, Fraction
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: string (convert to Complex)
      if (arguments.length === 2) {
        return signature1(arg0, convert8(arg1)); // signature: Complex, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
  }
  if (test2(arg0)) { // type: BigNumber
    if (test1(arg1)) { // type: Complex
      if (arguments.length === 2) {
        return signature1(convert6(arg0), arg1); // signature: BigNumber, Complex
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: BigNumber
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  /**
* Logical `xor`. Test whether one and only one value is defined with a nonzero/nonempty value.
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">xor</span>(x, y)
*
* Examples:
*
*    math.xor(2, 4);   // returns false
*
*    a = [2, 0, 0];
*    b = [2, 7, 0];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.zeros" id="apidoc.element.mathjs.expression.mathWithTransform.zeros">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.</span>zeros
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function zeros(arg0, arg1) {
  "use strict";
  var name = 'zeros';
  if (arguments.length === 0) {
    return signature0(); // signature:
  }
  if (test0(arg0)) { // type: Array
    if (arguments.length === 1) {
      return signature1(arg0); // signature: Array
    }
    if (test1(arg1)) { // type: string
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: Array, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: number (convert to string)
      if (arguments.length === 2) {
        return signature2(arg0, convert0(arg1)); // signature: Array, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: boolean (convert to string)
      if (arguments.length === 2) {
        return signature2(arg0, convert1(arg1)); // signature: Array, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: null (convert to string)
      if (arguments.length === 2) {
        return signature2(arg0, convert2(arg1)); // signature: Array, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'string');
  }
  if (test5(arg0)) { // type: Matrix
    if (arguments.length === 1) {
      return signature3(arg0); // signature: Matrix
    }
    if (test1(arg1)) { // type: string
      if (arguments.length === 2) {
        return signature2(arg0, arg1); // signature: Matrix, string
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test2(arg1)) { // type: number (convert to string)
      if (arguments.length === 2) {
        return signature2(arg0, convert0(arg1)); // signature: Matrix, number
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test3(arg1)) { // type: boolean (convert to string)
      if (arguments.length === 2) {
        return signature2(arg0, convert1(arg1)); // signature: Matrix, boolean
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    if (test4(arg1)) { // type: null (convert to string)
      if (arguments.length === 2) {
        return signature2(arg0, convert2(arg1)); // signature: Matrix, null
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'string');
  }
  if (test2(arg0) || test6(arg0) || test1(arg0) || test7(arg0) || test3(arg0) || test3(arg0) || test3(arg0) || test4(arg0) || test4
(arg0) || test4(arg0)) { // type: ...number|BigNumber|string|Fraction|boolean|null
    var varArgs = [arg0];
    for (var i = 1; i &lt; arguments.length; i++) {
      if (test2(arguments[i]) || test6(arguments[i]) || test1(arguments[i])) {
        varArgs.push(arguments[i]);
      }
      else if (test7(arguments[i])) {
        varArgs.push(convert3(arguments[i]));
      }
      else if (test3(arguments[i])) {
        varArgs.push(convert4(arguments[i]));
      }
      else if (test3(arguments[i])) {
        varArgs.push(convert5(arguments[i]));
      }
      else if (test3(arguments[i])) {
        varArgs.push(convert1(arguments[i]));
      }
      else if (test4(arguments[i])) {
        varArgs.push(convert6(arguments[i]));
      }
      else if (test4(arguments[i])) {
        varArgs.push(convert2(arguments[i]));
      }
      else if (test4(arguments[i])) {
        varArgs.push(convert7(arguments[i]));
      } else {
        throw createError(name, arguments.length, i, arguments[i], 'number,BigNumber,string');
      }
    }
    return signature4(varArgs); // signature: ...number|BigN ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*     math.squeeze(x)
*
* Examples:
*
*     math.squeeze([3]);           // returns 3
*     math.squeeze([[3]]);         // returns 3
*
*     var A = math.<span class="apidocCodeKeywordSpan">zeros</span>(3, 1);    // returns [[0], [0], [0]] (size 3x1)
*     math.squeeze(A);             // returns [0, 0, 0] (size 3)
*
*     var B = math.zeros(1, 3);    // returns [[0, 0, 0]] (size 1x3)
*     math.squeeze(B);             // returns [0, 0, 0] (size 3)
*
*     // only inner and outer dimensions are removed
*     var C = math.zeros(2, 1, 3); // returns [[[0, 0, 0]], [[0, 0, 0]]] (size 2x1x3)
...</pre></li>
    </ul>








































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.expression.mathWithTransform.AccessorNode.prototype" id="apidoc.module.mathjs.expression.mathWithTransform.AccessorNode.prototype">module mathjs.expression.mathWithTransform.AccessorNode.prototype</a></h1>




    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.AccessorNode.prototype._compile" id="apidoc.element.mathjs.expression.mathWithTransform.AccessorNode.prototype._compile">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.AccessorNode.prototype.</span>_compile
        <span class="apidocSignatureSpan">(defs, args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_compile = function (defs, args) {
  defs.access = access;
  defs.getSafeProperty = getSafeProperty;

  var object = this.object._compile(defs, args);
  var index = this.index._compile(defs, args);

  if (this.index.isObjectProperty()) {
    var prop = this.index.getObjectProperty();
    return 'getSafeProperty(' + object + ', "' + prop + '")';
  }
  else if (this.index.needsSize()) {
    // if some parameters use the 'end' parameter, we need to calculate the size
    return '(function () {' +
        '  var object = ' + object + ';' +
        '  var size = math.size(object).valueOf();' +
        '  return access(object, ' + index + ');' +
        '})()';
  }
  else {
    return 'access(' + object + ', ' + index + ')';
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * @return {string} js
   * @private
   */
  AccessorNode.prototype._compile = function (defs, args) {
defs.access = access;
defs.getSafeProperty = getSafeProperty;

var object = this.object.<span class="apidocCodeKeywordSpan">_compile</span>(defs, args);
var index = this.index._compile(defs, args);

if (this.index.isObjectProperty()) {
  var prop = this.index.getObjectProperty();
  return 'getSafeProperty(' + object + ', "' + prop + '")';
}
else if (this.index.needsSize()) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.AccessorNode.prototype._toString" id="apidoc.element.mathjs.expression.mathWithTransform.AccessorNode.prototype._toString">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.AccessorNode.prototype.</span>_toString
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_toString = function (options) {
  var object = this.object.toString(options);
  if (needParenthesis(this.object)) {
    object = '(' + object + ')';
  }

  return object + this.index.toString(options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      }
  }

  if (typeof customString !== 'undefined') {
    return customString;
  }

  return this.<span class="apidocCodeKeywordSpan">_toString</span>(options);
};

/**
 * Internal function to generate the string output.
 * This has to be implemented by every Node
 *
 * @throws {Error}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.AccessorNode.prototype._toTex" id="apidoc.element.mathjs.expression.mathWithTransform.AccessorNode.prototype._toTex">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.AccessorNode.prototype.</span>_toTex
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_toTex = function (options) {
  var object = this.object.toTex(options);
  if (needParenthesis(this.object)) {
    object = '\\left(' + object + '\\right)';
  }

  return object + this.index.toTex(options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
  }

  if (typeof customTex !== 'undefined') {
    return customTex;
  }

  return this.<span class="apidocCodeKeywordSpan">_toTex</span>(options);
};

/**
 * Internal function to generate the LaTeX output.
 * This has to be implemented by every Node
 *
 * @param {Object} [options]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.AccessorNode.prototype.clone" id="apidoc.element.mathjs.expression.mathWithTransform.AccessorNode.prototype.clone">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.AccessorNode.prototype.</span>clone
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clone = function () {
  return new AccessorNode(this.object, this.index);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return desc;
};

/**
 * Export the help object to JSON
 */
Help.prototype.toJSON = function () {
  var obj = object.<span class="apidocCodeKeywordSpan">clone</span>(this.doc);
  obj.mathjs = 'Help';
  return obj;
};

/**
 * Instantiate a Help object from a JSON object
 * @param {Object} json
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.AccessorNode.prototype.forEach" id="apidoc.element.mathjs.expression.mathWithTransform.AccessorNode.prototype.forEach">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.AccessorNode.prototype.</span>forEach
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEach = function (callback) {
  callback(this.object, 'object', this);
  callback(this.index, 'index', this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (def.indexOf(keyword) == 0) {
      matches.push(def);
    }
  }
}

// commandline keywords
['exit', 'quit', 'clear'].<span class="apidocCodeKeywordSpan">forEach</span>(function (cmd) {
  if (cmd.indexOf(keyword) == 0) {
    matches.push(cmd);
  }
});

// math functions and constants
var ignore = ['expr', 'type'];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.AccessorNode.prototype.map" id="apidoc.element.mathjs.expression.mathWithTransform.AccessorNode.prototype.map">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.AccessorNode.prototype.</span>map
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">map = function (callback) {
  return new AccessorNode(
      this._ifNode(callback(this.object, 'object', this)),
      this._ifNode(callback(this.index, 'index', this))
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (res &amp;&amp; res.isResultSet) {
  // we can have 0 or 1 results in the ResultSet, as the CLI
  // does not allow multiple expressions separated by a return
  res = res.entries[0];
  node = node.blocks
      .filter(function (entry) { return entry.visible; })
      .<span class="apidocCodeKeywordSpan">map</span>(function (entry) { return entry.node })[0];
}

if (node) {
  if (node.isAssignmentNode) {
    var name = findSymbolName(node);
    if (name != null) {
      scope.ans = scope[name];
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.expression.mathWithTransform.ArrayNode.prototype" id="apidoc.module.mathjs.expression.mathWithTransform.ArrayNode.prototype">module mathjs.expression.mathWithTransform.ArrayNode.prototype</a></h1>




    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.ArrayNode.prototype._compile" id="apidoc.element.mathjs.expression.mathWithTransform.ArrayNode.prototype._compile">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.ArrayNode.prototype.</span>_compile
        <span class="apidocSignatureSpan">(defs, args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_compile = function (defs, args) {
  var asMatrix = (defs.math.config().matrix !== 'Array');

  var items = this.items.map(function (node) {
    return node._compile(defs, args);
  });

  return (asMatrix ? 'math.matrix([' : '[') +
      items.join(',') +
      (asMatrix ? '])' : ']');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * @return {string} js
   * @private
   */
  AccessorNode.prototype._compile = function (defs, args) {
defs.access = access;
defs.getSafeProperty = getSafeProperty;

var object = this.object.<span class="apidocCodeKeywordSpan">_compile</span>(defs, args);
var index = this.index._compile(defs, args);

if (this.index.isObjectProperty()) {
  var prop = this.index.getObjectProperty();
  return 'getSafeProperty(' + object + ', "' + prop + '")';
}
else if (this.index.needsSize()) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.ArrayNode.prototype._toString" id="apidoc.element.mathjs.expression.mathWithTransform.ArrayNode.prototype._toString">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.ArrayNode.prototype.</span>_toString
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_toString = function (options) {
  var items = this.items.map(function (node) {
    return node.toString(options);
  });
  return '[' + items.join(', ') + ']';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      }
  }

  if (typeof customString !== 'undefined') {
    return customString;
  }

  return this.<span class="apidocCodeKeywordSpan">_toString</span>(options);
};

/**
 * Internal function to generate the string output.
 * This has to be implemented by every Node
 *
 * @throws {Error}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.ArrayNode.prototype._toTex" id="apidoc.element.mathjs.expression.mathWithTransform.ArrayNode.prototype._toTex">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.ArrayNode.prototype.</span>_toTex
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_toTex = function (options) {
  var s = '\\begin{bmatrix}';

  this.items.forEach(function(node) {
    if (node.items) {
      s += node.items.map(function(childNode) {
        return childNode.toTex(options);
      }).join('&amp;');
    }
    else {
      s += node.toTex(options);
    }

    // new line
    s += '\\\\';
  });
  s += '\\end{bmatrix}';
  return s;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
  }

  if (typeof customTex !== 'undefined') {
    return customTex;
  }

  return this.<span class="apidocCodeKeywordSpan">_toTex</span>(options);
};

/**
 * Internal function to generate the LaTeX output.
 * This has to be implemented by every Node
 *
 * @param {Object} [options]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.ArrayNode.prototype.clone" id="apidoc.element.mathjs.expression.mathWithTransform.ArrayNode.prototype.clone">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.ArrayNode.prototype.</span>clone
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clone = function () {
  return new ArrayNode(this.items.slice(0));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return desc;
};

/**
 * Export the help object to JSON
 */
Help.prototype.toJSON = function () {
  var obj = object.<span class="apidocCodeKeywordSpan">clone</span>(this.doc);
  obj.mathjs = 'Help';
  return obj;
};

/**
 * Instantiate a Help object from a JSON object
 * @param {Object} json
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.ArrayNode.prototype.forEach" id="apidoc.element.mathjs.expression.mathWithTransform.ArrayNode.prototype.forEach">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.ArrayNode.prototype.</span>forEach
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEach = function (callback) {
  for (var i = 0; i &lt; this.items.length; i++) {
    var node = this.items[i];
    callback(node, 'items[' + i + ']', this);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (def.indexOf(keyword) == 0) {
      matches.push(def);
    }
  }
}

// commandline keywords
['exit', 'quit', 'clear'].<span class="apidocCodeKeywordSpan">forEach</span>(function (cmd) {
  if (cmd.indexOf(keyword) == 0) {
    matches.push(cmd);
  }
});

// math functions and constants
var ignore = ['expr', 'type'];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.ArrayNode.prototype.map" id="apidoc.element.mathjs.expression.mathWithTransform.ArrayNode.prototype.map">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.ArrayNode.prototype.</span>map
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">map = function (callback) {
  var items = [];
  for (var i = 0; i &lt; this.items.length; i++) {
    items[i] = this._ifNode(callback(this.items[i], 'items[' + i + ']', this));
  }
  return new ArrayNode(items);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (res &amp;&amp; res.isResultSet) {
  // we can have 0 or 1 results in the ResultSet, as the CLI
  // does not allow multiple expressions separated by a return
  res = res.entries[0];
  node = node.blocks
      .filter(function (entry) { return entry.visible; })
      .<span class="apidocCodeKeywordSpan">map</span>(function (entry) { return entry.node })[0];
}

if (node) {
  if (node.isAssignmentNode) {
    var name = findSymbolName(node);
    if (name != null) {
      scope.ans = scope[name];
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.expression.mathWithTransform.AssignmentNode.prototype" id="apidoc.module.mathjs.expression.mathWithTransform.AssignmentNode.prototype">module mathjs.expression.mathWithTransform.AssignmentNode.prototype</a></h1>




    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.AssignmentNode.prototype._compile" id="apidoc.element.mathjs.expression.mathWithTransform.AssignmentNode.prototype._compile">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.AssignmentNode.prototype.</span>_compile
        <span class="apidocSignatureSpan">(defs, args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_compile = function (defs, args) {
  defs.assign = assign;
  defs.access = access;
  defs.getSafeProperty = getSafeProperty;
  defs.setSafeProperty = setSafeProperty;

  var size;
  var object = this.object._compile(defs, args);
  var index = this.index ? this.index._compile(defs, args) : null;
  var value = this.value._compile(defs, args);

  if (!this.index) {
    // apply a variable to the scope, for example `a=2`
    if (!this.object.isSymbolNode) {
      throw new TypeError('SymbolNode expected as object');
    }

    return 'setSafeProperty(scope, "' + this.object.name + '", ' + value + ')';
  }
  else if (this.index.isObjectProperty()) {
    // apply an object property for example `a.b=2`
    return 'setSafeProperty(' + object + ', "' + this.index.getObjectProperty() + '", ' + value + ')';
  }
  else if (this.object.isSymbolNode) {
    // update a matrix subset, for example `a[2]=3`
    size = this.index.needsSize() ? 'var size = math.size(object).valueOf();' : '';

    // apply updated object to scope
    return '(function () {' +
        '  var object = ' + object + ';' +
        '  var value = ' + value + ';' +
        '  ' + size +
        '  setSafeProperty(scope, "' + this.object.name + '", assign(object, ' + index + ', value));' +
        '  return value;' +
        '})()';
  }
  else { // this.object.isAccessorNode === true
    // update a matrix subset, for example `a.b[2]=3`
    size = this.index.needsSize() ? 'var size = math.size(object).valueOf();' : '';

    // we will not use the _compile of the AccessorNode, but compile it
    // ourselves here as we need the parent object of the AccessorNode:
    // wee need to apply the updated object to parent object
    var parentObject = this.object.object._compile(defs, args);

    if (this.object.index.isObjectProperty()) {
      var parentProperty = '"' + this.object.index.getObjectProperty() + '"';
      return '(function () {' +
          '  var parent = ' + parentObject + ';' +
          '  var object = getSafeProperty(parent, ' + parentProperty + ');' + // parentIndex is a property
          '  var value = ' + value + ';' +
          size +
          '  setSafeProperty(parent, ' + parentProperty + ', assign(object, ' + index + ', value));' +
          '  return value;' +
          '})()';
    }
    else {
      // if some parameters use the 'end' parameter, we need to calculate the size
      var parentSize = this.object.index.needsSize() ? 'var size = math.size(parent).valueOf();' : '';
      var parentIndex = this.object.index._compile(defs, args);

      return '(function () {' +
          '  var parent = ' + parentObject + ';' +
          '  ' + parentSize +
          '  var parentIndex = ' + parentIndex + ';' +
          '  var object = access(parent, parentIndex);' +
          '  var value = ' + value + ';' +
          '  ' + size +
          '  assign(parent, parentIndex, assign(object, ' + index + ', value));' +
          '  return value;' +
          '})()';
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * @return {string} js
   * @private
   */
  AccessorNode.prototype._compile = function (defs, args) {
defs.access = access;
defs.getSafeProperty = getSafeProperty;

var object = this.object.<span class="apidocCodeKeywordSpan">_compile</span>(defs, args);
var index = this.index._compile(defs, args);

if (this.index.isObjectProperty()) {
  var prop = this.index.getObjectProperty();
  return 'getSafeProperty(' + object + ', "' + prop + '")';
}
else if (this.index.needsSize()) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.AssignmentNode.prototype._toString" id="apidoc.element.mathjs.expression.mathWithTransform.AssignmentNode.prototype._toString">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.AssignmentNode.prototype.</span>_toString
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_toString = function (options) {
  var object = this.object.toString(options);
  var index = this.index ? this.index.toString(options) : '';
  var value = this.value.toString(options);
  if (needParenthesis(this, options &amp;&amp; options.parenthesis)) {
    value = '(' + value + ')';
  }

  return object + index + ' = ' + value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      }
  }

  if (typeof customString !== 'undefined') {
    return customString;
  }

  return this.<span class="apidocCodeKeywordSpan">_toString</span>(options);
};

/**
 * Internal function to generate the string output.
 * This has to be implemented by every Node
 *
 * @throws {Error}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.AssignmentNode.prototype._toTex" id="apidoc.element.mathjs.expression.mathWithTransform.AssignmentNode.prototype._toTex">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.AssignmentNode.prototype.</span>_toTex
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_toTex = function (options) {
  var object = this.object.toTex(options);
  var index = this.index ? this.index.toTex(options) : '';
  var value = this.value.toTex(options);
  if (needParenthesis(this, options &amp;&amp; options.parenthesis)) {
    value = '\\left(' + value + '\\right)';
  }

  return object + index + ':=' + value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
  }

  if (typeof customTex !== 'undefined') {
    return customTex;
  }

  return this.<span class="apidocCodeKeywordSpan">_toTex</span>(options);
};

/**
 * Internal function to generate the LaTeX output.
 * This has to be implemented by every Node
 *
 * @param {Object} [options]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.AssignmentNode.prototype.clone" id="apidoc.element.mathjs.expression.mathWithTransform.AssignmentNode.prototype.clone">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.AssignmentNode.prototype.</span>clone
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clone = function () {
  return new AssignmentNode(this.object, this.index, this.value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return desc;
};

/**
 * Export the help object to JSON
 */
Help.prototype.toJSON = function () {
  var obj = object.<span class="apidocCodeKeywordSpan">clone</span>(this.doc);
  obj.mathjs = 'Help';
  return obj;
};

/**
 * Instantiate a Help object from a JSON object
 * @param {Object} json
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.AssignmentNode.prototype.forEach" id="apidoc.element.mathjs.expression.mathWithTransform.AssignmentNode.prototype.forEach">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.AssignmentNode.prototype.</span>forEach
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEach = function (callback) {
  callback(this.object, 'object', this);
  if (this.index) {
    callback(this.index, 'index', this);
  }
  callback(this.value, 'value', this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (def.indexOf(keyword) == 0) {
      matches.push(def);
    }
  }
}

// commandline keywords
['exit', 'quit', 'clear'].<span class="apidocCodeKeywordSpan">forEach</span>(function (cmd) {
  if (cmd.indexOf(keyword) == 0) {
    matches.push(cmd);
  }
});

// math functions and constants
var ignore = ['expr', 'type'];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.AssignmentNode.prototype.map" id="apidoc.element.mathjs.expression.mathWithTransform.AssignmentNode.prototype.map">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.AssignmentNode.prototype.</span>map
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">map = function (callback) {
  var object = this._ifNode(callback(this.object, 'object', this));
  var index = this.index
      ? this._ifNode(callback(this.index, 'index', this))
      : null;
  var value = this._ifNode(callback(this.value, 'value', this));

  return new AssignmentNode(object, index, value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (res &amp;&amp; res.isResultSet) {
  // we can have 0 or 1 results in the ResultSet, as the CLI
  // does not allow multiple expressions separated by a return
  res = res.entries[0];
  node = node.blocks
      .filter(function (entry) { return entry.visible; })
      .<span class="apidocCodeKeywordSpan">map</span>(function (entry) { return entry.node })[0];
}

if (node) {
  if (node.isAssignmentNode) {
    var name = findSymbolName(node);
    if (name != null) {
      scope.ans = scope[name];
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.expression.mathWithTransform.BlockNode.prototype" id="apidoc.module.mathjs.expression.mathWithTransform.BlockNode.prototype">module mathjs.expression.mathWithTransform.BlockNode.prototype</a></h1>




    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.BlockNode.prototype._compile" id="apidoc.element.mathjs.expression.mathWithTransform.BlockNode.prototype._compile">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.BlockNode.prototype.</span>_compile
        <span class="apidocSignatureSpan">(defs, args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_compile = function (defs, args) {
  defs.ResultSet = ResultSet;
  var blocks = this.blocks.map(function (param) {
    var js = param.node._compile(defs, args);
    if (param.visible) {
      return 'results.push(' + js + ');';
    }
    else {
      return js + ';';
    }
  });

  return '(function () {' +
      'var results = [];' +
      blocks.join('') +
      'return new ResultSet(results);' +
      '})()';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * @return {string} js
   * @private
   */
  AccessorNode.prototype._compile = function (defs, args) {
defs.access = access;
defs.getSafeProperty = getSafeProperty;

var object = this.object.<span class="apidocCodeKeywordSpan">_compile</span>(defs, args);
var index = this.index._compile(defs, args);

if (this.index.isObjectProperty()) {
  var prop = this.index.getObjectProperty();
  return 'getSafeProperty(' + object + ', "' + prop + '")';
}
else if (this.index.needsSize()) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.BlockNode.prototype._toString" id="apidoc.element.mathjs.expression.mathWithTransform.BlockNode.prototype._toString">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.BlockNode.prototype.</span>_toString
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_toString = function (options) {
  return this.blocks.map(function (param) {
    return param.node.toString(options) + (param.visible ? '' : ';');
  }).join('\n');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      }
  }

  if (typeof customString !== 'undefined') {
    return customString;
  }

  return this.<span class="apidocCodeKeywordSpan">_toString</span>(options);
};

/**
 * Internal function to generate the string output.
 * This has to be implemented by every Node
 *
 * @throws {Error}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.BlockNode.prototype._toTex" id="apidoc.element.mathjs.expression.mathWithTransform.BlockNode.prototype._toTex">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.BlockNode.prototype.</span>_toTex
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_toTex = function (options) {
  return this.blocks.map(function (param) {
    return param.node.toTex(options) + (param.visible ? '' : ';');
  }).join('\\;\\;\n');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
  }

  if (typeof customTex !== 'undefined') {
    return customTex;
  }

  return this.<span class="apidocCodeKeywordSpan">_toTex</span>(options);
};

/**
 * Internal function to generate the LaTeX output.
 * This has to be implemented by every Node
 *
 * @param {Object} [options]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.BlockNode.prototype.clone" id="apidoc.element.mathjs.expression.mathWithTransform.BlockNode.prototype.clone">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.BlockNode.prototype.</span>clone
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clone = function () {
  var blocks = this.blocks.map(function (block) {
    return {
      node: block.node,
      visible: block.visible
    };
  });

  return new BlockNode(blocks);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return desc;
};

/**
 * Export the help object to JSON
 */
Help.prototype.toJSON = function () {
  var obj = object.<span class="apidocCodeKeywordSpan">clone</span>(this.doc);
  obj.mathjs = 'Help';
  return obj;
};

/**
 * Instantiate a Help object from a JSON object
 * @param {Object} json
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.BlockNode.prototype.forEach" id="apidoc.element.mathjs.expression.mathWithTransform.BlockNode.prototype.forEach">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.BlockNode.prototype.</span>forEach
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEach = function (callback) {
  for (var i = 0; i &lt; this.blocks.length; i++) {
    callback(this.blocks[i].node, 'blocks[' + i + '].node', this);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (def.indexOf(keyword) == 0) {
      matches.push(def);
    }
  }
}

// commandline keywords
['exit', 'quit', 'clear'].<span class="apidocCodeKeywordSpan">forEach</span>(function (cmd) {
  if (cmd.indexOf(keyword) == 0) {
    matches.push(cmd);
  }
});

// math functions and constants
var ignore = ['expr', 'type'];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.BlockNode.prototype.map" id="apidoc.element.mathjs.expression.mathWithTransform.BlockNode.prototype.map">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.BlockNode.prototype.</span>map
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">map = function (callback) {
  var blocks = [];
  for (var i = 0; i &lt; this.blocks.length; i++) {
    var block = this.blocks[i];
    var node = this._ifNode(callback(block.node, 'blocks[' + i + '].node', this));
    blocks[i] = {
      node: node,
      visible: block.visible
    };
  }
  return new BlockNode(blocks);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (res &amp;&amp; res.isResultSet) {
  // we can have 0 or 1 results in the ResultSet, as the CLI
  // does not allow multiple expressions separated by a return
  res = res.entries[0];
  node = node.blocks
      .filter(function (entry) { return entry.visible; })
      .<span class="apidocCodeKeywordSpan">map</span>(function (entry) { return entry.node })[0];
}

if (node) {
  if (node.isAssignmentNode) {
    var name = findSymbolName(node);
    if (name != null) {
      scope.ans = scope[name];
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.expression.mathWithTransform.ConditionalNode.prototype" id="apidoc.module.mathjs.expression.mathWithTransform.ConditionalNode.prototype">module mathjs.expression.mathWithTransform.ConditionalNode.prototype</a></h1>




    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.ConditionalNode.prototype._compile" id="apidoc.element.mathjs.expression.mathWithTransform.ConditionalNode.prototype._compile">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.ConditionalNode.prototype.</span>_compile
        <span class="apidocSignatureSpan">(defs, args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_compile = function (defs, args) {
<span class="apidocCodeCommentSpan">  /**
   * Test whether a condition is met
   * @param {*} condition
   * @returns {boolean} true if condition is true or non-zero, else false
   */
</span>  defs.testCondition = function (condition) {
    if (typeof condition === 'number'
        || typeof condition === 'boolean'
        || typeof condition === 'string') {
      return condition ? true : false;
    }

    if (condition) {
      if (condition.isBigNumber === true) {
        return condition.isZero() ? false : true;
      }

      if (condition.isComplex === true) {
        return (condition.re || condition.im) ? true : false;
      }

      if (condition.isUnit === true) {
        return condition.value ? true : false;
      }
    }

    if (condition === null || condition === undefined) {
      return false;
    }

    throw new TypeError('Unsupported type of condition "' + defs.math['typeof'](condition) + '"');
  };

  return (
    'testCondition(' + this.condition._compile(defs, args) + ') ? ' +
    '( ' + this.trueExpr._compile(defs, args) + ') : ' +
    '( ' + this.falseExpr._compile(defs, args) + ')'
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * @return {string} js
   * @private
   */
  AccessorNode.prototype._compile = function (defs, args) {
defs.access = access;
defs.getSafeProperty = getSafeProperty;

var object = this.object.<span class="apidocCodeKeywordSpan">_compile</span>(defs, args);
var index = this.index._compile(defs, args);

if (this.index.isObjectProperty()) {
  var prop = this.index.getObjectProperty();
  return 'getSafeProperty(' + object + ', "' + prop + '")';
}
else if (this.index.needsSize()) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.ConditionalNode.prototype._toString" id="apidoc.element.mathjs.expression.mathWithTransform.ConditionalNode.prototype._toString">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.ConditionalNode.prototype.</span>_toString
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_toString = function (options) {
  var parenthesis = (options &amp;&amp; options.parenthesis) ? options.parenthesis : 'keep';
  var precedence = operators.getPrecedence(this, parenthesis);

  //Enclose Arguments in parentheses if they are an OperatorNode
  //or have lower or equal precedence
  //NOTE: enclosing all OperatorNodes in parentheses is a decision
  //purely based on aesthetics and readability
  var condition = this.condition.toString(options);
  var conditionPrecedence = operators.getPrecedence(this.condition, parenthesis);
  if ((parenthesis === 'all')
      || (this.condition.type === 'OperatorNode')
      || ((conditionPrecedence !== null) &amp;&amp; (conditionPrecedence &lt;= precedence))) {
    condition = '(' + condition + ')';
  }

  var trueExpr = this.trueExpr.toString(options);
  var truePrecedence = operators.getPrecedence(this.trueExpr, parenthesis);
  if ((parenthesis === 'all')
      || (this.trueExpr.type === 'OperatorNode')
      || ((truePrecedence !== null) &amp;&amp; (truePrecedence &lt;= precedence))) {
    trueExpr = '(' + trueExpr + ')';
  }

  var falseExpr = this.falseExpr.toString(options);
  var falsePrecedence = operators.getPrecedence(this.falseExpr, parenthesis);
  if ((parenthesis === 'all')
      || (this.falseExpr.type === 'OperatorNode')
      || ((falsePrecedence !== null) &amp;&amp; (falsePrecedence &lt;= precedence))) {
    falseExpr = '(' + falseExpr + ')';
  }
  return condition + ' ? ' + trueExpr + ' : ' + falseExpr;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      }
  }

  if (typeof customString !== 'undefined') {
    return customString;
  }

  return this.<span class="apidocCodeKeywordSpan">_toString</span>(options);
};

/**
 * Internal function to generate the string output.
 * This has to be implemented by every Node
 *
 * @throws {Error}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.ConditionalNode.prototype._toTex" id="apidoc.element.mathjs.expression.mathWithTransform.ConditionalNode.prototype._toTex">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.ConditionalNode.prototype.</span>_toTex
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_toTex = function (options) {
  return '\\begin{cases} {'
      + this.trueExpr.toTex(options) + '}, &amp;\\quad{\\text{if }\\;'
      + this.condition.toTex(options)
      + '}\\\\{' + this.falseExpr.toTex(options)
      + '}, &amp;\\quad{\\text{otherwise}}\\end{cases}';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
  }

  if (typeof customTex !== 'undefined') {
    return customTex;
  }

  return this.<span class="apidocCodeKeywordSpan">_toTex</span>(options);
};

/**
 * Internal function to generate the LaTeX output.
 * This has to be implemented by every Node
 *
 * @param {Object} [options]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.ConditionalNode.prototype.clone" id="apidoc.element.mathjs.expression.mathWithTransform.ConditionalNode.prototype.clone">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.ConditionalNode.prototype.</span>clone
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clone = function () {
  return new ConditionalNode(this.condition, this.trueExpr, this.falseExpr);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return desc;
};

/**
 * Export the help object to JSON
 */
Help.prototype.toJSON = function () {
  var obj = object.<span class="apidocCodeKeywordSpan">clone</span>(this.doc);
  obj.mathjs = 'Help';
  return obj;
};

/**
 * Instantiate a Help object from a JSON object
 * @param {Object} json
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.ConditionalNode.prototype.forEach" id="apidoc.element.mathjs.expression.mathWithTransform.ConditionalNode.prototype.forEach">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.ConditionalNode.prototype.</span>forEach
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEach = function (callback) {
  callback(this.condition, 'condition', this);
  callback(this.trueExpr, 'trueExpr', this);
  callback(this.falseExpr, 'falseExpr', this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (def.indexOf(keyword) == 0) {
      matches.push(def);
    }
  }
}

// commandline keywords
['exit', 'quit', 'clear'].<span class="apidocCodeKeywordSpan">forEach</span>(function (cmd) {
  if (cmd.indexOf(keyword) == 0) {
    matches.push(cmd);
  }
});

// math functions and constants
var ignore = ['expr', 'type'];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.ConditionalNode.prototype.map" id="apidoc.element.mathjs.expression.mathWithTransform.ConditionalNode.prototype.map">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.ConditionalNode.prototype.</span>map
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">map = function (callback) {
  return new ConditionalNode(
      this._ifNode(callback(this.condition, 'condition', this)),
      this._ifNode(callback(this.trueExpr, 'trueExpr', this)),
      this._ifNode(callback(this.falseExpr, 'falseExpr', this))
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (res &amp;&amp; res.isResultSet) {
  // we can have 0 or 1 results in the ResultSet, as the CLI
  // does not allow multiple expressions separated by a return
  res = res.entries[0];
  node = node.blocks
      .filter(function (entry) { return entry.visible; })
      .<span class="apidocCodeKeywordSpan">map</span>(function (entry) { return entry.node })[0];
}

if (node) {
  if (node.isAssignmentNode) {
    var name = findSymbolName(node);
    if (name != null) {
      scope.ans = scope[name];
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.expression.mathWithTransform.ConstantNode.prototype" id="apidoc.module.mathjs.expression.mathWithTransform.ConstantNode.prototype">module mathjs.expression.mathWithTransform.ConstantNode.prototype</a></h1>




    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.ConstantNode.prototype._compile" id="apidoc.element.mathjs.expression.mathWithTransform.ConstantNode.prototype._compile">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.ConstantNode.prototype.</span>_compile
        <span class="apidocSignatureSpan">(defs, args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_compile = function (defs, args) {
  switch (this.valueType) {
    case 'number':
      // TODO: replace this with using config.number
      var numConfig = defs.math.config().number;
      if (numConfig === 'BigNumber') {
        return 'math.bignumber("' + this.value + '")';
      }
      else if (numConfig === 'Fraction') {
        return 'math.fraction("' + this.value + '")';
      }
      else {
        // remove leading zeros like '003.2' which are not allowed by JavaScript
        return this.value.replace(/^(0*)[0-9]/, function (match, zeros) {
          return match.substring(zeros.length);
        });
      }

    case 'string':
      return '"' + this.value + '"';

    case 'boolean':
      return this.value;

    case 'undefined':
      return this.value;

    case 'null':
      return this.value;

    default:
      // TODO: move this error to the constructor?
      throw new TypeError('Unsupported type of constant "' + this.valueType + '"');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * @return {string} js
   * @private
   */
  AccessorNode.prototype._compile = function (defs, args) {
defs.access = access;
defs.getSafeProperty = getSafeProperty;

var object = this.object.<span class="apidocCodeKeywordSpan">_compile</span>(defs, args);
var index = this.index._compile(defs, args);

if (this.index.isObjectProperty()) {
  var prop = this.index.getObjectProperty();
  return 'getSafeProperty(' + object + ', "' + prop + '")';
}
else if (this.index.needsSize()) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.ConstantNode.prototype._toString" id="apidoc.element.mathjs.expression.mathWithTransform.ConstantNode.prototype._toString">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.ConstantNode.prototype.</span>_toString
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_toString = function (options) {
  switch (this.valueType) {
    case 'string':
      return '"' + this.value + '"';

    default:
      return this.value;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      }
  }

  if (typeof customString !== 'undefined') {
    return customString;
  }

  return this.<span class="apidocCodeKeywordSpan">_toString</span>(options);
};

/**
 * Internal function to generate the string output.
 * This has to be implemented by every Node
 *
 * @throws {Error}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.ConstantNode.prototype._toTex" id="apidoc.element.mathjs.expression.mathWithTransform.ConstantNode.prototype._toTex">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.ConstantNode.prototype.</span>_toTex
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_toTex = function (options) {
  var value = this.value,
      index;
  switch (this.valueType) {
    case 'string':
      return '\\mathtt{"' + value + '"}';

    case 'number':
      index = value.toLowerCase().indexOf('e');
      if (index !== -1) {
        return value.substring(0, index) + '\\cdot10^{' +
            value.substring(index + 1) + '}';
      }
      return value;

    default:
      return value;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
  }

  if (typeof customTex !== 'undefined') {
    return customTex;
  }

  return this.<span class="apidocCodeKeywordSpan">_toTex</span>(options);
};

/**
 * Internal function to generate the LaTeX output.
 * This has to be implemented by every Node
 *
 * @param {Object} [options]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.ConstantNode.prototype.clone" id="apidoc.element.mathjs.expression.mathWithTransform.ConstantNode.prototype.clone">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.ConstantNode.prototype.</span>clone
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clone = function () {
  return new ConstantNode(this.value, this.valueType);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return desc;
};

/**
 * Export the help object to JSON
 */
Help.prototype.toJSON = function () {
  var obj = object.<span class="apidocCodeKeywordSpan">clone</span>(this.doc);
  obj.mathjs = 'Help';
  return obj;
};

/**
 * Instantiate a Help object from a JSON object
 * @param {Object} json
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.ConstantNode.prototype.forEach" id="apidoc.element.mathjs.expression.mathWithTransform.ConstantNode.prototype.forEach">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.ConstantNode.prototype.</span>forEach
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEach = function (callback) {
  // nothing to do, we don't have childs
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (def.indexOf(keyword) == 0) {
      matches.push(def);
    }
  }
}

// commandline keywords
['exit', 'quit', 'clear'].<span class="apidocCodeKeywordSpan">forEach</span>(function (cmd) {
  if (cmd.indexOf(keyword) == 0) {
    matches.push(cmd);
  }
});

// math functions and constants
var ignore = ['expr', 'type'];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.ConstantNode.prototype.map" id="apidoc.element.mathjs.expression.mathWithTransform.ConstantNode.prototype.map">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.ConstantNode.prototype.</span>map
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">map = function (callback) {
  return this.clone();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (res &amp;&amp; res.isResultSet) {
  // we can have 0 or 1 results in the ResultSet, as the CLI
  // does not allow multiple expressions separated by a return
  res = res.entries[0];
  node = node.blocks
      .filter(function (entry) { return entry.visible; })
      .<span class="apidocCodeKeywordSpan">map</span>(function (entry) { return entry.node })[0];
}

if (node) {
  if (node.isAssignmentNode) {
    var name = findSymbolName(node);
    if (name != null) {
      scope.ans = scope[name];
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.expression.mathWithTransform.FunctionAssignmentNode.prototype" id="apidoc.module.mathjs.expression.mathWithTransform.FunctionAssignmentNode.prototype">module mathjs.expression.mathWithTransform.FunctionAssignmentNode.prototype</a></h1>




    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.FunctionAssignmentNode.prototype._compile" id="apidoc.element.mathjs.expression.mathWithTransform.FunctionAssignmentNode.prototype._compile">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.FunctionAssignmentNode.prototype.</span>_compile
        <span class="apidocSignatureSpan">(defs, args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_compile = function (defs, args) {
  defs.typed = typed;
  defs.setSafeProperty = setSafeProperty;

  // we extend the original args and add the args to the child object
  var childArgs = Object.create(args);
  this.params.forEach(function (variable) {
    childArgs[variable] = true;
  });

  // compile the function expression with the child args
  var jsExpr = this.expr._compile(defs, childArgs);

  return 'setSafeProperty(scope, "' + this.name + '", ' +
      '  (function () {' +
      '    var fn = typed("' + this.name + '", {' +
      '      "' + this.types.join(',') + '": function (' + this.params.join(',') + ') {' +
      '        return ' + jsExpr + '' +
      '      }' +
      '    });' +
      '    fn.syntax = "' + this.name + '(' + this.params.join(', ') + ')";' +
      '    return fn;' +
      '  })())';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * @return {string} js
   * @private
   */
  AccessorNode.prototype._compile = function (defs, args) {
defs.access = access;
defs.getSafeProperty = getSafeProperty;

var object = this.object.<span class="apidocCodeKeywordSpan">_compile</span>(defs, args);
var index = this.index._compile(defs, args);

if (this.index.isObjectProperty()) {
  var prop = this.index.getObjectProperty();
  return 'getSafeProperty(' + object + ', "' + prop + '")';
}
else if (this.index.needsSize()) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.FunctionAssignmentNode.prototype._toString" id="apidoc.element.mathjs.expression.mathWithTransform.FunctionAssignmentNode.prototype._toString">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.FunctionAssignmentNode.prototype.</span>_toString
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_toString = function (options) {
  var parenthesis = (options &amp;&amp; options.parenthesis) ? options.parenthesis : 'keep';
  var expr = this.expr.toString(options);
  if (needParenthesis(this, parenthesis)) {
    expr = '(' + expr + ')';
  }
  return this.name + '(' + this.params.join(', ') + ') = ' + expr;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      }
  }

  if (typeof customString !== 'undefined') {
    return customString;
  }

  return this.<span class="apidocCodeKeywordSpan">_toString</span>(options);
};

/**
 * Internal function to generate the string output.
 * This has to be implemented by every Node
 *
 * @throws {Error}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.FunctionAssignmentNode.prototype._toTex" id="apidoc.element.mathjs.expression.mathWithTransform.FunctionAssignmentNode.prototype._toTex">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.FunctionAssignmentNode.prototype.</span>_toTex
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_toTex = function (options) {
  var parenthesis = (options &amp;&amp; options.parenthesis) ? options.parenthesis : 'keep';
  var expr = this.expr.toTex(options);
  if (needParenthesis(this, parenthesis)) {
    expr = '\\left(' + expr + '\\right)';
  }

  return '\\mathrm{' + this.name
      + '}\\left(' + this.params.map(latex.toSymbol).join(',') + '\\right):=' + expr;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
  }

  if (typeof customTex !== 'undefined') {
    return customTex;
  }

  return this.<span class="apidocCodeKeywordSpan">_toTex</span>(options);
};

/**
 * Internal function to generate the LaTeX output.
 * This has to be implemented by every Node
 *
 * @param {Object} [options]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.FunctionAssignmentNode.prototype.clone" id="apidoc.element.mathjs.expression.mathWithTransform.FunctionAssignmentNode.prototype.clone">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.FunctionAssignmentNode.prototype.</span>clone
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clone = function () {
  return new FunctionAssignmentNode(this.name, this.params.slice(0), this.expr);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return desc;
};

/**
 * Export the help object to JSON
 */
Help.prototype.toJSON = function () {
  var obj = object.<span class="apidocCodeKeywordSpan">clone</span>(this.doc);
  obj.mathjs = 'Help';
  return obj;
};

/**
 * Instantiate a Help object from a JSON object
 * @param {Object} json
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.FunctionAssignmentNode.prototype.forEach" id="apidoc.element.mathjs.expression.mathWithTransform.FunctionAssignmentNode.prototype.forEach">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.FunctionAssignmentNode.prototype.</span>forEach
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEach = function (callback) {
  callback(this.expr, 'expr', this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (def.indexOf(keyword) == 0) {
      matches.push(def);
    }
  }
}

// commandline keywords
['exit', 'quit', 'clear'].<span class="apidocCodeKeywordSpan">forEach</span>(function (cmd) {
  if (cmd.indexOf(keyword) == 0) {
    matches.push(cmd);
  }
});

// math functions and constants
var ignore = ['expr', 'type'];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.FunctionAssignmentNode.prototype.map" id="apidoc.element.mathjs.expression.mathWithTransform.FunctionAssignmentNode.prototype.map">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.FunctionAssignmentNode.prototype.</span>map
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">map = function (callback) {
  var expr = this._ifNode(callback(this.expr, 'expr', this));

  return new FunctionAssignmentNode(this.name, this.params.slice(0), expr);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (res &amp;&amp; res.isResultSet) {
  // we can have 0 or 1 results in the ResultSet, as the CLI
  // does not allow multiple expressions separated by a return
  res = res.entries[0];
  node = node.blocks
      .filter(function (entry) { return entry.visible; })
      .<span class="apidocCodeKeywordSpan">map</span>(function (entry) { return entry.node })[0];
}

if (node) {
  if (node.isAssignmentNode) {
    var name = findSymbolName(node);
    if (name != null) {
      scope.ans = scope[name];
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.expression.mathWithTransform.FunctionNode.prototype" id="apidoc.module.mathjs.expression.mathWithTransform.FunctionNode.prototype">module mathjs.expression.mathWithTransform.FunctionNode.prototype</a></h1>




    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.FunctionNode.prototype._compile" id="apidoc.element.mathjs.expression.mathWithTransform.FunctionNode.prototype._compile">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.FunctionNode.prototype.</span>_compile
        <span class="apidocSignatureSpan">(defs, args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_compile = function (defs, args) {
  // compile fn and arguments
  var jsFn = this.fn._compile(defs, args);
  var jsArgs = this.args.map(function (arg) {
    return arg._compile(defs, args);
  });
  var jsScope = this._compileScope(defs, args);
  var argsName;

  if (this.fn.isSymbolNode) {
    // we can statically determine whether the function has an rawArgs property
    var name = this.fn.name;
    var fn = defs.math[name];
    var isRaw = (typeof fn === 'function') &amp;&amp; (fn.rawArgs == true);

    if (isRaw) {
      // pass unevaluated parameters (nodes) to the function
      argsName = this._getUniqueArgumentsName(defs);
      defs[argsName] = this.args;

      return jsFn + '(' + argsName + ', math, ' + jsScope + ')';
    }
    else {
      // "regular" evaluation
      return jsFn + '(' + jsArgs.join(', ') + ')';
    }
  }
  else if (this.fn.isAccessorNode &amp;&amp; this.fn.index.isObjectProperty()) {
    // execute the function with the right context: the object of the AccessorNode
    argsName = this._getUniqueArgumentsName(defs);
    defs[argsName] = this.args;
    defs.validateSafeMethod = validateSafeMethod

    var jsObject = this.fn.object._compile(defs, args);
    var prop = this.fn.index.getObjectProperty();

    return '(function () {' +
        'var object = ' + jsObject + ';' +
        'validateSafeMethod(object, "' + prop + '");' +
        'return (object["' + prop + '"] &amp;&amp; object["' + prop + '"].rawArgs) ' +
        ' ? object["' + prop + '"](' + argsName + ', math, ' + jsScope + ')' +
        ' : object["' + prop + '"](' + jsArgs.join(', ') + ')' +
        '})()';
  }
  else { // this.fn.isAccessorNode &amp;&amp; !this.fn.index.isObjectProperty()
    // we have to dynamically determine whether the function has a rawArgs property
    argsName = this._getUniqueArgumentsName(defs);
    defs[argsName] = this.args;

    return '(function () {' +
        'var fn = ' + jsFn + ';' +
        'return (fn &amp;&amp; fn.rawArgs) ' +
        ' ? fn(' + argsName + ', math, ' + jsScope + ')' +
        ' : fn(' + jsArgs.join(', ') + ')' +
        '})()';
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * @return {string} js
   * @private
   */
  AccessorNode.prototype._compile = function (defs, args) {
defs.access = access;
defs.getSafeProperty = getSafeProperty;

var object = this.object.<span class="apidocCodeKeywordSpan">_compile</span>(defs, args);
var index = this.index._compile(defs, args);

if (this.index.isObjectProperty()) {
  var prop = this.index.getObjectProperty();
  return 'getSafeProperty(' + object + ', "' + prop + '")';
}
else if (this.index.needsSize()) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.FunctionNode.prototype._compileScope" id="apidoc.element.mathjs.expression.mathWithTransform.FunctionNode.prototype._compileScope">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.FunctionNode.prototype.</span>_compileScope
        <span class="apidocSignatureSpan">(defs, args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_compileScope = function (defs, args) {
  var names = Object.keys(args);
  if (names.length === 0) {
    return 'scope';
  }
  else {
    // merge arguments into scope
    defs.extend = extend;

    var jsArgs = names
        .map(function (arg) {
          return '"' + arg + '": ' + arg;
        })
        .join(', ');

    return 'extend(extend({}, scope), {' + jsArgs + '})';
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   */
  FunctionNode.prototype._compile = function (defs, args) {
// compile fn and arguments
var jsFn = this.fn._compile(defs, args);
var jsArgs = this.args.map(function (arg) {
  return arg._compile(defs, args);
});
var jsScope = this.<span class="apidocCodeKeywordSpan">_compileScope</span>(defs, args);
var argsName;

if (this.fn.isSymbolNode) {
  // we can statically determine whether the function has an rawArgs property
  var name = this.fn.name;
  var fn = defs.math[name];
  var isRaw = (typeof fn === 'function') &amp;&amp; (fn.rawArgs == true);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.FunctionNode.prototype._getUniqueArgumentsName" id="apidoc.element.mathjs.expression.mathWithTransform.FunctionNode.prototype._getUniqueArgumentsName">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.FunctionNode.prototype.</span>_getUniqueArgumentsName
        <span class="apidocSignatureSpan">(defs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getUniqueArgumentsName = function (defs) {
  var argsName;
  var i = 0;

  do {
    argsName = 'args' + i;
    i++;
  }
  while (argsName in defs);

  return argsName;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// we can statically determine whether the function has an rawArgs property
var name = this.fn.name;
var fn = defs.math[name];
var isRaw = (typeof fn === 'function') &amp;&amp; (fn.rawArgs == true);

if (isRaw) {
  // pass unevaluated parameters (nodes) to the function
  argsName = this.<span class="apidocCodeKeywordSpan">_getUniqueArgumentsName</span>(defs);
  defs[argsName] = this.args;

  return jsFn + '(' + argsName + ', math, ' + jsScope + ')';
}
else {
  // "regular" evaluation
  return jsFn + '(' + jsArgs.join(', ') + ')';
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.FunctionNode.prototype._toString" id="apidoc.element.mathjs.expression.mathWithTransform.FunctionNode.prototype._toString">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.FunctionNode.prototype.</span>_toString
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_toString = function (options) {
  var args = this.args.map(function (arg) {
    return arg.toString(options);
  });

  // format the arguments like "add(2, 4.2)"
  return this.fn.toString(options) + '(' + args.join(', ') + ')';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      }
  }

  if (typeof customString !== 'undefined') {
    return customString;
  }

  return this.<span class="apidocCodeKeywordSpan">_toString</span>(options);
};

/**
 * Internal function to generate the string output.
 * This has to be implemented by every Node
 *
 * @throws {Error}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.FunctionNode.prototype._toTex" id="apidoc.element.mathjs.expression.mathWithTransform.FunctionNode.prototype._toTex">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.FunctionNode.prototype.</span>_toTex
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_toTex = function (options) {
  var args = this.args.map(function (arg) { //get LaTeX of the arguments
    return arg.toTex(options);
  });

  var latexConverter;

  if (math[this.name] &amp;&amp; ((typeof math[this.name].toTex === 'function') || (typeof math[this.name].toTex === 'object') || (typeof
 math[this.name].toTex === 'string'))) {
    //.toTex is a callback function
    latexConverter = math[this.name].toTex;
  }

  var customToTex;
  switch (typeof latexConverter) {
    case 'function': //a callback function
      customToTex = latexConverter(this, options);
      break;
    case 'string': //a template string
      customToTex = expandTemplate(latexConverter, this, options);
      break;
    case 'object': //an object with different "converters" for different numbers of arguments
      switch (typeof latexConverter[args.length]) {
        case 'function':
          customToTex = latexConverter[args.length](this, options);
          break;
        case 'string':
          customToTex = expandTemplate(latexConverter[args.length], this, options);
          break;
      }
  }

  if (typeof customToTex !== 'undefined') {
    return customToTex;
  }

  return expandTemplate(latex.defaultTemplate, this, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
  }

  if (typeof customTex !== 'undefined') {
    return customTex;
  }

  return this.<span class="apidocCodeKeywordSpan">_toTex</span>(options);
};

/**
 * Internal function to generate the LaTeX output.
 * This has to be implemented by every Node
 *
 * @param {Object} [options]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.FunctionNode.prototype.clone" id="apidoc.element.mathjs.expression.mathWithTransform.FunctionNode.prototype.clone">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.FunctionNode.prototype.</span>clone
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clone = function () {
  return new FunctionNode(this.fn, this.args.slice(0));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return desc;
};

/**
 * Export the help object to JSON
 */
Help.prototype.toJSON = function () {
  var obj = object.<span class="apidocCodeKeywordSpan">clone</span>(this.doc);
  obj.mathjs = 'Help';
  return obj;
};

/**
 * Instantiate a Help object from a JSON object
 * @param {Object} json
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.FunctionNode.prototype.forEach" id="apidoc.element.mathjs.expression.mathWithTransform.FunctionNode.prototype.forEach">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.FunctionNode.prototype.</span>forEach
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEach = function (callback) {
  for (var i = 0; i &lt; this.args.length; i++) {
    callback(this.args[i], 'args[' + i + ']', this);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (def.indexOf(keyword) == 0) {
      matches.push(def);
    }
  }
}

// commandline keywords
['exit', 'quit', 'clear'].<span class="apidocCodeKeywordSpan">forEach</span>(function (cmd) {
  if (cmd.indexOf(keyword) == 0) {
    matches.push(cmd);
  }
});

// math functions and constants
var ignore = ['expr', 'type'];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.FunctionNode.prototype.getIdentifier" id="apidoc.element.mathjs.expression.mathWithTransform.FunctionNode.prototype.getIdentifier">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.FunctionNode.prototype.</span>getIdentifier
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getIdentifier = function () {
  return this.type + ':' + this.name;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
function getPrecedence (_node, parenthesis) {
  var node = _node;
  if (parenthesis !== 'keep') {
    //ParenthesisNodes are only ignored when not in 'keep' mode
    node = _node.getContent();
  }
  var identifier = node.<span class="apidocCodeKeywordSpan">getIdentifier</span>();
  for (var i = 0; i &lt; properties.length; i++) {
    if (identifier in properties[i]) {
      return i;
    }
  }
  return null;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.FunctionNode.prototype.map" id="apidoc.element.mathjs.expression.mathWithTransform.FunctionNode.prototype.map">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.FunctionNode.prototype.</span>map
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">map = function (callback) {
  var fn = this.fn.map(callback);
  var args = [];
  for (var i = 0; i &lt; this.args.length; i++) {
    args[i] = this._ifNode(callback(this.args[i], 'args[' + i + ']', this));
  }
  return new FunctionNode(fn, args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (res &amp;&amp; res.isResultSet) {
  // we can have 0 or 1 results in the ResultSet, as the CLI
  // does not allow multiple expressions separated by a return
  res = res.entries[0];
  node = node.blocks
      .filter(function (entry) { return entry.visible; })
      .<span class="apidocCodeKeywordSpan">map</span>(function (entry) { return entry.node })[0];
}

if (node) {
  if (node.isAssignmentNode) {
    var name = findSymbolName(node);
    if (name != null) {
      scope.ans = scope[name];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.FunctionNode.prototype.toString" id="apidoc.element.mathjs.expression.mathWithTransform.FunctionNode.prototype.toString">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.FunctionNode.prototype.</span>toString
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function (options) {
  var customString;
  var name = this.fn.toString(options);
  if (options &amp;&amp; (typeof options.handler === 'object') &amp;&amp; options.handler.hasOwnProperty(name)) {
    //callback is a map of callback functions
    customString = options.handler[name](this, options);
  }

  if (typeof customString !== 'undefined') {
    return customString;
  }

  //fall back to Node's toString
  return nodeToString.call(this, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      }
      else {
        scope.ans = res;
        console.log(format(res));
      }
    }
    else if (res instanceof math.type.Help) {
      console.log(res.<span class="apidocCodeKeywordSpan">toString</span>());
    }
    else {
      scope.ans = res;
      console.log(format(res));
    }
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.FunctionNode.prototype.toTex" id="apidoc.element.mathjs.expression.mathWithTransform.FunctionNode.prototype.toTex">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.FunctionNode.prototype.</span>toTex
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toTex = function (options) {
  var customTex;
  if (options &amp;&amp; (typeof options.handler === 'object') &amp;&amp; options.handler.hasOwnProperty(this.name)) {
    //callback is a map of callback functions
    customTex = options.handler[this.name](this, options);
  }

  if (typeof customTex !== 'undefined') {
    return customTex;
  }

  //fall back to Node's toTex
  return nodeToTex.call(this, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    catch (err) {
      console.log(err.toString());
    }
    break;

  case 'tex':
    try {
      var tex = math.parse(expr).<span class="apidocCodeKeywordSpan">toTex</span>({parenthesis: parenthesis});
      console.log(tex);
    }
    catch (err) {
      console.log(err.toString());
    }
    break;
}
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.expression.mathWithTransform.IndexNode.prototype" id="apidoc.module.mathjs.expression.mathWithTransform.IndexNode.prototype">module mathjs.expression.mathWithTransform.IndexNode.prototype</a></h1>




    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.IndexNode.prototype._compile" id="apidoc.element.mathjs.expression.mathWithTransform.IndexNode.prototype._compile">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.IndexNode.prototype.</span>_compile
        <span class="apidocSignatureSpan">(defs, args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_compile = function (defs, args) {
  // args can be mutated by IndexNode, when dimensions use `end`
  var childArgs = Object.create(args);

  // helper function to create a Range from start, step and end
  defs.range = function (start, end, step) {
    return new Range(
        (start &amp;&amp; start.isBigNumber === true) ? start.toNumber() : start,
        (end   &amp;&amp; end.isBigNumber === true)   ? end.toNumber()   : end,
        (step  &amp;&amp; step.isBigNumber === true)  ? step.toNumber()  : step
    );
  };

  // TODO: implement support for bignumber (currently bignumbers are silently
  //       reduced to numbers when changing the value to zero-based)

  // TODO: Optimization: when the range values are ConstantNodes,
  //       we can beforehand resolve the zero-based value

  // optimization for a simple object property
  var dimensions = this.dimensions.map(function (range, i) {
    if (range &amp;&amp; range.isRangeNode) {
      if (range.needsEnd()) {
        childArgs.end = true;

        // resolve end and create range
        return '(function () {' +
            'var end = size[' + i + ']; ' +
            'return range(' +
            range.start._compile(defs, childArgs) + ', ' +
            range.end._compile(defs, childArgs) + ', ' +
            (range.step ? range.step._compile(defs, childArgs) : '1') +
            '); ' +
            '})()';
      }
      else {
        // create range
        return 'range(' +
            range.start._compile(defs, childArgs) + ', ' +
            range.end._compile(defs, childArgs) + ', ' +
            (range.step ? range.step._compile(defs, childArgs) : '1') +
            ')';
      }
    }
    if (range.isSymbolNode &amp;&amp; range.name === 'end') {
      childArgs.end = true;

      // resolve the parameter 'end'
      return '(function () {' +
          'var end = size[' + i + ']; ' +
          'return ' + range._compile(defs, childArgs) + '; ' +
          '})()'
    }
    else { // ConstantNode
      return range._compile(defs, childArgs);
    }
  });

  return 'math.index(' + dimensions.join(', ') + ')';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * @return {string} js
   * @private
   */
  AccessorNode.prototype._compile = function (defs, args) {
defs.access = access;
defs.getSafeProperty = getSafeProperty;

var object = this.object.<span class="apidocCodeKeywordSpan">_compile</span>(defs, args);
var index = this.index._compile(defs, args);

if (this.index.isObjectProperty()) {
  var prop = this.index.getObjectProperty();
  return 'getSafeProperty(' + object + ', "' + prop + '")';
}
else if (this.index.needsSize()) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.IndexNode.prototype._toString" id="apidoc.element.mathjs.expression.mathWithTransform.IndexNode.prototype._toString">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.IndexNode.prototype.</span>_toString
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_toString = function (options) {
  // format the parameters like "[1, 0:5]"
  return this.dotNotation
      ? ('.' + this.getObjectProperty())
      : ('[' + this.dimensions.join(', ') + ']');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      }
  }

  if (typeof customString !== 'undefined') {
    return customString;
  }

  return this.<span class="apidocCodeKeywordSpan">_toString</span>(options);
};

/**
 * Internal function to generate the string output.
 * This has to be implemented by every Node
 *
 * @throws {Error}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.IndexNode.prototype._toTex" id="apidoc.element.mathjs.expression.mathWithTransform.IndexNode.prototype._toTex">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.IndexNode.prototype.</span>_toTex
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_toTex = function (options) {
  var dimensions = this.dimensions.map(function (range) {
    return range.toTex(options);
  });

  return this.dotNotation
      ? ('.' + this.getObjectProperty() + '')
      : ('_{' + dimensions.join(',') + '}');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
  }

  if (typeof customTex !== 'undefined') {
    return customTex;
  }

  return this.<span class="apidocCodeKeywordSpan">_toTex</span>(options);
};

/**
 * Internal function to generate the LaTeX output.
 * This has to be implemented by every Node
 *
 * @param {Object} [options]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.IndexNode.prototype.clone" id="apidoc.element.mathjs.expression.mathWithTransform.IndexNode.prototype.clone">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.IndexNode.prototype.</span>clone
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clone = function () {
  return new IndexNode(this.dimensions.slice(0));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return desc;
};

/**
 * Export the help object to JSON
 */
Help.prototype.toJSON = function () {
  var obj = object.<span class="apidocCodeKeywordSpan">clone</span>(this.doc);
  obj.mathjs = 'Help';
  return obj;
};

/**
 * Instantiate a Help object from a JSON object
 * @param {Object} json
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.IndexNode.prototype.forEach" id="apidoc.element.mathjs.expression.mathWithTransform.IndexNode.prototype.forEach">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.IndexNode.prototype.</span>forEach
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEach = function (callback) {
  for (var i = 0; i &lt; this.dimensions.length; i++) {
    callback(this.dimensions[i], 'dimensions[' + i + ']', this);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (def.indexOf(keyword) == 0) {
      matches.push(def);
    }
  }
}

// commandline keywords
['exit', 'quit', 'clear'].<span class="apidocCodeKeywordSpan">forEach</span>(function (cmd) {
  if (cmd.indexOf(keyword) == 0) {
    matches.push(cmd);
  }
});

// math functions and constants
var ignore = ['expr', 'type'];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.IndexNode.prototype.getObjectProperty" id="apidoc.element.mathjs.expression.mathWithTransform.IndexNode.prototype.getObjectProperty">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.IndexNode.prototype.</span>getObjectProperty
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getObjectProperty = function () {
  return this.isObjectProperty() ? this.dimensions[0].value : null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.index = index;

// readonly property name
Object.defineProperty(this, 'name', {
  get: function () {
    if (this.index) {
      return (this.index.isObjectProperty())
          ? this.index.<span class="apidocCodeKeywordSpan">getObjectProperty</span>()
          : '';
    }
    else {
      return this.object.name || '';
    }
  }.bind(this),
  set: function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.IndexNode.prototype.isObjectProperty" id="apidoc.element.mathjs.expression.mathWithTransform.IndexNode.prototype.isObjectProperty">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.IndexNode.prototype.</span>isObjectProperty
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isObjectProperty = function () {
  return this.dimensions.length === 1 &amp;&amp;
      this.dimensions[0].isConstantNode &amp;&amp;
      this.dimensions[0].valueType === 'string';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.object = object || null;
this.index = index;

// readonly property name
Object.defineProperty(this, 'name', {
  get: function () {
    if (this.index) {
      return (this.index.<span class="apidocCodeKeywordSpan">isObjectProperty</span>())
          ? this.index.getObjectProperty()
          : '';
    }
    else {
      return this.object.name || '';
    }
  }.bind(this),
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.IndexNode.prototype.map" id="apidoc.element.mathjs.expression.mathWithTransform.IndexNode.prototype.map">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.IndexNode.prototype.</span>map
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">map = function (callback) {
  var dimensions = [];
  for (var i = 0; i &lt; this.dimensions.length; i++) {
    dimensions[i] = this._ifNode(callback(this.dimensions[i], 'dimensions[' + i + ']', this));
  }

  return new IndexNode(dimensions);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (res &amp;&amp; res.isResultSet) {
  // we can have 0 or 1 results in the ResultSet, as the CLI
  // does not allow multiple expressions separated by a return
  res = res.entries[0];
  node = node.blocks
      .filter(function (entry) { return entry.visible; })
      .<span class="apidocCodeKeywordSpan">map</span>(function (entry) { return entry.node })[0];
}

if (node) {
  if (node.isAssignmentNode) {
    var name = findSymbolName(node);
    if (name != null) {
      scope.ans = scope[name];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.IndexNode.prototype.needsSize" id="apidoc.element.mathjs.expression.mathWithTransform.IndexNode.prototype.needsSize">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.IndexNode.prototype.</span>needsSize
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">needsSize = function () {
  return this.dimensions.some(function (range) {
    return (range.isRangeNode &amp;&amp; range.needsEnd()) ||
        (range.isSymbolNode &amp;&amp; range.name === 'end');
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var object = this.object._compile(defs, args);
var index = this.index._compile(defs, args);

if (this.index.isObjectProperty()) {
  var prop = this.index.getObjectProperty();
  return 'getSafeProperty(' + object + ', "' + prop + '")';
}
else if (this.index.<span class="apidocCodeKeywordSpan">needsSize</span>()) {
  // if some parameters use the 'end' parameter, we need to calculate the size
  return '(function () {' +
      '  var object = ' + object + ';' +
      '  var size = math.size(object).valueOf();' +
      '  return access(object, ' + index + ');' +
      '})()';
}
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.expression.mathWithTransform.Node.prototype" id="apidoc.module.mathjs.expression.mathWithTransform.Node.prototype">module mathjs.expression.mathWithTransform.Node.prototype</a></h1>




    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.Node.prototype._compile" id="apidoc.element.mathjs.expression.mathWithTransform.Node.prototype._compile">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.Node.prototype.</span>_compile
        <span class="apidocSignatureSpan">(defs, args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_compile = function (defs, args) {
  // must be implemented by each of the Node implementations
  throw new Error('Cannot compile a Node interface');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * @return {string} js
   * @private
   */
  AccessorNode.prototype._compile = function (defs, args) {
defs.access = access;
defs.getSafeProperty = getSafeProperty;

var object = this.object.<span class="apidocCodeKeywordSpan">_compile</span>(defs, args);
var index = this.index._compile(defs, args);

if (this.index.isObjectProperty()) {
  var prop = this.index.getObjectProperty();
  return 'getSafeProperty(' + object + ', "' + prop + '")';
}
else if (this.index.needsSize()) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.Node.prototype._ifNode" id="apidoc.element.mathjs.expression.mathWithTransform.Node.prototype._ifNode">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.Node.prototype.</span>_ifNode
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_ifNode = function (node) {
  if (!(node &amp;&amp; node.isNode)) {
    throw new TypeError('Callback function must return a Node');
  }

  return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Create a new AccessorNode having it's childs be the results of calling
 * the provided callback function for each of the childs of the original node.
 * @param {function(child: Node, path: string, parent: Node): Node} callback
 * @returns {AccessorNode} Returns a transformed copy of the node
 */
AccessorNode.prototype.map = function (callback) {
  return new AccessorNode(
      this.<span class="apidocCodeKeywordSpan">_ifNode</span>(callback(this.object, 'object', this)),
      this._ifNode(callback(this.index, 'index', this))
  );
};

/**
 * Create a clone of this node, a shallow copy
 * @return {AccessorNode}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.Node.prototype._toString" id="apidoc.element.mathjs.expression.mathWithTransform.Node.prototype._toString">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.Node.prototype.</span>_toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_toString = function () {
  //must be implemented by each of the Node implementations
  throw new Error('_toString not implemented for ' + this.type);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      }
  }

  if (typeof customString !== 'undefined') {
    return customString;
  }

  return this.<span class="apidocCodeKeywordSpan">_toString</span>(options);
};

/**
 * Internal function to generate the string output.
 * This has to be implemented by every Node
 *
 * @throws {Error}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.Node.prototype._toTex" id="apidoc.element.mathjs.expression.mathWithTransform.Node.prototype._toTex">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.Node.prototype.</span>_toTex
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_toTex = function (options) {
  //must be implemented by each of the Node implementations
  throw new Error('_toTex not implemented for ' + this.type);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
  }

  if (typeof customTex !== 'undefined') {
    return customTex;
  }

  return this.<span class="apidocCodeKeywordSpan">_toTex</span>(options);
};

/**
 * Internal function to generate the LaTeX output.
 * This has to be implemented by every Node
 *
 * @param {Object} [options]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.Node.prototype.clone" id="apidoc.element.mathjs.expression.mathWithTransform.Node.prototype.clone">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.Node.prototype.</span>clone
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clone = function () {
  // must be implemented by each of the Node implementations
  throw new Error('Cannot clone a Node interface');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return desc;
};

/**
 * Export the help object to JSON
 */
Help.prototype.toJSON = function () {
  var obj = object.<span class="apidocCodeKeywordSpan">clone</span>(this.doc);
  obj.mathjs = 'Help';
  return obj;
};

/**
 * Instantiate a Help object from a JSON object
 * @param {Object} json
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.Node.prototype.cloneDeep" id="apidoc.element.mathjs.expression.mathWithTransform.Node.prototype.cloneDeep">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.Node.prototype.</span>cloneDeep
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cloneDeep = function () {
  return this.map(function (node) {
    return node.cloneDeep();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * Create a deep clone of this node
 * @return {Node}
 */
Node.prototype.cloneDeep = function () {
  return this.map(function (node) {
    return node.<span class="apidocCodeKeywordSpan">cloneDeep</span>();
  });
};

/**
 * Deep compare this node with another node.
 * @param {Node} other
 * @return {boolean} Returns true when both nodes are of the same type and
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.Node.prototype.compile" id="apidoc.element.mathjs.expression.mathWithTransform.Node.prototype.compile">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.Node.prototype.</span>compile
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function () {
  // TODO: calling compile(math) is deprecated since version 2.0.0. Remove this warning some day
  if (arguments.length &gt; 0) {
    throw new Error('Calling compile(math) is deprecated. Call the function as compile() instead.');
  }

  // definitions globally available inside the closure of the compiled expressions
  var defs = {
    math: math.expression.mathWithTransform,
    args: {}, // can be filled with names of FunctionAssignment arguments
    _validateScope: _validateScope
  };

  // will be used to put local function arguments
  var args = {};

  var code = this._compile(defs, args);

  var defsCode = Object.keys(defs).map(function (name) {
    return '    var ' + name + ' = defs["' + name + '"];';
  });

  var factoryCode =
      defsCode.join(' ') +
      'return {' +
      '  "eval": function (scope) {' +
      '    if (scope) _validateScope(scope);' +
      '    scope = scope || {};' +
      '    return ' + code + ';' +
      '  }' +
      '};';

  var factory = new Function('defs', factoryCode);
  return factory(defs);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*     parse(expr, options)
*     parse([expr1, expr2, expr3, ...])
*     parse([expr1, expr2, expr3, ...], options)
*
* Example:
*
*     var node = parse('sqrt(3^2 + 4^2)');
*     node.<span class="apidocCodeKeywordSpan">compile</span>(math).eval(); // 5
*
*     var scope = {a:3, b:4}
*     var node = parse('a * b'); // 12
*     var code = node.compile(math);
*     code.eval(scope); // 12
*     scope.a = 5;
*     code.eval(scope); // 20
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.Node.prototype.equals" id="apidoc.element.mathjs.expression.mathWithTransform.Node.prototype.equals">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.Node.prototype.</span>equals
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">equals = function (other) {
  return other
      ? deepEqual(this, other)
      : false
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (inv) {
  root = root.neg();
}

if (root.isZero()) {
  throw new Error('Root must be non-zero');
}
if (a.isNegative() &amp;&amp; !root.abs().mod(2).<span class="apidocCodeKeywordSpan">equals</span>(1)) {
  throw new Error('Root must be odd when a is negative.');
}

// edge cases zero and infinity
if (a.isZero()) {
  return inv ? new Big(Infinity) : 0;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.Node.prototype.eval" id="apidoc.element.mathjs.expression.mathWithTransform.Node.prototype.eval">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.Node.prototype.</span>eval
        <span class="apidocSignatureSpan">(scope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eval = function (scope) {
  return this.compile().eval(scope);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
math.atan2(3, -3) / math.pi;      // 0.75
math.log(1000, 10);               // 3
math.sqrt(-4);                    // 2i
math.pow([[-1, 2], [3, 1]], 2);   // [[7, 0], [0, 7]]
math.derivative('x^2 + x', 'x');  // 2 * x + 1

// expressions
math.<span class="apidocCodeKeywordSpan">eval</span>('12 / (2.3 + 0.7)');    // 4
math.eval('5.08 cm to inch');     // 2 inch
math.eval('sin(45 deg) ^ 2');     // 0.5
math.eval('9 / 3 + 2i');          // 3 + 2i
math.eval('det([-1, 2; 3, 1])');  // -7

// chaining
math.chain(3)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.Node.prototype.filter" id="apidoc.element.mathjs.expression.mathWithTransform.Node.prototype.filter">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.Node.prototype.</span>filter
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">filter = function (callback) {
  var nodes = [];

  this.traverse(function (node, path, parent) {
    if (callback(node, path, parent)) {
      nodes.push(node);
    }
  });

  return nodes;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            }
          }
        }
      }
    }

    // remove duplicates
    matches = matches.<span class="apidocCodeKeywordSpan">filter</span>(function(elem, pos, arr) {
      return arr.indexOf(elem) == pos;
    });
  }

  return [matches, keyword];
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.Node.prototype.find" id="apidoc.element.mathjs.expression.mathWithTransform.Node.prototype.find">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.Node.prototype.</span>find
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">find = function () {
  throw new Error('Function Node.find is deprecated. Use Node.filter instead.');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var mf = multiplyScalar;

// process data types
if (adt &amp;&amp; bdt &amp;&amp; adt === bdt &amp;&amp; typeof adt === 'string') {
  // datatype
  dt = adt;
  // find signatures that matches (dt, dt)
  af = typed.<span class="apidocCodeKeywordSpan">find</span>(addScalar, [dt, dt]);
  mf = typed.find(multiplyScalar, [dt, dt]);
}

// result (do not initialize it with zero)
var c = mf(adata[0], bdata[0]);
// loop data
for (var i = 1; i &lt; n; i++) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.Node.prototype.forEach" id="apidoc.element.mathjs.expression.mathWithTransform.Node.prototype.forEach">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.Node.prototype.</span>forEach
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEach = function (callback) {
  // must be implemented by each of the Node implementations
  throw new Error('Cannot run forEach on a Node interface');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (def.indexOf(keyword) == 0) {
      matches.push(def);
    }
  }
}

// commandline keywords
['exit', 'quit', 'clear'].<span class="apidocCodeKeywordSpan">forEach</span>(function (cmd) {
  if (cmd.indexOf(keyword) == 0) {
    matches.push(cmd);
  }
});

// math functions and constants
var ignore = ['expr', 'type'];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.Node.prototype.getContent" id="apidoc.element.mathjs.expression.mathWithTransform.Node.prototype.getContent">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.Node.prototype.</span>getContent
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getContent = function () {
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {string} parenthesis
 * @return {number|null}
 */
function getPrecedence (_node, parenthesis) {
var node = _node;
if (parenthesis !== 'keep') {
  //ParenthesisNodes are only ignored when not in 'keep' mode
  node = _node.<span class="apidocCodeKeywordSpan">getContent</span>();
}
var identifier = node.getIdentifier();
for (var i = 0; i &lt; properties.length; i++) {
  if (identifier in properties[i]) {
    return i;
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.Node.prototype.getIdentifier" id="apidoc.element.mathjs.expression.mathWithTransform.Node.prototype.getIdentifier">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.Node.prototype.</span>getIdentifier
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getIdentifier = function () {
  return this.type;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
function getPrecedence (_node, parenthesis) {
  var node = _node;
  if (parenthesis !== 'keep') {
    //ParenthesisNodes are only ignored when not in 'keep' mode
    node = _node.getContent();
  }
  var identifier = node.<span class="apidocCodeKeywordSpan">getIdentifier</span>();
  for (var i = 0; i &lt; properties.length; i++) {
    if (identifier in properties[i]) {
      return i;
    }
  }
  return null;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.Node.prototype.map" id="apidoc.element.mathjs.expression.mathWithTransform.Node.prototype.map">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.Node.prototype.</span>map
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">map = function (callback) {
  // must be implemented by each of the Node implementations
  throw new Error('Cannot run map on a Node interface');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (res &amp;&amp; res.isResultSet) {
  // we can have 0 or 1 results in the ResultSet, as the CLI
  // does not allow multiple expressions separated by a return
  res = res.entries[0];
  node = node.blocks
      .filter(function (entry) { return entry.visible; })
      .<span class="apidocCodeKeywordSpan">map</span>(function (entry) { return entry.node })[0];
}

if (node) {
  if (node.isAssignmentNode) {
    var name = findSymbolName(node);
    if (name != null) {
      scope.ans = scope[name];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.Node.prototype.match" id="apidoc.element.mathjs.expression.mathWithTransform.Node.prototype.match">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.Node.prototype.</span>match
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">match = function () {
  throw new Error('Function Node.match is deprecated. See functions Node.filter, Node.transform, Node.traverse.');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {function} fn   A typed function
 * @return {number} Returns the maximum number of expected arguments.
 *                  Returns -1 when no signatures where found on the function.
 */
exports.maxArgumentCount = function (fn) {
  return Object.keys(fn.signatures || {})
      .reduce(function (args, signature) {
        var count = (signature.<span class="apidocCodeKeywordSpan">match</span>(/,/g) || []).length + 1;
        return Math.max(args, count);
      }, -1);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.Node.prototype.toString" id="apidoc.element.mathjs.expression.mathWithTransform.Node.prototype.toString">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.Node.prototype.</span>toString
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function (options) {
  var customString;
  if (options &amp;&amp; typeof options == "object") {
      switch (typeof options.handler) {
        case 'object':
        case 'undefined':
          break;
        case 'function':
          customString = options.handler(this, options);
          break;
        default:
          throw new TypeError('Object or function expected as callback');
      }
  }

  if (typeof customString !== 'undefined') {
    return customString;
  }

  return this._toString(options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      }
      else {
        scope.ans = res;
        console.log(format(res));
      }
    }
    else if (res instanceof math.type.Help) {
      console.log(res.<span class="apidocCodeKeywordSpan">toString</span>());
    }
    else {
      scope.ans = res;
      console.log(format(res));
    }
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.Node.prototype.toTex" id="apidoc.element.mathjs.expression.mathWithTransform.Node.prototype.toTex">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.Node.prototype.</span>toTex
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toTex = function (options) {
  var customTex;
  if (options &amp;&amp; typeof options == 'object') {
    switch (typeof options.handler) {
      case 'object':
      case 'undefined':
        break;
      case 'function':
        customTex = options.handler(this, options);
        break;
      default:
        throw new TypeError('Object or function expected as callback');
    }
  }

  if (typeof customTex !== 'undefined') {
    return customTex;
  }

  return this._toTex(options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    catch (err) {
      console.log(err.toString());
    }
    break;

  case 'tex':
    try {
      var tex = math.parse(expr).<span class="apidocCodeKeywordSpan">toTex</span>({parenthesis: parenthesis});
      console.log(tex);
    }
    catch (err) {
      console.log(err.toString());
    }
    break;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.Node.prototype.transform" id="apidoc.element.mathjs.expression.mathWithTransform.Node.prototype.transform">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.Node.prototype.</span>transform
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">transform = function (callback) {
  // traverse over all childs
  function _transform (node, callback) {
    return node.map(function(child, path, parent) {
      var replacement = callback(child, path, parent);
      return _transform(replacement, callback);
    });
  }

  var replacement = callback(this, null, null);
  return _transform(replacement, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  /**
* Recursively transform a node tree via a transform function.
*
* For example, to replace all nodes of type SymbolNode having name 'x' with a
* ConstantNode with value 2:
*
*     var res = Node.<span class="apidocCodeKeywordSpan">transform</span>(function (node, path, parent) {
*       if (node &amp;&amp; node.isSymbolNode) &amp;&amp; (node.name == 'x')) {
*         return new ConstantNode(2);
*       }
*       else {
*         return node;
*       }
*     });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.Node.prototype.traverse" id="apidoc.element.mathjs.expression.mathWithTransform.Node.prototype.traverse">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.Node.prototype.</span>traverse
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">traverse = function (callback) {
  // execute callback for itself
  callback(this, null, null);

  // recursively traverse over all childs of a node
  function _traverse(node, callback) {
    node.forEach(function (child, path, parent) {
      callback(child, path, parent);
      _traverse(child, callback);
    });
  }

  _traverse(this, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *            otherwise. Function signature:
 *            callback(node: Node, index: string, parent: Node) : boolean
 * @return {Node[]} nodes       An array with nodes matching given filter criteria
 */
Node.prototype.filter = function (callback) {
  var nodes = [];

  this.<span class="apidocCodeKeywordSpan">traverse</span>(function (node, path, parent) {
    if (callback(node, path, parent)) {
      nodes.push(node);
    }
  });

  return nodes;
};
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.expression.mathWithTransform.ObjectNode.prototype" id="apidoc.module.mathjs.expression.mathWithTransform.ObjectNode.prototype">module mathjs.expression.mathWithTransform.ObjectNode.prototype</a></h1>




    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.ObjectNode.prototype._compile" id="apidoc.element.mathjs.expression.mathWithTransform.ObjectNode.prototype._compile">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.ObjectNode.prototype.</span>_compile
        <span class="apidocSignatureSpan">(defs, args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_compile = function (defs, args) {
  var entries = [];
  for (var key in this.properties) {
    if (this.properties.hasOwnProperty(key)) {
      entries.push('"' + key + '": ' + this.properties[key]._compile(defs, args));
    }
  }
  return '{' + entries.join(', ') + '}';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * @return {string} js
   * @private
   */
  AccessorNode.prototype._compile = function (defs, args) {
defs.access = access;
defs.getSafeProperty = getSafeProperty;

var object = this.object.<span class="apidocCodeKeywordSpan">_compile</span>(defs, args);
var index = this.index._compile(defs, args);

if (this.index.isObjectProperty()) {
  var prop = this.index.getObjectProperty();
  return 'getSafeProperty(' + object + ', "' + prop + '")';
}
else if (this.index.needsSize()) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.ObjectNode.prototype._toString" id="apidoc.element.mathjs.expression.mathWithTransform.ObjectNode.prototype._toString">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.ObjectNode.prototype.</span>_toString
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_toString = function (options) {
  var entries = [];
  for (var key in this.properties) {
    if (this.properties.hasOwnProperty(key)) {
      entries.push('"' + key + '": ' + this.properties[key].toString(options));
    }
  }
  return '{' + entries.join(', ') + '}';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      }
  }

  if (typeof customString !== 'undefined') {
    return customString;
  }

  return this.<span class="apidocCodeKeywordSpan">_toString</span>(options);
};

/**
 * Internal function to generate the string output.
 * This has to be implemented by every Node
 *
 * @throws {Error}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.ObjectNode.prototype._toTex" id="apidoc.element.mathjs.expression.mathWithTransform.ObjectNode.prototype._toTex">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.ObjectNode.prototype.</span>_toTex
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_toTex = function (options) {
  var entries = [];
  for (var key in this.properties) {
    if (this.properties.hasOwnProperty(key)) {
      entries.push("\\mathbf{" + key + ':} &amp; ' + this.properties[key].toTex(options) + "\\\\");
    }
  }
  return '\\left\\{\\begin{array}{ll}' + entries.join('\n') + '\\end{array}\\right\\}';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
  }

  if (typeof customTex !== 'undefined') {
    return customTex;
  }

  return this.<span class="apidocCodeKeywordSpan">_toTex</span>(options);
};

/**
 * Internal function to generate the LaTeX output.
 * This has to be implemented by every Node
 *
 * @param {Object} [options]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.ObjectNode.prototype.clone" id="apidoc.element.mathjs.expression.mathWithTransform.ObjectNode.prototype.clone">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.ObjectNode.prototype.</span>clone
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clone = function () {
  var properties = {};
  for (var key in this.properties) {
    if (this.properties.hasOwnProperty(key)) {
      properties[key] = this.properties[key];
    }
  }
  return new ObjectNode(properties);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return desc;
};

/**
 * Export the help object to JSON
 */
Help.prototype.toJSON = function () {
  var obj = object.<span class="apidocCodeKeywordSpan">clone</span>(this.doc);
  obj.mathjs = 'Help';
  return obj;
};

/**
 * Instantiate a Help object from a JSON object
 * @param {Object} json
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.ObjectNode.prototype.forEach" id="apidoc.element.mathjs.expression.mathWithTransform.ObjectNode.prototype.forEach">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.ObjectNode.prototype.</span>forEach
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEach = function (callback) {
  for (var key in this.properties) {
    if (this.properties.hasOwnProperty(key)) {
      callback(this.properties[key], 'properties["' + key + '"]', this);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (def.indexOf(keyword) == 0) {
      matches.push(def);
    }
  }
}

// commandline keywords
['exit', 'quit', 'clear'].<span class="apidocCodeKeywordSpan">forEach</span>(function (cmd) {
  if (cmd.indexOf(keyword) == 0) {
    matches.push(cmd);
  }
});

// math functions and constants
var ignore = ['expr', 'type'];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.ObjectNode.prototype.map" id="apidoc.element.mathjs.expression.mathWithTransform.ObjectNode.prototype.map">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.ObjectNode.prototype.</span>map
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">map = function (callback) {
  var properties = {};
  for (var key in this.properties) {
    if (this.properties.hasOwnProperty(key)) {
      properties[key] = this._ifNode(callback(this.properties[key], 'properties["' + key + '"]', this));
    }
  }
  return new ObjectNode(properties);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (res &amp;&amp; res.isResultSet) {
  // we can have 0 or 1 results in the ResultSet, as the CLI
  // does not allow multiple expressions separated by a return
  res = res.entries[0];
  node = node.blocks
      .filter(function (entry) { return entry.visible; })
      .<span class="apidocCodeKeywordSpan">map</span>(function (entry) { return entry.node })[0];
}

if (node) {
  if (node.isAssignmentNode) {
    var name = findSymbolName(node);
    if (name != null) {
      scope.ans = scope[name];
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.expression.mathWithTransform.OperatorNode.prototype" id="apidoc.module.mathjs.expression.mathWithTransform.OperatorNode.prototype">module mathjs.expression.mathWithTransform.OperatorNode.prototype</a></h1>




    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.OperatorNode.prototype._compile" id="apidoc.element.mathjs.expression.mathWithTransform.OperatorNode.prototype._compile">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.OperatorNode.prototype.</span>_compile
        <span class="apidocSignatureSpan">(defs, args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_compile = function (defs, args) {
  if (!defs.math[this.fn]) {
    throw new Error('Function ' + this.fn + ' missing in provided namespace "math"');
  }

  var jsArgs = this.args.map(function (arg) {
    return arg._compile(defs, args);
  });

  return 'math.' + this.fn + '(' + jsArgs.join(', ') + ')';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * @return {string} js
   * @private
   */
  AccessorNode.prototype._compile = function (defs, args) {
defs.access = access;
defs.getSafeProperty = getSafeProperty;

var object = this.object.<span class="apidocCodeKeywordSpan">_compile</span>(defs, args);
var index = this.index._compile(defs, args);

if (this.index.isObjectProperty()) {
  var prop = this.index.getObjectProperty();
  return 'getSafeProperty(' + object + ', "' + prop + '")';
}
else if (this.index.needsSize()) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.OperatorNode.prototype._toString" id="apidoc.element.mathjs.expression.mathWithTransform.OperatorNode.prototype._toString">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.OperatorNode.prototype.</span>_toString
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_toString = function (options) {
  var parenthesis = (options &amp;&amp; options.parenthesis) ? options.parenthesis : 'keep';
  var implicit = (options &amp;&amp; options.implicit) ? options.implicit : 'hide';
  var args = this.args;
  var parens = calculateNecessaryParentheses(this, parenthesis, args, false);

  if (args.length === 1) { //unary operators
    var assoc = operators.getAssociativity(this, parenthesis);

    var operand = args[0].toString(options);
    if (parens[0]) {
      operand = '(' + operand + ')';
    }

    if (assoc === 'right') { //prefix operator
      return this.op + operand;
    }
    else if (assoc === 'left') { //postfix
      return operand + this.op;
    }

    //fall back to postfix
    return operand + this.op;
  } else if (args.length == 2) {
    var lhs = args[0].toString(options); //left hand side
    var rhs = args[1].toString(options); //right hand side
    if (parens[0]) { //left hand side in parenthesis?
      lhs = '(' + lhs + ')';
    }
    if (parens[1]) { //right hand side in parenthesis?
      rhs = '(' + rhs + ')';
    }

    if (this.implicit &amp;&amp; (this.getIdentifier() === 'OperatorNode:multiply') &amp;&amp; (implicit == 'hide')) {
      return lhs + ' ' + rhs;
    }

    return lhs + ' ' + this.op + ' ' + rhs;
  } else if ((args.length &gt; 2) &amp;&amp; ((this.getIdentifier() === 'OperatorNode:add') || (this.getIdentifier() === 'OperatorNode:multiply
'))) {
    var stringifiedArgs = args.map(function (arg, index) {
      arg = arg.toString(options);
      if (parens[index]) { //put in parenthesis?
        arg = '(' + arg + ')';
      }

      return arg;
    });

    if (this.implicit &amp;&amp; (this.getIdentifier() === 'OperatorNode:multiply') &amp;&amp; (implicit === 'hide')) {
      return stringifiedArgs.join(' ');
    }

    return stringifiedArgs.join(' ' + this.op + ' ');
  } else {
    //fallback to formatting as a function call
    return this.fn + '(' + this.args.join(', ') + ')';
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      }
  }

  if (typeof customString !== 'undefined') {
    return customString;
  }

  return this.<span class="apidocCodeKeywordSpan">_toString</span>(options);
};

/**
 * Internal function to generate the string output.
 * This has to be implemented by every Node
 *
 * @throws {Error}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.OperatorNode.prototype._toTex" id="apidoc.element.mathjs.expression.mathWithTransform.OperatorNode.prototype._toTex">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.OperatorNode.prototype.</span>_toTex
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_toTex = function (options) {
  var parenthesis = (options &amp;&amp; options.parenthesis) ? options.parenthesis : 'keep';
  var implicit = (options &amp;&amp; options.implicit) ? options.implicit : 'hide';
  var args = this.args;
  var parens = calculateNecessaryParentheses(this, parenthesis, args, true);
  var op = latex.operators[this.fn];
  op = typeof op === 'undefined' ? this.op : op; //fall back to using this.op

  if (args.length === 1) { //unary operators
    var assoc = operators.getAssociativity(this, parenthesis);

    var operand = args[0].toTex(options);
    if (parens[0]) {
      operand = '\\left(' + operand + '\\right)';
    }

    if (assoc === 'right') { //prefix operator
      return op + operand;
    }
    else if (assoc === 'left') { //postfix operator
      return operand + op;
    }

    //fall back to postfix
    return operand + op;
  } else if (args.length === 2) { //binary operators
    var lhs = args[0]; //left hand side
    var lhsTex = lhs.toTex(options);
    if (parens[0]) {
      lhsTex = '\\left(' + lhsTex + '\\right)';
    }

    var rhs = args[1]; //right hand side
    var rhsTex = rhs.toTex(options);
    if (parens[1]) {
      rhsTex = '\\left(' + rhsTex + '\\right)';
    }

    //handle some exceptions (due to the way LaTeX works)
    var lhsIdentifier;
    if (parenthesis === 'keep') {
      lhsIdentifier = lhs.getIdentifier();
    }
    else {
      //Ignore ParenthesisNodes if in 'keep' mode
      lhsIdentifier = lhs.getContent().getIdentifier();
    }
    switch (this.getIdentifier()) {
      case 'OperatorNode:divide':
        //op contains '\\frac' at this point
        return op + '{' + lhsTex + '}' + '{' + rhsTex + '}';
      case 'OperatorNode:pow':
        lhsTex = '{' + lhsTex + '}';
        rhsTex = '{' + rhsTex + '}';
        switch (lhsIdentifier) {
          case 'ConditionalNode': //
          case 'OperatorNode:divide':
            lhsTex = '\\left(' + lhsTex + '\\right)';
        }
      case 'OperatorNode:multiply':
        if (this.implicit &amp;&amp; (implicit === 'hide')) {
          return lhsTex + '~' + rhsTex;
        }
    }
    return lhsTex + op + rhsTex;
  } else if ((args.length &gt; 2) &amp;&amp; ((this.getIdentifier() === 'OperatorNode:add') || (this.getIdentifier() === 'OperatorNode:multiply
'))) {
    var texifiedArgs = args.map(function (arg, index) {
      arg = arg.toTex(options);
      if (parens[index]) {
        arg = '\\left(' + arg + '\\right)';
      }
      return arg;
    });

    if ((this.getIdentifier() === 'OperatorNode:multiply') &amp;&amp; this.implicit) {
      return texifiedArgs.join('~');
    }

    return texifiedArgs.join(op)
  } else {
    //fall back to formatting as a function call
    //as this is a fallback, it doesn't use
    //fancy function names
    return '\\mathrm{' + this.fn + '}\\left('
        + args.map(function (arg) {
          return arg.toTex(options);
        }).join(',') + '\\right)';
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
  }

  if (typeof customTex !== 'undefined') {
    return customTex;
  }

  return this.<span class="apidocCodeKeywordSpan">_toTex</span>(options);
};

/**
 * Internal function to generate the LaTeX output.
 * This has to be implemented by every Node
 *
 * @param {Object} [options]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.OperatorNode.prototype.clone" id="apidoc.element.mathjs.expression.mathWithTransform.OperatorNode.prototype.clone">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.OperatorNode.prototype.</span>clone
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clone = function () {
  return new OperatorNode(this.op, this.fn, this.args.slice(0), this.implicit);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return desc;
};

/**
 * Export the help object to JSON
 */
Help.prototype.toJSON = function () {
  var obj = object.<span class="apidocCodeKeywordSpan">clone</span>(this.doc);
  obj.mathjs = 'Help';
  return obj;
};

/**
 * Instantiate a Help object from a JSON object
 * @param {Object} json
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.OperatorNode.prototype.forEach" id="apidoc.element.mathjs.expression.mathWithTransform.OperatorNode.prototype.forEach">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.OperatorNode.prototype.</span>forEach
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEach = function (callback) {
  for (var i = 0; i &lt; this.args.length; i++) {
    callback(this.args[i], 'args[' + i + ']', this);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (def.indexOf(keyword) == 0) {
      matches.push(def);
    }
  }
}

// commandline keywords
['exit', 'quit', 'clear'].<span class="apidocCodeKeywordSpan">forEach</span>(function (cmd) {
  if (cmd.indexOf(keyword) == 0) {
    matches.push(cmd);
  }
});

// math functions and constants
var ignore = ['expr', 'type'];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.OperatorNode.prototype.getIdentifier" id="apidoc.element.mathjs.expression.mathWithTransform.OperatorNode.prototype.getIdentifier">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.OperatorNode.prototype.</span>getIdentifier
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getIdentifier = function () {
  return this.type + ':' + this.fn;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
function getPrecedence (_node, parenthesis) {
  var node = _node;
  if (parenthesis !== 'keep') {
    //ParenthesisNodes are only ignored when not in 'keep' mode
    node = _node.getContent();
  }
  var identifier = node.<span class="apidocCodeKeywordSpan">getIdentifier</span>();
  for (var i = 0; i &lt; properties.length; i++) {
    if (identifier in properties[i]) {
      return i;
    }
  }
  return null;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.OperatorNode.prototype.map" id="apidoc.element.mathjs.expression.mathWithTransform.OperatorNode.prototype.map">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.OperatorNode.prototype.</span>map
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">map = function (callback) {
  var args = [];
  for (var i = 0; i &lt; this.args.length; i++) {
    args[i] = this._ifNode(callback(this.args[i], 'args[' + i + ']', this));
  }
  return new OperatorNode(this.op, this.fn, args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (res &amp;&amp; res.isResultSet) {
  // we can have 0 or 1 results in the ResultSet, as the CLI
  // does not allow multiple expressions separated by a return
  res = res.entries[0];
  node = node.blocks
      .filter(function (entry) { return entry.visible; })
      .<span class="apidocCodeKeywordSpan">map</span>(function (entry) { return entry.node })[0];
}

if (node) {
  if (node.isAssignmentNode) {
    var name = findSymbolName(node);
    if (name != null) {
      scope.ans = scope[name];
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.expression.mathWithTransform.ParenthesisNode.prototype" id="apidoc.module.mathjs.expression.mathWithTransform.ParenthesisNode.prototype">module mathjs.expression.mathWithTransform.ParenthesisNode.prototype</a></h1>




    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.ParenthesisNode.prototype._compile" id="apidoc.element.mathjs.expression.mathWithTransform.ParenthesisNode.prototype._compile">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.ParenthesisNode.prototype.</span>_compile
        <span class="apidocSignatureSpan">(defs, args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_compile = function (defs, args) {
  return this.content._compile(defs, args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * @return {string} js
   * @private
   */
  AccessorNode.prototype._compile = function (defs, args) {
defs.access = access;
defs.getSafeProperty = getSafeProperty;

var object = this.object.<span class="apidocCodeKeywordSpan">_compile</span>(defs, args);
var index = this.index._compile(defs, args);

if (this.index.isObjectProperty()) {
  var prop = this.index.getObjectProperty();
  return 'getSafeProperty(' + object + ', "' + prop + '")';
}
else if (this.index.needsSize()) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.ParenthesisNode.prototype._toString" id="apidoc.element.mathjs.expression.mathWithTransform.ParenthesisNode.prototype._toString">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.ParenthesisNode.prototype.</span>_toString
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_toString = function (options) {
  if ((!options) || (options &amp;&amp; !options.parenthesis) || (options &amp;&amp; options.parenthesis === 'keep')) {
    return '(' + this.content.toString(options) + ')';
  }
  return this.content.toString(options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      }
  }

  if (typeof customString !== 'undefined') {
    return customString;
  }

  return this.<span class="apidocCodeKeywordSpan">_toString</span>(options);
};

/**
 * Internal function to generate the string output.
 * This has to be implemented by every Node
 *
 * @throws {Error}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.ParenthesisNode.prototype._toTex" id="apidoc.element.mathjs.expression.mathWithTransform.ParenthesisNode.prototype._toTex">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.ParenthesisNode.prototype.</span>_toTex
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_toTex = function (options) {
  if ((!options) || (options &amp;&amp; !options.parenthesis) || (options &amp;&amp; options.parenthesis === 'keep')) {
    return '\\left(' + this.content.toTex(options) + '\\right)';
  }
  return this.content.toTex(options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
  }

  if (typeof customTex !== 'undefined') {
    return customTex;
  }

  return this.<span class="apidocCodeKeywordSpan">_toTex</span>(options);
};

/**
 * Internal function to generate the LaTeX output.
 * This has to be implemented by every Node
 *
 * @param {Object} [options]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.ParenthesisNode.prototype.clone" id="apidoc.element.mathjs.expression.mathWithTransform.ParenthesisNode.prototype.clone">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.ParenthesisNode.prototype.</span>clone
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clone = function () {
  return new ParenthesisNode(this.content);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return desc;
};

/**
 * Export the help object to JSON
 */
Help.prototype.toJSON = function () {
  var obj = object.<span class="apidocCodeKeywordSpan">clone</span>(this.doc);
  obj.mathjs = 'Help';
  return obj;
};

/**
 * Instantiate a Help object from a JSON object
 * @param {Object} json
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.ParenthesisNode.prototype.forEach" id="apidoc.element.mathjs.expression.mathWithTransform.ParenthesisNode.prototype.forEach">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.ParenthesisNode.prototype.</span>forEach
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEach = function (callback) {
  callback(this.content, 'content', this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (def.indexOf(keyword) == 0) {
      matches.push(def);
    }
  }
}

// commandline keywords
['exit', 'quit', 'clear'].<span class="apidocCodeKeywordSpan">forEach</span>(function (cmd) {
  if (cmd.indexOf(keyword) == 0) {
    matches.push(cmd);
  }
});

// math functions and constants
var ignore = ['expr', 'type'];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.ParenthesisNode.prototype.getContent" id="apidoc.element.mathjs.expression.mathWithTransform.ParenthesisNode.prototype.getContent">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.ParenthesisNode.prototype.</span>getContent
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getContent = function () {
  return this.content.getContent();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {string} parenthesis
 * @return {number|null}
 */
function getPrecedence (_node, parenthesis) {
var node = _node;
if (parenthesis !== 'keep') {
  //ParenthesisNodes are only ignored when not in 'keep' mode
  node = _node.<span class="apidocCodeKeywordSpan">getContent</span>();
}
var identifier = node.getIdentifier();
for (var i = 0; i &lt; properties.length; i++) {
  if (identifier in properties[i]) {
    return i;
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.ParenthesisNode.prototype.map" id="apidoc.element.mathjs.expression.mathWithTransform.ParenthesisNode.prototype.map">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.ParenthesisNode.prototype.</span>map
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">map = function (callback) {
  var content = callback(this.content, 'content', this);
  return new ParenthesisNode(content);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (res &amp;&amp; res.isResultSet) {
  // we can have 0 or 1 results in the ResultSet, as the CLI
  // does not allow multiple expressions separated by a return
  res = res.entries[0];
  node = node.blocks
      .filter(function (entry) { return entry.visible; })
      .<span class="apidocCodeKeywordSpan">map</span>(function (entry) { return entry.node })[0];
}

if (node) {
  if (node.isAssignmentNode) {
    var name = findSymbolName(node);
    if (name != null) {
      scope.ans = scope[name];
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.expression.mathWithTransform.RangeNode.prototype" id="apidoc.module.mathjs.expression.mathWithTransform.RangeNode.prototype">module mathjs.expression.mathWithTransform.RangeNode.prototype</a></h1>




    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.RangeNode.prototype._compile" id="apidoc.element.mathjs.expression.mathWithTransform.RangeNode.prototype._compile">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.RangeNode.prototype.</span>_compile
        <span class="apidocSignatureSpan">(defs, args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_compile = function (defs, args) {
  return 'math.range(' +
      this.start._compile(defs, args) + ', ' +
      this.end._compile(defs, args) +
      (this.step ? (', ' + this.step._compile(defs, args)) : '') +
      ')';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * @return {string} js
   * @private
   */
  AccessorNode.prototype._compile = function (defs, args) {
defs.access = access;
defs.getSafeProperty = getSafeProperty;

var object = this.object.<span class="apidocCodeKeywordSpan">_compile</span>(defs, args);
var index = this.index._compile(defs, args);

if (this.index.isObjectProperty()) {
  var prop = this.index.getObjectProperty();
  return 'getSafeProperty(' + object + ', "' + prop + '")';
}
else if (this.index.needsSize()) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.RangeNode.prototype._toString" id="apidoc.element.mathjs.expression.mathWithTransform.RangeNode.prototype._toString">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.RangeNode.prototype.</span>_toString
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_toString = function (options) {
  var parenthesis = (options &amp;&amp; options.parenthesis) ? options.parenthesis : 'keep';
  var parens = calculateNecessaryParentheses(this, parenthesis);

  //format string as start:step:stop
  var str;

  var start = this.start.toString(options);
  if (parens.start) {
    start = '(' + start + ')';
  }
  str = start;

  if (this.step) {
    var step = this.step.toString(options);
    if (parens.step) {
      step = '(' + step + ')';
    }
    str += ':' + step;
  }

  var end = this.end.toString(options);
  if (parens.end) {
    end = '(' + end + ')';
  }
  str += ':' + end;

  return str;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      }
  }

  if (typeof customString !== 'undefined') {
    return customString;
  }

  return this.<span class="apidocCodeKeywordSpan">_toString</span>(options);
};

/**
 * Internal function to generate the string output.
 * This has to be implemented by every Node
 *
 * @throws {Error}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.RangeNode.prototype._toTex" id="apidoc.element.mathjs.expression.mathWithTransform.RangeNode.prototype._toTex">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.RangeNode.prototype.</span>_toTex
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_toTex = function (options) {
  var parenthesis = (options &amp;&amp; options.parenthesis) ? options.parenthesis : 'keep';
  var parens = calculateNecessaryParentheses(this, parenthesis);

  var str = this.start.toTex(options);
  if (parens.start) {
    str = '\\left(' + str + '\\right)';
  }

  if (this.step) {
    var step = this.step.toTex(options);
    if (parens.step) {
      step = '\\left(' + step + '\\right)';
    }
    str += ':' + step;
  }

  var end = this.end.toTex(options);
  if (parens.end) {
    end = '\\left(' + end + '\\right)';
  }
  str += ':' + end;

  return str;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
  }

  if (typeof customTex !== 'undefined') {
    return customTex;
  }

  return this.<span class="apidocCodeKeywordSpan">_toTex</span>(options);
};

/**
 * Internal function to generate the LaTeX output.
 * This has to be implemented by every Node
 *
 * @param {Object} [options]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.RangeNode.prototype.clone" id="apidoc.element.mathjs.expression.mathWithTransform.RangeNode.prototype.clone">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.RangeNode.prototype.</span>clone
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clone = function () {
  return new RangeNode(this.start, this.end, this.step &amp;&amp; this.step);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return desc;
};

/**
 * Export the help object to JSON
 */
Help.prototype.toJSON = function () {
  var obj = object.<span class="apidocCodeKeywordSpan">clone</span>(this.doc);
  obj.mathjs = 'Help';
  return obj;
};

/**
 * Instantiate a Help object from a JSON object
 * @param {Object} json
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.RangeNode.prototype.forEach" id="apidoc.element.mathjs.expression.mathWithTransform.RangeNode.prototype.forEach">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.RangeNode.prototype.</span>forEach
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEach = function (callback) {
  callback(this.start, 'start', this);
  callback(this.end, 'end', this);
  if (this.step) {
    callback(this.step, 'step', this);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (def.indexOf(keyword) == 0) {
      matches.push(def);
    }
  }
}

// commandline keywords
['exit', 'quit', 'clear'].<span class="apidocCodeKeywordSpan">forEach</span>(function (cmd) {
  if (cmd.indexOf(keyword) == 0) {
    matches.push(cmd);
  }
});

// math functions and constants
var ignore = ['expr', 'type'];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.RangeNode.prototype.map" id="apidoc.element.mathjs.expression.mathWithTransform.RangeNode.prototype.map">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.RangeNode.prototype.</span>map
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">map = function (callback) {
  return new RangeNode(
      this._ifNode(callback(this.start, 'start', this)),
      this._ifNode(callback(this.end, 'end', this)),
      this.step &amp;&amp; this._ifNode(callback(this.step, 'step', this))
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (res &amp;&amp; res.isResultSet) {
  // we can have 0 or 1 results in the ResultSet, as the CLI
  // does not allow multiple expressions separated by a return
  res = res.entries[0];
  node = node.blocks
      .filter(function (entry) { return entry.visible; })
      .<span class="apidocCodeKeywordSpan">map</span>(function (entry) { return entry.node })[0];
}

if (node) {
  if (node.isAssignmentNode) {
    var name = findSymbolName(node);
    if (name != null) {
      scope.ans = scope[name];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.RangeNode.prototype.needsEnd" id="apidoc.element.mathjs.expression.mathWithTransform.RangeNode.prototype.needsEnd">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.RangeNode.prototype.</span>needsEnd
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">needsEnd = function () {
  // find all `end` symbols in this RangeNode
  var endSymbols = this.filter(function (node) {
    return (node &amp;&amp; node.isSymbolNode) &amp;&amp; (node.name == 'end');
  });

  return endSymbols.length &gt; 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    // TODO: Optimization: when the range values are ConstantNodes,
    //       we can beforehand resolve the zero-based value

    // optimization for a simple object property
    var dimensions = this.dimensions.map(function (range, i) {
      if (range &amp;&amp; range.isRangeNode) {
        if (range.<span class="apidocCodeKeywordSpan">needsEnd</span>()) {
childArgs.end = true;

// resolve end and create range
return '(function () {' +
    'var end = size[' + i + ']; ' +
    'return range(' +
    range.start._compile(defs, childArgs) + ', ' +
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.expression.mathWithTransform.SymbolNode.prototype" id="apidoc.module.mathjs.expression.mathWithTransform.SymbolNode.prototype">module mathjs.expression.mathWithTransform.SymbolNode.prototype</a></h1>




    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.SymbolNode.prototype._compile" id="apidoc.element.mathjs.expression.mathWithTransform.SymbolNode.prototype._compile">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.SymbolNode.prototype.</span>_compile
        <span class="apidocSignatureSpan">(defs, args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_compile = function (defs, args) {
  // add a function to the definitions
  defs['undef'] = undef;
  defs['Unit'] = Unit;
  defs.getSafeProperty = getSafeProperty;

  if (args[this.name]) {
    // this is a FunctionAssignment argument
    // (like an x when inside the expression of a function assignment `f(x) = ...`)
    return this.name;
  }
  else if (this.name in defs.math) {
    return '("' + this.name + '" in scope ? getSafeProperty(scope, "' + this.name + '") : getSafeProperty(math, "' + this.name + '"))';
  }
  else {
    return '(' +
        '"' + this.name + '" in scope ? getSafeProperty(scope, "' + this.name + '") : ' +
        (Unit.isValuelessUnit(this.name) ?
        'new Unit(null, "' + this.name + '")' :
        'undef("' + this.name + '")') +
        ')';
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * @return {string} js
   * @private
   */
  AccessorNode.prototype._compile = function (defs, args) {
defs.access = access;
defs.getSafeProperty = getSafeProperty;

var object = this.object.<span class="apidocCodeKeywordSpan">_compile</span>(defs, args);
var index = this.index._compile(defs, args);

if (this.index.isObjectProperty()) {
  var prop = this.index.getObjectProperty();
  return 'getSafeProperty(' + object + ', "' + prop + '")';
}
else if (this.index.needsSize()) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.SymbolNode.prototype._toString" id="apidoc.element.mathjs.expression.mathWithTransform.SymbolNode.prototype._toString">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.SymbolNode.prototype.</span>_toString
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_toString = function (options) {
  return this.name;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      }
  }

  if (typeof customString !== 'undefined') {
    return customString;
  }

  return this.<span class="apidocCodeKeywordSpan">_toString</span>(options);
};

/**
 * Internal function to generate the string output.
 * This has to be implemented by every Node
 *
 * @throws {Error}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.SymbolNode.prototype._toTex" id="apidoc.element.mathjs.expression.mathWithTransform.SymbolNode.prototype._toTex">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.SymbolNode.prototype.</span>_toTex
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_toTex = function (options) {
  var isUnit = false;
  if ((typeof math[this.name] === 'undefined') &amp;&amp; Unit.isValuelessUnit(this.name)) {
    isUnit = true;
  }
  var symbol = latex.toSymbol(this.name, isUnit);
  if (symbol[0] === '\\') {
    //no space needed if the symbol starts with '\'
    return symbol;
  }
  //the space prevents symbols from breaking stuff like '\cdot' if it's written right before the symbol
  return ' ' + symbol;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
  }

  if (typeof customTex !== 'undefined') {
    return customTex;
  }

  return this.<span class="apidocCodeKeywordSpan">_toTex</span>(options);
};

/**
 * Internal function to generate the LaTeX output.
 * This has to be implemented by every Node
 *
 * @param {Object} [options]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.SymbolNode.prototype.clone" id="apidoc.element.mathjs.expression.mathWithTransform.SymbolNode.prototype.clone">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.SymbolNode.prototype.</span>clone
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clone = function () {
  return new SymbolNode(this.name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return desc;
};

/**
 * Export the help object to JSON
 */
Help.prototype.toJSON = function () {
  var obj = object.<span class="apidocCodeKeywordSpan">clone</span>(this.doc);
  obj.mathjs = 'Help';
  return obj;
};

/**
 * Instantiate a Help object from a JSON object
 * @param {Object} json
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.SymbolNode.prototype.forEach" id="apidoc.element.mathjs.expression.mathWithTransform.SymbolNode.prototype.forEach">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.SymbolNode.prototype.</span>forEach
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEach = function (callback) {
  // nothing to do, we don't have childs
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (def.indexOf(keyword) == 0) {
      matches.push(def);
    }
  }
}

// commandline keywords
['exit', 'quit', 'clear'].<span class="apidocCodeKeywordSpan">forEach</span>(function (cmd) {
  if (cmd.indexOf(keyword) == 0) {
    matches.push(cmd);
  }
});

// math functions and constants
var ignore = ['expr', 'type'];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.mathWithTransform.SymbolNode.prototype.map" id="apidoc.element.mathjs.expression.mathWithTransform.SymbolNode.prototype.map">
        function <span class="apidocSignatureSpan">mathjs.expression.mathWithTransform.SymbolNode.prototype.</span>map
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">map = function (callback) {
  return this.clone();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (res &amp;&amp; res.isResultSet) {
  // we can have 0 or 1 results in the ResultSet, as the CLI
  // does not allow multiple expressions separated by a return
  res = res.entries[0];
  node = node.blocks
      .filter(function (entry) { return entry.visible; })
      .<span class="apidocCodeKeywordSpan">map</span>(function (entry) { return entry.node })[0];
}

if (node) {
  if (node.isAssignmentNode) {
    var name = findSymbolName(node);
    if (name != null) {
      scope.ans = scope[name];
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.expression.node" id="apidoc.module.mathjs.expression.node">module mathjs.expression.node</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.expression.node.AccessorNode" id="apidoc.element.mathjs.expression.node.AccessorNode">
        function <span class="apidocSignatureSpan">mathjs.expression.node.</span>AccessorNode
        <span class="apidocSignatureSpan">(object, index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AccessorNode(object, index) {
  if (!(this instanceof AccessorNode)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  if (!(object &amp;&amp; object.isNode)) {
    throw new TypeError('Node expected for parameter "object"');
  }
  if (!(index &amp;&amp; index.isIndexNode)) {
    throw new TypeError('IndexNode expected for parameter "index"');
  }

  this.object = object || null;
  this.index = index;

  // readonly property name
  Object.defineProperty(this, 'name', {
    get: function () {
      if (this.index) {
        return (this.index.isObjectProperty())
            ? this.index.getObjectProperty()
            : '';
      }
      else {
        return this.object.name || '';
      }
    }.bind(this),
    set: function () {
      throw new Error('Cannot assign a new name, name is read-only');
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.node.ArrayNode" id="apidoc.element.mathjs.expression.node.ArrayNode">
        function <span class="apidocSignatureSpan">mathjs.expression.node.</span>ArrayNode
        <span class="apidocSignatureSpan">(items)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ArrayNode(items) {
  if (!(this instanceof ArrayNode)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  this.items = items || [];

  // validate input
  if (!Array.isArray(this.items)
      || !this.items.every(function (item) {return item &amp;&amp; item.isNode;})) {
    throw new TypeError('Array containing Nodes expected');
  }

  // TODO: deprecated since v3, remove some day
  var deprecated = function () {
    throw new Error('Property `ArrayNode.nodes` is deprecated, use `ArrayNode.items` instead');
  };
  Object.defineProperty(this, 'nodes', { get: deprecated, set: deprecated });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.node.AssignmentNode" id="apidoc.element.mathjs.expression.node.AssignmentNode">
        function <span class="apidocSignatureSpan">mathjs.expression.node.</span>AssignmentNode
        <span class="apidocSignatureSpan">(object, index, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AssignmentNode(object, index, value) {
  if (!(this instanceof AssignmentNode)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  this.object = object;
  this.index = value ? index : null;
  this.value = value ? value : index;

  // validate input
  if (!object || !(object.isSymbolNode || object.isAccessorNode)) {
    throw new TypeError('SymbolNode or AccessorNode expected as "object"');
  }
  if (object &amp;&amp; object.isSymbolNode &amp;&amp; object.name === 'end') {
    throw new Error('Cannot assign to symbol "end"');
  }
  if (this.index &amp;&amp; !this.index.isIndexNode) {
    throw new TypeError('IndexNode expected as "index"');
  }
  if (!this.value || !this.value.isNode) {
    throw new TypeError('Node expected as "value"');
  }

  // readonly property name
  Object.defineProperty(this, 'name', {
    get: function () {
      if (this.index) {
        return (this.index.isObjectProperty())
            ? this.index.getObjectProperty()
            : '';
      }
      else {
        return this.object.name || '';
      }
    }.bind(this),
    set: function () {
      throw new Error('Cannot assign a new name, name is read-only');
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.node.BlockNode" id="apidoc.element.mathjs.expression.node.BlockNode">
        function <span class="apidocSignatureSpan">mathjs.expression.node.</span>BlockNode
        <span class="apidocSignatureSpan">(blocks)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BlockNode(blocks) {
  if (!(this instanceof BlockNode)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  // validate input, copy blocks
  if (!Array.isArray(blocks)) throw new Error('Array expected');
  this.blocks = blocks.map(function (block) {
    var node = block &amp;&amp; block.node;
    var visible = block &amp;&amp; block.visible !== undefined ? block.visible : true;

    if (!(node &amp;&amp; node.isNode))      throw new TypeError('Property "node" must be a Node');
    if (typeof visible !== 'boolean') throw new TypeError('Property "visible" must be a boolean');

    return {
      node: node,
      visible: visible
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.node.ConditionalNode" id="apidoc.element.mathjs.expression.node.ConditionalNode">
        function <span class="apidocSignatureSpan">mathjs.expression.node.</span>ConditionalNode
        <span class="apidocSignatureSpan">(condition, trueExpr, falseExpr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ConditionalNode(condition, trueExpr, falseExpr) {
  if (!(this instanceof ConditionalNode)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }
  if (!(condition &amp;&amp; condition.isNode)) throw new TypeError('Parameter condition must be a Node');
  if (!(trueExpr &amp;&amp; trueExpr.isNode))  throw new TypeError('Parameter trueExpr must be a Node');
  if (!(falseExpr &amp;&amp; falseExpr.isNode)) throw new TypeError('Parameter falseExpr must be a Node');

  this.condition = condition;
  this.trueExpr = trueExpr;
  this.falseExpr = falseExpr;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.node.ConstantNode" id="apidoc.element.mathjs.expression.node.ConstantNode">
        function <span class="apidocSignatureSpan">mathjs.expression.node.</span>ConstantNode
        <span class="apidocSignatureSpan">(value, valueType)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ConstantNode(value, valueType) {
  if (!(this instanceof ConstantNode)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  if (valueType) {
    if (typeof valueType !== 'string') {
      throw new TypeError('String expected for parameter "valueType"');
    }
    if (typeof value !== 'string') {
      throw new TypeError('String expected for parameter "value"');
    }

    this.value = value;
    this.valueType = valueType;
  }
  else {
    // stringify the value and determine the type
    this.value = value + '';
    this.valueType = getType(value);
  }

  if (!SUPPORTED_TYPES[this.valueType]) {
    throw new TypeError('Unsupported type of value "' + this.valueType + '"');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.node.FunctionAssignmentNode" id="apidoc.element.mathjs.expression.node.FunctionAssignmentNode">
        function <span class="apidocSignatureSpan">mathjs.expression.node.</span>FunctionAssignmentNode
        <span class="apidocSignatureSpan">(name, params, expr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function FunctionAssignmentNode(name, params, expr) {
  if (!(this instanceof FunctionAssignmentNode)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  // validate input
  if (typeof name !== 'string') throw new TypeError('String expected for parameter "name"');
  if (!Array.isArray(params))  throw new TypeError('Array containing strings or objects expected for parameter "params"');
  if (!(expr &amp;&amp; expr.isNode)) throw new TypeError('Node expected for parameter "expr"');
  if (name in keywords) throw new Error('Illegal function name, "' + name + '" is a reserved keyword');

  this.name = name;
  this.params = params.map(function (param) {
    return param &amp;&amp; param.name || param;
  });
  this.types = params.map(function (param) {
    return param &amp;&amp; param.type || 'any'
  });
  this.expr = expr;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.node.FunctionNode" id="apidoc.element.mathjs.expression.node.FunctionNode">
        function <span class="apidocSignatureSpan">mathjs.expression.node.</span>FunctionNode
        <span class="apidocSignatureSpan">(fn, args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function FunctionNode(fn, args) {
  if (!(this instanceof FunctionNode)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  if (typeof fn === 'string') {
    fn = new SymbolNode(fn);
  }

  // validate input
  if (!fn || !fn.isNode) throw new TypeError('Node expected as parameter "fn"');
  if (!Array.isArray(args)
      || !args.every(function (arg) {return arg &amp;&amp; arg.isNode;})) {
    throw new TypeError('Array containing Nodes expected for parameter "args"');
  }

  this.fn = fn;
  this.args = args || [];

  // readonly property name
  Object.defineProperty(this, 'name', {
    get: function () {
      return this.fn.name || '';
    }.bind(this),
    set: function () {
      throw new Error('Cannot assign a new name, name is read-only');
    }
  });

  // TODO: deprecated since v3, remove some day
  var deprecated = function () {
    throw new Error('Property `FunctionNode.object` is deprecated, use `FunctionNode.fn` instead');
  };
  Object.defineProperty(this, 'object', { get: deprecated, set: deprecated });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.node.IndexNode" id="apidoc.element.mathjs.expression.node.IndexNode">
        function <span class="apidocSignatureSpan">mathjs.expression.node.</span>IndexNode
        <span class="apidocSignatureSpan">(dimensions, dotNotation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function IndexNode(dimensions, dotNotation) {
  if (!(this instanceof IndexNode)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  this.dimensions = dimensions;
  this.dotNotation = dotNotation || false;

  // validate input
  if (!isArray(dimensions)
      || !dimensions.every(function (range) {return range &amp;&amp; range.isNode;})) {
    throw new TypeError('Array containing Nodes expected for parameter "dimensions"');
  }
  if (this.dotNotation &amp;&amp; !this.isObjectProperty()) {
    throw new Error('dotNotation only applicable for object properties');
  }

  // TODO: deprecated since v3, remove some day
  var deprecated = function () {
    throw new Error('Property `IndexNode.object` is deprecated, use `IndexNode.fn` instead');
  };
  Object.defineProperty(this, 'object', { get: deprecated, set: deprecated });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.node.Node" id="apidoc.element.mathjs.expression.node.Node">
        function <span class="apidocSignatureSpan">mathjs.expression.node.</span>Node
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Node() {
  if (!(this instanceof Node)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.node.ObjectNode" id="apidoc.element.mathjs.expression.node.ObjectNode">
        function <span class="apidocSignatureSpan">mathjs.expression.node.</span>ObjectNode
        <span class="apidocSignatureSpan">(properties)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ObjectNode(properties) {
  if (!(this instanceof ObjectNode)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  this.properties = properties || {};

  // validate input
  if (properties) {
    if (!(typeof properties === 'object') || Object.keys(properties).some(function (key) {
          return !properties[key] || !properties[key].isNode;
        })) {
      throw new TypeError('Object containing Nodes expected');
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.node.OperatorNode" id="apidoc.element.mathjs.expression.node.OperatorNode">
        function <span class="apidocSignatureSpan">mathjs.expression.node.</span>OperatorNode
        <span class="apidocSignatureSpan">(op, fn, args, implicit)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function OperatorNode(op, fn, args, implicit) {
  if (!(this instanceof OperatorNode)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  //validate input
  if (typeof op !== 'string') {
    throw new TypeError('string expected for parameter "op"');
  }
  if (typeof fn !== 'string') {
    throw new TypeError('string expected for parameter "fn"');
  }
  if (!Array.isArray(args)
      || !args.every(function (node) {return node &amp;&amp; node.isNode;})) {
    throw new TypeError('Array containing Nodes expected for parameter "args"');
  }

  this.implicit = (implicit === true);
  this.op = op;
  this.fn = fn;
  this.args = args || [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.node.ParenthesisNode" id="apidoc.element.mathjs.expression.node.ParenthesisNode">
        function <span class="apidocSignatureSpan">mathjs.expression.node.</span>ParenthesisNode
        <span class="apidocSignatureSpan">(content)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ParenthesisNode(content) {
  if (!(this instanceof ParenthesisNode)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  // validate input
  if (!(content &amp;&amp; content.isNode)) {
    throw new TypeError('Node expected for parameter "content"');
  }

  this.content = content;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.node.RangeNode" id="apidoc.element.mathjs.expression.node.RangeNode">
        function <span class="apidocSignatureSpan">mathjs.expression.node.</span>RangeNode
        <span class="apidocSignatureSpan">(start, end, step)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RangeNode(start, end, step) {
  if (!(this instanceof RangeNode)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  // validate inputs
  if (!(start &amp;&amp; start.isNode)) throw new TypeError('Node expected');
  if (!(end &amp;&amp; end.isNode)) throw new TypeError('Node expected');
  if (step &amp;&amp; !(step &amp;&amp; step.isNode)) throw new TypeError('Node expected');
  if (arguments.length &gt; 3) throw new Error('Too many arguments');

  this.start = start;         // included lower-bound
  this.end = end;           // included upper-bound
  this.step = step || null;  // optional step
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.node.SymbolNode" id="apidoc.element.mathjs.expression.node.SymbolNode">
        function <span class="apidocSignatureSpan">mathjs.expression.node.</span>SymbolNode
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SymbolNode(name) {
  if (!(this instanceof SymbolNode)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  // validate input
  if (typeof name !== 'string')  throw new TypeError('String expected for parameter "name"');

  this.name = name;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.node.UpdateNode" id="apidoc.element.mathjs.expression.node.UpdateNode">
        function <span class="apidocSignatureSpan">mathjs.expression.node.</span>UpdateNode
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function UpdateNode() {
  // TODO: deprecated since v3. Cleanup some day
  throw new Error('UpdateNode is deprecated. Use AssignmentNode instead.');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.expression.parse" id="apidoc.module.mathjs.expression.parse">module mathjs.expression.parse</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.expression.parse.parse" id="apidoc.element.mathjs.expression.parse.parse">
        function <span class="apidocSignatureSpan">mathjs.expression.</span>parse
        <span class="apidocSignatureSpan">(expr, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parse(expr, options) {
  if (arguments.length != 1 &amp;&amp; arguments.length != 2) {
    throw new ArgumentsError('parse', arguments.length, 1, 2);
  }

  // pass extra nodes
  extra_nodes = (options &amp;&amp; options.nodes) ? options.nodes : {};

  if (typeof expr === 'string') {
    // parse a single expression
    expression = expr;
    return parseStart();
  }
  else if (Array.isArray(expr) || expr instanceof type.Matrix) {
    // parse an array or matrix with expressions
    return deepMap(expr, function (elem) {
      if (typeof elem !== 'string') throw new TypeError('String expected');

      expression = elem;
      return parseStart();
    });
  }
  else {
    // oops
    throw new TypeError('String or matrix expected');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        if (!expr) {
          break;
        }
        switch (mode) {
          case 'eval':
            // evaluate expression
            try {
var node = math.<span class="apidocCodeKeywordSpan">parse</span>(expr);
var res = node.eval(scope);

if (res &amp;&amp; res.isResultSet) {
  // we can have 0 or 1 results in the ResultSet, as the CLI
  // does not allow multiple expressions separated by a return
  res = res.entries[0];
  node = node.blocks
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.parse.isAlpha" id="apidoc.element.mathjs.expression.parse.isAlpha">
        function <span class="apidocSignatureSpan">mathjs.expression.parse.</span>isAlpha
        <span class="apidocSignatureSpan">(c, cPrev, cNext)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isAlpha(c, cPrev, cNext) {
  return parse.isValidLatinOrGreek(c)
      || parse.isValidMathSymbol(c, cNext)
      || parse.isValidMathSymbol(cPrev, c);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
}

return;
    }

    // check for variables, functions, named operators
    if (parse.<span class="apidocCodeKeywordSpan">isAlpha</span>(c, prevPreview(), nextPreview())) {
while (parse.isAlpha(c, prevPreview(), nextPreview()) || parse.isDigit(c)) {
  token += c;
  next();
}

if (NAMED_DELIMITERS.hasOwnProperty(token)) {
  token_type = TOKENTYPE.DELIMITER;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.parse.isDecimalMark" id="apidoc.element.mathjs.expression.parse.isDecimalMark">
        function <span class="apidocSignatureSpan">mathjs.expression.parse.</span>isDecimalMark
        <span class="apidocSignatureSpan">(c, cNext)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isDecimalMark(c, cNext) {
  return c == '.' &amp;&amp; cNext !== '/' &amp;&amp; cNext !== '*' &amp;&amp; cNext !== '^';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
}
else {
  while (parse.isDigit(c)) {
    token += c;
    next();
  }
  if (parse.<span class="apidocCodeKeywordSpan">isDecimalMark</span>(c, nextPreview())) {
    token += c;
    next();
  }
}
while (parse.isDigit(c)) {
  token += c;
  next();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.parse.isDigit" id="apidoc.element.mathjs.expression.parse.isDigit">
        function <span class="apidocSignatureSpan">mathjs.expression.parse.</span>isDigit
        <span class="apidocSignatureSpan">(c)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isDigit(c) {
  return (c &gt;= '0' &amp;&amp; c &lt;= '9');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
token_type = TOKENTYPE.NUMBER;

// get number, can have a single dot
if (c == '.') {
  token += c;
  next();

  if (!parse.<span class="apidocCodeKeywordSpan">isDigit</span>(c)) {
    // this is no number, it is just a dot (can be dot notation)
    token_type = TOKENTYPE.DELIMITER;
  }
}
else {
  while (parse.isDigit(c)) {
    token += c;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.parse.isDigitDot" id="apidoc.element.mathjs.expression.parse.isDigitDot">
        function <span class="apidocSignatureSpan">mathjs.expression.parse.</span>isDigitDot
        <span class="apidocSignatureSpan">(c)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isDigitDot(c) {
  return ((c &gt;= '0' &amp;&amp; c &lt;= '9') || c == '.');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
token_type = TOKENTYPE.DELIMITER;
token = c;
next();
return;
    }

    // check for a number
    if (parse.<span class="apidocCodeKeywordSpan">isDigitDot</span>(c)) {
token_type = TOKENTYPE.NUMBER;

// get number, can have a single dot
if (c == '.') {
  token += c;
  next();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.parse.isValidLatinOrGreek" id="apidoc.element.mathjs.expression.parse.isValidLatinOrGreek">
        function <span class="apidocSignatureSpan">mathjs.expression.parse.</span>isValidLatinOrGreek
        <span class="apidocSignatureSpan">(c)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isValidLatinOrGreek(c) {
  return /^[a-zA-Z_\u00C0-\u02AF\u0370-\u03FF\u2100-\u214F]$/.test(c);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * @param {string} c      Current character in the expression
 * @param {string} cPrev  Previous character
 * @param {string} cNext  Next character
 * @return {boolean}
 */
parse.isAlpha = function isAlpha (c, cPrev, cNext) {
  return parse.<span class="apidocCodeKeywordSpan">isValidLatinOrGreek</span>(c)
      || parse.isValidMathSymbol(c, cNext)
      || parse.isValidMathSymbol(cPrev, c);
};

/**
 * Test whether a character is a valid latin, greek, or letter-like character
 * @param {string} c
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.parse.isValidMathSymbol" id="apidoc.element.mathjs.expression.parse.isValidMathSymbol">
        function <span class="apidocSignatureSpan">mathjs.expression.parse.</span>isValidMathSymbol
        <span class="apidocSignatureSpan">(high, low)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isValidMathSymbol(high, low) {
  return /^[\uD835]$/.test(high) &amp;&amp;
      /^[\uDC00-\uDFFF]$/.test(low) &amp;&amp;
      /^[^\uDC55\uDC9D\uDCA0\uDCA1\uDCA3\uDCA4\uDCA7\uDCA8\uDCAD\uDCBA\uDCBC\uDCC4\uDD06\uDD0B\uDD0C\uDD15\uDD1D\uDD3A\uDD3F\uDD45\uDD47-\uDD49\uDD51\uDEA6\uDEA7\uDFCC\uDFCD]$/.test(low);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {string} c      Current character in the expression
 * @param {string} cPrev  Previous character
 * @param {string} cNext  Next character
 * @return {boolean}
 */
parse.isAlpha = function isAlpha (c, cPrev, cNext) {
  return parse.isValidLatinOrGreek(c)
      || parse.<span class="apidocCodeKeywordSpan">isValidMathSymbol</span>(c, cNext)
      || parse.isValidMathSymbol(cPrev, c);
};

/**
 * Test whether a character is a valid latin, greek, or letter-like character
 * @param {string} c
 * @return {boolean}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.parse.isWhitespace" id="apidoc.element.mathjs.expression.parse.isWhitespace">
        function <span class="apidocSignatureSpan">mathjs.expression.parse.</span>isWhitespace
        <span class="apidocSignatureSpan">(c, nestingLevel)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isWhitespace(c, nestingLevel) {
  // TODO: also take '\r' carriage return as newline? Or does that give problems on mac?
  return c == ' ' || c == '\t' || (c == '\n' &amp;&amp; nestingLevel &gt; 0);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  function getToken() {
token_type = TOKENTYPE.NULL;
token = '';
comment = '';

// skip over whitespaces
// space, tab, and newline when inside parameters
while (parse.<span class="apidocCodeKeywordSpan">isWhitespace</span>(c, nesting_level)) {
  next();
}

// skip comment
if (c == '#') {
  while (c != '\n' &amp;&amp; c != '') {
    comment += c;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.expression.transform" id="apidoc.module.mathjs.expression.transform">module mathjs.expression.transform</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.expression.transform.concat" id="apidoc.element.mathjs.expression.transform.concat">
        function <span class="apidocSignatureSpan">mathjs.expression.transform.</span>concat
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function concat(arg0) {
  "use strict";
  var name = 'concat';
  if (arguments.length &gt; 0) {
    var varArgs = [];
    for (var i = 0; i &lt; arguments.length; i++) {
      varArgs.push(arguments[i]);
    }
    return signature0(varArgs); // signature: ...any
  }
  throw createError(name, arguments.length, 0, arguments[0], 'any');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// figure out what number of arguments the callback function expects
var args = maxArgumentCount(callback);

var recurse = function (value, index) {
  if (Array.isArray(value)) {
    value.forEach(function (child, i) {
      // we create a copy of the index array and append the new index value
      recurse(child, index.<span class="apidocCodeKeywordSpan">concat</span>(i + 1)); // one based index, hence i+1
    });
  }
  else {
    // invoke the callback function with the right number of arguments
    if (args === 1) {
      callback(value);
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.transform.filter" id="apidoc.element.mathjs.expression.transform.filter">
        function <span class="apidocSignatureSpan">mathjs.expression.transform.</span>filter
        <span class="apidocSignatureSpan">(args, math, scope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function filterTransform(args, math, scope) {
  var x, test;

  if (args[0]) {
    x = args[0].compile().eval(scope);
  }

  if (args[1]) {
    if (args[1] &amp;&amp; args[1].isSymbolNode) {
      // a function pointer, like filter([3, -2, 5], myTestFunction);
      test = args[1].compile().eval(scope);
    }
    else {
      // an equation like filter([3, -2, 5], x &gt; 0)

      // find an undefined symbol
      var _scope = scope || {};
      var symbol = args[1]
          .filter(function (node) {
            return (node &amp;&amp; node.isSymbolNode) &amp;&amp;
                !(node.name in math) &amp;&amp;
                !(node.name in _scope);
          })[0];

      // create a test function for this equation
      var sub = Object.create(_scope);
      var eq = args[1].compile();
      if (symbol) {
        var name = symbol.name;
        test = function (x) {
          sub[name] = x;
          return eq.eval(sub);
        }
      }
      else {
        throw new Error('No undefined variable found in filter equation');
      }
    }
  }

  return filter(x, test);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            }
          }
        }
      }
    }

    // remove duplicates
    matches = matches.<span class="apidocCodeKeywordSpan">filter</span>(function(elem, pos, arr) {
      return arr.indexOf(elem) == pos;
    });
  }

  return [matches, keyword];
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.transform.forEach" id="apidoc.element.mathjs.expression.transform.forEach">
        function <span class="apidocSignatureSpan">mathjs.expression.transform.</span>forEach
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function forEach(arg0, arg1) {
  "use strict";
  var name = 'forEach';
  if (test0(arg0)) { // type: Array
    if (test1(arg1)) { // type: function
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: Array, function
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'function');
  }
  if (test2(arg0)) { // type: Matrix
    if (test1(arg1)) { // type: function
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: Matrix, function
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'function');
  }
  throw createError(name, arguments.length, 0, arguments[0], 'Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (def.indexOf(keyword) == 0) {
      matches.push(def);
    }
  }
}

// commandline keywords
['exit', 'quit', 'clear'].<span class="apidocCodeKeywordSpan">forEach</span>(function (cmd) {
  if (cmd.indexOf(keyword) == 0) {
    matches.push(cmd);
  }
});

// math functions and constants
var ignore = ['expr', 'type'];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.transform.index" id="apidoc.element.mathjs.expression.transform.index">
        function <span class="apidocSignatureSpan">mathjs.expression.transform.</span>index
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function indexTransform() {
  var args = [];
  for (var i = 0, ii = arguments.length; i &lt; ii; i++) {
    var arg = arguments[i];

    // change from one-based to zero based, and convert BigNumber to number
    if (arg &amp;&amp; arg.isRange === true) {
      arg.start--;
      arg.end -= (arg.step &gt; 0 ? 0 : 2);
    }
    else if (arg &amp;&amp; arg.isSet === true) {
      arg = arg.map(function (v) { return v - 1; });
    }
    else if (arg &amp;&amp; (arg.isArray === true || arg.isMatrix)) {
      arg = arg.map(function (v) { return v - 1; });
    }
    else if (typeof arg === 'number') {
      arg--;
    }
    else if (arg &amp;&amp; arg.isBigNumber === true) {
      arg = arg.toNumber() - 1;
    }
    else if (typeof arg === 'string') {
      // leave as is
    }
    else {
      throw new TypeError('Dimension must be an Array, Matrix, number, string, or Range');
    }

    args[i] = arg;
  }

  var res = new type.Index();
  type.Index.apply(res, args);
  return res;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
          '})()'
    }
    else { // ConstantNode
      return range._compile(defs, childArgs);
    }
  });

  return 'math.<span class="apidocCodeKeywordSpan">index</span>(' + dimensions.join(', ') + ')';
};

/**
 * Execute a callback for each of the child nodes of this node
 * @param {function(child: Node, path: string, parent: Node)} callback
 */
IndexNode.prototype.forEach = function (callback) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.transform.map" id="apidoc.element.mathjs.expression.transform.map">
        function <span class="apidocSignatureSpan">mathjs.expression.transform.</span>map
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function max(arg0, arg1) {
  "use strict";
  var name = 'max';
  if (test0(arg0)) { // type: Array
    if (test1(arg1)) { // type: function
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: Array, function
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'function');
  }
  if (test2(arg0)) { // type: Matrix
    if (test1(arg1)) { // type: function
      if (arguments.length === 2) {
        return signature1(arg0, arg1); // signature: Matrix, function
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'function');
  }
  throw createError(name, arguments.length, 0, arguments[0], 'Array,Matrix');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (res &amp;&amp; res.isResultSet) {
  // we can have 0 or 1 results in the ResultSet, as the CLI
  // does not allow multiple expressions separated by a return
  res = res.entries[0];
  node = node.blocks
      .filter(function (entry) { return entry.visible; })
      .<span class="apidocCodeKeywordSpan">map</span>(function (entry) { return entry.node })[0];
}

if (node) {
  if (node.isAssignmentNode) {
    var name = findSymbolName(node);
    if (name != null) {
      scope.ans = scope[name];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.transform.max" id="apidoc.element.mathjs.expression.transform.max">
        function <span class="apidocSignatureSpan">mathjs.expression.transform.</span>max
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function max(arg0) {
  "use strict";
  var name = 'max';
  if (arguments.length &gt; 0) {
    var varArgs = [];
    for (var i = 0; i &lt; arguments.length; i++) {
      varArgs.push(arguments[i]);
    }
    return signature0(varArgs); // signature: ...any
  }
  throw createError(name, arguments.length, 0, arguments[0], 'any');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @return {number} Returns the maximum number of expected arguments.
 *                  Returns -1 when no signatures where found on the function.
 */
exports.maxArgumentCount = function (fn) {
  return Object.keys(fn.signatures || {})
      .reduce(function (args, signature) {
        var count = (signature.match(/,/g) || []).length + 1;
        return Math.<span class="apidocCodeKeywordSpan">max</span>(args, count);
      }, -1);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.transform.mean" id="apidoc.element.mathjs.expression.transform.mean">
        function <span class="apidocSignatureSpan">mathjs.expression.transform.</span>mean
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mean(arg0) {
  "use strict";
  var name = 'mean';
  if (arguments.length &gt; 0) {
    var varArgs = [];
    for (var i = 0; i &lt; arguments.length; i++) {
      varArgs.push(arguments[i]);
    }
    return signature0(varArgs); // signature: ...any
  }
  throw createError(name, arguments.length, 0, arguments[0], 'any');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Compute the mean value of matrix or a list with values.
* In case of a multi dimensional array, the mean of the flattened array
* will be calculated. When `dim` is provided, the maximum over the selected
* dimension will be calculated. Parameter `dim` is zero-based.
*
* Syntax:
*
*     math.<span class="apidocCodeKeywordSpan">mean</span>(a, b, c, ...)
*     math.mean(A)
*     math.mean(A, dim)
*
* Examples:
*
*     math.mean(2, 1, 4, 3);                     // returns 2.5
*     math.mean([1, 2.7, 3.2, 4]);               // returns 2.725
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.transform.min" id="apidoc.element.mathjs.expression.transform.min">
        function <span class="apidocSignatureSpan">mathjs.expression.transform.</span>min
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function min(arg0) {
  "use strict";
  var name = 'min';
  if (arguments.length &gt; 0) {
    var varArgs = [];
    for (var i = 0; i &lt; arguments.length; i++) {
      varArgs.push(arguments[i]);
    }
    return signature0(varArgs); // signature: ...any
  }
  throw createError(name, arguments.length, 0, arguments[0], 'any');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @private
 */
function _resize (array, size, dim, defaultValue) {
var i;
var elem;
var oldLen = array.length;
var newLen = size[dim];
var minLen = Math.<span class="apidocCodeKeywordSpan">min</span>(oldLen, newLen);

// apply new length
array.length = newLen;

if (dim &lt; size.length - 1) {
  // non-last dimension
  var dimNext = dim + 1;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.transform.range" id="apidoc.element.mathjs.expression.transform.range">
        function <span class="apidocSignatureSpan">mathjs.expression.transform.</span>range
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function range(arg0) {
  "use strict";
  var name = 'range';
  if (arguments.length &gt; 0) {
    var varArgs = [];
    for (var i = 0; i &lt; arguments.length; i++) {
      varArgs.push(arguments[i]);
    }
    return signature0(varArgs); // signature: ...any
  }
  throw createError(name, arguments.length, 0, arguments[0], 'any');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *                          the name of the argument, and the value is `true`.
 *                          The object may not be mutated, but must be
 *                          extended instead.
 * @return {string} js
 * @private
 */
RangeNode.prototype._compile = function (defs, args) {
  return 'math.<span class="apidocCodeKeywordSpan">range</span>(' +
      this.start._compile(defs, args) + ', ' +
      this.end._compile(defs, args) +
      (this.step ? (', ' + this.step._compile(defs, args)) : '') +
      ')';
};

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.expression.transform.subset" id="apidoc.element.mathjs.expression.transform.subset">
        function <span class="apidocSignatureSpan">mathjs.expression.transform.</span>subset
        <span class="apidocSignatureSpan">(arg0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function subset(arg0) {
  "use strict";
  var name = 'subset';
  if (arguments.length &gt; 0) {
    var varArgs = [];
    for (var i = 0; i &lt; arguments.length; i++) {
      varArgs.push(arguments[i]);
    }
    return signature0(varArgs); // signature: ...any
  }
  throw createError(name, arguments.length, 0, arguments[0], 'any');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function factory (type, config, load, typed) {
var matrix = load(require('../../type/matrix/function/matrix'));

/**
 * Get or set a subset of a matrix or string.
 *
 * Syntax:
 *     math.<span class="apidocCodeKeywordSpan">subset</span>(value, index)                                // retrieve a subset
 *     math.subset(value, index, replacement [, defaultValue])  // replace a subset
 *
 * Examples:
 *
 *     // get a subset
 *     var d = [[1, 2], [3, 4]];
 *     math.subset(d, math.index(1, 0));        // returns 3
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.eye" id="apidoc.module.mathjs.eye">module mathjs.eye</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.eye.factory" id="apidoc.element.mathjs.eye.factory">
        function <span class="apidocSignatureSpan">mathjs.eye.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {

  var matrix = load(require('../../type/matrix/function/matrix'));

<span class="apidocCodeCommentSpan">  /**
   * Create a 2-dimensional identity matrix with size m x n or n x n.
   * The matrix has ones on the diagonal and zeros elsewhere.
   *
   * Syntax:
   *
   *    math.eye(n)
   *    math.eye(n, format)
   *    math.eye(m, n)
   *    math.eye(m, n, format)
   *    math.eye([m, n])
   *    math.eye([m, n], format)
   *
   * Examples:
   *
   *    math.eye(3);                    // returns [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
   *    math.eye(3, 2);                 // returns [[1, 0], [0, 1], [0, 0]]
   *
   *    var A = [[1, 2, 3], [4, 5, 6]];
   *    math.eye(math.size(A));         // returns [[1, 0, 0], [0, 1, 0]]
   *
   * See also:
   *
   *    diag, ones, zeros, size, range
   *
   * @param {...number | Matrix | Array} size   The size for the matrix
   * @param {string} [format]                   The Matrix storage format
   *
   * @return {Matrix | Array | number} A matrix with ones on the diagonal.
   */
</span>  var eye = typed('eye', {
    '': function () {
      return (config.matrix === 'Matrix') ? matrix([]) : [];
    },

    'string': function (format) {
      return matrix(format);
    },

    'number | BigNumber': function (rows) {
      return _eye(rows, rows, config.matrix === 'Matrix' ? 'default' : undefined);
    },

    'number | BigNumber, string': function (rows, format) {
      return _eye(rows, rows, format);
    },

    'number | BigNumber, number | BigNumber': function (rows, cols) {
      return _eye(rows, cols, config.matrix === 'Matrix' ? 'default' : undefined);
    },

    'number | BigNumber, number | BigNumber, string': function (rows, cols, format) {
      return _eye(rows, cols, format);
    },

    'Array':  function (size) {
      return _eyeVector(size);
    },

    'Array, string':  function (size, format) {
      return _eyeVector(size, format);
    },

    'Matrix': function (size) {
      return _eyeVector(size.valueOf(), size.storage());
    },

    'Matrix, string': function (size, format) {
      return _eyeVector(size.valueOf(), format);
    }
  });

  eye.toTex = undefined; // use default template

  return eye;

  function _eyeVector (size, format) {
    switch (size.length) {
      case 0: return format ? matrix(format) : [];
      case 1: return _eye(size[0], size[0], format);
      case 2: return _eye(size[0], size[1], format);
      default: throw new Error('Vector containing two values expected');
    }
  }

  /**
   * Create an identity matrix
   * @param {number | BigNumber} rows
   * @param {number | BigNumber} cols
   * @param {string} [format]
   * @returns {Matrix}
   * @private
   */
  function _eye (rows, cols, format) {
    // BigNumber constructor with the right precision
    var Big = (rows &amp;&amp; rows.isBigNumber === true)
        ? type.BigNumber
        : (cols &amp;&amp; cols.isBigNumber === true)
            ? type.BigNumber
            : null;

    if (rows &amp;&amp; rows.isBigNumber === true) rows = rows.toNumber();
    if (cols &amp;&amp; cols.isBigNumber === true) cols = cols.toNumber();

    if (!isInteger(rows) || rows &lt; 1) {
      throw new Error('Parameters in function eye must be positive integers');
    }
    if (!isInteger(cols) || cols &lt; 1) {
      throw new Error('Parameters in function eye must be positive integers');
    }

    var one = Big ? new type.BigNumber(1) : 1;
    var defaultValue = Big ? new Big(0) : 0;
    var size = [rows, cols];

    // check we need to return a matrix
    if (format) {
      // get matrix storage constructor
      var F = type.Matrix.storage(format);
      // create diagonal matrix (use optimized implementation for storage format)
      return F.diagonal(size, one, 0, defaultValue);
    }

    // create and resize array
    var res = array.resize([], size, defaultValue);
    // fill in ones on the diagonal
    var minimum = rows &lt; cols ? rows : cols;
    // fill diagonal
    for (var d = 0; d &lt; minimum; d++) {
      res[d][d] = one;
    }
    return res;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.factorial" id="apidoc.module.mathjs.factorial">module mathjs.factorial</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.factorial.factory" id="apidoc.element.mathjs.factorial.factory">
        function <span class="apidocSignatureSpan">mathjs.factorial.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var gamma = load(require('./gamma'));
  var latex = require('../../utils/latex');

<span class="apidocCodeCommentSpan">  /**
   * Compute the factorial of a value
   *
   * Factorial only supports an integer value as argument.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.factorial(n)
   *
   * Examples:
   *
   *    math.factorial(5);    // returns 120
   *    math.factorial(3);    // returns 6
   *
   * See also:
   *
   *    combinations, gamma, permutations
   *
   * @param {number | BigNumber | Array | Matrix} n   An integer number
   * @return {number | BigNumber | Array | Matrix}    The factorial of `n`
   */
</span>  var factorial = typed('factorial', {
    'number': function (n) {
      if (n &lt; 0) {
        throw new Error('Value must be non-negative');
      }

      return gamma(n + 1);
    },

    'BigNumber': function (n) {
      if (n.isNegative()) {
        throw new Error('Value must be non-negative');
      }

      return gamma(n.plus(1));
    },

    'Array | Matrix': function (n) {
      return deepMap(n, factorial);
    }
  });

  factorial.toTex = {
    1: '\\left(${args[0]}\\right)' + latex.operators['factorial']
  };

  return factorial;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.filter" id="apidoc.module.mathjs.filter">module mathjs.filter</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.filter.factory" id="apidoc.element.mathjs.filter.factory">
        function <span class="apidocSignatureSpan">mathjs.filter.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var matrix = load(require('../../type/matrix/function/matrix'));

<span class="apidocCodeCommentSpan">  /**
   * Filter the items in an array or one dimensional matrix.
   *
   * Syntax:
   *
   *    math.filter(x, test)
   *
   * Examples:
   *
   *    function isPositive (x) {
   *      return x &gt; 0;
   *    }
   *    math.filter([6, -2, -1, 4, 3], isPositive); // returns [6, 4, 3]
   *
   *    math.filter(["23", "foo", "100", "55", "bar"], /[0-9]+/); // returns ["23", "100", "55"]
   *
   * See also:
   *
   *    forEach, map, sort
   *
   * @param {Matrix | Array} x    A one dimensional matrix or array to filter
   * @param {Function | RegExp} test
   *        A function or regular expression to test items.
   *        All entries for which `test` returns true are returned.
   *        When `test` is a function, it is invoked with three parameters:
   *        the value of the element, the index of the element, and the
   *        matrix/array being traversed. The function must return a boolean.
   * @return {Matrix | Array} Returns the filtered matrix.
   */
</span>  var filter = typed('filter', {
    'Array, function': _filterCallback,

    'Array, RegExp': _filterRegExp,

    'Matrix, function': function (x, test) {
      return matrix(_filterCallback(x.toArray(), test));
    },

    'Matrix, RegExp': function (x, test) {
      return matrix(_filterRegExp(x.toArray(), test));
    }
  });

  filter.toTex = undefined; // use default template

  return filter;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.filter_transform" id="apidoc.module.mathjs.filter_transform">module mathjs.filter_transform</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.filter_transform.factory" id="apidoc.element.mathjs.filter_transform.factory">
        function <span class="apidocSignatureSpan">mathjs.filter_transform.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var filter = load(require('../../function/matrix/filter'));
  var SymbolNode = load(require('../node/SymbolNode'));

  function filterTransform(args, math, scope) {
    var x, test;

    if (args[0]) {
      x = args[0].compile().eval(scope);
    }

    if (args[1]) {
      if (args[1] &amp;&amp; args[1].isSymbolNode) {
        // a function pointer, like filter([3, -2, 5], myTestFunction);
        test = args[1].compile().eval(scope);
      }
      else {
        // an equation like filter([3, -2, 5], x &gt; 0)

        // find an undefined symbol
        var _scope = scope || {};
        var symbol = args[1]
            .filter(function (node) {
              return (node &amp;&amp; node.isSymbolNode) &amp;&amp;
                  !(node.name in math) &amp;&amp;
                  !(node.name in _scope);
            })[0];

        // create a test function for this equation
        var sub = Object.create(_scope);
        var eq = args[1].compile();
        if (symbol) {
          var name = symbol.name;
          test = function (x) {
            sub[name] = x;
            return eq.eval(sub);
          }
        }
        else {
          throw new Error('No undefined variable found in filter equation');
        }
      }
    }

    return filter(x, test);
  }

  filterTransform.rawArgs = true;

  return filterTransform;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.fix" id="apidoc.module.mathjs.fix">module mathjs.fix</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.fix.factory" id="apidoc.element.mathjs.fix.factory">
        function <span class="apidocSignatureSpan">mathjs.fix.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
<span class="apidocCodeCommentSpan">  /**
   * Round a value towards zero.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.fix(x)
   *
   * Examples:
   *
   *    math.fix(3.2);                // returns number 3
   *    math.fix(3.8);                // returns number 3
   *    math.fix(-4.2);               // returns number -4
   *    math.fix(-4.7);               // returns number -4
   *
   *    var c = math.complex(3.2, -2.7);
   *    math.fix(c);                  // returns Complex 3 - 2i
   *
   *    math.fix([3.2, 3.8, -4.7]);   // returns Array [3, 3, -4]
   *
   * See also:
   *
   *    ceil, floor, round
   *
   * @param {number | BigNumber | Fraction | Complex | Array | Matrix} x Number to be rounded
   * @return {number | BigNumber | Fraction | Complex | Array | Matrix}            Rounded value
   */
</span>  var fix = typed('fix', {
    'number': function (x) {
      return (x &gt; 0) ? Math.floor(x) : Math.ceil(x);
    },

    'Complex': function (x) {
      return new type.Complex(
          (x.re &gt; 0) ? Math.floor(x.re) : Math.ceil(x.re),
          (x.im &gt; 0) ? Math.floor(x.im) : Math.ceil(x.im)
      );
    },

    'BigNumber': function (x) {
      return x.isNegative() ? x.ceil() : x.floor();
    },

    'Fraction': function (x) {
      return x.s &lt; 0 ? x.ceil() : x.floor();
    },

    'Array | Matrix': function (x) {
      // deep map collection, skip zeros since fix(0) = 0
      return deepMap(x, fix, true);
    }
  });

  fix.toTex = {1: '\\mathrm{${name}}\\left(${args[0]}\\right)'};

  return fix;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.flatten" id="apidoc.module.mathjs.flatten">module mathjs.flatten</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.flatten.factory" id="apidoc.element.mathjs.flatten.factory">
        function <span class="apidocSignatureSpan">mathjs.flatten.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var matrix = load(require('../../type/matrix/function/matrix'));

<span class="apidocCodeCommentSpan">  /**
   * Flatten a multi dimensional matrix into a single dimensional matrix.
   *
   * Syntax:
   *
   *    math.flatten(x)
   *
   * Examples:
   *
   *    math.flatten([[1,2], [3,4]]);   // returns [1, 2, 3, 4]
   *
   * See also:
   *
   *    concat, resize, size, squeeze
   *
   * @param {Matrix | Array} x   Matrix to be flattened
   * @return {Matrix | Array} Returns the flattened matrix
   */
</span>  var flatten = typed('flatten', {
    'Array': function (x) {
      return _flatten(clone(x));
    },

    'Matrix': function (x) {
      var flat = _flatten(clone(x.toArray()));
      // TODO: return the same matrix type as x
      return matrix(flat);
    }
  });

  flatten.toTex = undefined; // use default template

  return flatten;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.floor" id="apidoc.module.mathjs.floor">module mathjs.floor</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.floor.factory" id="apidoc.element.mathjs.floor.factory">
        function <span class="apidocSignatureSpan">mathjs.floor.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
<span class="apidocCodeCommentSpan">  /**
   * Round a value towards minus infinity.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.floor(x)
   *
   * Examples:
   *
   *    math.floor(3.2);              // returns number 3
   *    math.floor(3.8);              // returns number 3
   *    math.floor(-4.2);             // returns number -5
   *    math.floor(-4.7);             // returns number -5
   *
   *    var c = math.complex(3.2, -2.7);
   *    math.floor(c);                // returns Complex 3 - 3i
   *
   *    math.floor([3.2, 3.8, -4.7]); // returns Array [3, 3, -5]
   *
   * See also:
   *
   *    ceil, fix, round
   *
   * @param  {number | BigNumber | Fraction | Complex | Array | Matrix} x  Number to be rounded
   * @return {number | BigNumber | Fraction | Complex | Array | Matrix} Rounded value
   */
</span>  var floor = typed('floor', {
    'number': Math.floor,

    'Complex': function (x) {
      return x.floor();
    },

    'BigNumber': function (x) {
      return x.floor();
    },

    'Fraction': function (x) {
      return x.floor();
    },

    'Array | Matrix': function (x) {
      // deep map collection, skip zeros since floor(0) = 0
      return deepMap(x, floor, true);
    }
  });

  floor.toTex = {1: '\\left\\lfloor${args[0]}\\right\\rfloor'};

  return floor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.forEach" id="apidoc.module.mathjs.forEach">module mathjs.forEach</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.forEach.factory" id="apidoc.element.mathjs.forEach.factory">
        function <span class="apidocSignatureSpan">mathjs.forEach.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
<span class="apidocCodeCommentSpan">  /**
   * Iterate over all elements of a matrix/array, and executes the given callback function.
   *
   * Syntax:
   *
   *    math.forEach(x, callback)
   *
   * Examples:
   *
   *    math.forEach([1, 2, 3], function(value) {
   *      console.log(value);
   *    });
   *    // outputs 1, 2, 3
   *
   * See also:
   *
   *    filter, map, sort
   *
   * @param {Matrix | Array} x    The matrix to iterate on.
   * @param {Function} callback   The callback function is invoked with three
   *                              parameters: the value of the element, the index
   *                              of the element, and the Matrix/array being traversed.
   */
</span>  var forEach = typed('forEach', {
    'Array, function': _forEach,

    'Matrix, function': function (x, callback) {
      return x.forEach(callback);
    }
  });

  forEach.toTex = undefined; // use default template

  return forEach;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.forEach_transform" id="apidoc.module.mathjs.forEach_transform">module mathjs.forEach_transform</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.forEach_transform.factory" id="apidoc.element.mathjs.forEach_transform.factory">
        function <span class="apidocSignatureSpan">mathjs.forEach_transform.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var forEach = load(require('../../function/matrix/forEach'));

  return typed('forEach', {
    'Array | Matrix, function': function (array, callback) {
      // figure out what number of arguments the callback function expects
      var args = maxArgumentCount(callback);

      var recurse = function (value, index) {
        if (Array.isArray(value)) {
          value.forEach(function (child, i) {
            // we create a copy of the index array and append the new index value
            recurse(child, index.concat(i + 1)); // one based index, hence i+1
          });
        }
        else {
          // invoke the callback function with the right number of arguments
          if (args === 1) {
            callback(value);
          }
          else if (args === 2) {
            callback(value, index);
          }
          else { // 3 or -1
            callback(value, index, array);
          }
        }
      };
      recurse(array.valueOf(), []); // pass Array
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.format" id="apidoc.module.mathjs.format">module mathjs.format</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.format.factory" id="apidoc.element.mathjs.format.factory">
        function <span class="apidocSignatureSpan">mathjs.format.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  /**
   * Format a value of any type into a string.
   *
   * Syntax:
   *
   *    math.format(value)
   *    math.format(value, options)
   *    math.format(value, precision)
   *    math.format(value, callback)
   *
   * Where:
   *
   *  - `value: *`
   *    The value to be formatted
   *  - `options: Object`
   *    An object with formatting options. Available options:
   *    - `notation: string`
   *      Number notation. Choose from:
   *      - 'fixed'
   *        Always use regular number notation.
   *        For example '123.40' and '14000000'
   *      - 'exponential'
   *        Always use exponential notation.
   *        For example '1.234e+2' and '1.4e+7'
   *      - 'engineering'
   *        Always use engineering notation.
   *        For example '123.4e+0' and '14.0e+6'
   *      - 'auto' (default)
   *        Regular number notation for numbers having an absolute value between
   *        `lower` and `upper` bounds, and uses exponential notation elsewhere.
   *        Lower bound is included, upper bound is excluded.
   *        For example '123.4' and '1.4e7'.
   *    - `precision: number`
   *      A number between 0 and 16 to round the digits of the number. In case
   *      of notations 'exponential' and 'auto', `precision` defines the total
   *      number of significant digits returned and is undefined by default.
   *      In case of notation 'fixed', `precision` defines the number of
   *      significant digits after the decimal point, and is 0 by default.
   *    - `exponential: Object`
   *      An object containing two parameters, {number} lower and {number} upper,
   *      used by notation 'auto' to determine when to return exponential
   *      notation. Default values are `lower=1e-3` and `upper=1e5`. Only
   *      applicable for notation `auto`.
   *    - `fraction: string`. Available values: 'ratio' (default) or 'decimal'.
   *      For example `format(fraction(1, 3))` will output '1/3' when 'ratio' is
   *      configured, and will output `0.(3)` when 'decimal' is configured.
   * - `callback: function`
   *   A custom formatting function, invoked for all numeric elements in `value`,
   *   for example all elements of a matrix, or the real and imaginary
   *   parts of a complex number. This callback can be used to override the
   *   built-in numeric notation with any type of formatting. Function `callback`
   *   is called with `value` as parameter and must return a string.
   *
   * When `value` is an Object:
   *
   * - When the object contains a property `format` being a function, this function
   *   is invoked as `value.format(options)` and the result is returned.
   * - When the object has its own `toString` method, this method is invoked
   *   and the result is returned.
   * - In other cases the function will loop over all object properties and
   *   return JSON object notation like '{"a": 2, "b": 3}'.
   *
   * When value is a function:
   *
   * - When the function has a property `syntax`, it returns this
   *   syntax description.
   * - In other cases, a string `'function'` is returned.
   *
   * Examples:
   *
   *    math.format(6.4);                                        // returns '6.4'
   *    math.format(1240000);                                    // returns '1.24e6'
   *    math.format(1/3);                                        // returns '0.3333333333333333'
   *    math.format(1/3, 3);                                     // returns '0.333'
   *    math.format(21385, 2);                                   // returns '21000'
   *    math.format(12.071, {notation: 'fixed'});                // returns '12'
   *    math.format(2.3,    {notation: 'fixed', precision: 2});  // returns '2.30'
   *    math.format(52.8,   {notation: 'exponential'});          // returns '5.28e+1'
   *    math.format(12400,  {notation: 'engineering'});         // returns '12.400e+3'
   *
   *    function formatCurrency(value) {
   *      // return currency notation with two digits:
   *      return '$' + value.toFixed(2);
   *
   * ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.formatter" id="apidoc.module.mathjs.formatter">module mathjs.formatter</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.formatter.format" id="apidoc.element.mathjs.formatter.format">
        function <span class="apidocSignatureSpan">mathjs.formatter.</span>format
        <span class="apidocSignatureSpan">(value, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">format = function (value, options) {
  if (typeof options === 'function') {
    // handle format(value, fn)
    return options(value);
  }

  // handle special cases
  if (!value.isFinite()) {
    return value.isNaN() ? 'NaN' : (value.gt(0) ? 'Infinity' : '-Infinity');
  }

  // default values for options
  var notation = 'auto';
  var precision = undefined;

  if (options !== undefined) {
    // determine notation from options
    if (options.notation) {
      notation = options.notation;
    }

    // determine precision from options
    if (typeof options === 'number') {
      precision = options;
    }
    else if (options.precision) {
      precision = options.precision;
    }
  }

  // handle the various notations
  switch (notation) {
    case 'fixed':
      return exports.toFixed(value, precision);

    case 'exponential':
      return exports.toExponential(value, precision);

    case 'auto':
      // determine lower and upper bound for exponential notation.
      // TODO: implement support for upper and lower to be BigNumbers themselves
      var lower = 1e-3;
      var upper = 1e5;
      if (options &amp;&amp; options.exponential) {
        if (options.exponential.lower !== undefined) {
          lower = options.exponential.lower;
        }
        if (options.exponential.upper !== undefined) {
          upper = options.exponential.upper;
        }
      }

      // adjust the configuration of the BigNumber constructor (yeah, this is quite tricky...)
      var oldConfig = {
        toExpNeg: value.constructor.toExpNeg,
        toExpPos: value.constructor.toExpPos
      };

      value.constructor.config({
        toExpNeg: Math.round(Math.log(lower) / Math.LN10),
        toExpPos: Math.round(Math.log(upper) / Math.LN10)
      });

      // handle special case zero
      if (value.isZero()) return '0';

      // determine whether or not to output exponential notation
      var str;
      var abs = value.abs();
      if (abs.gte(lower) &amp;&amp; abs.lt(upper)) {
        // normal number notation
        str = value.toSignificantDigits(precision).toFixed();
      }
      else {
        // exponential notation
        str = exports.toExponential(value, precision);
      }

      // remove trailing zeros after the decimal point
      return str.replace(/((\.\d*?)(0+))($|e)/, function () {
        var digits = arguments[2];
        var e = arguments[4];
        return (digits !== '.') ? digits + e : e;
      });

    default:
      throw new Error('Unknown notation "' + notation + '". ' +
          'Choose "auto", "exponential", or "fixed".');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Helper function to format a value. Regular numbers will be rounded
 * to 14 digits to prevent round-off errors from showing up.
 * @param {*} value
 */
function format(value) {
var math = getMath();

return math.<span class="apidocCodeKeywordSpan">format</span>(value, {
  fn: function (value) {
    if (typeof value === 'number') {
      // round numbers
      return math.format(value, PRECISION);
    }
    else {
      return math.format(value);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.formatter.toExponential" id="apidoc.element.mathjs.formatter.toExponential">
        function <span class="apidocSignatureSpan">mathjs.formatter.</span>toExponential
        <span class="apidocSignatureSpan">(value, precision)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toExponential = function (value, precision) {
  if (precision !== undefined) {
    return value.toExponential(precision - 1); // Note the offset of one
  }
  else {
    return value.toExponential();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  // handle the various notations
  switch (notation) {
case 'fixed':
  return exports.toFixed(value, precision);

case 'exponential':
  return exports.<span class="apidocCodeKeywordSpan">toExponential</span>(value, precision);

case 'auto':
  // determine lower and upper bound for exponential notation.
  // TODO: implement support for upper and lower to be BigNumbers themselves
  var lower = 1e-3;
  var upper = 1e5;
  if (options &amp;&amp; options.exponential) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.formatter.toFixed" id="apidoc.element.mathjs.formatter.toFixed">
        function <span class="apidocSignatureSpan">mathjs.formatter.</span>toFixed
        <span class="apidocSignatureSpan">(value, precision)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toFixed = function (value, precision) {
  return value.toFixed(precision || 0);
  // Note: the (precision || 0) is needed as the toFixed of BigNumber has an
  // undefined default precision instead of 0.
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*    math.format(12.071, {notation: 'fixed'});                // returns '12'
*    math.format(2.3,    {notation: 'fixed', precision: 2});  // returns '2.30'
*    math.format(52.8,   {notation: 'exponential'});          // returns '5.28e+1'
*    math.format(12400,  {notation: 'engineering'});         // returns '12.400e+3'
*
*    function formatCurrency(value) {
*      // return currency notation with two digits:
*      return '$' + value.<span class="apidocCodeKeywordSpan">toFixed</span>(2);
*
*      // you could also use math.format inside the callback:
*      // return '$' + math.format(value, {notation: 'fixed', precision: 2});
*    }
*    math.format([2.1, 3, 0.016], formatCurrency};            // returns '[$2.10, $3.00, $0.02]'
*
* See also:
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.function" id="apidoc.module.mathjs.function">module mathjs.function</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.function.maxArgumentCount" id="apidoc.element.mathjs.function.maxArgumentCount">
        function <span class="apidocSignatureSpan">mathjs.function.</span>maxArgumentCount
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">maxArgumentCount = function (fn) {
  return Object.keys(fn.signatures || {})
      .reduce(function (args, signature) {
        var count = (signature.match(/,/g) || []).length + 1;
        return Math.max(args, count);
      }, -1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.function.memoize" id="apidoc.element.mathjs.function.memoize">
        function <span class="apidocSignatureSpan">mathjs.function.</span>memoize
        <span class="apidocSignatureSpan">(fn, hasher)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">memoize = function (fn, hasher) {
  return function memoize() {
    if (typeof memoize.cache !== 'object') {
      memoize.cache = {};
    }

    var args = [];
    for (var i = 0; i &lt; arguments.length; i++) {
      args[i] = arguments[i];
    }

    var hash = hasher ? hasher(args) : JSON.stringify(args);
    if (!(hash in memoize.cache)) {
      return memoize.cache[hash] = fn.apply(fn, args);
    }
    return memoize.cache[hash];
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.gamma" id="apidoc.module.mathjs.gamma">module mathjs.gamma</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.gamma.factory" id="apidoc.element.mathjs.gamma.factory">
        function <span class="apidocSignatureSpan">mathjs.gamma.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var multiply = load(require('../arithmetic/multiply'));
  var pow = load(require('../arithmetic/pow'));

<span class="apidocCodeCommentSpan">  /**
   * Compute the gamma function of a value using Lanczos approximation for
   * small values, and an extended Stirling approximation for large values.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.gamma(n)
   *
   * Examples:
   *
   *    math.gamma(5);       // returns 24
   *    math.gamma(-0.5);    // returns -3.5449077018110335
   *    math.gamma(math.i);  // returns -0.15494982830180973 - 0.49801566811835596i
   *
   * See also:
   *
   *    combinations, factorial, permutations
   *
   * @param {number | Array | Matrix} n   A real or complex number
   * @return {number | Array | Matrix}    The gamma of `n`
   */
</span>  var gamma = typed('gamma', {
    'number': function (n) {
      var t, x;

      if (isInteger(n)) {
        if (n &lt;= 0) {
          return isFinite(n) ? Infinity : NaN;
        }

        if (n &gt; 171) {
          return Infinity;                  // Will overflow
        }

        var value = n - 2;
        var res = n - 1;
        while (value &gt; 1) {
          res *= value;
          value--;
        }

        if (res == 0) {
          res = 1;                          // 0! is per definition 1
        }

        return res;
      }

      if (n &lt; 0.5) {
        return Math.PI / (Math.sin(Math.PI * n) * gamma(1-n));
      }

      if (n &gt;= 171.35) {
        return Infinity;                    // will overflow
      }

      if (n &gt; 85.0) {                       // Extended Stirling Approx
        var twoN = n*n;
        var threeN = twoN*n;
        var fourN = threeN*n;
        var fiveN = fourN*n;
        return Math.sqrt(2*Math.PI/n) * Math.pow((n/Math.E), n) *
            (1 + 1/(12*n) + 1/(288*twoN) - 139/(51840*threeN) -
            571/(2488320*fourN) + 163879/(209018880*fiveN) +
            5246819/(75246796800*fiveN*n));
      }

      --n;
      x = p[0];
      for (var i = 1; i &lt; p.length; ++i) {
        x += p[i] / (n+i);
      }

      t = n + g + 0.5;
      return Math.sqrt(2*Math.PI) * Math.pow(t, n+0.5) * Math.exp(-t) * x;
    },

    'Complex': function (n) {
      var t, x;

      if (n.im == 0) {
        return gamma(n.re);
      }

      n = new type.Complex(n.re - 1, n.im);
      x = new type.Complex(p[0], 0);
      for (var i = 1; i &lt; p.length; ++i) {
        var real = n.re + i;                // x += p[i]/(n+i)
        var den = real*real + n.im*n.im;
        if (den != 0) {
          x.re += p[i] * real / den;
          x.im += -(p[i] * n.im) / den;
        } else {
          x.re = p[i] &lt; 0
              ? -Infinity
              :  Infinity;
        }
      }

      t = new type.Complex(n.re + g + 0.5, n.im);
      var twoPiSqrt = Math.sqrt(2*Math.PI);

      n.re += 0.5;
      var result = pow(t, n);
      if (result.im == 0) {                 // sqrt(2*PI)*result
        result.re *= twoPiSqrt;
      } else if (result.re == 0) {
        result.im *= twoPiSqrt;
      } else {
        result.re *= twoPiSqrt;
        result.im *= twoPiSqrt;
      }

      var r = Math.exp(-t.re);              // exp(-t)
      t.re = r * Math.cos(-t.im);
      t.im = r * Math.sin(-t.im);

      return multiply(multiply(result, t), x);
    },

    'BigNumber': function (n) {
      if (n.isInteger()) {
        return (n.isNegative() || n.isZero())
            ? new type.BigNumber(Infinity)
            : bigFactorial(n.minus(1));
      }

      if (!n.isFinite()) {
        return new type.BigNumber(n.isNegative() ? NaN : Infinity);
      }

      throw new Error('Integer BigNumber expected');
    },

    'Array | Matrix': function (n) {
      return deepMap(n, gamma);
    }
  });

  /**
   * Calculate factorial for a BigNumber
   * @param {BigNumber} n
   * @returns {BigNumber} Returns the factorial of n
   */
  function bigFactorial(n) {
    if (n.isZero()) {
      return new type.BigNumber(1); // 0! is per definition 1
    }

    var precision = config.precision + (Math.log(n.toNumber() ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.gcd" id="apidoc.module.mathjs.gcd">module mathjs.gcd</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.gcd.factory" id="apidoc.element.mathjs.gcd.factory">
        function <span class="apidocSignatureSpan">mathjs.gcd.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {

  var matrix = load(require('../../type/matrix/function/matrix'));

  var algorithm01 = load(require('../../type/matrix/utils/algorithm01'));
  var algorithm04 = load(require('../../type/matrix/utils/algorithm04'));
  var algorithm10 = load(require('../../type/matrix/utils/algorithm10'));
  var algorithm13 = load(require('../../type/matrix/utils/algorithm13'));
  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));

<span class="apidocCodeCommentSpan">  /**
   * Calculate the greatest common divisor for two or more values or arrays.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.gcd(a, b)
   *    math.gcd(a, b, c, ...)
   *
   * Examples:
   *
   *    math.gcd(8, 12);              // returns 4
   *    math.gcd(-4, 6);              // returns 2
   *    math.gcd(25, 15, -10);        // returns 5
   *
   *    math.gcd([8, -4], [12, 6]);   // returns [4, 2]
   *
   * See also:
   *
   *    lcm, xgcd
   *
   * @param {... number | BigNumber | Fraction | Array | Matrix} args  Two or more integer numbers
   * @return {number | BigNumber | Fraction | Array | Matrix}                           The greatest common divisor
   */
</span>  var gcd = typed('gcd', {

    'number, number': _gcd,

    'BigNumber, BigNumber': _gcdBigNumber,

    'Fraction, Fraction': function (x, y) {
      return x.gcd(y);
    },

    'Matrix, Matrix': function (x, y) {
      // result
      var c;

      // process matrix storage
      switch (x.storage()) {
        case 'sparse':
          switch (y.storage()) {
            case 'sparse':
              // sparse + sparse
              c = algorithm04(x, y, gcd);
              break;
            default:
              // sparse + dense
              c = algorithm01(y, x, gcd, true);
              break;
          }
          break;
        default:
          switch (y.storage()) {
            case 'sparse':
              // dense + sparse
              c = algorithm01(x, y, gcd, false);
              break;
            default:
              // dense + dense
              c = algorithm13(x, y, gcd);
              break;
          }
          break;
      }
      return c;
    },

    'Array, Array': function (x, y) {
      // use matrix implementation
      return gcd(matrix(x), matrix(y)).valueOf();
    },

    'Array, Matrix': function (x, y) {
      // use matrix implementation
      return gcd(matrix(x), y);
    },

    'Matrix, Array': function (x, y) {
      // use matrix implementation
      return gcd(x, matrix(y));
    },

    'Matrix, number | BigNumber': function (x, y) {
      // result
      var c;
      // check storage format
      switch (x.storage()) {
        case 'sparse':
          c = algorithm10(x, y, gcd, false);
          break;
        default:
          c = algorithm14(x, y, gcd, false);
          break;
      }
      return c;
    },

    'number | BigNumber, Matrix': function (x, y) {
      // result
      var c;
      // check storage format
      switch (y.storage()) {
        case 'sparse':
          c = algorithm10(y, x, gcd, true);
          break;
        default:
          c = algorithm14(y, x, gcd, true);
          break;
      }
      return c;
    },

    'Array, number | BigNumber': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(x), y, gcd, false).valueOf();
    },

    'number | BigNumber, Array': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(y), x, gcd, true).valueOf();
    },

    // TODO: need a smarter notation here
    'Array | Matrix | number | BigNumber, Array | Matrix | number | BigNumber, ...Array | Matrix | number | BigNumber': function
 (a, b, args) {
      var res = gcd(a, b);
      for (var i = 0; i &lt; args.length; i++) {
        res = gcd(res, args[i]);
      }
      return res;
    }
  });

  gcd.toTex = '\\gcd\\left(${args}\\right)';

  return gcd;

  /**
   * Calculate gcd for BigNumbers
   * @param {BigNumber} a
   * @param {BigNumber} b
   * @returns {BigNumber} Returns greatest common denomin ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.hypot" id="apidoc.module.mathjs.hypot">module mathjs.hypot</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.hypot.factory" id="apidoc.element.mathjs.hypot.factory">
        function <span class="apidocSignatureSpan">mathjs.hypot.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var abs = load(require('./abs'));
  var add = load(require('./addScalar'));
  var divide = load(require('./divideScalar'));
  var multiply = load(require('./multiplyScalar'));
  var sqrt = load(require('./sqrt'));
  var smaller = load(require('../relational/smaller'));
  var isPositive = load(require('../utils/isPositive'));

<span class="apidocCodeCommentSpan">  /**
   * Calculate the hypotenusa of a list with values. The hypotenusa is defined as:
   *
   *     hypot(a, b, c, ...) = sqrt(a^2 + b^2 + c^2 + ...)
   *
   * For matrix input, the hypotenusa is calculated for all values in the matrix.
   *
   * Syntax:
   *
   *     math.hypot(a, b, ...)
   *     math.hypot([a, b, c, ...])
   *
   * Examples:
   *
   *     math.hypot(3, 4);      // 5
   *     math.hypot(3, 4, 5);   // 7.0710678118654755
   *     math.hypot([3, 4, 5]); // 7.0710678118654755
   *     math.hypot(-2);        // 2
   *
   * See also:
   *
   *     abs, norm
   *
   * @param {... number | BigNumber} args
   * @return {number | BigNumber} Returns the hypothenusa of the input values.
   */
</span>  var hypot = typed('hypot', {
    '... number | BigNumber': _hypot,

    'Array': function (x) {
      return hypot.apply(hypot, flatten(x));
    },

    'Matrix': function (x) {
      return hypot.apply(hypot, flatten(x.toArray()));
    }
  });

  /**
   * Calculate the hypotenusa for an Array with values
   * @param {Array.&lt;number | BigNumber&gt;} args
   * @return {number | BigNumber} Returns the result
   * @private
   */
  function _hypot (args) {
    // code based on `hypot` from es6-shim:
    // https://github.com/paulmillr/es6-shim/blob/master/es6-shim.js#L1619-L1633
    var result = 0;
    var largest = 0;

    for (var i = 0; i &lt; args.length; i++) {
      var value = abs(args[i]);
      if (smaller(largest, value)) {
        result = multiply(result, multiply(divide(largest, value), divide(largest, value)));
        result = add(result, 1);
        largest = value;
      } else {
        result = add(result, isPositive(value) ? multiply(divide(value, largest), divide(value, largest)) : value);
      }
    }

    return multiply(largest, sqrt(result));
  }

  hypot.toTex = '\\hypot\\left(${args}\\right)';

  return hypot;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.im" id="apidoc.module.mathjs.im">module mathjs.im</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.im.factory" id="apidoc.element.mathjs.im.factory">
        function <span class="apidocSignatureSpan">mathjs.im.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
<span class="apidocCodeCommentSpan">  /**
   * Get the imaginary part of a complex number.
   * For a complex number `a + bi`, the function returns `b`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.im(x)
   *
   * Examples:
   *
   *    var a = math.complex(2, 3);
   *    math.re(a);                     // returns number 2
   *    math.im(a);                     // returns number 3
   *
   *    math.re(math.complex('-5.2i')); // returns number -5.2
   *    math.re(math.complex(2.4));     // returns number 0
   *
   * See also:
   *
   *    re, conj, abs, arg
   *
   * @param {number | BigNumber | Complex | Array | Matrix} x
   *            A complex number or array with complex numbers
   * @return {number | BigNumber | Array | Matrix} The imaginary part of x
   */
</span>  var im = typed('im', {
    'number': function (x) {
      return 0;
    },

    'BigNumber': function (x) {
      return new type.BigNumber(0);
    },

    'Complex': function (x) {
      return x.im;
    },

    'Array | Matrix': function (x) {
      return deepMap(x, im);
    }
  });

  im.toTex = {1: '\\Im\\left\\lbrace${args[0]}\\right\\rbrace'};

  return im;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.import" id="apidoc.module.mathjs.import">module mathjs.import</a></h1>






    <h2>
        <a href="#apidoc.element.mathjs.import.factory" id="apidoc.element.mathjs.import.factory">
        function <span class="apidocSignatureSpan">mathjs.import.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed, math)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed, math) {
<span class="apidocCodeCommentSpan">  /**
   * Import functions from an object or a module
   *
   * Syntax:
   *
   *    math.import(object)
   *    math.import(object, options)
   *
   * Where:
   *
   * - `object: Object`
   *   An object with functions to be imported.
   * - `options: Object` An object with import options. Available options:
   *   - `override: boolean`
   *     If true, existing functions will be overwritten. False by default.
   *   - `silent: boolean`
   *     If true, the function will not throw errors on duplicates or invalid
   *     types. False by default.
   *   - `wrap: boolean`
   *     If true, the functions will be wrapped in a wrapper function
   *     which converts data types like Matrix to primitive data types like Array.
   *     The wrapper is needed when extending math.js with libraries which do not
   *     support these data type. False by default.
   *
   * Examples:
   *
   *    // define new functions and variables
   *    math.import({
   *      myvalue: 42,
   *      hello: function (name) {
   *        return 'hello, ' + name + '!';
   *      }
   *    });
   *
   *    // use the imported function and variable
   *    math.myvalue * 2;               // 84
   *    math.hello('user');             // 'hello, user!'
   *
   *    // import the npm module 'numbers'
   *    // (must be installed first with `npm install numbers`)
   *    math.import(require('numbers'), {wrap: true});
   *
   *    math.fibonacci(7); // returns 13
   *
   * @param {Object | Array} object   Object with functions to be imported.
   * @param {Object} [options]        Import options.
   */
</span>  function math_import(object, options) {
    var num = arguments.length;
    if (num !== 1 &amp;&amp; num !== 2) {
      throw new ArgumentsError('import', num, 1, 2);
    }

    if (!options) {
      options = {};
    }

    if (isFactory(object)) {
      _importFactory(object, options);
    }
    // TODO: allow a typed-function with name too
    else if (Array.isArray(object)) {
      object.forEach(function (entry) {
        math_import(entry, options);
      });
    }
    else if (typeof object === 'object') {
      // a map with functions
      for (var name in object) {
        if (object.hasOwnProperty(name)) {
          var value = object[name];
          if (isSupportedType(value)) {
            _import(name, value, options);
          }
          else if (isFactory(object)) {
            _importFactory(object, options);
          }
          else {
            math_import(value, options);
          }
        }
      }
    }
    else {
      if (!options.silent) {
        throw new TypeError('Factory, Object, or Array expected');
      }
    }
  }

  /**
   * Add a property to the math namespace and create a chain proxy for it.
   * @param {string} name
   * @param {*} value
   * @param {Object} options  See import for a description of the options
   * @private
   */
  function _import(name, value, options) {
    // TODO: refactor this function, it's to complicated and contains duplicate code
    if (options.wrap &amp;&amp; typeof value === 'function') {
      // create a wrapper around the function
      value = _wrap(value);
    }

    if (isTypedFunction(math[name]) &amp;&amp; isTypedFunction(value)) {
      if (options.override) {
        // give the typed function the right name
        value = typed(name, value.signatures);
      }
      else {
        // merge the existing and typed function
        value = typed(math[name], value);
      }

      math[name] = value;
      _importTransform(name, value);
      math.emit('import', name, function resolver() {
        return value;
      });
      return;
    }

    if (math[name] === undefined || options.override) {
      math[name] = value;
      _importTransform(name, value);
      math.emit('import', name, function resolver() {
        return value;
      });
      return;
    }

    if (!options.silent) {
      throw new Error('Cannot import "' + name + '": already exists');
    }
  }

  function _importTransform (name, value) {
    if (value &amp;&amp; typeof value ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.index_transform" id="apidoc.module.mathjs.index_transform">module mathjs.index_transform</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.index_transform.factory" id="apidoc.element.mathjs.index_transform.factory">
        function <span class="apidocSignatureSpan">mathjs.index_transform.</span>factory
        <span class="apidocSignatureSpan">(type, config, load)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load) {

  return function indexTransform() {
    var args = [];
    for (var i = 0, ii = arguments.length; i &lt; ii; i++) {
      var arg = arguments[i];

      // change from one-based to zero based, and convert BigNumber to number
      if (arg &amp;&amp; arg.isRange === true) {
        arg.start--;
        arg.end -= (arg.step &gt; 0 ? 0 : 2);
      }
      else if (arg &amp;&amp; arg.isSet === true) {
        arg = arg.map(function (v) { return v - 1; });
      }
      else if (arg &amp;&amp; (arg.isArray === true || arg.isMatrix)) {
        arg = arg.map(function (v) { return v - 1; });
      }
      else if (typeof arg === 'number') {
        arg--;
      }
      else if (arg &amp;&amp; arg.isBigNumber === true) {
        arg = arg.toNumber() - 1;
      }
      else if (typeof arg === 'string') {
        // leave as is
      }
      else {
        throw new TypeError('Dimension must be an Array, Matrix, number, string, or Range');
      }

      args[i] = arg;
    }

    var res = new type.Index();
    type.Index.apply(res, args);
    return res;
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.intersect" id="apidoc.module.mathjs.intersect">module mathjs.intersect</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.intersect.factory" id="apidoc.element.mathjs.intersect.factory">
        function <span class="apidocSignatureSpan">mathjs.intersect.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {

  var abs = load(require('../arithmetic/abs'));
  var add = load(require('../arithmetic/add'));
  var matrix = load(require('../../type/matrix/function/matrix'));
  var multiply = load(require('../arithmetic/multiply'));
  var subtract = load(require('../arithmetic/subtract'));

<span class="apidocCodeCommentSpan">  /**
   * Calculates the point of intersection of two lines in two or three dimensions
   * and of a line and a plane in three dimensions. The inputs are in the form of
   * arrays or 1 dimensional matrices. The line intersection functions return null
   * if the lines do not meet.
   *
   * Note: Fill the plane coefficients as `x + y + z = c` and not as `x + y + z + c = 0`.
   *
   * Syntax:
   *
   *    math.intersect(endPoint1Line1, endPoint2Line1, endPoint1Line2, endPoint2Line2)
   *    math.intersect(endPoint1, endPoint2, planeCoefficients)
   *
   * Examples:
   *
   *    math.intersect([0, 0], [10, 10], [10, 0], [0, 10]);              // Returns [5, 5]
   *    math.intersect([0, 0, 0], [10, 10, 0], [10, 0, 0], [0, 10, 0]);  // Returns [5, 5, 0]
   *    math.intersect([1, 0, 1],  [4, -2, 2], [1, 1, 1, 6]);            // Returns [7, -4, 3]
   *
   * @param  {Array | Matrix} w   Co-ordinates of first end-point of first line
   * @param  {Array | Matrix} x   Co-ordinates of second end-point of first line
   * @param  {Array | Matrix} y   Co-ordinates of first end-point of second line
   *                              OR Co-efficients of the plane's equation
   * @param  {Array | Matrix} z   Co-ordinates of second end-point of second line
   *                              OR null if the calculation is for line and plane
   * @return {Array}              Returns the point of intersection of lines/lines-planes
   */
</span>  var intersect = typed('intersect', {
    'Array, Array, Array': function (x, y, plane) {
      if (!_3d(x)) { throw new TypeError('Array with 3 numbers expected for first argument'); }
      if (!_3d(y)) { throw new TypeError('Array with 3 numbers expected for second argument'); }
      if (!_4d(plane)) { throw new TypeError('Array with 4 numbers expected as third argument'); }

      return _intersectLinePlane(x[0], x[1], x[2], y[0], y[1], y[2], plane[0], plane[1], plane[2], plane[3]);
    },

    'Array, Array, Array, Array': function (w, x, y, z) {
      if (w.length === 2) {
        if (!_2d(w)) { throw new TypeError('Array with 2 numbers expected for first argument'); }
        if (!_2d(x)) { throw new TypeError('Array with 2 numbers expected for second argument'); }
        if (!_2d(y)) { throw new TypeError('Array with 2 numbers expected for third argument'); }
        if (!_2d(z)) { throw new TypeError('Array with 2 numbers expected for fourth argument'); }

        return _intersect2d(w, x, y, z);
      }
      else if (w.length === 3) {
        if (!_3d(w)) { throw new TypeError('Array with 3 numbers expected for first argument'); }
        if (!_3d(x)) { throw new TypeError('Array with 3 numbers expected for second argument'); }
        if (!_3d(y)) { throw new TypeError('Array with 3 numbers expected for third argument'); }
        if (!_3d(z)) { throw new TypeError('Array with 3 numbers expected for fourth argument'); }

        return _intersect3d(w[0], w[1], w[2], x[0], x[1], x[2], y[0], y[1], y[2], z[0], z[1], z[2]);
      }
      else {
        throw new TypeError('Arrays with two or thee dimensional points expected');
      }
    },

    'Matrix, Matrix, Matrix': function (x, y, plane) {
      return matrix(intersect(x.valueOf(), y.valueOf(), plane.valueOf()));
    },

    'Matrix, Matrix, Matrix, Matrix': function (w, x, y, z) {
      // TODO: output matrix type should match input matrix type
      return matrix(intersect(w.valueOf(), x.valueOf(), y.valueOf(), z.valueOf()));
    }
  });

  function _2d(x) {
    return x.length === 2 &amp;&amp; typeof x[0] === 'number' &amp;&amp; typeof x[1] === 'number';
  }

  function _3d(x) {
    return x.length === 3 &amp;&amp; typeof x[0] === 'number' &amp;&amp; typeof x[1] === 'number' &amp;&amp; typeof x[2] === 'number';
  }

  function _4d(x) {
    return x.length ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.inv" id="apidoc.module.mathjs.inv">module mathjs.inv</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.inv.factory" id="apidoc.element.mathjs.inv.factory">
        function <span class="apidocSignatureSpan">mathjs.inv.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var matrix       = load(require('../../type/matrix/function/matrix'));
  var divideScalar = load(require('../arithmetic/divideScalar'));
  var addScalar    = load(require('../arithmetic/addScalar'));
  var multiply     = load(require('../arithmetic/multiply'));
  var unaryMinus   = load(require('../arithmetic/unaryMinus'));
  var det          = load(require('../matrix/det'));
  var eye          = load(require('./eye'));

<span class="apidocCodeCommentSpan">  /**
   * Calculate the inverse of a square matrix.
   *
   * Syntax:
   *
   *     math.inv(x)
   *
   * Examples:
   *
   *     math.inv([[1, 2], [3, 4]]);  // returns [[-2, 1], [1.5, -0.5]]
   *     math.inv(4);                 // returns 0.25
   *     1 / 4;                       // returns 0.25
   *
   * See also:
   *
   *     det, transpose
   *
   * @param {number | Complex | Array | Matrix} x     Matrix to be inversed
   * @return {number | Complex | Array | Matrix} The inverse of `x`.
   */
</span>  var inv = typed('inv', {
    'Array | Matrix': function (x) {
      var size = (x.isMatrix === true) ? x.size() : util.array.size(x);
      switch (size.length) {
        case 1:
          // vector
          if (size[0] == 1) {
            if (x.isMatrix === true) {
              return matrix([
                divideScalar(1, x.valueOf()[0])
              ]);
            }
            else {
              return [
                divideScalar(1, x[0])
              ];
            }
          }
          else {
            throw new RangeError('Matrix must be square ' +
            '(size: ' + util.string.format(size) + ')');
          }

        case 2:
          // two dimensional array
          var rows = size[0];
          var cols = size[1];
          if (rows == cols) {
            if (x.isMatrix === true) {
              return matrix(
                  _inv(x.valueOf(), rows, cols),
                  x.storage()
              );
            }
            else {
              // return an Array
              return _inv(x, rows, cols);
            }
          }
          else {
            throw new RangeError('Matrix must be square ' +
            '(size: ' + util.string.format(size) + ')');
          }

        default:
          // multi dimensional array
          throw new RangeError('Matrix must be two dimensional ' +
          '(size: ' + util.string.format(size) + ')');
      }
    },

    'any': function (x) {
      // scalar
      return divideScalar(1, x); // FIXME: create a BigNumber one when configured for bignumbers
    }
  });

  /**
   * Calculate the inverse of a square matrix
   * @param {Array[]} mat     A square matrix
   * @param {number} rows     Number of rows
   * @param {number} cols     Number of columns, must equal rows
   * @return {Array[]} inv    Inverse matrix
   * @private
   */
  function _inv (mat, rows, cols){
    var r, s, f, value, temp;

    if (rows == 1) {
      // this is a 1 x 1 matrix
      value = mat[0][0];
      if (value == 0) {
        throw Error('Cannot calculate inverse, determinant is zero');
      }
      return [[
        divideScalar(1, value)
      ]];
    }
    else if (rows == 2) {
      // this is a 2 x 2 matrix
      var d = det(mat);
      if (d == 0) {
        throw Error('Cannot calculate inverse, determinant is zero');
      }
      return [
        [
          divideScalar(mat[1][1], d),
          divideScalar(unaryMinus(mat[0][1]), d)
        ],
        [
          divideScalar(unaryMinus(mat[1][0]), d),
          divideScalar(mat[0][0], d)
        ]
      ];
    }
    else {
      // this is a matrix of 3 x 3 or larger
      // calculate inverse using gauss-jordan elimination
      //      http://en.wikipedia.org/wiki/Gaussian_elimination
      //      http://mathworld.wolfram.com/MatrixInverse.html
      //      http://math.uww.edu/~mcfarlat/inverse.htm

      // make a copy of the matrix (only the arrays, not of the elements)
      var A = mat.concat();
      for (r = 0; r &lt; rows; r++) {
        A[r] = A[r].concat();
      }

      // create an identity matrix which in the end will ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.isInteger" id="apidoc.module.mathjs.isInteger">module mathjs.isInteger</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.isInteger.factory" id="apidoc.element.mathjs.isInteger.factory">
        function <span class="apidocSignatureSpan">mathjs.isInteger.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
<span class="apidocCodeCommentSpan">  /**
   * Test whether a value is an integer number.
   * The function supports `number`, `BigNumber`, and `Fraction`.
   *
   * The function is evaluated element-wise in case of Array or Matrix input.
   *
   * Syntax:
   *
   *     math.isInteger(x)
   *
   * Examples:
   *
   *    math.isInteger(2);                     // returns true
   *    math.isInteger(0);                     // returns true
   *    math.isInteger(0.5);                   // returns false
   *    math.isInteger(math.bignumber(500));   // returns true
   *    math.isInteger(math.fraction(4));      // returns true
   *    math.isInteger('3');                   // returns true
   *    math.isInteger([3, 0.5, -2]);          // returns [true, false, true]
   *    math.isInteger(math.complex('2-4i');   // throws an error
   *
   * See also:
   *
   *    isNumeric, isPositive, isNegative, isZero
   *
   * @param {number | BigNumber | Fraction | Array | Matrix} x   Value to be tested
   * @return {boolean}  Returns true when `x` contains a numeric, integer value.
   *                    Throws an error in case of an unknown data type.
   */
</span>  var isInteger = typed('isInteger', {
    'number': number.isInteger, // TODO: what to do with isInteger(add(0.1, 0.2))  ?

    'BigNumber': function (x) {
      return x.isInt();
    },

    'Fraction': function (x) {
      return x.d === 1 &amp;&amp; isFinite(x.n);
    },

    'Array | Matrix': function (x) {
      return deepMap(x, isInteger);
    }
  });

  return isInteger;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.isNaN" id="apidoc.module.mathjs.isNaN">module mathjs.isNaN</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.isNaN.factory" id="apidoc.element.mathjs.isNaN.factory">
        function <span class="apidocSignatureSpan">mathjs.isNaN.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
<span class="apidocCodeCommentSpan">  /**
   * Test whether a value is NaN (not a number).
   * The function supports types `number`, `BigNumber`, `Fraction`, `Unit` and `Complex`.
   *
   * The function is evaluated element-wise in case of Array or Matrix input.
   *
   * Syntax:
   *
   *     math.isNaN(x)
   *
   * Examples:
   *
   *    math.isNaN(3);                     // returns false
   *    math.isNaN(NaN);                   // returns true
   *    math.isNaN(0);                     // returns false
   *    math.isNaN(math.bignumber(NaN));   // returns true
   *    math.isNaN(math.bignumber(0));     // returns false
   *    math.isNaN(math.fraction(-2, 5));  // returns false
   *    math.isNaN('-2');                  // returns false
   *    math.isNaN([2, 0, -3, NaN]');      // returns [false, false, false, true]
   *
   * See also:
   *
   *    isNumeric, isNegative, isPositive, isZero, isInteger
   *
   * @param {number | BigNumber | Fraction | Unit | Array | Matrix} x  Value to be tested
   * @return {boolean}  Returns true when `x` is NaN.
   *                    Throws an error in case of an unknown data type.
   */
</span>  var isNaN = typed('isNaN', {
    'number': function (x) {
      return Number.isNaN(x);
    },

    'BigNumber': function (x) {
      return x.isNaN();
    },

    'Fraction': function (x) {
      return false;
    },

    'Complex': function (x) {
      return Number.isNaN(x.re) &amp;&amp; Number.isNaN(x.im);
    },

    'Unit': function (x) {
      return Number.isNaN(x.value);
    },

    'Array | Matrix': function (x) {
      return deepMap(x, Number.isNaN);
    }
  });

  return isNaN;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.isNegative" id="apidoc.module.mathjs.isNegative">module mathjs.isNegative</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.isNegative.factory" id="apidoc.element.mathjs.isNegative.factory">
        function <span class="apidocSignatureSpan">mathjs.isNegative.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
<span class="apidocCodeCommentSpan">  /**
   * Test whether a value is negative: smaller than zero.
   * The function supports types `number`, `BigNumber`, `Fraction`, and `Unit`.
   *
   * The function is evaluated element-wise in case of Array or Matrix input.
   *
   * Syntax:
   *
   *     math.isNegative(x)
   *
   * Examples:
   *
   *    math.isNegative(3);                     // returns false
   *    math.isNegative(-2);                    // returns true
   *    math.isNegative(0);                     // returns false
   *    math.isNegative(-0);                    // returns false
   *    math.isNegative(math.bignumber(2));     // returns false
   *    math.isNegative(math.fraction(-2, 5));  // returns true
   *    math.isNegative('-2');                  // returns true
   *    math.isNegative([2, 0, -3]');           // returns [false, false, true]
   *
   * See also:
   *
   *    isNumeric, isPositive, isZero, isInteger
   *
   * @param {number | BigNumber | Fraction | Unit | Array | Matrix} x  Value to be tested
   * @return {boolean}  Returns true when `x` is larger than zero.
   *                    Throws an error in case of an unknown data type.
   */
</span>  var isNegative = typed('isNegative', {
    'number': function (x) {
      return x &lt; 0;
    },

    'BigNumber': function (x) {
      return x.isNeg() &amp;&amp; !x.isZero() &amp;&amp; !x.isNaN();
    },

    'Fraction': function (x) {
      return x.s &lt; 0; // It's enough to decide on the sign
    },

    'Unit': function (x) {
      return isNegative(x.value);
    },

    'Array | Matrix': function (x) {
      return deepMap(x, isNegative);
    }
  });

  return isNegative;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.isNumeric" id="apidoc.module.mathjs.isNumeric">module mathjs.isNumeric</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.isNumeric.factory" id="apidoc.element.mathjs.isNumeric.factory">
        function <span class="apidocSignatureSpan">mathjs.isNumeric.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
<span class="apidocCodeCommentSpan">  /**
   * Test whether a value is an numeric value.
   *
   * The function is evaluated element-wise in case of Array or Matrix input.
   *
   * Syntax:
   *
   *     math.isNumeric(x)
   *
   * Examples:
   *
   *    math.isNumeric(2);                     // returns true
   *    math.isNumeric(0);                     // returns true
   *    math.isNumeric(math.bignumber(500));   // returns true
   *    math.isNumeric(math.fraction(4));      // returns true
   *    math.isNumeric(math.complex('2-4i');   // returns false
   *    math.isNumeric('3');                   // returns false
   *    math.isNumeric([2.3, 'foo', false]);   // returns [true, false, true]
   *
   * See also:
   *
   *    isZero, isPositive, isNegative, isInteger
   *
   * @param {*} x       Value to be tested
   * @return {boolean}  Returns true when `x` is a `number`, `BigNumber`,
   *                    `Fraction`, or `boolean`. Returns false for other types.
   *                    Throws an error in case of unknown types.
   */
</span>  var isNumeric = typed('isNumeric', {
    'number | BigNumber | Fraction | boolean': function () {
      return true;
    },

    'Complex | Unit | string': function () {
      return false;
    },

    'Array | Matrix': function (x) {
      return deepMap(x, isNumeric);
    }
  });

  return isNumeric;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.isPositive" id="apidoc.module.mathjs.isPositive">module mathjs.isPositive</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.isPositive.factory" id="apidoc.element.mathjs.isPositive.factory">
        function <span class="apidocSignatureSpan">mathjs.isPositive.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
<span class="apidocCodeCommentSpan">  /**
   * Test whether a value is positive: larger than zero.
   * The function supports types `number`, `BigNumber`, `Fraction`, and `Unit`.
   *
   * The function is evaluated element-wise in case of Array or Matrix input.
   *
   * Syntax:
   *
   *     math.isPositive(x)
   *
   * Examples:
   *
   *    math.isPositive(3);                     // returns true
   *    math.isPositive(-2);                    // returns false
   *    math.isPositive(0);                     // returns false
   *    math.isPositive(-0);                    // returns false
   *    math.isPositive(0.5);                   // returns true
   *    math.isPositive(math.bignumber(2));     // returns true
   *    math.isPositive(math.fraction(-2, 5));  // returns false
   *    math.isPositive(math.fraction(1,3));    // returns false
   *    math.isPositive('2');                   // returns true
   *    math.isPositive([2, 0, -3]');           // returns [true, false, false]
   *
   * See also:
   *
   *    isNumeric, isZero, isNegative, isInteger
   *
   * @param {number | BigNumber | Fraction | Unit | Array | Matrix} x  Value to be tested
   * @return {boolean}  Returns true when `x` is larger than zero.
   *                    Throws an error in case of an unknown data type.
   */
</span>  var isPositive = typed('isPositive', {
    'number': function (x) {
      return x &gt; 0;
    },

    'BigNumber': function (x) {
      return !x.isNeg() &amp;&amp; !x.isZero() &amp;&amp; !x.isNaN();
    },

    'Fraction': function (x) {
      return x.s &gt; 0 &amp;&amp; x.n &gt; 0;
    },

    'Unit': function (x) {
      return isPositive(x.value);
    },

    'Array | Matrix': function (x) {
      return deepMap(x, isPositive);
    }
  });

  return isPositive;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.isPrime" id="apidoc.module.mathjs.isPrime">module mathjs.isPrime</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.isPrime.factory" id="apidoc.element.mathjs.isPrime.factory">
        function <span class="apidocSignatureSpan">mathjs.isPrime.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
<span class="apidocCodeCommentSpan">  /**
   * Test whether a value is prime: has no divisors other than itself and one.
   * The function supports type `number`, `bignumber`.
   *
   * The function is evaluated element-wise in case of Array or Matrix input.
   *
   * Syntax:
   *
   *     math.isPrime(x)
   *
   * Examples:
   *
   *    math.isPrime(3);                     // returns true
   *    math.isPrime(-2);                    // returns false
   *    math.isPrime(0);                     // returns false
   *    math.isPrime(-0);                    // returns false
   *    math.isPrime(0.5);                   // returns false
   *    math.isPrime('2');                   // returns true
   *    math.isPrime([2, 17, 100]');           // returns [true, true, false]
   *
   * See also:
   *
   *    isNumeric, isZero, isNegative, isInteger
   *
   * @param {number | BigNumber | Array | Matrix} x  Value to be tested
   * @return {boolean}  Returns true when `x` is larger than zero.
   *                    Throws an error in case of an unknown data type.
   */
</span>  var isPrime = typed('isPrime', {
    'number': function (x) {
      if (x &lt; 2){
        return false;
      }
      if (x == 2){
        return true;
      }
      if (x % 2 == 0){
        return false;
      }
      for (var i = 3; i * i &lt;= x; i += 2){
        if (x % i == 0){
          return false;
        }
      }
      return true;
    },

    'BigNumber': function (x) {
      if (x.lt(2)){
        return false;
      }
      if (x.equals(2)){
        return true;
      }
      if (x.mod(2).isZero()){
        return false;
      }
      for(var i = type.BigNumber(3); i.times(i).lte(x); i = i.plus(1)){
        if (x.mod(i).isZero()){
          return false;
        }
      }
      return true;
    },

    'Array | Matrix': function (x) {
      return deepMap(x, isPrime);
    }
  });

  return isPrime;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.isZero" id="apidoc.module.mathjs.isZero">module mathjs.isZero</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.isZero.factory" id="apidoc.element.mathjs.isZero.factory">
        function <span class="apidocSignatureSpan">mathjs.isZero.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
<span class="apidocCodeCommentSpan">  /**
   * Test whether a value is zero.
   * The function can check for zero for types `number`, `BigNumber`, `Fraction`,
   * `Complex`, and `Unit`.
   *
   * The function is evaluated element-wise in case of Array or Matrix input.
   *
   * Syntax:
   *
   *     math.isZero(x)
   *
   * Examples:
   *
   *    math.isZero(0);                     // returns true
   *    math.isZero(2);                     // returns false
   *    math.isZero(0.5);                   // returns false
   *    math.isZero(math.bignumber(0));     // returns true
   *    math.isZero(math.fraction(0));      // returns true
   *    math.isZero(math.fraction(1,3));    // returns false
   *    math.isZero(math.complex('2 - 4i'); // returns false
   *    math.isZero(math.complex('0i');     // returns true
   *    math.isZero('0');                   // returns true
   *    math.isZero('2');                   // returns false
   *    math.isZero([2, 0, -3]');           // returns [false, true, false]
   *
   * See also:
   *
   *    isNumeric, isPositive, isNegative, isInteger
   *
   * @param {number | BigNumber | Complex | Fraction | Unit | Array | Matrix} x       Value to be tested
   * @return {boolean}  Returns true when `x` is zero.
   *                    Throws an error in case of an unknown data type.
   */
</span>  var isZero = typed('isZero', {
    'number': function (x) {
      return x === 0;
    },

    'BigNumber': function (x) {
      return x.isZero();
    },

    'Complex': function (x) {
      return x.re === 0 &amp;&amp; x.im === 0;
    },

    'Fraction': function (x) {
      return x.d === 1 &amp;&amp; x.n === 0;
    },

    'Unit': function (x) {
      return isZero(x.value);
    },

    'Array | Matrix': function (x) {
      return deepMap(x, isZero);
    }
  });

  return isZero;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.json" id="apidoc.module.mathjs.json">module mathjs.json</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.json.reviver" id="apidoc.element.mathjs.json.reviver">
        function <span class="apidocSignatureSpan">mathjs.json.</span>reviver
        <span class="apidocSignatureSpan">(key, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reviver(key, value) {
  var constructor = type[value &amp;&amp; value.mathjs];
  if (constructor &amp;&amp; typeof constructor.fromJSON === 'function') {
    return constructor.fromJSON(value);
  }

  return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.kldivergence" id="apidoc.module.mathjs.kldivergence">module mathjs.kldivergence</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.kldivergence.factory" id="apidoc.element.mathjs.kldivergence.factory">
        function <span class="apidocSignatureSpan">mathjs.kldivergence.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
    var matrix = load(require('../../type/matrix/function/matrix'));
    var divide = load(require('../arithmetic/divide'));
    var sum = load(require('../statistics/sum'));
    var multiply = load(require('../arithmetic/multiply'));
    var dotDivide = load(require('../arithmetic/dotDivide'));
    var log = load(require('../arithmetic/log'));
    var isNumeric = load(require('../utils/isNumeric'));

<span class="apidocCodeCommentSpan">    /**
     * Calculate the Kullback-Leibler (KL) divergence  between two distributions
     *
     * Syntax:
     *
     *     math.kldivergence(x, y)
     *
     * Examples:
     *
     *     math.kldivergence([0.7,0.5,0.4], [0.2,0.9,0.5]);   //returns 0.24376698773121153
     *
     *
     * @param  {Array | Matrix} q    First vector
     * @param  {Array | Matrix} p    Second vector
     * @return {number}              Returns distance between q and p
     */
</span>    var kldivergence = typed('kldivergence', {
        'Array, Array': function(q, p) {
            return _kldiv(matrix(q), matrix(p));
        },

        'Matrix, Array': function(q, p) {
            return _kldiv(q, matrix(p));
        },

        'Array, Matrix': function(q, p){
            return _kldiv(matrix(q), p);
        },

        'Matrix, Matrix': function(q, p){
            return _kldiv(q, p);
        }

    });

    function _kldiv(q, p) {
        var plength = p.size().length;
        var qlength = q.size().length;
        if (plength &gt; 1) {
            throw new Error('first object must be one dimensional');
        }

        if (qlength &gt; 1) {
            throw new Error('second object must be one dimensional');
        }

        if(plength !== qlength){
            throw new Error("Length of two vectors must be equal");
        }

        //Before calculation, apply normalization
        var sumq = sum(q);
        if (sumq === 0) {
            throw new Error("Sum of elements in first object must be non zero");
        }

        var sump = sum(p);
        if (sump === 0) {
            throw new Error("Sum of elements in second object must be non zero");
        }
        var qnorm = divide(q, sum(q));
        var pnorm = divide(p, sum(p));

        var result = sum(multiply(qnorm, log(dotDivide(qnorm, pnorm))));
        if (isNumeric(result)) {
            return result;
        }
        else {
            return Number.NaN;
        }
    }

    return kldivergence;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.kron" id="apidoc.module.mathjs.kron">module mathjs.kron</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.kron.factory" id="apidoc.element.mathjs.kron.factory">
        function <span class="apidocSignatureSpan">mathjs.kron.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var matrix = load(require('../../type/matrix/function/matrix'));
  var multiplyScalar = load(require('../arithmetic/multiplyScalar'))
<span class="apidocCodeCommentSpan">    /**
     * Calculates the kronecker product of 2 matrices or vectors.
     *
     * NOTE: If a one dimensional vector / matrix is given, it will be
     * wrapped so its two dimensions.
     * See the examples.
     *
     * Syntax:
     *
     *    math.kron(x, y)
     *
     * Examples:
     *
     *    math.kron([[1, 0], [0, 1]], [[1, 2], [3, 4]]);
     *    // returns [ [ 1, 2, 0, 0 ], [ 3, 4, 0, 0 ], [ 0, 0, 1, 2 ], [ 0, 0, 3, 4 ] ]
     *
     *    math.kron([1,1], [2,3,4]);
     *    // returns [ [ 2, 3, 4, 2, 3, 4 ] ]
     *
     * See also:
     *
     *    multiply, dot, cross
     *
     * @param  {Array | Matrix} x     First vector
     * @param  {Array | Matrix} y     Second vector
     * @return {Array | Matrix}       Returns the kronecker product of `x` and `y`
     */
</span>    var kron = typed('kron', {
        'Matrix, Matrix': function(x, y) {
            return matrix(_kron(x.toArray(), y.toArray()));
        },

        'Matrix, Array': function(x, y) {
            return matrix(_kron(x.toArray(), y));
        },

        'Array, Matrix': function(x, y) {
            return matrix(_kron(x, y.toArray()));
        },

        'Array, Array': _kron
    });

    return kron;

    /**
     * Calculate the kronecker product of two matrices / vectors
     * @param {Array} a  First vector
     * @param {Array} b  Second vector
     * @returns {Array} Returns the kronecker product of x and y
     * @private
     */
    function _kron(a, b) {
        // Deal with the dimensions of the matricies.
        if (size(a).length === 1) {
          // Wrap it in a 2D Matrix
          a = [a];
        }
        if (size(b).length === 1) {
          // Wrap it in a 2D Matrix
          b = [b]
        }
        if (size(a).length &gt; 2 || size(b).length &gt; 2) {
            throw new RangeError('Vectors with dimensions greater then 2 are not supported expected ' +
            '(Size x = ' + JSON.stringify(a.length) + ', y = ' + JSON.stringify(b.length) + ')');
        }
        var t = [];
        var r = [];

        return a.map(function(a) {
            return b.map(function(b) {
                return a.map(function(y) {
                    return b.map(function(x) {
                        return r.push(multiplyScalar(y, x));
                    });
                }, t.push(r = []));
            });
        }, t = []) &amp;&amp; t;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.larger" id="apidoc.module.mathjs.larger">module mathjs.larger</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.larger.factory" id="apidoc.element.mathjs.larger.factory">
        function <span class="apidocSignatureSpan">mathjs.larger.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {

  var matrix = load(require('../../type/matrix/function/matrix'));

  var algorithm03 = load(require('../../type/matrix/utils/algorithm03'));
  var algorithm07 = load(require('../../type/matrix/utils/algorithm07'));
  var algorithm12 = load(require('../../type/matrix/utils/algorithm12'));
  var algorithm13 = load(require('../../type/matrix/utils/algorithm13'));
  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));

  var latex = require('../../utils/latex');

<span class="apidocCodeCommentSpan">  /**
   * Test whether value x is larger than y.
   *
   * The function returns true when x is larger than y and the relative
   * difference between x and y is larger than the configured epsilon. The
   * function cannot be used to compare values smaller than approximately 2.22e-16.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.larger(x, y)
   *
   * Examples:
   *
   *    math.larger(2, 3);             // returns false
   *    math.larger(5, 2 + 2);         // returns true
   *
   *    var a = math.unit('5 cm');
   *    var b = math.unit('2 inch');
   *    math.larger(a, b);             // returns false
   *
   * See also:
   *
   *    equal, unequal, smaller, smallerEq, largerEq, compare
   *
   * @param  {number | BigNumber | Fraction | boolean | Unit | string | Array | Matrix} x First value to compare
   * @param  {number | BigNumber | Fraction | boolean | Unit | string | Array | Matrix} y Second value to compare
   * @return {boolean | Array | Matrix} Returns true when the x is larger than y, else returns false
   */
</span>  var larger = typed('larger', {

    'boolean, boolean': function (x, y) {
      return x &gt; y;
    },

    'number, number': function (x, y) {
      return x &gt; y &amp;&amp; !nearlyEqual(x, y, config.epsilon);
    },

    'BigNumber, BigNumber': function (x, y) {
      return x.gt(y) &amp;&amp; !bigNearlyEqual(x, y, config.epsilon);
    },

    'Fraction, Fraction': function (x, y) {
      return x.compare(y) === 1;
    },

    'Complex, Complex': function () {
      throw new TypeError('No ordering relation is defined for complex numbers');
    },

    'Unit, Unit': function (x, y) {
      if (!x.equalBase(y)) {
        throw new Error('Cannot compare units with different base');
      }
      return larger(x.value, y.value);
    },

    'string, string': function (x, y) {
      return x &gt; y;
    },

    'Matrix, Matrix': function (x, y) {
      // result
      var c;

      // process matrix storage
      switch (x.storage()) {
        case 'sparse':
          switch (y.storage()) {
            case 'sparse':
              // sparse + sparse
              c = algorithm07(x, y, larger);
              break;
            default:
              // sparse + dense
              c = algorithm03(y, x, larger, true);
              break;
          }
          break;
        default:
          switch (y.storage()) {
            case 'sparse':
              // dense + sparse
              c = algorithm03(x, y, larger, false);
              break;
            default:
              // dense + dense
              c = algorithm13(x, y, larger);
              break;
          }
          break;
      }
      return c;
    },

    'Array, Array': function (x, y) {
      // use matrix implementation
      return larger(matrix(x), matrix(y)).valueOf();
    },

    'Array, Matrix': function (x, y) {
      // use matrix implementation
      return larger(matrix(x), y);
    },

    'Matrix, Array': function (x, y) {
      // use matrix implementation
      return larger(x, matrix(y));
    },

    'Matrix, any': function (x, y) {
      // result
      var c;
      // check storage format
      switch (x.storage()) {
        case 'sparse':
          c = algorithm12(x, y, larger, false);
          break;
        default:
          c = algorithm14(x, y, larger, false);
          break;
      }
      return c;
    },

    'any, Matrix': function (x, y) {
      // result
      var c;
      // check storage format
      switch (y.storage()) {
        case 'sparse': ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.largerEq" id="apidoc.module.mathjs.largerEq">module mathjs.largerEq</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.largerEq.factory" id="apidoc.element.mathjs.largerEq.factory">
        function <span class="apidocSignatureSpan">mathjs.largerEq.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {

  var matrix = load(require('../../type/matrix/function/matrix'));

  var algorithm03 = load(require('../../type/matrix/utils/algorithm03'));
  var algorithm07 = load(require('../../type/matrix/utils/algorithm07'));
  var algorithm12 = load(require('../../type/matrix/utils/algorithm12'));
  var algorithm13 = load(require('../../type/matrix/utils/algorithm13'));
  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));

  var latex = require('../../utils/latex');

<span class="apidocCodeCommentSpan">  /**
   * Test whether value x is larger or equal to y.
   *
   * The function returns true when x is larger than y or the relative
   * difference between x and y is smaller than the configured epsilon. The
   * function cannot be used to compare values smaller than approximately 2.22e-16.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.largerEq(x, y)
   *
   * Examples:
   *
   *    math.larger(2, 1 + 1);         // returns false
   *    math.largerEq(2, 1 + 1);       // returns true
   *
   * See also:
   *
   *    equal, unequal, smaller, smallerEq, larger, compare
   *
   * @param  {number | BigNumber | Fraction | boolean | Unit | string | Array | Matrix} x First value to compare
   * @param  {number | BigNumber | Fraction | boolean | Unit | string | Array | Matrix} y Second value to compare
   * @return {boolean | Array | Matrix} Returns true when the x is larger or equal to y, else returns false
   */
</span>  var largerEq = typed('largerEq', {

    'boolean, boolean': function (x, y) {
      return x &gt;= y;
    },

    'number, number': function (x, y) {
      return x &gt;= y || nearlyEqual(x, y, config.epsilon);
    },

    'BigNumber, BigNumber': function (x, y) {
      return x.gte(y) || bigNearlyEqual(x, y, config.epsilon);
    },

    'Fraction, Fraction': function (x, y) {
      return x.compare(y) !== -1;
    },

    'Complex, Complex': function () {
      throw new TypeError('No ordering relation is defined for complex numbers');
    },

    'Unit, Unit': function (x, y) {
      if (!x.equalBase(y)) {
        throw new Error('Cannot compare units with different base');
      }
      return largerEq(x.value, y.value);
    },

    'string, string': function (x, y) {
      return x &gt;= y;
    },

    'Matrix, Matrix': function (x, y) {
      // result
      var c;

      // process matrix storage
      switch (x.storage()) {
        case 'sparse':
          switch (y.storage()) {
            case 'sparse':
              // sparse + sparse
              c = algorithm07(x, y, largerEq);
              break;
            default:
              // sparse + dense
              c = algorithm03(y, x, largerEq, true);
              break;
          }
          break;
        default:
          switch (y.storage()) {
            case 'sparse':
              // dense + sparse
              c = algorithm03(x, y, largerEq, false);
              break;
            default:
              // dense + dense
              c = algorithm13(x, y, largerEq);
              break;
          }
          break;
      }
      return c;
    },

    'Array, Array': function (x, y) {
      // use matrix implementation
      return largerEq(matrix(x), matrix(y)).valueOf();
    },

    'Array, Matrix': function (x, y) {
      // use matrix implementation
      return largerEq(matrix(x), y);
    },

    'Matrix, Array': function (x, y) {
      // use matrix implementation
      return largerEq(x, matrix(y));
    },

    'Matrix, any': function (x, y) {
      // result
      var c;
      // check storage format
      switch (x.storage()) {
        case 'sparse':
          c = algorithm12(x, y, largerEq, false);
          break;
        default:
          c = algorithm14(x, y, largerEq, false);
          break;
      }
      return c;
    },

    'any, Matrix': function (x, y) {
      // result
      var c;
      // check storage format
      switch (y.storage()) {
        case 'sparse':
          c = algorithm12(y, x, largerEq, true);
          break;
        default: ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.latex" id="apidoc.module.mathjs.latex">module mathjs.latex</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.latex.toSymbol" id="apidoc.element.mathjs.latex.toSymbol">
        function <span class="apidocSignatureSpan">mathjs.latex.</span>toSymbol
        <span class="apidocSignatureSpan">(name, isUnit)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toSymbol = function (name, isUnit) {
  isUnit = typeof isUnit === 'undefined' ? false : isUnit;
  if (isUnit) {
    if (units.hasOwnProperty(name)) {
      return units[name];
    }
    return '\\mathrm{' + name + '}';
  }

  if (exports.symbols.hasOwnProperty(name)) {
    return exports.symbols[name];
  }
  else if (name.indexOf('_') !== -1) {
    //symbol with index (eg. alpha_1)
    var index = name.indexOf('_');
    return exports.toSymbol(name.substring(0, index)) + '_{'
      + exports.toSymbol(name.substring(index + 1)) + '}';
  }
  return name;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  if (exports.symbols.hasOwnProperty(name)) {
    return exports.symbols[name];
  }
  else if (name.indexOf('_') !== -1) {
    //symbol with index (eg. alpha_1)
    var index = name.indexOf('_');
    return exports.<span class="apidocCodeKeywordSpan">toSymbol</span>(name.substring(0, index)) + '_{'
      + exports.toSymbol(name.substring(index + 1)) + '}';
  }
  return name;
};
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.lcm" id="apidoc.module.mathjs.lcm">module mathjs.lcm</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.lcm.factory" id="apidoc.element.mathjs.lcm.factory">
        function <span class="apidocSignatureSpan">mathjs.lcm.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {

  var matrix = load(require('../../type/matrix/function/matrix'));

  var algorithm02 = load(require('../../type/matrix/utils/algorithm02'));
  var algorithm06 = load(require('../../type/matrix/utils/algorithm06'));
  var algorithm11 = load(require('../../type/matrix/utils/algorithm11'));
  var algorithm13 = load(require('../../type/matrix/utils/algorithm13'));
  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));

<span class="apidocCodeCommentSpan">  /**
   * Calculate the least common multiple for two or more values or arrays.
   *
   * lcm is defined as:
   *
   *     lcm(a, b) = abs(a * b) / gcd(a, b)
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.lcm(a, b)
   *    math.lcm(a, b, c, ...)
   *
   * Examples:
   *
   *    math.lcm(4, 6);               // returns 12
   *    math.lcm(6, 21);              // returns 42
   *    math.lcm(6, 21, 5);           // returns 210
   *
   *    math.lcm([4, 6], [6, 21]);    // returns [12, 42]
   *
   * See also:
   *
   *    gcd, xgcd
   *
   * @param {... number | BigNumber | Array | Matrix} args  Two or more integer numbers
   * @return {number | BigNumber | Array | Matrix}                           The least common multiple
   */
</span>  var lcm = typed('lcm', {
    'number, number': _lcm,

    'BigNumber, BigNumber': _lcmBigNumber,

    'Fraction, Fraction': function (x, y) {

      return x.lcm(y);
    },

    'Matrix, Matrix': function (x, y) {
      // result
      var c;

      // process matrix storage
      switch (x.storage()) {
        case 'sparse':
          switch (y.storage()) {
            case 'sparse':
              // sparse + sparse
              c = algorithm06(x, y, lcm);
              break;
            default:
              // sparse + dense
              c = algorithm02(y, x, lcm, true);
              break;
          }
          break;
        default:
          switch (y.storage()) {
            case 'sparse':
              // dense + sparse
              c = algorithm02(x, y, lcm, false);
              break;
            default:
              // dense + dense
              c = algorithm13(x, y, lcm);
              break;
          }
          break;
      }
      return c;
    },

    'Array, Array': function (x, y) {
      // use matrix implementation
      return lcm(matrix(x), matrix(y)).valueOf();
    },

    'Array, Matrix': function (x, y) {
      // use matrix implementation
      return lcm(matrix(x), y);
    },

    'Matrix, Array': function (x, y) {
      // use matrix implementation
      return lcm(x, matrix(y));
    },

    'Matrix, number | BigNumber': function (x, y) {
      // result
      var c;
      // check storage format
      switch (x.storage()) {
        case 'sparse':
          c = algorithm11(x, y, lcm, false);
          break;
        default:
          c = algorithm14(x, y, lcm, false);
          break;
      }
      return c;
    },

    'number | BigNumber, Matrix': function (x, y) {
      // result
      var c;
      // check storage format
      switch (y.storage()) {
        case 'sparse':
          c = algorithm11(y, x, lcm, true);
          break;
        default:
          c = algorithm14(y, x, lcm, true);
          break;
      }
      return c;
    },

    'Array, number | BigNumber': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(x), y, lcm, false).valueOf();
    },

    'number | BigNumber, Array': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(y), x, lcm, true).valueOf();
    },

    // TODO: need a smarter notation here
    'Array | Matrix | number | BigNumber, Array | Matrix | number | BigNumber, ...Array | Matrix | number | BigNumber': function
 (a, b, args) {
      var res = lcm(a, b);
      for (var i = 0; i &lt; args.length; i++) {
        res = lcm(res, args[i]);
      }
      return res;
    }
  });

  lcm.toTex = undefined;  // use default template

  return lcm;

  /**
   * Calculate lcm for two BigNumbers
   * @param {BigNumber} a
   * @param {BigNu ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.leftShift" id="apidoc.module.mathjs.leftShift">module mathjs.leftShift</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.leftShift.factory" id="apidoc.element.mathjs.leftShift.factory">
        function <span class="apidocSignatureSpan">mathjs.leftShift.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var latex = require('../../utils/latex');

  var matrix = load(require('../../type/matrix/function/matrix'));
  var equalScalar = load(require('../relational/equalScalar'));
  var zeros = load(require('../matrix/zeros'));

  var algorithm01 = load(require('../../type/matrix/utils/algorithm01'));
  var algorithm02 = load(require('../../type/matrix/utils/algorithm02'));
  var algorithm08 = load(require('../../type/matrix/utils/algorithm08'));
  var algorithm10 = load(require('../../type/matrix/utils/algorithm10'));
  var algorithm11 = load(require('../../type/matrix/utils/algorithm11'));
  var algorithm13 = load(require('../../type/matrix/utils/algorithm13'));
  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));

<span class="apidocCodeCommentSpan">  /**
   * Bitwise left logical shift of a value x by y number of bits, `x &lt;&lt; y`.
   * For matrices, the function is evaluated element wise.
   * For units, the function is evaluated on the best prefix base.
   *
   * Syntax:
   *
   *    math.leftShift(x, y)
   *
   * Examples:
   *
   *    math.leftShift(1, 2);               // returns number 4
   *
   *    math.leftShift([1, 2, 3], 4);       // returns Array [16, 32, 64]
   *
   * See also:
   *
   *    leftShift, bitNot, bitOr, bitXor, rightArithShift, rightLogShift
   *
   * @param  {number | BigNumber | Array | Matrix} x Value to be shifted
   * @param  {number | BigNumber} y Amount of shifts
   * @return {number | BigNumber | Array | Matrix} `x` shifted left `y` times
   */
</span>  var leftShift = typed('leftShift', {

    'number, number': function (x, y) {
      if (!isInteger(x) || !isInteger(y)) {
        throw new Error('Integers expected in function leftShift');
      }

      return x &lt;&lt; y;
    },

    'BigNumber, BigNumber': bigLeftShift,

    'Matrix, Matrix': function (x, y) {
      // result
      var c;

      // process matrix storage
      switch (x.storage()) {
        case 'sparse':
          switch (y.storage()) {
            case 'sparse':
              // sparse &amp; sparse
              c = algorithm08(x, y, leftShift, false);
              break;
            default:
              // sparse &amp; dense
              c = algorithm02(y, x, leftShift, true);
              break;
          }
          break;
        default:
          switch (y.storage()) {
            case 'sparse':
              // dense &amp; sparse
              c = algorithm01(x, y, leftShift, false);
              break;
            default:
              // dense &amp; dense
              c = algorithm13(x, y, leftShift);
              break;
          }
          break;
      }
      return c;
    },

    'Array, Array': function (x, y) {
      // use matrix implementation
      return leftShift(matrix(x), matrix(y)).valueOf();
    },

    'Array, Matrix': function (x, y) {
      // use matrix implementation
      return leftShift(matrix(x), y);
    },

    'Matrix, Array': function (x, y) {
      // use matrix implementation
      return leftShift(x, matrix(y));
    },

    'Matrix, number | BigNumber': function (x, y) {
      // check scalar
      if (!equalScalar(y, 0)) {
        // result
        var c;
        // check storage format
        switch (x.storage()) {
          case 'sparse':
            c = algorithm11(x, y, leftShift, false);
            break;
          default:
            c = algorithm14(x, y, leftShift, false);
            break;
        }
        return c;
      }
      return x.clone();
    },

    'number | BigNumber, Matrix': function (x, y) {
      // check scalar
      if (!equalScalar(x, 0)) {
        // result
        var c;
        // check storage format
        switch (y.storage()) {
          case 'sparse':
            c = algorithm10(y, x, leftShift, true);
            break;
          default:
            c = algorithm14(y, x, leftShift, true);
            break;
        }
        return c;
      }
      return zeros(y.size(), y.storage());
    },

    'Array, number | BigNumber': function (x, y) {
      // use matrix implementation
      return leftShift(matrix(x), y).valueOf( ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.log10" id="apidoc.module.mathjs.log10">module mathjs.log10</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.log10.factory" id="apidoc.element.mathjs.log10.factory">
        function <span class="apidocSignatureSpan">mathjs.log10.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
<span class="apidocCodeCommentSpan">  /**
   * Calculate the 10-base logarithm of a value. This is the same as calculating `log(x, 10)`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.log10(x)
   *
   * Examples:
   *
   *    math.log10(0.00001);            // returns -5
   *    math.log10(10000);              // returns 4
   *    math.log(10000) / math.log(10); // returns 4
   *    math.pow(10, 4);                // returns 10000
   *
   * See also:
   *
   *    exp, log
   *
   * @param {number | BigNumber | Complex | Array | Matrix} x
   *            Value for which to calculate the logarithm.
   * @return {number | BigNumber | Complex | Array | Matrix}
   *            Returns the 10-base logarithm of `x`
   */
</span>  var log10 = typed('log10', {
    'number': function (x) {
      if (x &gt;= 0 || config.predictable) {
        return _log10(x);
      }
      else {
        // negative value -&gt; complex value computation
        return new type.Complex(x, 0).log().div(Math.LN10);
      }
    },

    'Complex': function (x) {
      return new type.Complex(x).log().div(Math.LN10);
    },

    'BigNumber': function (x) {
      if (!x.isNegative() || config.predictable) {
        return x.log();
      }
      else {
        // downgrade to number, return Complex valued result
        return new type.Complex(x.toNumber(), 0).log().div(Math.LN10);
      }
    },

    'Array | Matrix': function (x) {
      return deepMap(x, log10);
    }
  });

  log10.toTex = {1: '\\log_{10}\\left(${args[0]}\\right)'};

  return log10;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.mad" id="apidoc.module.mathjs.mad">module mathjs.mad</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.mad.factory" id="apidoc.element.mathjs.mad.factory">
        function <span class="apidocSignatureSpan">mathjs.mad.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var abs      = load(require('../arithmetic/abs'));
  var map      = load(require('../matrix/map'));
  var median   = load(require('../statistics/median'));
  var subtract = load(require('../arithmetic/subtract'));

<span class="apidocCodeCommentSpan">  /**
   * Compute the median absolute deviation of a matrix or a list with values.
   * The median absolute deviation is defined as the median of the absolute
   * deviations from the median.
   *
   * Syntax:
   *
   *     math.mad(a, b, c, ...)
   *     math.mad(A)
   *
   * Examples:
   *
   *     math.mad(10, 20, 30);             // returns 10
   *     math.mad([1, 2, 3]);              // returns 1
   *     math.mad([[1, 2, 3], [4, 5, 6]]); // returns 1.5
   *
   * See also:
   *
   *     median, mean, std, abs
   *
   * @param {Array | Matrix} array
   *                        A single matrix or multiple scalar values.
   * @return {*} The median absolute deviation.
   */
</span>  var mad = typed('mad', {
    // mad([a, b, c, d, ...])
    'Array | Matrix': _mad,

    // mad(a, b, c, d, ...)
    '...': function (args) {
      return _mad(args);
    }
  });

  mad.toTex = undefined; // use default template

  return mad;

  function _mad(array) {
    array = flatten(array.valueOf());

    if (array.length === 0) {
      throw new Error('Cannot calculate median absolute deviation of an empty array');
    }

    var med = median(array);
    return median(map(array, function (value) {
      return abs(subtract(value, med));
    }));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.map" id="apidoc.module.mathjs.map">module mathjs.map</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.map.factory" id="apidoc.element.mathjs.map.factory">
        function <span class="apidocSignatureSpan">mathjs.map.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
<span class="apidocCodeCommentSpan">  /**
   * Create a new matrix or array with the results of the callback function executed on
   * each entry of the matrix/array.
   *
   * Syntax:
   *
   *    math.map(x, callback)
   *
   * Examples:
   *
   *    math.map([1, 2, 3], function(value) {
   *      return value * value;
   *    });  // returns [1, 4, 9]
   *
   * See also:
   *
   *    filter, forEach, sort
   *
   * @param {Matrix | Array} x    The matrix to iterate on.
   * @param {Function} callback   The callback method is invoked with three
   *                              parameters: the value of the element, the index
   *                              of the element, and the matrix being traversed.
   * @return {Matrix | array}     Transformed map of x
   */
</span>  var map = typed('map', {
    'Array, function': _map,

    'Matrix, function': function (x, callback) {
      return x.map(callback);
    }
  });

  map.toTex = undefined; // use default template

  return map;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.map_transform" id="apidoc.module.mathjs.map_transform">module mathjs.map_transform</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.map_transform.factory" id="apidoc.element.mathjs.map_transform.factory">
        function <span class="apidocSignatureSpan">mathjs.map_transform.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var map = load(require('../../function/matrix/map'));
  var matrix = load(require('../../type/matrix/function/matrix'));

  return typed('max', {
    'Array, function': function (x, callback) {
      return _map(x, callback, x);
    },

    'Matrix, function': function (x, callback) {
      return matrix(_map(x.valueOf(), callback, x));
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.max" id="apidoc.module.mathjs.max">module mathjs.max</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.max.factory" id="apidoc.element.mathjs.max.factory">
        function <span class="apidocSignatureSpan">mathjs.max.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var larger = load(require('../relational/larger'));

<span class="apidocCodeCommentSpan">  /**
   * Compute the maximum value of a matrix or a  list with values.
   * In case of a multi dimensional array, the maximum of the flattened array
   * will be calculated. When `dim` is provided, the maximum over the selected
   * dimension will be calculated. Parameter `dim` is zero-based.
   *
   * Syntax:
   *
   *     math.max(a, b, c, ...)
   *     math.max(A)
   *     math.max(A, dim)
   *
   * Examples:
   *
   *     math.max(2, 1, 4, 3);                  // returns 4
   *     math.max([2, 1, 4, 3]);                // returns 4
   *
   *     // maximum over a specified dimension (zero-based)
   *     math.max([[2, 5], [4, 3], [1, 7]], 0); // returns [4, 7]
   *     math.max([[2, 5], [4, 3]], [1, 7], 1); // returns [5, 4, 7]
   *
   *     math.max(2.7, 7.1, -4.5, 2.0, 4.1);    // returns 7.1
   *     math.min(2.7, 7.1, -4.5, 2.0, 4.1);    // returns -4.5
   *
   * See also:
   *
   *    mean, median, min, prod, std, sum, var
   *
   * @param {... *} args  A single matrix or or multiple scalar values
   * @return {*} The maximum value
   */
</span>  var max = typed('max', {
    // max([a, b, c, d, ...])
    'Array | Matrix': _max,

    // max([a, b, c, d, ...], dim)
    'Array | Matrix, number | BigNumber': function (array, dim) {
      return reduce(array, dim.valueOf(), _largest);
    },

    // max(a, b, c, d, ...)
    '...': function (args) {
      if (containsCollections(args)) {
        throw new TypeError('Scalar values expected in function max');
      }

      return _max(args);
    }
  });

  max.toTex = '\\max\\left(${args}\\right)';

  return max;

  /**
   * Return the largest of two values
   * @param {*} x
   * @param {*} y
   * @returns {*} Returns x when x is largest, or y when y is largest
   * @private
   */
  function _largest(x, y){
    return larger(x, y) ? x : y;
  }

  /**
   * Recursively calculate the maximum value in an n-dimensional array
   * @param {Array} array
   * @return {number} max
   * @private
   */
  function _max(array) {
    var max = undefined;

    deepForEach(array, function (value) {
      if (max === undefined || larger(value, max)) {
        max = value;
      }
    });

    if (max === undefined) {
      throw new Error('Cannot calculate max of an empty array');
    }

    return max;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.max_transform" id="apidoc.module.mathjs.max_transform">module mathjs.max_transform</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.max_transform.factory" id="apidoc.element.mathjs.max_transform.factory">
        function <span class="apidocSignatureSpan">mathjs.max_transform.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var max = load(require('../../function/statistics/max'));

  return typed('max', {
    '...any': function (args) {
      // change last argument dim from one-based to zero-based
      if (args.length == 2 &amp;&amp; isCollection(args[0])) {
        var dim = args[1];
        if (typeof dim === 'number') {
          args[1] = dim - 1;
        }
        else if (dim &amp;&amp; dim.isBigNumber === true) {
          args[1] = dim.minus(1);
        }
      }

      try {
        return max.apply(null, args);
      }
      catch (err) {
        throw errorTransform(err);
      }
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.mean" id="apidoc.module.mathjs.mean">module mathjs.mean</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.mean.factory" id="apidoc.element.mathjs.mean.factory">
        function <span class="apidocSignatureSpan">mathjs.mean.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var add = load(require('../arithmetic/add'));
  var divide = load(require('../arithmetic/divide'));

<span class="apidocCodeCommentSpan">  /**
   * Compute the mean value of matrix or a list with values.
   * In case of a multi dimensional array, the mean of the flattened array
   * will be calculated. When `dim` is provided, the maximum over the selected
   * dimension will be calculated. Parameter `dim` is zero-based.
   *
   * Syntax:
   *
   *     math.mean(a, b, c, ...)
   *     math.mean(A)
   *     math.mean(A, dim)
   *
   * Examples:
   *
   *     math.mean(2, 1, 4, 3);                     // returns 2.5
   *     math.mean([1, 2.7, 3.2, 4]);               // returns 2.725
   *
   *     math.mean([[2, 5], [6, 3], [1, 7]], 0);    // returns [3, 5]
   *     math.mean([[2, 5], [6, 3], [1, 7]], 1);    // returns [3.5, 4.5, 4]
   *
   * See also:
   *
   *     median, min, max, sum, prod, std, var
   *
   * @param {... *} args  A single matrix or or multiple scalar values
   * @return {*} The mean of all values
   */
</span>  var mean = typed('mean', {
      // mean([a, b, c, d, ...])
    'Array | Matrix': _mean,

      // mean([a, b, c, d, ...], dim)
    'Array | Matrix, number | BigNumber': _nmean,

    // mean(a, b, c, d, ...)
    '...': function (args) {
      if (containsCollections(args)) {
        throw new TypeError('Scalar values expected in function mean');
      }

      return _mean(args);
    }
  });

  mean.toTex = undefined; // use default template

  return mean;

  /**
   * Calculate the mean value in an n-dimensional array, returning a
   * n-1 dimensional array
   * @param {Array} array
   * @param {number} dim
   * @return {number} mean
   * @private
   */
  function _nmean(array, dim){
    var sum = reduce(array, dim, add);
    var s = Array.isArray(array) ? size(array) : array.size();
    return divide(sum, s[dim]);
  }

  /**
   * Recursively calculate the mean value in an n-dimensional array
   * @param {Array} array
   * @return {number} mean
   * @private
   */
  function _mean(array) {
    var sum = 0;
    var num = 0;

    deepForEach(array, function (value) {
      sum = add(sum, value);
      num++;
    });

    if (num === 0) {
      throw new Error('Cannot calculate mean of an empty array');
    }

    return divide(sum, num);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.mean_transform" id="apidoc.module.mathjs.mean_transform">module mathjs.mean_transform</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.mean_transform.factory" id="apidoc.element.mathjs.mean_transform.factory">
        function <span class="apidocSignatureSpan">mathjs.mean_transform.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var mean = load(require('../../function/statistics/mean'));

  return typed('mean', {
    '...any': function (args) {
      // change last argument dim from one-based to zero-based
      if (args.length == 2 &amp;&amp; isCollection(args[0])) {
        var dim = args[1];
        if (typeof dim === 'number') {
          args[1] = dim - 1;
        }
        else if (dim &amp;&amp; dim.isBigNumber === true) {
          args[1] = dim.minus(1);
        }
      }

      try {
        return mean.apply(null, args);
      }
      catch (err) {
        throw errorTransform(err);
      }
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.median" id="apidoc.module.mathjs.median">module mathjs.median</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.median.factory" id="apidoc.element.mathjs.median.factory">
        function <span class="apidocSignatureSpan">mathjs.median.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var add = load(require('../arithmetic/addScalar'));
  var divide = load(require('../arithmetic/divideScalar'));
  var compare = load(require('../relational/compare'));
  var partitionSelect = load(require('../matrix/partitionSelect'));

<span class="apidocCodeCommentSpan">  /**
   * Compute the median of a matrix or a list with values. The values are
   * sorted and the middle value is returned. In case of an even number of
   * values, the average of the two middle values is returned.
   * Supported types of values are: Number, BigNumber, Unit
   *
   * In case of a (multi dimensional) array or matrix, the median of all
   * elements will be calculated.
   *
   * Syntax:
   *
   *     math.median(a, b, c, ...)
   *     math.median(A)
   *
   * Examples:
   *
   *     math.median(5, 2, 7);        // returns 5
   *     math.median([3, -1, 5, 7]);  // returns 4
   *
   * See also:
   *
   *     mean, min, max, sum, prod, std, var, quantileSeq
   *
   * @param {... *} args  A single matrix or or multiple scalar values
   * @return {*} The median
   */
</span>  var median = typed('median', {
    // median([a, b, c, d, ...])
    'Array | Matrix': _median,

    // median([a, b, c, d, ...], dim)
    'Array | Matrix, number | BigNumber': function (array, dim) {
      // TODO: implement median(A, dim)
      throw new Error('median(A, dim) is not yet supported');
      //return reduce(arguments[0], arguments[1], ...);
    },

    // median(a, b, c, d, ...)
    '...': function (args) {
      if (containsCollections(args)) {
          throw new TypeError('Scalar values expected in function median');
      }

      return _median(args);
    }
  });


  /**
   * Recursively calculate the median of an n-dimensional array
   * @param {Array} array
   * @return {Number} median
   * @private
   */
  function _median(array) {
    array = flatten(array.valueOf());

    var num = array.length;
    if (num == 0) {
      throw new Error('Cannot calculate median of an empty array');
    }

    if (num % 2 == 0) {
      // even: return the average of the two middle values
      var mid = num / 2 - 1;
      var right = partitionSelect(array, mid + 1);

      // array now partitioned at mid + 1, take max of left part
      var left = array[mid];
      for (var i = 0; i &lt; mid; ++i) {
        if (compare(array[i], left) &gt; 0) {
          left = array[i];
        }
      }

      return middle2(left, right);
    }
    else {
      // odd: return the middle value
      var m = partitionSelect(array, (num - 1) / 2);

      return middle(m);
    }
  }

  // helper function to type check the middle value of the array
  var middle = typed({
    'number | BigNumber | Unit': function (value) {
      return value;
    }
  });

  // helper function to type check the two middle value of the array
  var middle2 = typed({
    'number | BigNumber | Unit, number | BigNumber | Unit': function (left, right) {
      return divide(add(left, right), 2);
    }
  });

  median.toTex = undefined; // use default template

  return median;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.mod" id="apidoc.module.mathjs.mod">module mathjs.mod</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.mod.factory" id="apidoc.element.mathjs.mod.factory">
        function <span class="apidocSignatureSpan">mathjs.mod.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {

  var matrix = load(require('../../type/matrix/function/matrix'));
  var latex = require('../../utils/latex');

  var algorithm02 = load(require('../../type/matrix/utils/algorithm02'));
  var algorithm03 = load(require('../../type/matrix/utils/algorithm03'));
  var algorithm05 = load(require('../../type/matrix/utils/algorithm05'));
  var algorithm11 = load(require('../../type/matrix/utils/algorithm11'));
  var algorithm12 = load(require('../../type/matrix/utils/algorithm12'));
  var algorithm13 = load(require('../../type/matrix/utils/algorithm13'));
  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));

<span class="apidocCodeCommentSpan">  /**
   * Calculates the modulus, the remainder of an integer division.
   *
   * For matrices, the function is evaluated element wise.
   *
   * The modulus is defined as:
   *
   *     x - y * floor(x / y)
   *
   * See http://en.wikipedia.org/wiki/Modulo_operation.
   *
   * Syntax:
   *
   *    math.mod(x, y)
   *
   * Examples:
   *
   *    math.mod(8, 3);                // returns 2
   *    math.mod(11, 2);               // returns 1
   *
   *    function isOdd(x) {
   *      return math.mod(x, 2) != 0;
   *    }
   *
   *    isOdd(2);                      // returns false
   *    isOdd(3);                      // returns true
   *
   * See also:
   *
   *    divide
   *
   * @param  {number | BigNumber | Fraction | Array | Matrix} x Dividend
   * @param  {number | BigNumber | Fraction | Array | Matrix} y Divisor
   * @return {number | BigNumber | Fraction | Array | Matrix} Returns the remainder of `x` divided by `y`.
   */
</span>  var mod = typed('mod', {

    'number, number': _mod,

    'BigNumber, BigNumber': function (x, y) {
      return y.isZero() ? x : x.mod(y);
    },

    'Fraction, Fraction': function (x, y) {
      return x.mod(y);
    },

    'Matrix, Matrix': function (x, y) {
      // result
      var c;

      // process matrix storage
      switch (x.storage()) {
        case 'sparse':
          switch (y.storage()) {
            case 'sparse':
              // mod(sparse, sparse)
              c = algorithm05(x, y, mod, false);
              break;
            default:
              // mod(sparse, dense)
              c = algorithm02(y, x, mod, true);
              break;
          }
          break;
        default:
          switch (y.storage()) {
            case 'sparse':
              // mod(dense, sparse)
              c = algorithm03(x, y, mod, false);
              break;
            default:
              // mod(dense, dense)
              c = algorithm13(x, y, mod);
              break;
          }
          break;
      }
      return c;
    },

    'Array, Array': function (x, y) {
      // use matrix implementation
      return mod(matrix(x), matrix(y)).valueOf();
    },

    'Array, Matrix': function (x, y) {
      // use matrix implementation
      return mod(matrix(x), y);
    },

    'Matrix, Array': function (x, y) {
      // use matrix implementation
      return mod(x, matrix(y));
    },

    'Matrix, any': function (x, y) {
      // result
      var c;
      // check storage format
      switch (x.storage()) {
        case 'sparse':
          c = algorithm11(x, y, mod, false);
          break;
        default:
          c = algorithm14(x, y, mod, false);
          break;
      }
      return c;
    },

    'any, Matrix': function (x, y) {
      // result
      var c;
      // check storage format
      switch (y.storage()) {
        case 'sparse':
          c = algorithm12(y, x, mod, true);
          break;
        default:
          c = algorithm14(y, x, mod, true);
          break;
      }
      return c;
    },

    'Array, any': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(x), y, mod, false).valueOf();
    },

    'any, Array': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(y), x, mod, true).valueOf();
    }
  });

  mod.toTex = {
    2: '\\left(${args[0]}' + latex.operators['mod'] + '${args[1]}\\right)'
  };

  return mod;

  /** ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.mode" id="apidoc.module.mathjs.mode">module mathjs.mode</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.mode.factory" id="apidoc.element.mathjs.mode.factory">
        function <span class="apidocSignatureSpan">mathjs.mode.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {

<span class="apidocCodeCommentSpan">  /**
  * Computes the mode of a set of numbers or a list with values(numbers or characters).
  * If there are more than one modes, it returns a list of those values.
  *
  * Syntax:
  *
  *     math.mode(a, b, c, ...)
  *     math.mode(A)
  *
  * Examples:
  *
  *     math.mode(2, 1, 4, 3, 1);                            // returns [1]
  *     math.mode([1, 2.7, 3.2, 4, 2.7]);                    // returns [2.7]
  *     math.mode(1, 4, 6, 1, 6)                             // returns [1, 6]
  *     math.mode('a','a','b','c')                           // returns ["a"]
  *     math.mode(1, 1.5, 'abc')                             // returns [1, 1.5, "abc"]
  *
  * See also:
  *
  *     median,
  *     mean
  *
  * @param {... *} args  A single matrix
  * @return {*} The mode of all values
  */
</span>
  var mode = typed('mode', {
    'Array | Matrix' : _mode,

    '...': function (args) {
      return _mode(args);
    }
  });

  return mode;

  /**
   * Calculates the mode in an 1-dimensional array
   * @param {Array} values
   * @return {number} mode
   * @private
   */
  function _mode(values) {
    values = flatten(values.valueOf());
    var num = values.length;
    if (num == 0) {
      throw new Error('Cannot calculate mode of an empty array');
    }

    var count = {},
        mode = [],
        max = 0;
    for (var i in values) {
      if (!(values[i] in count)){
        count[values[i]] = 0;
      }
      count[values[i]]++;
      if (count[values[i]] == max){
        mode.push(values[i]);
      }
      else if (count[values[i]] &gt; max) {
        max = count[values[i]];
        mode = [values[i]];
      }
    }
    return mode;
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.multinomial" id="apidoc.module.mathjs.multinomial">module mathjs.multinomial</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.multinomial.factory" id="apidoc.element.mathjs.multinomial.factory">
        function <span class="apidocSignatureSpan">mathjs.multinomial.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var add = load(require('../arithmetic/add'));
  var multiply = load(require('../arithmetic/multiply'));
  var divide = load(require('../arithmetic/divide'));
  var factorial = load(require('../probability/factorial'));
  var isInteger = load(require('../utils/isInteger'));
  var isPositive = load(require('../utils/isPositive'));

<span class="apidocCodeCommentSpan">  /**
   * Multinomial Coefficients compute the number of ways of picking a1, a2, ..., ai unordered outcomes from `n` possibilities.
   *
   * multinomial takes one array of integers as an argument.
   * The following condition must be enforced: every ai &lt;= 0
   *
   * Syntax:
   *
   *     math.multinomial(a) // a is an array type
   *
   * Examples:
   *
   *    math.multinomial([1,2,1]); // returns 12
   *
   * See also:
   *
   *    combinations, factorial
   *
   * @param {number[] | BigNumber[]} a    Integer numbers of objects in the subset
   * @return {Number | BigNumber}         Multinomial coefficient.
   */
</span>  return typed('multinomial', {
    'Array | Matrix': function (a) {
      var sum = 0;
      var denom = 1;

      deepForEach(a, function(ai) {
        if(!isInteger(ai) || !isPositive(ai)) {
          throw new TypeError('Positive integer value expected in function multinomial');
        }
        sum = add(sum, ai);
        denom = multiply(denom, factorial(ai));
      });

      return divide(factorial(sum), denom);
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.multiply" id="apidoc.module.mathjs.multiply">module mathjs.multiply</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.multiply.factory" id="apidoc.element.mathjs.multiply.factory">
        function <span class="apidocSignatureSpan">mathjs.multiply.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var latex = require('../../utils/latex');

  var matrix = load(require('../../type/matrix/function/matrix'));
  var addScalar = load(require('./addScalar'));
  var multiplyScalar = load(require('./multiplyScalar'));
  var equalScalar = load(require('../relational/equalScalar'));

  var algorithm11 = load(require('../../type/matrix/utils/algorithm11'));
  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));

  var DenseMatrix = type.DenseMatrix;
  var SparseMatrix = type.SparseMatrix;

<span class="apidocCodeCommentSpan">  /**
   * Multiply two or more values, `x * y`.
   * For matrices, the matrix product is calculated.
   *
   * Syntax:
   *
   *    math.multiply(x, y)
   *    math.multiply(x, y, z, ...)
   *
   * Examples:
   *
   *    math.multiply(4, 5.2);        // returns number 20.8
   *    math.multiply(2, 3, 4);       // returns number 24
   *
   *    var a = math.complex(2, 3);
   *    var b = math.complex(4, 1);
   *    math.multiply(a, b);          // returns Complex 5 + 14i
   *
   *    var c = [[1, 2], [4, 3]];
   *    var d = [[1, 2, 3], [3, -4, 7]];
   *    math.multiply(c, d);          // returns Array [[7, -6, 17], [13, -4, 33]]
   *
   *    var e = math.unit('2.1 km');
   *    math.multiply(3, e);          // returns Unit 6.3 km
   *
   * See also:
   *
   *    divide, prod, cross, dot
   *
   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x First value to multiply
   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} y Second value to multiply
   * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} Multiplication of `x` and `y`
   */
</span>  var multiply = typed('multiply', extend({
    // we extend the signatures of multiplyScalar with signatures dealing with matrices

    'Array, Array': function (x, y) {
      // check dimensions
      _validateMatrixDimensions(array.size(x), array.size(y));

      // use dense matrix implementation
      var m = multiply(matrix(x), matrix(y));
      // return array or scalar
      return (m &amp;&amp; m.isMatrix === true) ? m.valueOf() : m;
    },

    'Matrix, Matrix': function (x, y) {
      // dimensions
      var xsize = x.size();
      var ysize = y.size();

      // check dimensions
      _validateMatrixDimensions(xsize, ysize);

      // process dimensions
      if (xsize.length === 1) {
        // process y dimensions
        if (ysize.length === 1) {
          // Vector * Vector
          return _multiplyVectorVector(x, y, xsize[0]);
        }
        // Vector * Matrix
        return _multiplyVectorMatrix(x, y);
      }
      // process y dimensions
      if (ysize.length === 1) {
        // Matrix * Vector
        return _multiplyMatrixVector(x, y);
      }
      // Matrix * Matrix
      return _multiplyMatrixMatrix(x, y);
    },

    'Matrix, Array': function (x, y) {
      // use Matrix * Matrix implementation
      return multiply(x, matrix(y));
    },

    'Array, Matrix': function (x, y) {
      // use Matrix * Matrix implementation
      return multiply(matrix(x, y.storage()), y);
    },

    'Matrix, any': function (x, y) {
      // result
      var c;

      // process storage format
      switch (x.storage()) {
        case 'sparse':
          c = algorithm11(x, y, multiplyScalar, false);
          break;
        case 'dense':
          c = algorithm14(x, y, multiplyScalar, false);
          break;
      }
      return c;
    },

    'any, Matrix': function (x, y) {
      // result
      var c;
      // check storage format
      switch (y.storage()) {
        case 'sparse':
          c = algorithm11(y, x, multiplyScalar, true);
          break;
        case 'dense':
          c = algorithm14(y, x, multiplyScalar, true);
          break;
      }
      return c;
    },

    'Array, any': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(x), y, multiplyScalar, false).valueOf();
    },

    'any, Array': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(y), x, multiplyScalar, tr ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.multiplyScalar" id="apidoc.module.mathjs.multiplyScalar">module mathjs.multiplyScalar</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.multiplyScalar.factory" id="apidoc.element.mathjs.multiplyScalar.factory">
        function <span class="apidocSignatureSpan">mathjs.multiplyScalar.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {

<span class="apidocCodeCommentSpan">  /**
   * Multiply two scalar values, `x * y`.
   * This function is meant for internal use: it is used by the public function
   * `multiply`
   *
   * This function does not support collections (Array or Matrix), and does
   * not validate the number of of inputs.
   *
   * @param  {number | BigNumber | Fraction | Complex | Unit} x   First value to multiply
   * @param  {number | BigNumber | Fraction | Complex} y          Second value to multiply
   * @return {number | BigNumber | Fraction | Complex | Unit}                      Multiplication of `x` and `y`
   * @private
   */
</span>  var multiplyScalar = typed('multiplyScalar', {

    'number, number': function (x, y) {
      return x * y;
    },

    'Complex, Complex': function (x, y) {
      return x.mul(y);
    },

    'BigNumber, BigNumber': function (x, y) {
      return x.times(y);
    },

    'Fraction, Fraction': function (x, y) {
      return x.mul(y);
    },

    'number | Fraction | BigNumber | Complex, Unit': function (x, y) {
      var res = y.clone();
      res.value = (res.value === null) ? res._normalize(x) : multiplyScalar(res.value, x);
      return res;
    },

    'Unit, number | Fraction | BigNumber | Complex': function (x, y) {
      var res = x.clone();
      res.value = (res.value === null) ? res._normalize(y) : multiplyScalar(res.value, y);
      return res;
    },

    'Unit, Unit': function (x, y) {
      return x.multiply(y);
    }

  });

  return multiplyScalar;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.norm" id="apidoc.module.mathjs.norm">module mathjs.norm</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.norm.factory" id="apidoc.element.mathjs.norm.factory">
        function <span class="apidocSignatureSpan">mathjs.norm.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {

  var abs         = load(require('../arithmetic/abs'));
  var add         = load(require('../arithmetic/add'));
  var pow         = load(require('../arithmetic/pow'));
  var sqrt        = load(require('../arithmetic/sqrt'));
  var multiply    = load(require('../arithmetic/multiply'));
  var equalScalar = load(require('../relational/equalScalar'));
  var larger      = load(require('../relational/larger'));
  var smaller     = load(require('../relational/smaller'));
  var matrix      = load(require('../../type/matrix/function/matrix'));
  var trace       = load(require('../matrix/trace'));
  var transpose   = load(require('../matrix/transpose'));


<span class="apidocCodeCommentSpan">  /**
   * Calculate the norm of a number, vector or matrix.
   *
   * The second parameter p is optional. If not provided, it defaults to 2.
   *
   * Syntax:
   *
   *    math.norm(x)
   *    math.norm(x, p)
   *
   * Examples:
   *
   *    math.abs(-3.5);                         // returns 3.5
   *    math.norm(-3.5);                        // returns 3.5
   *
   *    math.norm(math.complex(3, -4));         // returns 5
   *
   *    math.norm([1, 2, -3], Infinity);        // returns 3
   *    math.norm([1, 2, -3], -Infinity);       // returns 1
   *
   *    math.norm([3, 4], 2);                   // returns 5
   *
   *    math.norm([[1, 2], [3, 4]], 1)          // returns 6
   *    math.norm([[1, 2], [3, 4]], 'inf');     // returns 7
   *    math.norm([[1, 2], [3, 4]], 'fro');     // returns 5.477225575051661
   *
   * See also:
   *
   *    abs, hypot
   *
   * @param  {number | BigNumber | Complex | Array | Matrix} x
   *            Value for which to calculate the norm
   * @param  {number | BigNumber | string} [p=2]
   *            Vector space.
   *            Supported numbers include Infinity and -Infinity.
   *            Supported strings are: 'inf', '-inf', and 'fro' (The Frobenius norm)
   * @return {number | BigNumber} the p-norm
   */
</span>  var norm = typed('norm', {
    'number': Math.abs,

    'Complex': function (x) {
      return x.abs();
    },

    'BigNumber': function (x) {
      // norm(x) = abs(x)
      return x.abs();
    },

    'boolean | null' : function (x) {
      // norm(x) = abs(x)
      return Math.abs(x);
    },

    'Array': function (x) {
      return _norm(matrix(x), 2);
    },

    'Matrix': function (x) {
      return _norm(x, 2);
    },

    'number | Complex | BigNumber | boolean | null, number | BigNumber | string': function (x) {
      // ignore second parameter, TODO: remove the option of second parameter for these types
      return norm(x);
    },

    'Array, number | BigNumber | string': function (x, p) {
      return _norm(matrix(x), p);
    },

    'Matrix, number | BigNumber | string': function (x, p) {
      return _norm(x, p);
    }
  });

  /**
   * Calculate the norm for an array
   * @param {Array} x
   * @param {number | string} p
   * @returns {number} Returns the norm
   * @private
   */
  function _norm (x, p) {
    // size
    var sizeX = x.size();

    // check if it is a vector
    if (sizeX.length == 1) {
      // check p
      if (p === Number.POSITIVE_INFINITY || p === 'inf') {
        // norm(x, Infinity) = max(abs(x))
        var pinf = 0;
        // skip zeros since abs(0) == 0
        x.forEach(
          function (value) {
            var v = abs(value);
            if (larger(v, pinf))
              pinf = v;
          },
          true);
        return pinf;
      }
      if (p === Number.NEGATIVE_INFINITY || p === '-inf') {
        // norm(x, -Infinity) = min(abs(x))
        var ninf;
        // skip zeros since abs(0) == 0
        x.forEach(
          function (value) {
            var v = abs(value);
            if (!ninf || smaller(v, ninf))
              ninf = v;
          },
          true);
        return ninf || 0;
      }
      if (p === 'fro') {
        return _norm(x, 2);
      }
      if (typeof p === 'number' &amp;&amp; !isNaN(p)) {
        // check p != 0
        if (!equalScalar(p, 0)) {
          // norm(x, p) = sum(abs(xi) ^ p) ^ 1/p ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.not" id="apidoc.module.mathjs.not">module mathjs.not</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.not.factory" id="apidoc.element.mathjs.not.factory">
        function <span class="apidocSignatureSpan">mathjs.not.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var latex = require('../../utils/latex');

<span class="apidocCodeCommentSpan">  /**
   * Logical `not`. Flips boolean value of a given parameter.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.not(x)
   *
   * Examples:
   *
   *    math.not(2);      // returns false
   *    math.not(0);      // returns true
   *    math.not(true);   // returns false
   *
   *    a = [2, -7, 0];
   *    math.not(a);      // returns [false, false, true]
   *
   * See also:
   *
   *    and, or, xor
   *
   * @param  {number | BigNumber | Complex | Unit | Array | Matrix} x First value to check
   * @return {boolean | Array | Matrix}
   *            Returns true when input is a zero or empty value.
   */
</span>  var not = typed('not', {
    'number': function (x) {
      return !x;
    },

    'Complex': function (x) {
      return x.re === 0 &amp;&amp; x.im === 0;
    },

    'BigNumber': function (x) {
      return x.isZero() || x.isNaN();
    },

    'Unit': function (x) {
      return not(x.value);
    },

    'Array | Matrix': function (x) {
      return deepMap(x, not);
    }
  });

  not.toTex = {
    1: latex.operators['not'] + '\\left(${args[0]}\\right)'
  };

  return not;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.nthRoot" id="apidoc.module.mathjs.nthRoot">module mathjs.nthRoot</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.nthRoot.factory" id="apidoc.element.mathjs.nthRoot.factory">
        function <span class="apidocSignatureSpan">mathjs.nthRoot.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {

  var matrix = load(require('../../type/matrix/function/matrix'));

  var algorithm01 = load(require('../../type/matrix/utils/algorithm01'));
  var algorithm02 = load(require('../../type/matrix/utils/algorithm02'));
  var algorithm06 = load(require('../../type/matrix/utils/algorithm06'));
  var algorithm11 = load(require('../../type/matrix/utils/algorithm11'));
  var algorithm13 = load(require('../../type/matrix/utils/algorithm13'));
  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));

<span class="apidocCodeCommentSpan">  /**
   * Calculate the nth root of a value.
   * The principal nth root of a positive real number A, is the positive real
   * solution of the equation
   *
   *     x^root = A
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *     math.nthRoot(a)
   *     math.nthRoot(a, root)
   *
   * Examples:
   *
   *     math.nthRoot(9, 2);    // returns 3, as 3^2 == 9
   *     math.sqrt(9);          // returns 3, as 3^2 == 9
   *     math.nthRoot(64, 3);   // returns 4, as 4^3 == 64
   *
   * See also:
   *
   *     sqrt, pow
   *
   * @param {number | BigNumber | Array | Matrix | Complex} a
   *              Value for which to calculate the nth root
   * @param {number | BigNumber} [root=2]    The root.
   * @return {number | Complex | Array | Matrix} Returns the nth root of `a`
   */
</span>  var nthRoot = typed('nthRoot', {

    'number': function (x) {
      return _nthRoot(x, 2);
    },
    'number, number': _nthRoot,

    'BigNumber': function (x) {
      return _bigNthRoot(x, new type.BigNumber(2));
    },
    'Complex' : function(x) {
      return _nthComplexRoot(x, 2);
    },
    'Complex, number' : _nthComplexRoot,
    'BigNumber, BigNumber': _bigNthRoot,

    'Array | Matrix': function (x) {
      return nthRoot(x, 2);
    },

    'Matrix, Matrix': function (x, y) {
      // result
      var c;

      // process matrix storage
      switch (x.storage()) {
        case 'sparse':
          switch (y.storage()) {
            case 'sparse':
              // density must be one (no zeros in matrix)
              if (y.density() === 1) {
                // sparse + sparse
                c = algorithm06(x, y, nthRoot);
              }
              else {
                // throw exception
                throw new Error('Root must be non-zero');
              }
              break;
            default:
              // sparse + dense
              c = algorithm02(y, x, nthRoot, true);
              break;
          }
          break;
        default:
          switch (y.storage()) {
            case 'sparse':
              // density must be one (no zeros in matrix)
              if (y.density() === 1) {
                // dense + sparse
                c = algorithm01(x, y, nthRoot, false);
              }
              else {
                // throw exception
                throw new Error('Root must be non-zero');
              }
              break;
            default:
              // dense + dense
              c = algorithm13(x, y, nthRoot);
              break;
          }
          break;
      }
      return c;
    },

    'Array, Array': function (x, y) {
      // use matrix implementation
      return nthRoot(matrix(x), matrix(y)).valueOf();
    },

    'Array, Matrix': function (x, y) {
      // use matrix implementation
      return nthRoot(matrix(x), y);
    },

    'Matrix, Array': function (x, y) {
      // use matrix implementation
      return nthRoot(x, matrix(y));
    },

    'Matrix, number | BigNumber': function (x, y) {
      // result
      var c;
      // check storage format
      switch (x.storage()) {
        case 'sparse':
          c = algorithm11(x, y, nthRoot, false);
          break;
        default:
          c = algorithm14(x, y, nthRoot, false);
          break;
      }
      return c;
    },

    'number | BigNumber, Matrix': function (x, y) {
      // result
      var c;
      // check storage format
      switch (y.storage()) {
        case 'sparse':
          // density must be one ( ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.number" id="apidoc.module.mathjs.number">module mathjs.number</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.number.factory" id="apidoc.element.mathjs.number.factory">
        function <span class="apidocSignatureSpan">mathjs.number.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
<span class="apidocCodeCommentSpan">  /**
   * Create a number or convert a string, boolean, or unit to a number.
   * When value is a matrix, all elements will be converted to number.
   *
   * Syntax:
   *
   *    math.number(value)
   *    math.number(unit, valuelessUnit)
   *
   * Examples:
   *
   *    math.number(2);                         // returns number 2
   *    math.number('7.2');                     // returns number 7.2
   *    math.number(true);                      // returns number 1
   *    math.number([true, false, true, true]); // returns [1, 0, 1, 1]
   *    math.number(math.unit('52cm'), 'm');    // returns 0.52
   *
   * See also:
   *
   *    bignumber, boolean, complex, index, matrix, string, unit
   *
   * @param {string | number | BigNumber | Fraction | boolean | Array | Matrix | Unit | null} [value]  Value to be converted
   * @param {Unit | string} [valuelessUnit] A valueless unit, used to convert a unit to a number
   * @return {number | Array | Matrix} The created number
   */
</span>  var number = typed('number', {
    '': function () {
      return 0;
    },

    'number': function (x) {
      return x;
    },

    'string': function (x) {
      var num = Number(x);
      if (isNaN(num)) {
        throw new SyntaxError('String "' + x + '" is no valid number');
      }
      return num;
    },

    'BigNumber': function (x) {
      return x.toNumber();
    },

    'Fraction': function (x) {
      return x.valueOf();
    },

    'Unit': function (x) {
      throw new Error('Second argument with valueless unit expected');
    },

    'Unit, string | Unit': function (unit, valuelessUnit) {
      return unit.toNumber(valuelessUnit);
    },

    'Array | Matrix': function (x) {
      return deepMap(x, number);
    }
  });

  number.toTex = {
    0: '0',
    1: '\\left(${args[0]}\\right)',
    2: '\\left(\\left(${args[0]}\\right)${args[1]}\\right)'
  };

  return number;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.object" id="apidoc.module.mathjs.object">module mathjs.object</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.object.canDefineProperty" id="apidoc.element.mathjs.object.canDefineProperty">
        function <span class="apidocSignatureSpan">mathjs.object.</span>canDefineProperty
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">canDefineProperty = function () {
  // test needed for broken IE8 implementation
  try {
    if (Object.defineProperty) {
      Object.defineProperty({}, 'x', { get: function () {} });
      return true;
    }
  } catch (e) {}

  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * of the properties value.
 * @param {Object} object   Object where to add the property
 * @param {string} prop     Property name
 * @param {Function} fn     Function returning the property value. Called
 *                          without arguments.
 */
exports.lazy = function (object, prop, fn) {
if (exports.<span class="apidocCodeKeywordSpan">canDefineProperty</span>()) {
  var _uninitialized = true;
  var _value;
  Object.defineProperty(object, prop, {
    get: function () {
      if (_uninitialized) {
        _value = fn();
        _uninitialized = false;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.object.clone" id="apidoc.element.mathjs.object.clone">
        function <span class="apidocSignatureSpan">mathjs.object.</span>clone
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function clone(x) {
  var type = typeof x;

  // immutable primitive types
  if (type === 'number' || type === 'string' || type === 'boolean' ||
      x === null || x === undefined) {
    return x;
  }

  // use clone function of the object when available
  if (typeof x.clone === 'function') {
    return x.clone();
  }

  // array
  if (Array.isArray(x)) {
    return x.map(function (value) {
      return clone(value);
    });
  }

  if (x instanceof Number)    return new Number(x.valueOf());
  if (x instanceof String)    return new String(x.valueOf());
  if (x instanceof Boolean)   return new Boolean(x.valueOf());
  if (x instanceof Date)      return new Date(x.valueOf());
  if (x &amp;&amp; x.isBigNumber === true) return x; // bignumbers are immutable
  if (x instanceof RegExp)  throw new TypeError('Cannot clone ' + x);  // TODO: clone a RegExp

  // object
  var m = {};
  for (var key in x) {
    if (x.hasOwnProperty(key)) {
      m[key] = clone(x[key]);
    }
  }
  return m;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return desc;
};

/**
 * Export the help object to JSON
 */
Help.prototype.toJSON = function () {
  var obj = object.<span class="apidocCodeKeywordSpan">clone</span>(this.doc);
  obj.mathjs = 'Help';
  return obj;
};

/**
 * Instantiate a Help object from a JSON object
 * @param {Object} json
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.object.deepEqual" id="apidoc.element.mathjs.object.deepEqual">
        function <span class="apidocSignatureSpan">mathjs.object.</span>deepEqual
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deepEqual(a, b) {
  var prop, i, len;
  if (Array.isArray(a)) {
    if (!Array.isArray(b)) {
      return false;
    }

    if (a.length != b.length) {
      return false;
    }

    for (i = 0, len = a.length; i &lt; len; i++) {
      if (!exports.deepEqual(a[i], b[i])) {
        return false;
      }
    }
    return true;
  }
  else if (a instanceof Object) {
    if (Array.isArray(b) || !(b instanceof Object)) {
      return false;
    }

    for (prop in a) {
      //noinspection JSUnfilteredForInLoop
      if (!exports.deepEqual(a[prop], b[prop])) {
        return false;
      }
    }
    for (prop in b) {
      //noinspection JSUnfilteredForInLoop
      if (!exports.deepEqual(a[prop], b[prop])) {
        return false;
      }
    }
    return true;
  }
  else {
    return (typeof a === typeof b) &amp;&amp; (a == b);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (a.length != b.length) {
    return false;
  }

  for (i = 0, len = a.length; i &lt; len; i++) {
    if (!exports.<span class="apidocCodeKeywordSpan">deepEqual</span>(a[i], b[i])) {
      return false;
    }
  }
  return true;
}
else if (a instanceof Object) {
  if (Array.isArray(b) || !(b instanceof Object)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.object.deepExtend" id="apidoc.element.mathjs.object.deepExtend">
        function <span class="apidocSignatureSpan">mathjs.object.</span>deepExtend
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deepExtend(a, b) {
  // TODO: add support for Arrays to deepExtend
  if (Array.isArray(b)) {
    throw new TypeError('Arrays are not supported by deepExtend');
  }

  for (var prop in b) {
    if (b.hasOwnProperty(prop)) {
      if (b[prop] &amp;&amp; b[prop].constructor === Object) {
        if (a[prop] === undefined) {
          a[prop] = {};
        }
        if (a[prop].constructor === Object) {
          deepExtend(a[prop], b[prop]);
        }
        else {
          a[prop] = b[prop];
        }
      } else if (Array.isArray(b[prop])) {
        throw new TypeError('Arrays are not supported by deepExtend');
      } else {
        a[prop] = b[prop];
      }
    }
  }
  return a;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var prev = object.clone(config);

// validate some of the options
validateOption(options, 'matrix', MATRIX);
validateOption(options, 'number', NUMBER);

// merge options
object.<span class="apidocCodeKeywordSpan">deepExtend</span>(config, options);

var curr = object.clone(config);

var changes = object.clone(options);

// emit 'config' event
math.emit('config', curr, prev, changes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.object.extend" id="apidoc.element.mathjs.object.extend">
        function <span class="apidocSignatureSpan">mathjs.object.</span>extend
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extend = function (a, b) {
  for (var prop in b) {
    if (b.hasOwnProperty(prop)) {
      a[prop] = b[prop];
    }
  }
  return a;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.object.isFactory" id="apidoc.element.mathjs.object.isFactory">
        function <span class="apidocSignatureSpan">mathjs.object.</span>isFactory
        <span class="apidocSignatureSpan">(object)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isFactory = function (object) {
  return object &amp;&amp; typeof object.factory === 'function';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.object.lazy" id="apidoc.element.mathjs.object.lazy">
        function <span class="apidocSignatureSpan">mathjs.object.</span>lazy
        <span class="apidocSignatureSpan">(object, prop, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lazy = function (object, prop, fn) {
  if (exports.canDefineProperty()) {
    var _uninitialized = true;
    var _value;
    Object.defineProperty(object, prop, {
      get: function () {
        if (_uninitialized) {
          _value = fn();
          _uninitialized = false;
        }
        return _value;
      },

      set: function (value) {
        _value = value;
        _uninitialized = false;
      },

      configurable: true,
      enumerable: true
    });
  }
  else {
    // fall back to immediate evaluation
    object[prop] = fn();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function setConstant(math, name, value) {
  math[name] = value;
  math.expression.mathWithTransform[name] = value;
}

// create a lazy constant in both math and mathWithTransform
function setLazyConstant (math, name, resolver) {
  object.<span class="apidocCodeKeywordSpan">lazy</span>(math, name,  resolver);
  object.lazy(math.expression.mathWithTransform, name,  resolver);
}

exports.factory = factory;
exports.lazy = false;  // no lazy loading of constants, the constants themselves are lazy when needed
exports.math = true;   // request access to the math namespace
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.object.traverse" id="apidoc.element.mathjs.object.traverse">
        function <span class="apidocSignatureSpan">mathjs.object.</span>traverse
        <span class="apidocSignatureSpan">(object, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">traverse = function (object, path) {
  var obj = object;

  if (path) {
    var names = path.split('.');
    for (var i = 0; i &lt; names.length; i++) {
      var name = names[i];
      if (!(name in obj)) {
        obj[name] = {};
      }
      obj = obj[name];
    }
  }

  return obj;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *            otherwise. Function signature:
 *            callback(node: Node, index: string, parent: Node) : boolean
 * @return {Node[]} nodes       An array with nodes matching given filter criteria
 */
Node.prototype.filter = function (callback) {
  var nodes = [];

  this.<span class="apidocCodeKeywordSpan">traverse</span>(function (node, path, parent) {
    if (callback(node, path, parent)) {
      nodes.push(node);
    }
  });

  return nodes;
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.ones" id="apidoc.module.mathjs.ones">module mathjs.ones</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.ones.factory" id="apidoc.element.mathjs.ones.factory">
        function <span class="apidocSignatureSpan">mathjs.ones.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var matrix = load(require('../../type/matrix/function/matrix'));

<span class="apidocCodeCommentSpan">  /**
   * Create a matrix filled with ones. The created matrix can have one or
   * multiple dimensions.
   *
   * Syntax:
   *
   *    math.ones(m)
   *    math.ones(m, format)
   *    math.ones(m, n)
   *    math.ones(m, n, format)
   *    math.ones([m, n])
   *    math.ones([m, n], format)
   *    math.ones([m, n, p, ...])
   *    math.ones([m, n, p, ...], format)
   *
   * Examples:
   *
   *    math.ones(3);                   // returns [1, 1, 1]
   *    math.ones(3, 2);                // returns [[1, 1], [1, 1], [1, 1]]
   *    math.ones(3, 2, 'dense');       // returns Dense Matrix [[1, 1], [1, 1], [1, 1]]
   *
   *    var A = [[1, 2, 3], [4, 5, 6]];
   *    math.ones(math.size(A));       // returns [[1, 1, 1], [1, 1, 1]]
   *
   * See also:
   *
   *    zeros, eye, size, range
   *
   * @param {...number | Array} size    The size of each dimension of the matrix
   * @param {string} [format]           The Matrix storage format
   *
   * @return {Array | Matrix | number}  A matrix filled with ones
   */
</span>  var ones = typed('ones', {
    '': function () {
      return (config.matrix === 'Array')
          ? _ones([])
          : _ones([], 'default');
    },

    // math.ones(m, n, p, ..., format)
    // TODO: more accurate signature '...number | BigNumber, string' as soon as typed-function supports this
    '...number | BigNumber | string': function (size) {
      var last = size[size.length - 1];
      if (typeof last === 'string') {
        var format = size.pop();
        return _ones(size, format);
      }
      else if (config.matrix === 'Array') {
        return _ones(size);
      }
      else {
        return _ones(size, 'default');
      }
    },

    'Array': _ones,

    'Matrix': function (size) {
      var format = size.storage();
      return _ones(size.valueOf(), format);
    },

    'Array | Matrix, string': function (size, format) {
      return _ones (size.valueOf(), format);
    }
  });

  ones.toTex = undefined; // use default template

  return ones;

  /**
   * Create an Array or Matrix with ones
   * @param {Array} size
   * @param {string} [format='default']
   * @return {Array | Matrix}
   * @private
   */
  function _ones(size, format) {
    var hasBigNumbers = _normalize(size);
    var defaultValue = hasBigNumbers ? new type.BigNumber(1) : 1;
    _validate(size);

    if (format) {
      // return a matrix
      var m = matrix(format);
      if (size.length &gt; 0) {
        return m.resize(size, defaultValue);
      }
      return m;
    }
    else {
      // return an Array
      var arr = [];
      if (size.length &gt; 0) {
        return resize(arr, size, defaultValue);
      }
      return arr;
    }
  }

  // replace BigNumbers with numbers, returns true if size contained BigNumbers
  function _normalize(size) {
    var hasBigNumbers = false;
    size.forEach(function (value, index, arr) {
      if (value &amp;&amp; value.isBigNumber === true) {
        hasBigNumbers = true;
        arr[index] = value.toNumber();
      }
    });
    return hasBigNumbers;
  }

  // validate arguments
  function _validate (size) {
    size.forEach(function (value) {
      if (typeof value !== 'number' || !isInteger(value) || value &lt; 0) {
        throw new Error('Parameters in function ones must be positive integers');
      }
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.operators" id="apidoc.module.mathjs.operators">module mathjs.operators</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.operators.getAssociativity" id="apidoc.element.mathjs.operators.getAssociativity">
        function <span class="apidocSignatureSpan">mathjs.operators.</span>getAssociativity
        <span class="apidocSignatureSpan">(_node, parenthesis)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getAssociativity(_node, parenthesis) {
  var node = _node;
  if (parenthesis !== 'keep') {
    //ParenthesisNodes are only ignored when not in 'keep' mode
    node = _node.getContent();
  }
  var identifier = node.getIdentifier();
  var index = getPrecedence(node, parenthesis);
  if (index === null) {
    //node isn't in the list
    return null;
  }
  var property = properties[index][identifier];

  if (property.hasOwnProperty('associativity')) {
    if (property.associativity === 'left') {
      return 'left';
    }
    if (property.associativity === 'right') {
      return 'right';
    }
    //associativity is invalid
    throw Error('\'' + identifier + '\' has the invalid associativity \''
                + property.associativity + '\'.');
  }

  //associativity is undefined
  return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * @param {boolean} latex
   * @return {boolean[]}
   * @private
   */
  function calculateNecessaryParentheses(root, parenthesis, args, latex) {
//precedence of the root OperatorNode
var precedence = operators.getPrecedence(root, parenthesis);
var associativity = operators.<span class="apidocCodeKeywordSpan">getAssociativity</span>(root, parenthesis);

if ((parenthesis === 'all') || ((args.length &gt; 2) &amp;&amp; (root.getIdentifier() !== 'OperatorNode:add&amp;#
x27;) &amp;&amp; (root.getIdentifier() !== 'OperatorNode:multiply'))) {
  var parens = args.map(function (arg) {
    switch (arg.getContent().type) { //Nodes that don't need extra parentheses
      case 'ArrayNode':
      case 'ConstantNode':
      case 'SymbolNode':
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.operators.getPrecedence" id="apidoc.element.mathjs.operators.getPrecedence">
        function <span class="apidocSignatureSpan">mathjs.operators.</span>getPrecedence
        <span class="apidocSignatureSpan">(_node, parenthesis)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getPrecedence(_node, parenthesis) {
  var node = _node;
  if (parenthesis !== 'keep') {
    //ParenthesisNodes are only ignored when not in 'keep' mode
    node = _node.getContent();
  }
  var identifier = node.getIdentifier();
  for (var i = 0; i &lt; properties.length; i++) {
    if (identifier in properties[i]) {
      return i;
    }
  }
  return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @private
 */
function needParenthesis(node, parenthesis) {
  if (!parenthesis) {
    parenthesis = 'keep';
  }

  var precedence = operators.<span class="apidocCodeKeywordSpan">getPrecedence</span>(node, parenthesis);
  var exprPrecedence = operators.getPrecedence(node.value, parenthesis);
  return (parenthesis === 'all')
    || ((exprPrecedence !== null) &amp;&amp; (exprPrecedence &lt;= precedence));
}

/**
 * Get string representation
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.operators.isAssociativeWith" id="apidoc.element.mathjs.operators.isAssociativeWith">
        function <span class="apidocSignatureSpan">mathjs.operators.</span>isAssociativeWith
        <span class="apidocSignatureSpan">(nodeA, nodeB, parenthesis)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isAssociativeWith(nodeA, nodeB, parenthesis) {
  var a = nodeA;
  var b = nodeB;
  if (parenthesis !== 'keep') {
    //ParenthesisNodes are only ignored when not in 'keep' mode
    var a = nodeA.getContent();
    var b = nodeB.getContent();
  }
  var identifierA = a.getIdentifier();
  var identifierB = b.getIdentifier();
  var index = getPrecedence(a, parenthesis);
  if (index === null) {
    //node isn't in the list
    return null;
  }
  var property = properties[index][identifierA];

  if (property.hasOwnProperty('associativeWith')
      &amp;&amp; (property.associativeWith instanceof Array)) {
    for (var i = 0; i &lt; property.associativeWith.length; i++) {
      if (property.associativeWith[i] === identifierB) {
        return true;
      }
    }
    return false;
  }

  //associativeWith is not defined
  return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
//otherwise, no parens needed
return [false];
    } else if (args.length === 2) { //binary operators
var lhsParens; //left hand side needs parenthesis?
//precedence of the left hand side
var lhsPrecedence = operators.getPrecedence(args[0], parenthesis);
//is the root node associative with the left hand side
var assocWithLhs = operators.<span class="apidocCodeKeywordSpan">isAssociativeWith</span>(root, args[0], parenthesis);

if (lhsPrecedence === null) {
  //if the left hand side has no defined precedence, no parens are needed
  //FunctionNode for example
  lhsParens = false;
}
else if ((lhsPrecedence === precedence) &amp;&amp; (associativity === 'right') &amp;&amp; !assocWithLhs) {
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.or" id="apidoc.module.mathjs.or">module mathjs.or</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.or.factory" id="apidoc.element.mathjs.or.factory">
        function <span class="apidocSignatureSpan">mathjs.or.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var latex = require('../../utils/latex');

  var matrix = load(require('../../type/matrix/function/matrix'));

  var algorithm03 = load(require('../../type/matrix/utils/algorithm03'));
  var algorithm05 = load(require('../../type/matrix/utils/algorithm05'));
  var algorithm12 = load(require('../../type/matrix/utils/algorithm12'));
  var algorithm13 = load(require('../../type/matrix/utils/algorithm13'));
  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));

<span class="apidocCodeCommentSpan">  /**
   * Logical `or`. Test if at least one value is defined with a nonzero/nonempty value.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.or(x, y)
   *
   * Examples:
   *
   *    math.or(2, 4);   // returns true
   *
   *    a = [2, 5, 0];
   *    b = [0, 22, 0];
   *    c = 0;
   *
   *    math.or(a, b);   // returns [true, true, false]
   *    math.or(b, c);   // returns [false, true, false]
   *
   * See also:
   *
   *    and, not, xor
   *
   * @param  {number | BigNumber | Complex | Unit | Array | Matrix} x First value to check
   * @param  {number | BigNumber | Complex | Unit | Array | Matrix} y Second value to check
   * @return {boolean | Array | Matrix}
   *            Returns true when one of the inputs is defined with a nonzero/nonempty value.
   */
</span>  var or = typed('or', {

    'number, number': function (x, y) {
      return !!(x || y);
    },

    'Complex, Complex': function (x, y) {
      return (x.re !== 0 || x.im !== 0) || (y.re !== 0 || y.im !== 0);
    },

    'BigNumber, BigNumber': function (x, y) {
      return (!x.isZero() &amp;&amp; !x.isNaN()) || (!y.isZero() &amp;&amp; !y.isNaN());
    },

    'Unit, Unit': function (x, y) {
      return or(x.value, y.value);
    },

    'Matrix, Matrix': function (x, y) {
      // result
      var c;

      // process matrix storage
      switch (x.storage()) {
        case 'sparse':
          switch (y.storage()) {
            case 'sparse':
              // sparse + sparse
              c = algorithm05(x, y, or);
              break;
            default:
              // sparse + dense
              c = algorithm03(y, x, or, true);
              break;
          }
          break;
        default:
          switch (y.storage()) {
            case 'sparse':
              // dense + sparse
              c = algorithm03(x, y, or, false);
              break;
            default:
              // dense + dense
              c = algorithm13(x, y, or);
              break;
          }
          break;
      }
      return c;
    },

    'Array, Array': function (x, y) {
      // use matrix implementation
      return or(matrix(x), matrix(y)).valueOf();
    },

    'Array, Matrix': function (x, y) {
      // use matrix implementation
      return or(matrix(x), y);
    },

    'Matrix, Array': function (x, y) {
      // use matrix implementation
      return or(x, matrix(y));
    },

    'Matrix, any': function (x, y) {
      // result
      var c;
      // check storage format
      switch (x.storage()) {
        case 'sparse':
          c = algorithm12(x, y, or, false);
          break;
        default:
          c = algorithm14(x, y, or, false);
          break;
      }
      return c;
    },

    'any, Matrix': function (x, y) {
      // result
      var c;
      // check storage format
      switch (y.storage()) {
        case 'sparse':
          c = algorithm12(y, x, or, true);
          break;
        default:
          c = algorithm14(y, x, or, true);
          break;
      }
      return c;
    },

    'Array, any': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(x), y, or, false).valueOf();
    },

    'any, Array': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(y), x, or, true).valueOf();
    }
  });

  or.toTex = {
    2: '\\left(${args[0]}' + latex.operators['or'] + '${args[1]}\\right)'
  };

  return or;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.parse" id="apidoc.module.mathjs.parse">module mathjs.parse</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.parse.factory" id="apidoc.element.mathjs.parse.factory">
        function <span class="apidocSignatureSpan">mathjs.parse.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var AccessorNode            = load(require('./node/AccessorNode'));
  var ArrayNode               = load(require('./node/ArrayNode'));
  var AssignmentNode          = load(require('./node/AssignmentNode'));
  var BlockNode               = load(require('./node/BlockNode'));
  var ConditionalNode         = load(require('./node/ConditionalNode'));
  var ConstantNode            = load(require('./node/ConstantNode'));
  var FunctionAssignmentNode  = load(require('./node/FunctionAssignmentNode'));
  var IndexNode               = load(require('./node/IndexNode'));
  var ObjectNode              = load(require('./node/ObjectNode'));
  var OperatorNode            = load(require('./node/OperatorNode'));
  var ParenthesisNode         = load(require('./node/ParenthesisNode'));
  var FunctionNode            = load(require('./node/FunctionNode'));
  var RangeNode               = load(require('./node/RangeNode'));
  var SymbolNode              = load(require('./node/SymbolNode'));


<span class="apidocCodeCommentSpan">  /**
   * Parse an expression. Returns a node tree, which can be evaluated by
   * invoking node.eval();
   *
   * Syntax:
   *
   *     parse(expr)
   *     parse(expr, options)
   *     parse([expr1, expr2, expr3, ...])
   *     parse([expr1, expr2, expr3, ...], options)
   *
   * Example:
   *
   *     var node = parse('sqrt(3^2 + 4^2)');
   *     node.compile(math).eval(); // 5
   *
   *     var scope = {a:3, b:4}
   *     var node = parse('a * b'); // 12
   *     var code = node.compile(math);
   *     code.eval(scope); // 12
   *     scope.a = 5;
   *     code.eval(scope); // 20
   *
   *     var nodes = math.parse(['a = 3', 'b = 4', 'a * b']);
   *     nodes[2].compile(math).eval(); // 12
   *
   * @param {string | string[] | Matrix} expr
   * @param {{nodes: Object&lt;string, Node&gt;}} [options]  Available options:
   *                                                   - `nodes` a set of custom nodes
   * @return {Node | Node[]} node
   * @throws {Error}
   */
</span>  function parse (expr, options) {
    if (arguments.length != 1 &amp;&amp; arguments.length != 2) {
      throw new ArgumentsError('parse', arguments.length, 1, 2);
    }

    // pass extra nodes
    extra_nodes = (options &amp;&amp; options.nodes) ? options.nodes : {};

    if (typeof expr === 'string') {
      // parse a single expression
      expression = expr;
      return parseStart();
    }
    else if (Array.isArray(expr) || expr instanceof type.Matrix) {
      // parse an array or matrix with expressions
      return deepMap(expr, function (elem) {
        if (typeof elem !== 'string') throw new TypeError('String expected');

        expression = elem;
        return parseStart();
      });
    }
    else {
      // oops
      throw new TypeError('String or matrix expected');
    }
  }

  // token types enumeration
  var TOKENTYPE = {
    NULL : 0,
    DELIMITER : 1,
    NUMBER : 2,
    SYMBOL : 3,
    UNKNOWN : 4
  };

  // map with all delimiters
  var DELIMITERS = {
    ',': true,
    '(': true,
    ')': true,
    '[': true,
    ']': true,
    '{': true,
    '}': true,
    '\"': true,
    ';': true,

    '+': true,
    '-': true,
    '*': true,
    '.*': true,
    '/': true,
    './': true,
    '%': true,
    '^': true,
    '.^': true,
    '~': true,
    '!': true,
    '&amp;': true,
    '|': true,
    '^|': true,
    '\'': true,
    '=': true,
    ':': true,
    '?': true,

    '==': true,
    '!=': true,
    '&lt;': true,
    '&gt;': true,
    '&lt;=': true,
    '&gt;=': true,

    '&lt;&lt;': true,
    '&gt;&gt;': true,
    '&gt;&gt;&gt;': true
  };

  // map with all named delimiters
  var NAMED_DELIMITERS = {
    'mod': true,
    'to': true,
    'in': true,
    'and': true,
    'xor': true,
    'or': true,
    'not': true
  };

  var extra_nodes = {};             // current extra nodes
  var expression = '';              // current expression
  var comment = '';                 // last parsed comment
  var index = 0;                    // current index in expr
  var c = '';                       // current token character in expr
  var token = '';                   // current token
  v ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.partitionSelect" id="apidoc.module.mathjs.partitionSelect">module mathjs.partitionSelect</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.partitionSelect.factory" id="apidoc.element.mathjs.partitionSelect.factory">
        function <span class="apidocSignatureSpan">mathjs.partitionSelect.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var asc = load(require('../relational/compare'));
  function desc(a, b) {
    return -asc(a, b);
  }

<span class="apidocCodeCommentSpan">  /**
   * Partition-based selection of an array or 1D matrix.
   * Will find the kth smallest value, and mutates the input array.
   * Uses Quickselect.
   *
   * Syntax:
   *
   *    math.partitionSelect(x, k)
   *    math.partitionSelect(x, k, compare)
   *
   * Examples:
   *
   *    math.partitionSelect([5, 10, 1], 2);           // returns 10
   *    math.partitionSelect(['C', 'B', 'A', 'D'], 1); // returns 'B'
   *
   *    function sortByLength (a, b) {
   *      return a.length - b.length;
   *    }
   *    math.partitionSelect(['Langdon', 'Tom', 'Sara'], 2, sortByLength); // returns 'Langdon'
   *
   * See also:
   *
   *    sort
   *
   * @param {Matrix | Array} x    A one dimensional matrix or array to sort
   * @param {Number} k            The kth smallest value to be retrieved; zero-based index
   * @param {Function | 'asc' | 'desc'} [compare='asc']
   *        An optional comparator function. The function is called as
   *        `compare(a, b)`, and must return 1 when a &gt; b, -1 when a &lt; b,
   *        and 0 when a == b.
   * @return {*} Returns the kth lowest value.
   */
</span>  return typed('partitionSelect', {
    'Array | Matrix, number': function (x, k) {
      return _partitionSelect(x, k, asc);
    },

    'Array | Matrix, number, string': function (x, k, compare) {
      if (compare === 'asc') {
        return _partitionSelect(x, k, asc);
      }
      else if (compare === 'desc') {
        return _partitionSelect(x, k, desc);
      }
      else {
        throw new Error('Compare string must be "asc" or "desc"');
      }
    },

    'Array | Matrix, number, function': _partitionSelect
  });

  function _partitionSelect(x, k, compare) {
    if (!isInteger(k) || k &lt; 0) {
      throw new Error('k must be a non-negative integer');
    }

    if (x &amp;&amp; x.isMatrix) {
      var size = x.size();
      if (size.length &gt; 1) {
        throw new Error('Only one dimensional matrices supported');
      }
      return quickSelect(x.valueOf(), k, compare);
    }

    if (Array.isArray(x)) {
      return quickSelect(x, k, compare);
    }
  }

  /**
   * Quickselect algorithm.
   * Code adapted from:
   * http://blog.teamleadnet.com/2012/07/quick-select-algorithm-find-kth-element.html
   *
   * @param {Array} arr
   * @param {Number} k
   * @param {Function} compare
   * @private
   */
  function quickSelect(arr, k, compare) {
    if (k &gt;= arr.length) {
      throw new Error('k out of bounds');
    }

    var from = 0;
    var to = arr.length - 1;

    // if from == to we reached the kth element
    while (from &lt; to) {
      var r = from;
      var w = to;
      var pivot = arr[Math.floor(Math.random() * (to - from + 1)) + from];

      // stop if the reader and writer meets
      while (r &lt; w) {
        // arr[r] &gt;= pivot
        if (compare(arr[r], pivot) &gt;= 0) { // put the large values at the end
          var tmp = arr[w];
          arr[w] = arr[r];
          arr[r] = tmp;
          --w;
        } else { // the value is smaller than the pivot, skip
          ++r;
        }
      }

      // if we stepped up (r++) we need to step one down (arr[r] &gt; pivot)
      if (compare(arr[r], pivot) &gt; 0) {
        --r;
      }

      // the r pointer is on the end of the first k elements
      if (k &lt;= r) {
        to = r;
      } else {
        from = r + 1;
      }
    }

    return arr[k];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.permutations" id="apidoc.module.mathjs.permutations">module mathjs.permutations</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.permutations.factory" id="apidoc.element.mathjs.permutations.factory">
        function <span class="apidocSignatureSpan">mathjs.permutations.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var factorial = load(require('./factorial'));

<span class="apidocCodeCommentSpan">  /**
   * Compute the number of ways of obtaining an ordered subset of `k` elements
   * from a set of `n` elements.
   *
   * Permutations only takes integer arguments.
   * The following condition must be enforced: k &lt;= n.
   *
   * Syntax:
   *
   *     math.permutations(n)
   *     math.permutations(n, k)
   *
   * Examples:
   *
   *    math.permutations(5);     // 120
   *    math.permutations(5, 3);  // 60
   *
   * See also:
   *
   *    combinations, factorial
   *
   * @param {number | BigNumber} n   The number of objects in total
   * @param {number | BigNumber} [k] The number of objects in the subset
   * @return {number | BigNumber}    The number of permutations
   */
</span>  var permutations = typed('permutations', {
    'number | BigNumber': factorial,

    'number, number': function (n, k) {
      var result, i;

      if (!isInteger(n) || n &lt; 0) {
        throw new TypeError('Positive integer value expected in function permutations');
      }
      if (!isInteger(k) || k &lt; 0) {
        throw new TypeError('Positive integer value expected in function permutations');
      }
      if (k &gt; n) {
        throw new TypeError('second argument k must be less than or equal to first argument n');
      }

      // Permute n objects, k at a time
      result = 1;
      for (i = n - k + 1; i &lt;= n; i++) {
        result = result * i;
      }

      return result;
    },

    'BigNumber, BigNumber': function (n, k) {
      var result, i;

      if (!isPositiveInteger(n) || !isPositiveInteger(k)) {
        throw new TypeError('Positive integer value expected in function permutations');
      }
      if (k.gt(n)) {
        throw new TypeError('second argument k must be less than or equal to first argument n');
      }

      result = new type.BigNumber(1);
      for (i = n.minus(k).plus(1); i.lte(n); i = i.plus(1)) {
        result = result.times(i);
      }

      return result;
    }

    // TODO: implement support for collection in permutations
  });

  permutations.toTex = undefined; // use default template

  return permutations;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.physicalConstants" id="apidoc.module.mathjs.physicalConstants">module mathjs.physicalConstants</a></h1>






    <h2>
        <a href="#apidoc.element.mathjs.physicalConstants.factory" id="apidoc.element.mathjs.physicalConstants.factory">
        function <span class="apidocSignatureSpan">mathjs.physicalConstants.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed, math)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed, math) {

  // helper function to create a unit with a fixed prefix
  function fixedUnit(str) {
    var unit = type.Unit.parse(str);
    unit.fixPrefix = true;
    return unit;
  }

  // Source: http://www.wikiwand.com/en/Physical_constant

  // Universal constants
  lazy(math, 'speedOfLight',         function () {return fixedUnit('299792458 m s^-1')});
  lazy(math, 'gravitationConstant',  function () {return fixedUnit('6.6738480e-11 m^3 kg^-1 s^-2')});
  lazy(math, 'planckConstant',       function () {return fixedUnit('6.626069311e-34 J s')});
  lazy(math, 'reducedPlanckConstant',function () {return fixedUnit('1.05457172647e-34 J s')});

  // Electromagnetic constants
  lazy(math, 'magneticConstant',          function () {return fixedUnit('1.2566370614e-6 N A^-2')});
  lazy(math, 'electricConstant',          function () {return fixedUnit('8.854187817e-12 F m^-1')});
  lazy(math, 'vacuumImpedance',           function () {return fixedUnit('376.730313461 ohm')});
  lazy(math, 'coulomb',                   function () {return fixedUnit('8.9875517873681764e9 N m^2 C^-2')});
  lazy(math, 'elementaryCharge',          function () {return fixedUnit('1.60217656535e-19 C')});
  lazy(math, 'bohrMagneton',              function () {return fixedUnit('9.2740096820e-24 J T^-1')});
  lazy(math, 'conductanceQuantum',        function () {return fixedUnit('7.748091734625e-5 S')});
  lazy(math, 'inverseConductanceQuantum', function () {return fixedUnit('12906.403721742 ohm')});
  lazy(math, 'magneticFluxQuantum',       function () {return fixedUnit('2.06783375846e-15 Wb')});
  lazy(math, 'nuclearMagneton',           function () {return fixedUnit('5.0507835311e-27 J T^-1')});
  lazy(math, 'klitzing',                  function () {return fixedUnit('25812.807443484 ohm')});
  //lazy(math, 'josephson',                 function () {return fixedUnit('4.8359787011e-14 Hz V^-1')});  // TODO: support for Hz
 needed

  // Atomic and nuclear constants
  lazy(math, 'bohrRadius',              function () {return fixedUnit('5.291772109217e-11 m')});
  lazy(math, 'classicalElectronRadius', function () {return fixedUnit('2.817940326727e-15 m')});
  lazy(math, 'electronMass',            function () {return fixedUnit('9.1093829140e-31 kg')});
  lazy(math, 'fermiCoupling',           function () {return fixedUnit('1.1663645e-5 GeV^-2')});
  lazy(math, 'fineStructure',           function () {return 7.297352569824e-3});
  lazy(math, 'hartreeEnergy',           function () {return fixedUnit('4.3597443419e-18 J')});
  lazy(math, 'protonMass',              function () {return fixedUnit('1.67262177774e-27 kg')});
  lazy(math, 'deuteronMass',            function () {return fixedUnit('3.3435830926e-27 kg')});
  lazy(math, 'neutronMass',             function () {return fixedUnit('1.6749271613e-27 kg')});
  lazy(math, 'quantumOfCirculation',    function () {return fixedUnit('3.636947552024e-4 m^2 s^-1')});
  lazy(math, 'rydberg',                 function () {return fixedUnit('10973731.56853955 m^-1')});
  lazy(math, 'thomsonCrossSection',     function () {return fixedUnit('6.65245873413e-29 m^2')});
  lazy(math, 'weakMixingAngle',         function () {return 0.222321});
  lazy(math, 'efimovFactor',            function () {return 22.7});

  // Physico-chemical constants
  lazy(math, 'atomicMass',          function () {return fixedUnit('1.66053892173e-27 kg')});
  lazy(math, 'avogadro',            function () {return fixedUnit('6.0221412927e23 mol^-1')});
  lazy(math, 'boltzmann',           function () {return fixedUnit('1.380648813e-23 J K^-1')});
  lazy(math, 'faraday',             function () {return fixedUnit('96485.336521 C mol^-1')});
  lazy(math, 'firstRadiation',      function () {return fixedUnit('3.7417715317e-16 W m^2')});
  // lazy(math, 'spectralRadiance',   function () {return fixedUnit('1.19104286953e-16 W m^2 sr^-1')}); // TODO spectralRadiance
  lazy(math, 'loschmidt',           function () {return fixedUnit('2.686780524e25 m^-3')});
  lazy(math, 'gasConstant',         function () {return fixedUnit('8.314462175 J K ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.pickRandom" id="apidoc.module.mathjs.pickRandom">module mathjs.pickRandom</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.pickRandom.factory" id="apidoc.element.mathjs.pickRandom.factory">
        function <span class="apidocSignatureSpan">mathjs.pickRandom.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var distribution = load(require('./distribution'));

<span class="apidocCodeCommentSpan">  /**
   * Random pick one or more values from a one dimensional array.
   * Array elements are picked using a random function with uniform or weighted distribution.
   *
   * Syntax:
   *
   *     math.pickRandom(array)
   *     math.pickRandom(array, number)
   *     math.pickRandom(array, weights)
   *     math.pickRandom(array, number, weights)
   *     math.pickRandom(array, weights, number)
   *
   * Examples:
   *
   *     math.pickRandom([3, 6, 12, 2]);                  // returns one of the values in the array
   *     math.pickRandom([3, 6, 12, 2], 2);               // returns an array of two of the values in the array
   *     math.pickRandom([3, 6, 12, 2], [1, 3, 2, 1]);    // returns one of the values in the array with weighted distribution
   *     math.pickRandom([3, 6, 12, 2], 2, [1, 3, 2, 1]); // returns an array of two of the values in the array with weighted distribution
   *     math.pickRandom([3, 6, 12, 2], [1, 3, 2, 1], 2); // returns an array of two of the values in the array with weighted distribution
   *
   * See also:
   *
   *     random, randomInt
   *
   * @param {Array} array     A one dimensional array
   * @param {Int} number      An int or float
   * @param {Array} weights   An array of ints or floats
   * @return {number} One of the elements of the provided input array
   * @return {array} An array of elements of the provided input array
   */
</span>  // TODO: rework pickRandom to a typed-function
  var pickRandom =  distribution('uniform').pickRandom;

  pickRandom.toTex = undefined; // use default template

  return pickRandom;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.pow" id="apidoc.module.mathjs.pow">module mathjs.pow</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.pow.factory" id="apidoc.element.mathjs.pow.factory">
        function <span class="apidocSignatureSpan">mathjs.pow.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var latex = require('../../utils/latex');
  var eye = load(require('../matrix/eye'));
  var multiply = load(require('./multiply'));
  var matrix = load(require('../../type/matrix/function/matrix'));
  var fraction = load(require('../../type/fraction/function/fraction'));
  var number = load(require('../../type/number'));

<span class="apidocCodeCommentSpan">  /**
   * Calculates the power of x to y, `x ^ y`.
   * Matrix exponentiation is supported for square matrices `x`, and positive
   * integer exponents `y`.
   *
   * For cubic roots of negative numbers, the function returns the principal
   * root by default. In order to let the function return the real root,
   * math.js can be configured with `math.config({predictable: true})`.
   * To retrieve all cubic roots of a value, use `math.cbrt(x, true)`.
   *
   * Syntax:
   *
   *    math.pow(x, y)
   *
   * Examples:
   *
   *    math.pow(2, 3);               // returns number 8
   *
   *    var a = math.complex(2, 3);
   *    math.pow(a, 2)                // returns Complex -5 + 12i
   *
   *    var b = [[1, 2], [4, 3]];
   *    math.pow(b, 2);               // returns Array [[9, 8], [16, 17]]
   *
   * See also:
   *
   *    multiply, sqrt, cbrt, nthRoot
   *
   * @param  {number | BigNumber | Complex | Array | Matrix} x  The base
   * @param  {number | BigNumber | Complex} y                   The exponent
   * @return {number | BigNumber | Complex | Array | Matrix} The value of `x` to the power `y`
   */
</span>  var pow = typed('pow', {
    'number, number': _pow,

    'Complex, Complex': function (x, y) {
      return x.pow(y);
    },

    'BigNumber, BigNumber': function (x, y) {
      if (y.isInteger() || x &gt;= 0 || config.predictable) {
        return x.pow(y);
      }
      else {
        return new type.Complex(x.toNumber(), 0).pow(y.toNumber(), 0);
      }
    },

    'Fraction, Fraction': function (x, y) {
      if (y.d !== 1) {
        if (config.predictable) {
          throw new Error('Function pow does not support non-integer exponents for fractions.');
        }
        else {
          return _pow(x.valueOf(), y.valueOf());
        }
      }
      else {
        return x.pow(y);
     }
    },

    'Array, number': _powArray,

    'Array, BigNumber': function (x, y) {
      return _powArray(x, y.toNumber());
    },

    'Matrix, number': _powMatrix,

    'Matrix, BigNumber': function (x, y) {
      return _powMatrix(x, y.toNumber());
    },

    'Unit, number': function (x, y) {
      return x.pow(y);
    }

  });

  /**
   * Calculates the power of x to y, x^y, for two numbers.
   * @param {number} x
   * @param {number} y
   * @return {number | Complex} res
   * @private
   */
  function _pow(x, y) {

    // Alternatively could define a 'realmode' config option or something, but
    // 'predictable' will work for now
    if (config.predictable &amp;&amp; !isInteger(y) &amp;&amp; x &lt; 0) {
      // Check to see if y can be represented as a fraction
      try {
        var yFrac = fraction(y);
        var yNum = number(yFrac);
        if(y === yNum || Math.abs((y - yNum) / y) &lt; 1e-14) {
          if(yFrac.d % 2 === 1) {
            return (yFrac.n % 2 === 0 ? 1 : -1) * Math.pow(-x, y);
          }
        }
      }
      catch (ex) {
        // fraction() throws an error if y is Infinity, etc.
      }

      // Unable to express y as a fraction, so continue on
    }

    if (isInteger(y) || x &gt;= 0 || config.predictable) {
      return Math.pow(x, y);
    }
    else {
      return new type.Complex(x, 0).pow(y, 0);
    }
  }

  /**
   * Calculate the power of a 2d array
   * @param {Array} x     must be a 2 dimensional, square matrix
   * @param {number} y    a positive, integer value
   * @returns {Array}
   * @private
   */
  function _powArray(x, y) {
    if (!isInteger(y) || y &lt; 0) {
      throw new TypeError('For A^b, b must be a positive integer (value is ' + y + ')');
    }
    // verify that A is a 2 dimensional square matrix
    var s = size(x);
    if (s.length != 2) {
      throw new Error('For A^b, A must be 2 dimensional (A has ' + s.length + ' dimension ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.print" id="apidoc.module.mathjs.print">module mathjs.print</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.print.factory" id="apidoc.element.mathjs.print.factory">
        function <span class="apidocSignatureSpan">mathjs.print.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
<span class="apidocCodeCommentSpan">  /**
   * Interpolate values into a string template.
   *
   * Syntax:
   *
   *     math.print(template, values)
   *     math.print(template, values, precision)
   *     math.print(template, values, options)
   *
   * Example usage:
   *
   *     // the following outputs: 'Lucy is 5 years old'
   *     math.print('Lucy is $age years old', {age: 5});
   *
   *     // the following outputs: 'The value of pi is 3.141592654'
   *     math.print('The value of pi is $pi', {pi: math.pi}, 10);
   *
   *     // the following outputs: 'hello Mary! The date is 2013-03-23'
   *     math.print('Hello $user.name! The date is $date', {
   *       user: {
   *         name: 'Mary',
   *       },
   *       date: new Date(2013, 2, 23).toISOString().substring(0, 10)
   *     });
   *
   * See also:
   *
   *     format
   *
   * @param {string} template     A string containing variable placeholders.
   * @param {Object} values       An object containing variables which will
   *                              be filled in in the template.
   * @param {number | Object} [options]  Formatting options,
   *                              or the number of digits to format numbers.
   *                              See function math.format for a description
   *                              of all options.
   * @return {string} Interpolated string
   */
</span>  var print = typed ('print', {
    'string, Object': _print,
    'string, Object, number | Object': _print
  });

  print.toTex = undefined; // use default template

  return print;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.prod" id="apidoc.module.mathjs.prod">module mathjs.prod</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.prod.factory" id="apidoc.element.mathjs.prod.factory">
        function <span class="apidocSignatureSpan">mathjs.prod.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var multiply = load(require('../arithmetic/multiplyScalar'));

<span class="apidocCodeCommentSpan">  /**
   * Compute the product of a matrix or a list with values.
   * In case of a (multi dimensional) array or matrix, the sum of all
   * elements will be calculated.
   *
   * Syntax:
   *
   *     math.prod(a, b, c, ...)
   *     math.prod(A)
   *
   * Examples:
   *
   *     math.multiply(2, 3);           // returns 6
   *     math.prod(2, 3);               // returns 6
   *     math.prod(2, 3, 4);            // returns 24
   *     math.prod([2, 3, 4]);          // returns 24
   *     math.prod([[2, 5], [4, 3]]);   // returns 120
   *
   * See also:
   *
   *    mean, median, min, max, sum, std, var
   *
   * @param {... *} args  A single matrix or or multiple scalar values
   * @return {*} The product of all values
   */
</span>  var prod = typed('prod', {
    // prod([a, b, c, d, ...])
    'Array | Matrix': _prod,

    // prod([a, b, c, d, ...], dim)
    'Array | Matrix, number | BigNumber': function (array, dim) {
      // TODO: implement prod(A, dim)
      throw new Error('prod(A, dim) is not yet supported');
      //return reduce(arguments[0], arguments[1], math.prod);
    },

    // prod(a, b, c, d, ...)
    '...': function (args) {
      return _prod(args);
    }
  });

  prod.toTex = undefined; // use default template

  return prod;

  /**
   * Recursively calculate the product of an n-dimensional array
   * @param {Array} array
   * @return {number} prod
   * @private
   */
  function _prod(array) {
    var prod = undefined;

    deepForEach(array, function (value) {
      prod = (prod === undefined) ? value : multiply(prod, value);
    });

    if (prod === undefined) {
      throw new Error('Cannot calculate prod of an empty array');
    }

    return prod;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.quantileSeq" id="apidoc.module.mathjs.quantileSeq">module mathjs.quantileSeq</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.quantileSeq.factory" id="apidoc.element.mathjs.quantileSeq.factory">
        function <span class="apidocSignatureSpan">mathjs.quantileSeq.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var add = load(require('../arithmetic/add'));
  var multiply = load(require('../arithmetic/multiply'));
  var partitionSelect = load(require('../matrix/partitionSelect'));
  var compare = load(require('../relational/compare'));

<span class="apidocCodeCommentSpan">  /**
   * Compute the prob order quantile of a matrix or a list with values.
   * The sequence is sorted and the middle value is returned.
   * Supported types of sequence values are: Number, BigNumber, Unit
   * Supported types of probability are: Number, BigNumber
   *
   * In case of a (multi dimensional) array or matrix, the prob order quantile
   * of all elements will be calculated.
   *
   * Syntax:
   *
   *     math.quantileSeq(A, prob[, sorted])
   *     math.quantileSeq(A, [prob1, prob2, ...][, sorted])
   *     math.quantileSeq(A, N[, sorted])
   *
   * Examples:
   *
   *     math.quantileSeq([3, -1, 5, 7], 0.5);         // returns 4
   *     math.quantileSeq([3, -1, 5, 7], [1/3, 2/3]);  // returns [3, 5]
   *     math.quantileSeq([3, -1, 5, 7], 2);           // returns [3, 5]
   *     math.quantileSeq([-1, 3, 5, 7], 0.5, true);   // returns 4
   *
   * See also:
   *
   *     median, mean, min, max, sum, prod, std, var
   *
   * @param {Array, Matrix} data                A single matrix or Array
   * @param {Number, BigNumber, Array} probOrN  prob is the order of the quantile, while N is
   *                                            the amount of evenly distributed steps of
   *                                            probabilities; only one of these options can
   *                                            be provided
   * @param {Boolean} sorted=false              is data sorted in ascending order
   * @return {Number, BigNumber, Unit, Array}   Quantile(s)
   */
</span>  function quantileSeq(data, probOrN, sorted) {
    var probArr, dataArr, one;

    if (arguments.length &lt; 2 || arguments.length &gt; 3) {
      throw new SyntaxError('Function quantileSeq requires two or three parameters');
    }

    if (isCollection(data)) {
      sorted = sorted || false;
      if (typeof sorted === 'boolean') {
        dataArr = data.valueOf();
        if (isNumber(probOrN)) {
          if (probOrN &lt; 0) {
            throw new Error('N/prob must be non-negative');
          }

          if (probOrN &lt;= 1) {
            // quantileSeq([a, b, c, d, ...], prob[,sorted])
            return _quantileSeq(dataArr, probOrN, sorted);
          }

          if (probOrN &gt; 1) {
            // quantileSeq([a, b, c, d, ...], N[,sorted])
            if (!isInteger(probOrN)) {
              throw new Error('N must be a positive integer');
            }

            var nPlusOne = probOrN + 1;
            probArr = new Array(probOrN);
            for (var i = 0; i &lt; probOrN;) {
              probArr[i] = _quantileSeq(dataArr, (++i) / nPlusOne, sorted);
            }
            return probArr;
          }
        }

        if (probOrN &amp;&amp; probOrN.isBigNumber) {
          if (probOrN.isNegative()) {
            throw new Error('N/prob must be non-negative');
          }

          one = new probOrN.constructor(1);

          if (probOrN.lte(one)) {
            // quantileSeq([a, b, c, d, ...], prob[,sorted])
            return _quantileSeq(dataArr, probOrN, sorted);
          }

          if (probOrN.gt(one)) {
            // quantileSeq([a, b, c, d, ...], N[,sorted])
            if (!probOrN.isInteger()) {
              throw new Error('N must be a positive integer');
            }

            // largest possible Array length is 2^32-1;
            // 2^32 &lt; 10^15, thus safe conversion guaranteed
            var intN = probOrN.toNumber();
            if (intN &gt; 4294967295) {
              throw new Error('N must be less than or equal to 2^32-1, as that is the maximum length of an Array');
            }

            var nPlusOne = new type.BigNumber(intN + 1);
            probArr = new Array(intN);
            for (var i = 0; i &lt; intN;) {
              probArr[i] = _quantileSeq(dataArr, new type.BigNumber(++i).div(nPlusOne), sorted);
            }
            return ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.random" id="apidoc.module.mathjs.random">module mathjs.random</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.random.factory" id="apidoc.element.mathjs.random.factory">
        function <span class="apidocSignatureSpan">mathjs.random.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var distribution = load(require('./distribution'));

<span class="apidocCodeCommentSpan">  /**
   * Return a random number larger or equal to `min` and smaller than `max`
   * using a uniform distribution.
   *
   * Syntax:
   *
   *     math.random()                // generate a random number between 0 and 1
   *     math.random(max)             // generate a random number between 0 and max
   *     math.random(min, max)        // generate a random number between min and max
   *     math.random(size)            // generate a matrix with random numbers between 0 and 1
   *     math.random(size, max)       // generate a matrix with random numbers between 0 and max
   *     math.random(size, min, max)  // generate a matrix with random numbers between min and max
   *
   * Examples:
   *
   *     math.random();       // returns a random number between 0 and 1
   *     math.random(100);    // returns a random number between 0 and 100
   *     math.random(30, 40); // returns a random number between 30 and 40
   *     math.random([2, 3]); // returns a 2x3 matrix with random numbers between 0 and 1
   *
   * See also:
   *
   *     randomInt, pickRandom
   *
   * @param {Array | Matrix} [size] If provided, an array or matrix with given
   *                                size and filled with random values is returned
   * @param {number} [min]  Minimum boundary for the random value, included
   * @param {number} [max]  Maximum boundary for the random value, excluded
   * @return {number | Array | Matrix} A random number
   */
</span>  // TODO: rework random to a typed-function
  var random = distribution('uniform').random;

  random.toTex = undefined; // use default template

  return random;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.randomInt" id="apidoc.module.mathjs.randomInt">module mathjs.randomInt</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.randomInt.factory" id="apidoc.element.mathjs.randomInt.factory">
        function <span class="apidocSignatureSpan">mathjs.randomInt.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var distribution = load(require('./distribution'));

<span class="apidocCodeCommentSpan">  /**
   * Return a random integer number larger or equal to `min` and smaller than `max`
   * using a uniform distribution.
   *
   * Syntax:
   *
   *     math.randomInt(max)             // generate a random integer between 0 and max
   *     math.randomInt(min, max)        // generate a random integer between min and max
   *     math.randomInt(size)            // generate a matrix with random integer between 0 and 1
   *     math.randomInt(size, max)       // generate a matrix with random integer between 0 and max
   *     math.randomInt(size, min, max)  // generate a matrix with random integer between min and max
   *
   * Examples:
   *
   *     math.randomInt(100);    // returns a random integer between 0 and 100
   *     math.randomInt(30, 40); // returns a random integer between 30 and 40
   *     math.randomInt([2, 3]); // returns a 2x3 matrix with random integers between 0 and 1
   *
   * See also:
   *
   *     random, pickRandom
   *
   * @param {Array | Matrix} [size] If provided, an array or matrix with given
   *                                size and filled with random values is returned
   * @param {number} [min]  Minimum boundary for the random value, included
   * @param {number} [max]  Maximum boundary for the random value, excluded
   * @return {number | Array | Matrix} A random integer value
   */
</span>  // TODO: rework randomInt to a typed-function
  var randomInt = distribution('uniform').randomInt;

  randomInt.toTex = undefined; // use default template

  return randomInt;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.range" id="apidoc.module.mathjs.range">module mathjs.range</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.range.factory" id="apidoc.element.mathjs.range.factory">
        function <span class="apidocSignatureSpan">mathjs.range.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var matrix = load(require('../../type/matrix/function/matrix'));

  var ZERO = new type.BigNumber(0);
  var ONE = new type.BigNumber(1);

<span class="apidocCodeCommentSpan">  /**
   * Create an array from a range.
   * By default, the range end is excluded. This can be customized by providing
   * an extra parameter `includeEnd`.
   *
   * Syntax:
   *
   *     math.range(str [, includeEnd])               // Create a range from a string,
   *                                                  // where the string contains the
   *                                                  // start, optional step, and end,
   *                                                  // separated by a colon.
   *     math.range(start, end [, includeEnd])        // Create a range with start and
   *                                                  // end and a step size of 1.
   *     math.range(start, end, step [, includeEnd])  // Create a range with start, step,
   *                                                  // and end.
   *
   * Where:
   *
   * - `str: string`
   *   A string 'start:end' or 'start:step:end'
   * - `start: {number | BigNumber}`
   *   Start of the range
   * - `end: number | BigNumber`
   *   End of the range, excluded by default, included when parameter includeEnd=true
   * - `step: number | BigNumber`
   *   Step size. Default value is 1.
   * - `includeEnd: boolean`
   *   Option to specify whether to include the end or not. False by default.
   *
   * Examples:
   *
   *     math.range(2, 6);        // [2, 3, 4, 5]
   *     math.range(2, -3, -1);   // [2, 1, 0, -1, -2]
   *     math.range('2:1:6');     // [2, 3, 4, 5]
   *     math.range(2, 6, true);  // [2, 3, 4, 5, 6]
   *
   * See also:
   *
   *     ones, zeros, size, subset
   *
   * @param {*} args   Parameters describing the ranges `start`, `end`, and optional `step`.
   * @return {Array | Matrix} range
   */
</span>  var range = typed('range', {
    // TODO: simplify signatures when typed-function supports default values and optional arguments

    // TODO: a number or boolean should not be converted to string here
    'string': _strRange,
    'string, boolean': _strRange,

    'number, number':  function (start, end) {
      return _out(_rangeEx(start, end, 1));
    },
    'number, number, number': function (start, end, step) {
      return _out(_rangeEx(start, end, step));
    },
    'number, number, boolean': function (start, end, includeEnd) {
      return includeEnd
          ? _out(_rangeInc(start, end, 1))
          : _out(_rangeEx(start, end, 1));
    },
    'number, number, number, boolean': function (start, end, step, includeEnd) {
      return includeEnd
          ? _out(_rangeInc(start, end, step))
          : _out(_rangeEx(start, end, step));
    },

    'BigNumber, BigNumber':  function (start, end) {
      return _out(_bigRangeEx(start, end, ONE));
    },
    'BigNumber, BigNumber, BigNumber': function (start, end, step) {
      return _out(_bigRangeEx(start, end, step));
    },
    'BigNumber, BigNumber, boolean': function (start, end, includeEnd) {
      return includeEnd
          ? _out(_bigRangeInc(start, end, ONE))
          : _out(_bigRangeEx(start, end, ONE));
    },
    'BigNumber, BigNumber, BigNumber, boolean': function (start, end, step, includeEnd) {
      return includeEnd
          ? _out(_bigRangeInc(start, end, step))
          : _out(_bigRangeEx(start, end, step));
    }

  });

  range.toTex = undefined; // use default template

  return range;

  function _out(arr) {
    return config.matrix === 'Array' ? arr : matrix(arr);
  }

  function _strRange (str, includeEnd) {
    var r = _parse(str);
    if (!r){
      throw new SyntaxError('String "' + str + '" is no valid range');
    }

    var fn;
    if (config.number === 'BigNumber') {
      fn = includeEnd ? _bigRangeInc : _bigRangeEx;
      return _out(fn(
          new type.BigNumber(r.start),
          new type.BigNumber(r.end),
          new type.BigNumber(r.step)));
    }
    else {
      fn = includeEnd ? _rangeInc : _rangeEx;
      return _out(fn(r.start, r. ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.range_transform" id="apidoc.module.mathjs.range_transform">module mathjs.range_transform</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.range_transform.factory" id="apidoc.element.mathjs.range_transform.factory">
        function <span class="apidocSignatureSpan">mathjs.range_transform.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var range = load(require('../../function/matrix/range'));

  return typed('range', {
    '...any': function (args) {
      var lastIndex = args.length - 1;
      var last = args[lastIndex];
      if (typeof last !== 'boolean') {
        // append a parameter includeEnd=true
        args.push(true);
      }

      return range.apply(null, args);
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.re" id="apidoc.module.mathjs.re">module mathjs.re</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.re.factory" id="apidoc.element.mathjs.re.factory">
        function <span class="apidocSignatureSpan">mathjs.re.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
<span class="apidocCodeCommentSpan">  /**
   * Get the real part of a complex number.
   * For a complex number `a + bi`, the function returns `a`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.re(x)
   *
   * Examples:
   *
   *    var a = math.complex(2, 3);
   *    math.re(a);                     // returns number 2
   *    math.im(a);                     // returns number 3
   *
   *    math.re(math.complex('-5.2i')); // returns number 0
   *    math.re(math.complex(2.4));     // returns number 2.4
   *
   * See also:
   *
   *    im, conj, abs, arg
   *
   * @param {number | BigNumber | Complex | Array | Matrix} x
   *            A complex number or array with complex numbers
   * @return {number | BigNumber | Array | Matrix} The real part of x
   */
</span>  var re = typed('re', {
    'number': function (x) {
      return x;
    },

    'BigNumber': function (x) {
      return x;
    },

    'Complex': function (x) {
      return x.re;
    },

    'Array | Matrix': function (x) {
      return deepMap(x, re);
    }
  });

  re.toTex = {1: '\\Re\\left\\lbrace${args[0]}\\right\\rbrace'};

  return re;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.reshape" id="apidoc.module.mathjs.reshape">module mathjs.reshape</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.reshape.factory" id="apidoc.element.mathjs.reshape.factory">
        function <span class="apidocSignatureSpan">mathjs.reshape.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var matrix = load(require('../../type/matrix/function/matrix'));

<span class="apidocCodeCommentSpan">  /**
   * Reshape a multi dimensional array to fit the specified dimensions
   *
   * Syntax:
   *
   *     math.reshape(x, sizes)
   *
   * Examples:
   *
   *     math.reshape([1, 2, 3, 4, 5, 6], [2, 3]);
   *     // returns Array  [[1, 2, 3], [4, 5, 6]]
   *
   *     math.reshape([[1, 2], [3, 4]], [1, 4]);
   *     // returns Array  [[1, 2, 3, 4]]
   *
   *     math.reshape([[1, 2], [3, 4]], [4]);
   *     // returns Array [1, 2, 3, 4]
   *
   *     var x = math.matrix([1, 2, 3, 4, 5, 6, 7, 8]);
   *     math.reshape(x, [2, 2, 2]);
   *     // returns Matrix [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]
   *
   * See also:
   *
   *     size, squeeze, resize
   *
   * @param {Array | Matrix | *} x  Matrix to be reshaped
   * @param {number[]} sizes        One dimensional array with integral sizes for
   *                                each dimension
   *
   * @return {* | Array | Matrix}   A reshaped clone of matrix `x`
   *
   * @throws {TypeError}            If `sizes` does not contain solely integers
   * @throws {DimensionError}       If the product of the new dimension sizes does
   *                                not equal that of the old ones
   */
</span>  var reshape = typed('reshape', {

    'Matrix, Array': function (x, sizes) {
      if(x.reshape) {
        return x.reshape(sizes);
      } else {
        return matrix(array.reshape(x.valueOf(), sizes));
      }
    },

    'Array, Array': function (x, sizes) {
      sizes.forEach(function (size) {
        if (!isInteger(size)) {
          throw new TypeError('Invalid size for dimension: ' + size);
        }
      });
      return array.reshape(x, sizes);
    }

  });

  reshape.toTex = undefined; // use default template

  return reshape;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.resize" id="apidoc.module.mathjs.resize">module mathjs.resize</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.resize.factory" id="apidoc.element.mathjs.resize.factory">
        function <span class="apidocSignatureSpan">mathjs.resize.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var matrix = load(require('../../type/matrix/function/matrix'));

<span class="apidocCodeCommentSpan">  /**
   * Resize a matrix
   *
   * Syntax:
   *
   *     math.resize(x, size)
   *     math.resize(x, size, defaultValue)
   *
   * Examples:
   *
   *     math.resize([1, 2, 3, 4, 5], [3]); // returns Array  [1, 2, 3]
   *     math.resize([1, 2, 3], [5], 0);    // returns Array  [1, 2, 3, 0, 0]
   *     math.resize(2, [2, 3], 0);         // returns Matrix [[2, 0, 0], [0, 0, 0]]
   *     math.resize("hello", [8], "!");    // returns string 'hello!!!'
   *
   * See also:
   *
   *     size, squeeze, subset, reshape
   *
   * @param {Array | Matrix | *} x             Matrix to be resized
   * @param {Array | Matrix} size              One dimensional array with numbers
   * @param {number | string} [defaultValue=0] Zero by default, except in
   *                                           case of a string, in that case
   *                                           defaultValue = ' '
   * @return {* | Array | Matrix} A resized clone of matrix `x`
   */
</span>  // TODO: rework resize to a typed-function
  var resize = function resize (x, size, defaultValue) {
    if (arguments.length != 2 &amp;&amp; arguments.length != 3) {
      throw new ArgumentsError('resize', arguments.length, 2, 3);
    }

    if (size &amp;&amp; size.isMatrix === true) {
      size = size.valueOf(); // get Array
    }

    if (size.length &amp;&amp; size[0] &amp;&amp; size[0].isBigNumber === true) {
      // convert bignumbers to numbers
      size = size.map(function (value) {
        return (value &amp;&amp; value.isBigNumber === true) ? value.toNumber() : value;
      });
    }

    // check x is a Matrix
    if (x &amp;&amp; x.isMatrix === true) {
      // use optimized matrix implementation, return copy
      return x.resize(size, defaultValue, true);
    }

    if (typeof x === 'string') {
      // resize string
      return _resizeString(x, size, defaultValue);
    }

    // check result should be a matrix
    var asMatrix = Array.isArray(x) ? false : (config.matrix !== 'Array');

    if (size.length == 0) {
      // output a scalar
      while (Array.isArray(x)) {
        x = x[0];
      }

      return clone(x);
    }
    else {
      // output an array/matrix
      if (!Array.isArray(x)) {
        x = [x];
      }
      x = clone(x);

      var res = array.resize(x, size, defaultValue);
      return asMatrix ? matrix(res) : res;
    }
  };

  resize.toTex = undefined; // use default template

  return resize;

  /**
   * Resize a string
   * @param {string} str
   * @param {number[]} size
   * @param {string} [defaultChar=' ']
   * @private
   */
  function _resizeString(str, size, defaultChar) {
    if (defaultChar !== undefined) {
      if (typeof defaultChar !== 'string' || defaultChar.length !== 1) {
        throw new TypeError('Single character expected as defaultValue');
      }
    }
    else {
      defaultChar = ' ';
    }

    if (size.length !== 1) {
      throw new DimensionError(size.length, 1);
    }
    var len = size[0];
    if (typeof len !== 'number' || !isInteger(len)) {
      throw new TypeError('Invalid size, must contain positive integers ' +
          '(size: ' + format(size) + ')');
    }

    if (str.length &gt; len) {
      return str.substring(0, len);
    }
    else if (str.length &lt; len) {
      var res = str;
      for (var i = 0, ii = len - str.length; i &lt; ii; i++) {
        res += defaultChar;
      }
      return res;
    }
    else {
      return str;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.reviver" id="apidoc.module.mathjs.reviver">module mathjs.reviver</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.reviver.factory" id="apidoc.element.mathjs.reviver.factory">
        function <span class="apidocSignatureSpan">mathjs.reviver.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
<span class="apidocCodeCommentSpan">  /**
   * Instantiate mathjs data types from their JSON representation
   * @param {string} key
   * @param {*} value
   * @returns {*} Returns the revived object
   */
</span>  return function reviver(key, value) {
    var constructor = type[value &amp;&amp; value.mathjs];
    if (constructor &amp;&amp; typeof constructor.fromJSON === 'function') {
      return constructor.fromJSON(value);
    }

    return value;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.rightArithShift" id="apidoc.module.mathjs.rightArithShift">module mathjs.rightArithShift</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.rightArithShift.factory" id="apidoc.element.mathjs.rightArithShift.factory">
        function <span class="apidocSignatureSpan">mathjs.rightArithShift.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var latex = require('../../utils/latex');

  var matrix = load(require('../../type/matrix/function/matrix'));
  var equalScalar = load(require('../relational/equalScalar'));
  var zeros = load(require('../matrix/zeros'));

  var algorithm01 = load(require('../../type/matrix/utils/algorithm01'));
  var algorithm02 = load(require('../../type/matrix/utils/algorithm02'));
  var algorithm08 = load(require('../../type/matrix/utils/algorithm08'));
  var algorithm10 = load(require('../../type/matrix/utils/algorithm10'));
  var algorithm11 = load(require('../../type/matrix/utils/algorithm11'));
  var algorithm13 = load(require('../../type/matrix/utils/algorithm13'));
  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));

<span class="apidocCodeCommentSpan">  /**
   * Bitwise right arithmetic shift of a value x by y number of bits, `x &gt;&gt; y`.
   * For matrices, the function is evaluated element wise.
   * For units, the function is evaluated on the best prefix base.
   *
   * Syntax:
   *
   *    math.rightArithShift(x, y)
   *
   * Examples:
   *
   *    math.rightArithShift(4, 2);               // returns number 1
   *
   *    math.rightArithShift([16, -32, 64], 4);   // returns Array [1, -2, 3]
   *
   * See also:
   *
   *    bitAnd, bitNot, bitOr, bitXor, rightArithShift, rightLogShift
   *
   * @param  {number | BigNumber | Array | Matrix} x Value to be shifted
   * @param  {number | BigNumber} y Amount of shifts
   * @return {number | BigNumber | Array | Matrix} `x` sign-filled shifted right `y` times
   */
</span>  var rightArithShift = typed('rightArithShift', {

    'number, number': function (x, y) {
      if (!isInteger(x) || !isInteger(y)) {
        throw new Error('Integers expected in function rightArithShift');
      }

      return x &gt;&gt; y;
    },

    'BigNumber, BigNumber': bigRightArithShift,

    'Matrix, Matrix': function (x, y) {
      // result
      var c;

      // process matrix storage
      switch (x.storage()) {
        case 'sparse':
          switch (y.storage()) {
            case 'sparse':
              // sparse &amp; sparse
              c = algorithm08(x, y, rightArithShift, false);
              break;
            default:
              // sparse &amp; dense
              c = algorithm02(y, x, rightArithShift, true);
              break;
          }
          break;
        default:
          switch (y.storage()) {
            case 'sparse':
              // dense &amp; sparse
              c = algorithm01(x, y, rightArithShift, false);
              break;
            default:
              // dense &amp; dense
              c = algorithm13(x, y, rightArithShift);
              break;
          }
          break;
      }
      return c;
    },

    'Array, Array': function (x, y) {
      // use matrix implementation
      return rightArithShift(matrix(x), matrix(y)).valueOf();
    },

    'Array, Matrix': function (x, y) {
      // use matrix implementation
      return rightArithShift(matrix(x), y);
    },

    'Matrix, Array': function (x, y) {
      // use matrix implementation
      return rightArithShift(x, matrix(y));
    },

    'Matrix, number | BigNumber': function (x, y) {
      // check scalar
      if (!equalScalar(y, 0)) {
        // result
        var c;
        // check storage format
        switch (x.storage()) {
          case 'sparse':
            c = algorithm11(x, y, rightArithShift, false);
            break;
          default:
            c = algorithm14(x, y, rightArithShift, false);
            break;
        }
        return c;
      }
      return x.clone();
    },

    'number | BigNumber, Matrix': function (x, y) {
      // check scalar
      if (!equalScalar(x, 0)) {
        // result
        var c;
        // check storage format
        switch (y.storage()) {
          case 'sparse':
            c = algorithm10(y, x, rightArithShift, true);
            break;
          default:
            c = algorithm14(y, x, rightArithShift, true);
            break;
        }
        return c;
      }
      return zeros(y.size(), y.storage());
    },

    'Array, n ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.rightLogShift" id="apidoc.module.mathjs.rightLogShift">module mathjs.rightLogShift</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.rightLogShift.factory" id="apidoc.element.mathjs.rightLogShift.factory">
        function <span class="apidocSignatureSpan">mathjs.rightLogShift.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var latex = require('../../utils/latex');

  var matrix = load(require('../../type/matrix/function/matrix'));
  var equalScalar = load(require('../relational/equalScalar'));
  var zeros = load(require('../matrix/zeros'));

  var algorithm01 = load(require('../../type/matrix/utils/algorithm01'));
  var algorithm02 = load(require('../../type/matrix/utils/algorithm02'));
  var algorithm08 = load(require('../../type/matrix/utils/algorithm08'));
  var algorithm10 = load(require('../../type/matrix/utils/algorithm10'));
  var algorithm11 = load(require('../../type/matrix/utils/algorithm11'));
  var algorithm13 = load(require('../../type/matrix/utils/algorithm13'));
  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));

<span class="apidocCodeCommentSpan">  /**
   * Bitwise right logical shift of value x by y number of bits, `x &gt;&gt;&gt; y`.
   * For matrices, the function is evaluated element wise.
   * For units, the function is evaluated on the best prefix base.
   *
   * Syntax:
   *
   *    math.rightLogShift(x, y)
   *
   * Examples:
   *
   *    math.rightLogShift(4, 2);               // returns number 1
   *
   *    math.rightLogShift([16, -32, 64], 4);   // returns Array [1, 2, 3]
   *
   * See also:
   *
   *    bitAnd, bitNot, bitOr, bitXor, leftShift, rightLogShift
   *
   * @param  {number | Array | Matrix} x Value to be shifted
   * @param  {number} y Amount of shifts
   * @return {number | Array | Matrix} `x` zero-filled shifted right `y` times
   */
</span>
  var rightLogShift = typed('rightLogShift', {

    'number, number': function (x, y) {
      if (!isInteger(x) || !isInteger(y)) {
        throw new Error('Integers expected in function rightLogShift');
      }

      return x &gt;&gt;&gt; y;
    },

    // 'BigNumber, BigNumber': ..., // TODO: implement BigNumber support for rightLogShift

    'Matrix, Matrix': function (x, y) {
      // result
      var c;

      // process matrix storage
      switch (x.storage()) {
        case 'sparse':
          switch (y.storage()) {
            case 'sparse':
              // sparse &amp; sparse
              c = algorithm08(x, y, rightLogShift, false);
              break;
            default:
              // sparse &amp; dense
              c = algorithm02(y, x, rightLogShift, true);
              break;
          }
          break;
        default:
          switch (y.storage()) {
            case 'sparse':
              // dense &amp; sparse
              c = algorithm01(x, y, rightLogShift, false);
              break;
            default:
              // dense &amp; dense
              c = algorithm13(x, y, rightLogShift);
              break;
          }
          break;
      }
      return c;
    },

    'Array, Array': function (x, y) {
      // use matrix implementation
      return rightLogShift(matrix(x), matrix(y)).valueOf();
    },

    'Array, Matrix': function (x, y) {
      // use matrix implementation
      return rightLogShift(matrix(x), y);
    },

    'Matrix, Array': function (x, y) {
      // use matrix implementation
      return rightLogShift(x, matrix(y));
    },

    'Matrix, number | BigNumber': function (x, y) {
      // check scalar
      if (!equalScalar(y, 0)) {
        // result
        var c;
        // check storage format
        switch (x.storage()) {
          case 'sparse':
            c = algorithm11(x, y, rightLogShift, false);
            break;
          default:
            c = algorithm14(x, y, rightLogShift, false);
            break;
        }
        return c;
      }
      return x.clone();
    },

    'number | BigNumber, Matrix': function (x, y) {
      // check scalar
      if (!equalScalar(x, 0)) {
        // result
        var c;
        // check storage format
        switch (y.storage()) {
          case 'sparse':
            c = algorithm10(y, x, rightLogShift, true);
            break;
          default:
            c = algorithm14(y, x, rightLogShift, true);
            break;
        }
        return c;
      }
      return zeros(y.size(), y.storage());
    },

    'Array, number | BigNumber': function (x, y) ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.round" id="apidoc.module.mathjs.round">module mathjs.round</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.round.factory" id="apidoc.element.mathjs.round.factory">
        function <span class="apidocSignatureSpan">mathjs.round.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var matrix = load(require('../../type/matrix/function/matrix'));
  var equalScalar = load(require('../relational/equalScalar'));
  var zeros = load(require('../matrix/zeros'));

  var algorithm11 = load(require('../../type/matrix/utils/algorithm11'));
  var algorithm12 = load(require('../../type/matrix/utils/algorithm12'));
  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));

<span class="apidocCodeCommentSpan">  /**
   * Round a value towards the nearest integer.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.round(x)
   *    math.round(x, n)
   *
   * Examples:
   *
   *    math.round(3.2);              // returns number 3
   *    math.round(3.8);              // returns number 4
   *    math.round(-4.2);             // returns number -4
   *    math.round(-4.7);             // returns number -5
   *    math.round(math.pi, 3);       // returns number 3.142
   *    math.round(123.45678, 2);     // returns number 123.46
   *
   *    var c = math.complex(3.2, -2.7);
   *    math.round(c);                // returns Complex 3 - 3i
   *
   *    math.round([3.2, 3.8, -4.7]); // returns Array [3, 4, -5]
   *
   * See also:
   *
   *    ceil, fix, floor
   *
   * @param  {number | BigNumber | Fraction | Complex | Array | Matrix} x  Number to be rounded
   * @param  {number | BigNumber | Array} [n=0]                            Number of decimals
   * @return {number | BigNumber | Fraction | Complex | Array | Matrix} Rounded value
   */
</span>  var round = typed('round', {

    'number': Math.round,

    'number, number': function (x, n) {
      if (!isInteger(n))   {throw new TypeError(NO_INT);}
      if (n &lt; 0 || n &gt; 15) {throw new Error('Number of decimals in function round must be in te range of 0-15');}

      return _round(x, n);
    },

    'Complex': function (x) {
      return x.round();
    },

    'Complex, number': function (x, n) {
      if (n % 1) {throw new TypeError(NO_INT);}

      return x.round(n);
    },

    'Complex, BigNumber': function (x, n) {
      if (!n.isInteger()) {throw new TypeError(NO_INT);}

      var _n = n.toNumber();
      return x.round(_n);
    },

    'number, BigNumber': function (x, n) {
      if (!n.isInteger()) {throw new TypeError(NO_INT);}

      return new type.BigNumber(x).toDecimalPlaces(n.toNumber());
    },

    'BigNumber': function (x) {
      return x.toDecimalPlaces(0);
    },

    'BigNumber, BigNumber': function (x, n) {
      if (!n.isInteger()) {throw new TypeError(NO_INT);}

      return x.toDecimalPlaces(n.toNumber());
    },

    'Fraction': function (x) {
      return x.round();
    },

    'Fraction, number': function (x, n) {
      if (n % 1) {throw new TypeError(NO_INT);}
      return x.round(n);
    },

    'Array | Matrix': function (x) {
      // deep map collection, skip zeros since round(0) = 0
      return deepMap(x, round, true);
    },

    'Matrix, number | BigNumber': function (x, y) {
      // result
      var c;
      // check storage format
      switch (x.storage()) {
        case 'sparse':
          c = algorithm11(x, y, round, false);
          break;
        default:
          c = algorithm14(x, y, round, false);
          break;
      }
      return c;
    },

    'number | Complex | BigNumber, Matrix': function (x, y) {
      // check scalar is zero
      if (!equalScalar(x, 0)) {
        // result
        var c;
        // check storage format
        switch (y.storage()) {
          case 'sparse':
            c = algorithm12(y, x, round, true);
            break;
          default:
            c = algorithm14(y, x, round, true);
            break;
        }
        return c;
      }
      // do not execute algorithm, result will be a zero matrix
      return zeros(y.size(), y.storage());
    },

    'Array, number | BigNumber': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(x), y, round, false).valueOf();
    },

    'number | Complex | BigNumber, Array': function (x, y) {
      // use matrix implementation
      return algo ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.sec" id="apidoc.module.mathjs.sec">module mathjs.sec</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.sec.factory" id="apidoc.element.mathjs.sec.factory">
        function <span class="apidocSignatureSpan">mathjs.sec.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
<span class="apidocCodeCommentSpan">  /**
   * Calculate the secant of a value, defined as `sec(x) = 1/cos(x)`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.sec(x)
   *
   * Examples:
   *
   *    math.sec(2);      // returns number -2.4029979617223822
   *    1 / math.cos(2);  // returns number -2.4029979617223822
   *
   * See also:
   *
   *    cos, csc, cot
   *
   * @param {number | Complex | Unit | Array | Matrix} x  Function input
   * @return {number | Complex | Array | Matrix} Secant of x
   */
</span>  var sec = typed('sec', {
    'number': function (x) {
      return 1 / Math.cos(x);
    },

    'Complex': function (x) {
      return x.sec();
    },

    'BigNumber': function (x) {
      return new type.BigNumber(1).div(x.cos());
    },

    'Unit': function (x) {
      if (!x.hasBase(type.Unit.BASE_UNITS.ANGLE)) {
        throw new TypeError ('Unit in function sec is no angle');
      }
      return sec(x.value);
    },

    'Array | Matrix': function (x) {
      return deepMap(x, sec);
    }
  });

  sec.toTex = {1: '\\sec\\left(${args[0]}\\right)'};

  return sec;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.sech" id="apidoc.module.mathjs.sech">module mathjs.sech</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.sech.factory" id="apidoc.element.mathjs.sech.factory">
        function <span class="apidocSignatureSpan">mathjs.sech.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  /**
   * Calculate the hyperbolic secant of a value,
   * defined as `sech(x) = 1 / cosh(x)`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.sech(x)
   *
   * Examples:
   *
   *    // sech(x) = 1/ cosh(x)
   *    math.sech(0.5);       // returns 0.886818883970074
   *    1 / math.cosh(0.5);   // returns 0.886818883970074
   *
   * See also:
   *
   *    cosh, csch, coth
   *
   * @param {number | Complex | Unit | Array | Matrix} x  Function input
   * @return {number | Complex | Array | Matrix} Hyperbolic secant of x
   */
  var sech = typed('sech', {
    'number': _sech,

    'Complex': function (x) {
      return x.sech();
    },

    'BigNumber': function (x) {
      return new type.BigNumber(1).div(x.cosh());
    },

    'Unit': function (x) {
      if (!x.hasBase(type.Unit.BASE_UNITS.ANGLE)) {
        throw new TypeError ('Unit in function sech is no angle');
      }
      return sech(x.value);
    },

    'Array | Matrix': function (x) {
      return deepMap(x, sech);
    }
  });

  sech.toTex = {1: '\\mathrm{sech}\\left(${args[0]}\\right)'};

  return sech;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.sign" id="apidoc.module.mathjs.sign">module mathjs.sign</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.sign.factory" id="apidoc.element.mathjs.sign.factory">
        function <span class="apidocSignatureSpan">mathjs.sign.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
<span class="apidocCodeCommentSpan">  /**
   * Compute the sign of a value. The sign of a value x is:
   *
   * -  1 when x &gt; 1
   * - -1 when x &lt; 0
   * -  0 when x == 0
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.sign(x)
   *
   * Examples:
   *
   *    math.sign(3.5);               // returns 1
   *    math.sign(-4.2);              // returns -1
   *    math.sign(0);                 // returns 0
   *
   *    math.sign([3, 5, -2, 0, 2]);  // returns [1, 1, -1, 0, 1]
   *
   * See also:
   *
   *    abs
   *
   * @param  {number | BigNumber | Fraction | Complex | Array | Matrix | Unit} x
   *            The number for which to determine the sign
   * @return {number | BigNumber | Fraction | Complex | Array | Matrix | Unit}e
   *            The sign of `x`
   */
</span>  var sign = typed('sign', {
    'number': number.sign,

    'Complex': function (x) {
      return x.sign();
    },

    'BigNumber': function (x) {
      return new type.BigNumber(x.cmp(0));
    },

    'Fraction': function (x) {
      return new type.Fraction(x.s, 1);
    },

    'Array | Matrix': function (x) {
      // deep map collection, skip zeros since sign(0) = 0
      return deepMap(x, sign, true);
    },

    'Unit': function(x) {
      return sign(x.value);
    }
  });

  sign.toTex = {1: '\\mathrm{${name}}\\left(${args[0]}\\right)'};

  return sign;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.simplify" id="apidoc.module.mathjs.simplify">module mathjs.simplify</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.simplify.factory" id="apidoc.element.mathjs.simplify.factory">
        function <span class="apidocSignatureSpan">mathjs.simplify.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var parse = load(require('../../expression/parse'));
  var ConstantNode = load(require('../../expression/node/ConstantNode'));
  var FunctionNode = load(require('../../expression/node/FunctionNode'));
  var OperatorNode = load(require('../../expression/node/OperatorNode'));
  var ParenthesisNode = load(require('../../expression/node/ParenthesisNode'));
  var SymbolNode = load(require('../../expression/node/SymbolNode'));
  var Node = load(require('../../expression/node/Node'));
  var simplifyConstant = load(require('./simplify/simplifyConstant'));

  var util = load(require('./simplify/util'));
  var isCommutative = util.isCommutative;
  var isAssociative = util.isAssociative;
  var flatten = util.flatten;
  var unflattenr = util.unflattenr;
  var unflattenl = util.unflattenl;
  var createMakeNodeFunction = util.createMakeNodeFunction;

<span class="apidocCodeCommentSpan">  /**
   * Simplify an expression tree.
   *
   * It's possible to pass a custom set of rules to the function as second
   * argument. A rule can be specified as an object, string, or function:
   *
   *     var rules = [
   *       { l: 'n1*n3 + n2*n3', r: '(n1+n2)*n3' },
   *       'n1*n3 + n2*n3 -&gt; (n1+n2)*n3',
   *       function (node) {
   *         // ... return a new node or return the node unchanged
   *         return node
   *       }
   *     ]
   *
   *
   * The default list with rules is exposed on the function as `simplify.rules`
   * and can be used as a basis to built a set of custom rules.
   *
   * For more details on the theory, see:
   *
   * - [Strategies for simplifying math expressions (Stackoverflow)](http://stackoverflow.com/questions/7540227/strategies-for-simplifying
-math-expressions)
   * - [Symbolic computation - Simplification (Wikipedia)](https://en.wikipedia.org/wiki/Symbolic_computation#Simplification)
   *
   * Syntax:
   *
   *     simplify(expr)
   *     simplify(expr, rules)
   *
   * Examples:
   *
   *     math.simplify('2 * 1 * x ^ (2 - 1)');      // Node {2 * x}
   *     var f = math.parse('2 * 1 * x ^ (2 - 1)');
   *     math.simplify(f);                          // Node {2 * x}
   *
   * See also:
   *
   *     derivative, parse, eval
   *
   * @param {Node | string} expr
   *            The expression to be simplified
   * @param {Array&lt;{l:string, r: string} | string | function&gt;} [rules]
   *            Optional list with custom rules
   * @return {Node} Returns the simplified form of `expr`
   */
</span>  var simplify = typed('simplify', {
    'string': function (expr) {
      return simplify(parse(expr), simplify.rules);
    },

    'string, Array': function (expr, rules) {
      return simplify(parse(expr), rules);
    },

    'Node': function (expr) {
      return simplify(expr, simplify.rules);
    },

    'Node, Array': function (expr, rules) {
      rules = _buildRules(rules);

      var res = removeParens(expr);
      var after = res.toString({parenthesis: 'all'});
      var before = null;
      while(before != after) {
        lastsym = 0;
        before = after;
        for (var i=0; i&lt;rules.length; i++) {
          if (typeof rules[i] === 'function') {
            res = rules[i](res);
          }
          else {
            flatten(res);
            res = applyRule(res, rules[i]);
          }
          unflattenl(res); // using left-heavy binary tree here since custom rule functions may expect it
        }
        after = res.toString({parenthesis: 'all'});
      }

      return res;
    }
  });

  function removeParens(node) {
    return node.transform(function(node, path, parent) {
      if(node.isParenthesisNode) {
        return node.content;
      }
      else {
        return node;
      }
    });
  }

  // Array of strings, used to build the ruleSet.
  // Each l (left side) and r (right side) are parsed by
  // the expression parser into a node tree.
  // Left hand sides are matched to subtrees within the
  // expression to be parsed and replaced with the right
  // hand side.
  // TODO: Add support for constraints on constants (either in the form of a '=' expression or a callback [ca ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.sin" id="apidoc.module.mathjs.sin">module mathjs.sin</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.sin.factory" id="apidoc.element.mathjs.sin.factory">
        function <span class="apidocSignatureSpan">mathjs.sin.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {

<span class="apidocCodeCommentSpan">  /**
   * Calculate the sine of a value.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.sin(x)
   *
   * Examples:
   *
   *    math.sin(2);                      // returns number 0.9092974268256813
   *    math.sin(math.pi / 4);            // returns number 0.7071067811865475
   *    math.sin(math.unit(90, 'deg'));   // returns number 1
   *    math.sin(math.unit(30, 'deg'));   // returns number 0.5
   *
   *    var angle = 0.2;
   *    math.pow(math.sin(angle), 2) + math.pow(math.cos(angle), 2); // returns number ~1
   *
   * See also:
   *
   *    cos, tan
   *
   * @param {number | BigNumber | Complex | Unit | Array | Matrix} x  Function input
   * @return {number | BigNumber | Complex | Array | Matrix} Sine of x
   */
</span>  var sin = typed('sin', {
    'number': Math.sin,

    'Complex': function (x) {
      return x.sin();
    },

    'BigNumber': function (x) {
      return x.sin();
    },

    'Unit': function (x) {
      if (!x.hasBase(type.Unit.BASE_UNITS.ANGLE)) {
        throw new TypeError ('Unit in function sin is no angle');
      }
      return sin(x.value);
    },

    'Array | Matrix': function (x) {
      // deep map collection, skip zeros since sin(0) = 0
      return deepMap(x, sin, true);
    }
  });

  sin.toTex = {1: '\\sin\\left(${args[0]}\\right)'};

  return sin;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.sinh" id="apidoc.module.mathjs.sinh">module mathjs.sinh</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.sinh.factory" id="apidoc.element.mathjs.sinh.factory">
        function <span class="apidocSignatureSpan">mathjs.sinh.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  /**
   * Calculate the hyperbolic sine of a value,
   * defined as `sinh(x) = 1/2 * (exp(x) - exp(-x))`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.sinh(x)
   *
   * Examples:
   *
   *    math.sinh(0.5);       // returns number 0.5210953054937474
   *
   * See also:
   *
   *    cosh, tanh
   *
   * @param {number | BigNumber | Complex | Unit | Array | Matrix} x  Function input
   * @return {number | BigNumber | Complex | Array | Matrix} Hyperbolic sine of x
   */
  var sinh = typed('sinh', {
    'number': _sinh,

    'Complex': function (x) {
      return x.sinh();
    },

    'BigNumber': function (x) {
      return x.sinh();
    },

    'Unit': function (x) {
      if (!x.hasBase(type.Unit.BASE_UNITS.ANGLE)) {
        throw new TypeError ('Unit in function sinh is no angle');
      }
      return sinh(x.value);
    },

    'Array | Matrix': function (x) {
      // deep map collection, skip zeros since sinh(0) = 0
      return deepMap(x, sinh, true);
    }
  });

  sinh.toTex = {1: '\\sinh\\left(${args[0]}\\right)'};

  return sinh;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.size" id="apidoc.module.mathjs.size">module mathjs.size</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.size.factory" id="apidoc.element.mathjs.size.factory">
        function <span class="apidocSignatureSpan">mathjs.size.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var matrix = load(require('../../type/matrix/function/matrix'));

<span class="apidocCodeCommentSpan">  /**
   * Calculate the size of a matrix or scalar.
   *
   * Syntax:
   *
   *     math.size(x)
   *
   * Examples:
   *
   *     math.size(2.3);                  // returns []
   *     math.size('hello world');        // returns [11]
   *
   *     var A = [[1, 2, 3], [4, 5, 6]];
   *     math.size(A);                    // returns [2, 3]
   *     math.size(math.range(1,6));      // returns [5]
   *
   * See also:
   *
   *     resize, squeeze, subset
   *
   * @param {boolean | number | Complex | Unit | string | Array | Matrix} x  A matrix
   * @return {Array | Matrix} A vector with size of `x`.
   */
</span>  var size = typed('size', {
    'Matrix': function (x) {
      // TODO: return the same matrix type as the input
      return matrix(x.size());
    },

    'Array': array.size,

    'string': function (x) {
      return (config.matrix === 'Array') ? [x.length] : matrix([x.length]);
    },

    'number | Complex | BigNumber | Unit | boolean | null': function (x) {
      // scalar
      return (config.matrix === 'Array') ? [] : matrix([]);
    }
  });

  size.toTex = undefined; // use default template

  return size;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.smaller" id="apidoc.module.mathjs.smaller">module mathjs.smaller</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.smaller.factory" id="apidoc.element.mathjs.smaller.factory">
        function <span class="apidocSignatureSpan">mathjs.smaller.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {

  var matrix = load(require('../../type/matrix/function/matrix'));

  var algorithm03 = load(require('../../type/matrix/utils/algorithm03'));
  var algorithm07 = load(require('../../type/matrix/utils/algorithm07'));
  var algorithm12 = load(require('../../type/matrix/utils/algorithm12'));
  var algorithm13 = load(require('../../type/matrix/utils/algorithm13'));
  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));

  var latex = require('../../utils/latex');

<span class="apidocCodeCommentSpan">  /**
   * Test whether value x is smaller than y.
   *
   * The function returns true when x is smaller than y and the relative
   * difference between x and y is smaller than the configured epsilon. The
   * function cannot be used to compare values smaller than approximately 2.22e-16.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.smaller(x, y)
   *
   * Examples:
   *
   *    math.smaller(2, 3);            // returns true
   *    math.smaller(5, 2 * 2);        // returns false
   *
   *    var a = math.unit('5 cm');
   *    var b = math.unit('2 inch');
   *    math.smaller(a, b);            // returns true
   *
   * See also:
   *
   *    equal, unequal, smallerEq, smaller, smallerEq, compare
   *
   * @param  {number | BigNumber | Fraction | boolean | Unit | string | Array | Matrix} x First value to compare
   * @param  {number | BigNumber | Fraction | boolean | Unit | string | Array | Matrix} y Second value to compare
   * @return {boolean | Array | Matrix} Returns true when the x is smaller than y, else returns false
   */
</span>  var smaller = typed('smaller', {

    'boolean, boolean': function (x, y) {
      return x &lt; y;
    },

    'number, number': function (x, y) {
      return x &lt; y &amp;&amp; !nearlyEqual(x, y, config.epsilon);
    },

    'BigNumber, BigNumber': function (x, y) {
      return x.lt(y) &amp;&amp; !bigNearlyEqual(x, y, config.epsilon);
    },

    'Fraction, Fraction': function (x, y) {
      return x.compare(y) === -1;
    },

    'Complex, Complex': function (x, y) {
      throw new TypeError('No ordering relation is defined for complex numbers');
    },

    'Unit, Unit': function (x, y) {
      if (!x.equalBase(y)) {
        throw new Error('Cannot compare units with different base');
      }
      return smaller(x.value, y.value);
    },

    'string, string': function (x, y) {
      return x &lt; y;
    },

    'Matrix, Matrix': function (x, y) {
      // result
      var c;

      // process matrix storage
      switch (x.storage()) {
        case 'sparse':
          switch (y.storage()) {
            case 'sparse':
              // sparse + sparse
              c = algorithm07(x, y, smaller);
              break;
            default:
              // sparse + dense
              c = algorithm03(y, x, smaller, true);
              break;
          }
          break;
        default:
          switch (y.storage()) {
            case 'sparse':
              // dense + sparse
              c = algorithm03(x, y, smaller, false);
              break;
            default:
              // dense + dense
              c = algorithm13(x, y, smaller);
              break;
          }
          break;
      }
      return c;
    },

    'Array, Array': function (x, y) {
      // use matrix implementation
      return smaller(matrix(x), matrix(y)).valueOf();
    },

    'Array, Matrix': function (x, y) {
      // use matrix implementation
      return smaller(matrix(x), y);
    },

    'Matrix, Array': function (x, y) {
      // use matrix implementation
      return smaller(x, matrix(y));
    },

    'Matrix, any': function (x, y) {
      // result
      var c;
      // check storage format
      switch (x.storage()) {
        case 'sparse':
          c = algorithm12(x, y, smaller, false);
          break;
        default:
          c = algorithm14(x, y, smaller, false);
          break;
      }
      return c;
    },

    'any, Matrix': function (x, y) {
      // result
      var c;
      // check storage format
      switch (y.storage()) { ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.smallerEq" id="apidoc.module.mathjs.smallerEq">module mathjs.smallerEq</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.smallerEq.factory" id="apidoc.element.mathjs.smallerEq.factory">
        function <span class="apidocSignatureSpan">mathjs.smallerEq.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {

  var matrix = load(require('../../type/matrix/function/matrix'));

  var algorithm03 = load(require('../../type/matrix/utils/algorithm03'));
  var algorithm07 = load(require('../../type/matrix/utils/algorithm07'));
  var algorithm12 = load(require('../../type/matrix/utils/algorithm12'));
  var algorithm13 = load(require('../../type/matrix/utils/algorithm13'));
  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));

  var latex = require('../../utils/latex');

<span class="apidocCodeCommentSpan">  /**
   * Test whether value x is smaller or equal to y.
   *
   * The function returns true when x is smaller than y or the relative
   * difference between x and y is smaller than the configured epsilon. The
   * function cannot be used to compare values smaller than approximately 2.22e-16.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.smallerEq(x, y)
   *
   * Examples:
   *
   *    math.smaller(1 + 2, 3);        // returns false
   *    math.smallerEq(1 + 2, 3);      // returns true
   *
   * See also:
   *
   *    equal, unequal, smaller, larger, largerEq, compare
   *
   * @param  {number | BigNumber | Fraction | boolean | Unit | string | Array | Matrix} x First value to compare
   * @param  {number | BigNumber | Fraction | boolean | Unit | string | Array | Matrix} y Second value to compare
   * @return {boolean | Array | Matrix} Returns true when the x is smaller than y, else returns false
   */
</span>  var smallerEq = typed('smallerEq', {

    'boolean, boolean': function (x, y) {
      return x &lt;= y;
    },

    'number, number': function (x, y) {
      return x &lt;= y || nearlyEqual(x, y, config.epsilon);
    },

    'BigNumber, BigNumber': function (x, y) {
      return x.lte(y) || bigNearlyEqual(x, y, config.epsilon);
    },

    'Fraction, Fraction': function (x, y) {
      return x.compare(y) !== 1;
    },

    'Complex, Complex': function () {
      throw new TypeError('No ordering relation is defined for complex numbers');
    },

    'Unit, Unit': function (x, y) {
      if (!x.equalBase(y)) {
        throw new Error('Cannot compare units with different base');
      }
      return smallerEq(x.value, y.value);
    },

    'string, string': function (x, y) {
      return x &lt;= y;
    },

    'Matrix, Matrix': function (x, y) {
      // result
      var c;

      // process matrix storage
      switch (x.storage()) {
        case 'sparse':
          switch (y.storage()) {
            case 'sparse':
              // sparse + sparse
              c = algorithm07(x, y, smallerEq);
              break;
            default:
              // sparse + dense
              c = algorithm03(y, x, smallerEq, true);
              break;
          }
          break;
        default:
          switch (y.storage()) {
            case 'sparse':
              // dense + sparse
              c = algorithm03(x, y, smallerEq, false);
              break;
            default:
              // dense + dense
              c = algorithm13(x, y, smallerEq);
              break;
          }
          break;
      }
      return c;
    },

    'Array, Array': function (x, y) {
      // use matrix implementation
      return smallerEq(matrix(x), matrix(y)).valueOf();
    },

    'Array, Matrix': function (x, y) {
      // use matrix implementation
      return smallerEq(matrix(x), y);
    },

    'Matrix, Array': function (x, y) {
      // use matrix implementation
      return smallerEq(x, matrix(y));
    },

    'Matrix, any': function (x, y) {
      // result
      var c;
      // check storage format
      switch (x.storage()) {
        case 'sparse':
          c = algorithm12(x, y, smallerEq, false);
          break;
        default:
          c = algorithm14(x, y, smallerEq, false);
          break;
      }
      return c;
    },

    'any, Matrix': function (x, y) {
      // result
      var c;
      // check storage format
      switch (y.storage()) {
        case 'sparse':
          c = algorithm12(y, x, smallerEq, true);
          break;
        default: ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.sort" id="apidoc.module.mathjs.sort">module mathjs.sort</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.sort.factory" id="apidoc.element.mathjs.sort.factory">
        function <span class="apidocSignatureSpan">mathjs.sort.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var matrix = load(require('../../type/matrix/function/matrix'));
  var asc = load(require('../relational/compare'));
  var desc = function (a, b) {
    return -asc(a, b);
  };

<span class="apidocCodeCommentSpan">  /**
   * Sort the items in a matrix.
   *
   * Syntax:
   *
   *    math.sort(x)
   *    math.sort(x, compare)
   *
   * Examples:
   *
   *    math.sort([5, 10, 1]); // returns [1, 5, 10]
   *    math.sort(['C', 'B', 'A', 'D']); // returns ['A', 'B', 'C', 'D']
   *
   *    function sortByLength (a, b) {
   *      return a.length - b.length;
   *    }
   *    math.sort(['Langdon', 'Tom', 'Sara'], sortByLength); // returns ['Tom', 'Sara', 'Langdon']
   *
   * See also:
   *
   *    filter, forEach, map
   *
   * @param {Matrix | Array} x    A one dimensional matrix or array to sort
   * @param {Function | 'asc' | 'desc'} [compare='asc']
   *        An optional _comparator function. The function is called as
   *        `compare(a, b)`, and must return 1 when a &gt; b, -1 when a &lt; b,
   *        and 0 when a == b.
   * @return {Matrix | Array} Returns the sorted matrix.
   */
</span>  var sort = typed('sort', {
    'Array': function (x) {
      _arrayIsVector(x);
      return x.sort(asc);
    },

    'Matrix': function (x) {
      _matrixIsVector(x);
      return matrix(x.toArray().sort(asc), x.storage());
    },

    'Array, function': function (x, _comparator) {
      _arrayIsVector(x);
      return x.sort(_comparator);
    },

    'Matrix, function': function (x, _comparator) {
      _matrixIsVector(x);
      return matrix(x.toArray().sort(_comparator), x.storage());
    },

    'Array, string': function (x, order) {
      _arrayIsVector(x);
      return x.sort(_comparator(order));
    },

    'Matrix, string': function (x, order) {
      _matrixIsVector(x);
      return matrix(x.toArray().sort(_comparator(order)), x.storage());
    }
  });

  sort.toTex = undefined; // use default template

  /**
   * Get the comparator for given order ('asc' or 'desc')
   * @param {'asc' | 'desc'} order
   * @return {Function} Returns a _comparator function
   */
  function _comparator (order) {
    if (order === 'asc') {
      return asc;
    }
    else if (order === 'desc') {
      return desc;
    }
    else {
      throw new Error('String "asc" or "desc" expected');
    }
  }

  /**
   * Validate whether an array is one dimensional
   * Throws an error when this is not the case
   * @param {Array} array
   * @private
   */
  function _arrayIsVector (array) {
    if (size(array).length !== 1) {
      throw new Error('One dimensional array expected');
    }
  }

  /**
   * Validate whether a matrix is one dimensional
   * Throws an error when this is not the case
   * @param {Matrix} matrix
   * @private
   */
  function _matrixIsVector (matrix) {
    if (matrix.size().length !== 1) {
      throw new Error('One dimensional matrix expected');
    }
  }

  return sort;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.sqrt" id="apidoc.module.mathjs.sqrt">module mathjs.sqrt</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.sqrt.factory" id="apidoc.element.mathjs.sqrt.factory">
        function <span class="apidocSignatureSpan">mathjs.sqrt.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
<span class="apidocCodeCommentSpan">  /**
   * Calculate the square root of a value.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.sqrt(x)
   *
   * Examples:
   *
   *    math.sqrt(25);                // returns 5
   *    math.square(5);               // returns 25
   *    math.sqrt(-4);                // returns Complex 2i
   *
   * See also:
   *
   *    square, multiply, cube, cbrt
   *
   * @param {number | BigNumber | Complex | Array | Matrix | Unit} x
   *            Value for which to calculate the square root.
   * @return {number | BigNumber | Complex | Array | Matrix | Unit}
   *            Returns the square root of `x`
   */
</span>  var sqrt = typed('sqrt', {
    'number': _sqrtNumber,

    'Complex': function (x) {
        return x.sqrt();
    },

    'BigNumber': function (x) {
      if (!x.isNegative() || config.predictable) {
        return x.sqrt();
      }
      else {
        // negative value -&gt; downgrade to number to do complex value computation
        return _sqrtNumber(x.toNumber());
      }
    },

    'Array | Matrix': function (x) {
      // deep map collection, skip zeros since sqrt(0) = 0
      return deepMap(x, sqrt, true);
    },

    'Unit': function (x) {
      // Someday will work for complex units when they are implemented
      return x.pow(0.5);
    }

  });

  /**
   * Calculate sqrt for a number
   * @param {number} x
   * @returns {number | Complex} Returns the square root of x
   * @private
   */
  function _sqrtNumber(x) {
    if (x &gt;= 0 || config.predictable) {
      return Math.sqrt(x);
    }
    else {
      return new type.Complex(x, 0).sqrt();
    }
  }

  sqrt.toTex = {1: '\\sqrt{${args[0]}}'};

  return sqrt;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.square" id="apidoc.module.mathjs.square">module mathjs.square</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.square.factory" id="apidoc.element.mathjs.square.factory">
        function <span class="apidocSignatureSpan">mathjs.square.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
<span class="apidocCodeCommentSpan">  /**
   * Compute the square of a value, `x * x`.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.square(x)
   *
   * Examples:
   *
   *    math.square(2);           // returns number 4
   *    math.square(3);           // returns number 9
   *    math.pow(3, 2);           // returns number 9
   *    math.multiply(3, 3);      // returns number 9
   *
   *    math.square([1, 2, 3, 4]);  // returns Array [1, 4, 9, 16]
   *
   * See also:
   *
   *    multiply, cube, sqrt, pow
   *
   * @param  {number | BigNumber | Fraction | Complex | Array | Matrix | Unit} x
   *            Number for which to calculate the square
   * @return {number | BigNumber | Fraction | Complex | Array | Matrix | Unit}
   *            Squared value
   */
</span>  var square = typed('square', {
    'number': function (x) {
      return x * x;
    },

    'Complex': function (x) {
      return x.mul(x);
    },

    'BigNumber': function (x) {
      return x.times(x);
    },

    'Fraction': function (x) {
      return x.mul(x);
    },

    'Array | Matrix': function (x) {
      // deep map collection, skip zeros since square(0) = 0
      return deepMap(x, square, true);
    },

    'Unit': function(x) {
      return x.pow(2);
    }
  });

  square.toTex = {1: '\\left(${args[0]}\\right)^2'};

  return square;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.squeeze" id="apidoc.module.mathjs.squeeze">module mathjs.squeeze</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.squeeze.factory" id="apidoc.element.mathjs.squeeze.factory">
        function <span class="apidocSignatureSpan">mathjs.squeeze.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var matrix = load(require('../../type/matrix/function/matrix'));

<span class="apidocCodeCommentSpan">  /**
   * Squeeze a matrix, remove inner and outer singleton dimensions from a matrix.
   *
   * Syntax:
   *
   *     math.squeeze(x)
   *
   * Examples:
   *
   *     math.squeeze([3]);           // returns 3
   *     math.squeeze([[3]]);         // returns 3
   *
   *     var A = math.zeros(3, 1);    // returns [[0], [0], [0]] (size 3x1)
   *     math.squeeze(A);             // returns [0, 0, 0] (size 3)
   *
   *     var B = math.zeros(1, 3);    // returns [[0, 0, 0]] (size 1x3)
   *     math.squeeze(B);             // returns [0, 0, 0] (size 3)
   *
   *     // only inner and outer dimensions are removed
   *     var C = math.zeros(2, 1, 3); // returns [[[0, 0, 0]], [[0, 0, 0]]] (size 2x1x3)
   *     math.squeeze(C);             // returns [[[0, 0, 0]], [[0, 0, 0]]] (size 2x1x3)
   *
   * See also:
   *
   *     subset
   *
   * @param {Matrix | Array} x      Matrix to be squeezed
   * @return {Matrix | Array} Squeezed matrix
   */
</span>  var squeeze = typed('squeeze', {
    'Array': function (x) {
      return array.squeeze(object.clone(x));
    },

    'Matrix': function (x) {
      var res = array.squeeze(x.toArray());
      // FIXME: return the same type of matrix as the input
      return Array.isArray(res) ? matrix(res) : res;
    },

    'any': function (x) {
      // scalar
      return object.clone(x);
    }
  });

  squeeze.toTex = undefined; // use default template

  return squeeze;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.std" id="apidoc.module.mathjs.std">module mathjs.std</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.std.factory" id="apidoc.element.mathjs.std.factory">
        function <span class="apidocSignatureSpan">mathjs.std.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var sqrt       = load(require('../arithmetic/sqrt'));
  var variance   = load(require('../statistics/var'));

<span class="apidocCodeCommentSpan">  /**
   * Compute the standard deviation of a matrix or a  list with values.
   * The standard deviations is defined as the square root of the variance:
   * `std(A) = sqrt(var(A))`.
   * In case of a (multi dimensional) array or matrix, the standard deviation
   * over all elements will be calculated.
   *
   * Optionally, the type of normalization can be specified as second
   * parameter. The parameter `normalization` can be one of the following values:
   *
   * - 'unbiased' (default) The sum of squared errors is divided by (n - 1)
   * - 'uncorrected'        The sum of squared errors is divided by n
   * - 'biased'             The sum of squared errors is divided by (n + 1)
   *
   * Syntax:
   *
   *     math.std(a, b, c, ...)
   *     math.std(A)
   *     math.std(A, normalization)
   *
   * Examples:
   *
   *     math.std(2, 4, 6);                     // returns 2
   *     math.std([2, 4, 6, 8]);                // returns 2.581988897471611
   *     math.std([2, 4, 6, 8], 'uncorrected'); // returns 2.23606797749979
   *     math.std([2, 4, 6, 8], 'biased');      // returns 2
   *
   *     math.std([[1, 2, 3], [4, 5, 6]]);      // returns 1.8708286933869707
   *
   * See also:
   *
   *    mean, median, max, min, prod, sum, var
   *
   * @param {Array | Matrix} array
   *                        A single matrix or or multiple scalar values
   * @param {string} [normalization='unbiased']
   *                        Determines how to normalize the variance.
   *                        Choose 'unbiased' (default), 'uncorrected', or 'biased'.
   * @return {*} The standard deviation
   */
</span>  var std = typed('std', {
    // std([a, b, c, d, ...])
    'Array | Matrix': _std,

    // std([a, b, c, d, ...], normalization)
    'Array | Matrix, string': _std,

    // std(a, b, c, d, ...)
    '...': function (args) {
      return _std(args);
    }
  });

  std.toTex = undefined; // use default template

  return std;

  function _std(array, normalization) {
    if (array.length == 0) {
      throw new SyntaxError('Function std requires one or more parameters (0 provided)');
    }

    return sqrt(variance.apply(null, arguments));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.stirlingS2" id="apidoc.module.mathjs.stirlingS2">module mathjs.stirlingS2</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.stirlingS2.factory" id="apidoc.element.mathjs.stirlingS2.factory">
        function <span class="apidocSignatureSpan">mathjs.stirlingS2.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var add = load(require('../arithmetic/add'));
  var subtract = load(require('../arithmetic/subtract'));
  var multiply = load(require('../arithmetic/multiply'));
  var divide = load(require('../arithmetic/divide'));
  var pow = load(require('../arithmetic/pow'));
  var factorial = load(require('../probability/factorial'));
  var combinations = load(require('../probability/combinations'));
  var isNegative = load(require('../utils/isNegative'));
  var isInteger = load(require('../utils/isInteger'));
  var larger = load(require('../relational/larger'));

<span class="apidocCodeCommentSpan">  /**
   * The Stirling numbers of the second kind, counts the number of ways to partition
   * a set of n labelled objects into k nonempty unlabelled subsets.
   * stirlingS2 only takes integer arguments.
   * The following condition must be enforced: k &lt;= n.
   *
   *  If n = k or k = 1, then s(n,k) = 1
   *
   * Syntax:
   *
   *   math.stirlingS2(n, k)
   *
   * Examples:
   *
   *    math.stirlingS2(5, 3); //returns 25
   *
   * See also:
   *
   *    Bell numbers
   *
   * @param {Number | BigNumber} n    Total number of objects in the set
   * @param {Number | BigNumber} k    Number of objects in the subset
   * @return {Number | BigNumber}     S(n,k)
   */
</span>  var stirlingS2 = typed('stirlingS2', {
    'number | BigNumber, number | BigNumber': function (n, k) {
      if (!isInteger(n) || isNegative(n) || !isInteger(k) || isNegative(k)) {
        throw new TypeError('Non-negative integer value expected in function stirlingS2');
      }
      else if (larger(k, n)) {
        throw new TypeError('k must be less than or equal to n in function stirlingS2');
      }

      // 1/k! Sum(i=0 -&gt; k) [(-1)^(k-i)*C(k,j)* i^n]
      var kFactorial = factorial(k);
      var result = 0;
      for(var i = 0; i &lt;= k; i++) {
        var negativeOne = pow(-1, subtract(k,i));
        var kChooseI = combinations(k,i);
        var iPower = pow(i,n);

        result = add(result, multiply(multiply(kChooseI, iPower), negativeOne));
      }

      return divide(result, kFactorial);
    }
  });

  stirlingS2.toTex = {2: '\\mathrm{S}\\left(${args}\\right)'};

  return stirlingS2;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.string" id="apidoc.module.mathjs.string">module mathjs.string</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.string.factory" id="apidoc.element.mathjs.string.factory">
        function <span class="apidocSignatureSpan">mathjs.string.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
<span class="apidocCodeCommentSpan">  /**
   * Create a string or convert any object into a string.
   * Elements of Arrays and Matrices are processed element wise.
   *
   * Syntax:
   *
   *    math.string(value)
   *
   * Examples:
   *
   *    math.string(4.2);               // returns string '4.2'
   *    math.string(math.complex(3, 2); // returns string '3 + 2i'
   *
   *    var u = math.unit(5, 'km');
   *    math.string(u.to('m'));         // returns string '5000 m'
   *
   *    math.string([true, false]);     // returns ['true', 'false']
   *
   * See also:
   *
   *    bignumber, boolean, complex, index, matrix, number, unit
   *
   * @param {* | Array | Matrix | null} [value]  A value to convert to a string
   * @return {string | Array | Matrix} The created string
   */
</span>  var string = typed('string', {
    '': function () {
      return '';
    },

    'number': number.format,

    'null': function (x) {
      return 'null';
    },

    'boolean': function (x) {
      return x + '';
    },

    'string': function (x) {
      return x;
    },

    'Array | Matrix': function (x) {
      return deepMap(x, string);
    },

    'any': function (x) {
      return String(x);
    }
  });

  string.toTex = {
    0: '\\mathtt{""}',
    1: '\\mathrm{string}\\left(${args[0]}\\right)'
  };

  return string;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.subset" id="apidoc.module.mathjs.subset">module mathjs.subset</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.subset.factory" id="apidoc.element.mathjs.subset.factory">
        function <span class="apidocSignatureSpan">mathjs.subset.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var matrix = load(require('../../type/matrix/function/matrix'));

<span class="apidocCodeCommentSpan">  /**
   * Get or set a subset of a matrix or string.
   *
   * Syntax:
   *     math.subset(value, index)                                // retrieve a subset
   *     math.subset(value, index, replacement [, defaultValue])  // replace a subset
   *
   * Examples:
   *
   *     // get a subset
   *     var d = [[1, 2], [3, 4]];
   *     math.subset(d, math.index(1, 0));        // returns 3
   *     math.subset(d, math.index([0, 2], 1));   // returns [[2], [4]]
   *
   *     // replace a subset
   *     var e = [];
   *     var f = math.subset(e, math.index(0, [0, 2]), [5, 6]);  // f = [[5, 6]]
   *     var g = math.subset(f, math.index(1, 1), 7, 0);         // g = [[5, 6], [0, 7]]
   *
   * See also:
   *
   *     size, resize, squeeze, index
   *
   * @param {Array | Matrix | string} matrix  An array, matrix, or string
   * @param {Index} index                     An index containing ranges for each
   *                                          dimension
   * @param {*} [replacement]                 An array, matrix, or scalar.
   *                                          If provided, the subset is replaced with replacement.
   *                                          If not provided, the subset is returned
   * @param {*} [defaultValue=undefined]      Default value, filled in on new entries when
   *                                          the matrix is resized. If not provided,
   *                                          math.matrix elements will be left undefined.
   * @return {Array | Matrix | string} Either the retrieved subset or the updated matrix.
   */
</span>  var subset = typed('subset', {
    // get subset
    'Array, Index': function (value, index) {
      var m = matrix(value);
      var subset = m.subset(index);       // returns a Matrix
      return subset &amp;&amp; subset.valueOf();  // return an Array (like the input)
    },

    'Matrix, Index': function (value, index) {
      return value.subset(index);
    },

    'Object, Index': _getObjectProperty,

    'string, Index': _getSubstring,

    // set subset
    'Array, Index, any': function (value, index, replacement) {
      return matrix(clone(value))
          .subset(index, replacement, undefined)
          .valueOf();
    },

    'Array, Index, any, any': function (value, index, replacement, defaultValue) {
      return matrix(clone(value))
          .subset(index, replacement, defaultValue)
          .valueOf();
    },

    'Matrix, Index, any': function (value, index, replacement) {
      return value.clone().subset(index, replacement);
    },

    'Matrix, Index, any, any': function (value, index, replacement, defaultValue) {
      return value.clone().subset(index, replacement, defaultValue);
    },

    'string, Index, string': _setSubstring,
    'string, Index, string, string': _setSubstring,
    'Object, Index, any': _setObjectProperty
  });

  subset.toTex = undefined; // use default template

  return subset;

  /**
   * Retrieve a subset of a string
   * @param {string} str            string from which to get a substring
   * @param {Index} index           An index containing ranges for each dimension
   * @returns {string} substring
   * @private
   */
  function _getSubstring(str, index) {
    if (!index || index.isIndex !== true) {
      // TODO: better error message
      throw new TypeError('Index expected');
    }
    if (index.size().length != 1) {
      throw new DimensionError(index.size().length, 1);
    }

    // validate whether the range is out of range
    var strLen = str.length;
    validateIndex(index.min()[0], strLen);
    validateIndex(index.max()[0], strLen);

    var range = index.dimension(0);

    var substr = '';
    range.forEach(function (v) {
      substr += str.charAt(v);
    });

    return substr;
  }

  /**
   * Replace a substring in a string
   * @param {string} str            string to be replaced
   * @param {Index} index           An index containing ranges for each dimension
   * @param {string} ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.subset_transform" id="apidoc.module.mathjs.subset_transform">module mathjs.subset_transform</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.subset_transform.factory" id="apidoc.element.mathjs.subset_transform.factory">
        function <span class="apidocSignatureSpan">mathjs.subset_transform.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var subset = load(require('../../function/matrix/subset'));

  return typed('subset', {
    '...any': function (args) {
      try {
        return subset.apply(null, args);
      }
      catch (err) {
        throw errorTransform(err);
      }
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.subtract" id="apidoc.module.mathjs.subtract">module mathjs.subtract</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.subtract.factory" id="apidoc.element.mathjs.subtract.factory">
        function <span class="apidocSignatureSpan">mathjs.subtract.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var latex = require('../../utils/latex');

  var matrix = load(require('../../type/matrix/function/matrix'));
  var addScalar = load(require('./addScalar'));
  var unaryMinus = load(require('./unaryMinus'));

  var algorithm01 = load(require('../../type/matrix/utils/algorithm01'));
  var algorithm03 = load(require('../../type/matrix/utils/algorithm03'));
  var algorithm05 = load(require('../../type/matrix/utils/algorithm05'));
  var algorithm10 = load(require('../../type/matrix/utils/algorithm10'));
  var algorithm13 = load(require('../../type/matrix/utils/algorithm13'));
  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));

  // TODO: split function subtract in two: subtract and subtractScalar

<span class="apidocCodeCommentSpan">  /**
   * Subtract two values, `x - y`.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.subtract(x, y)
   *
   * Examples:
   *
   *    math.subtract(5.3, 2);        // returns number 3.3
   *
   *    var a = math.complex(2, 3);
   *    var b = math.complex(4, 1);
   *    math.subtract(a, b);          // returns Complex -2 + 2i
   *
   *    math.subtract([5, 7, 4], 4);  // returns Array [1, 3, 0]
   *
   *    var c = math.unit('2.1 km');
   *    var d = math.unit('500m');
   *    math.subtract(c, d);          // returns Unit 1.6 km
   *
   * See also:
   *
   *    add
   *
   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x
   *            Initial value
   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} y
   *            Value to subtract from `x`
   * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix}
   *            Subtraction of `x` and `y`
   */
</span>  var subtract = typed('subtract', {

    'number, number': function (x, y) {
      return x - y;
    },

    'Complex, Complex': function (x, y) {
      return x.sub(y);
    },

    'BigNumber, BigNumber': function (x, y) {
      return x.minus(y);
    },

    'Fraction, Fraction': function (x, y) {
      return x.sub(y);
    },

    'Unit, Unit': function (x, y) {
      if (x.value == null) {
        throw new Error('Parameter x contains a unit with undefined value');
      }

      if (y.value == null) {
        throw new Error('Parameter y contains a unit with undefined value');
      }

      if (!x.equalBase(y)) {
        throw new Error('Units do not match');
      }

      var res = x.clone();
      res.value = subtract(res.value, y.value);
      res.fixPrefix = false;

      return res;
    },

    'Matrix, Matrix': function (x, y) {
      // matrix sizes
      var xsize = x.size();
      var ysize = y.size();

      // check dimensions
      if (xsize.length !== ysize.length)
        throw new DimensionError(xsize.length, ysize.length);

      // result
      var c;

      // process matrix storage
      switch (x.storage()) {
        case 'sparse':
          switch (y.storage()) {
            case 'sparse':
              // sparse - sparse
              c = algorithm05(x, y, subtract);
              break;
            default:
              // sparse - dense
              c = algorithm03(y, x, subtract, true);
              break;
          }
          break;
        default:
          switch (y.storage()) {
            case 'sparse':
              // dense - sparse
              c = algorithm01(x, y, subtract, false);
              break;
            default:
              // dense - dense
              c = algorithm13(x, y, subtract);
              break;
          }
          break;
      }
      return c;
    },

    'Array, Array': function (x, y) {
      // use matrix implementation
      return subtract(matrix(x), matrix(y)).valueOf();
    },

    'Array, Matrix': function (x, y) {
      // use matrix implementation
      return subtract(matrix(x), y);
    },

    'Matrix, Array': function (x, y) {
      // use matrix implementation
      return subtract(x, matrix(y));
    },

    'Matrix, any': function (x, y) {
      // result
      var c;
      // check stor ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.sum" id="apidoc.module.mathjs.sum">module mathjs.sum</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.sum.factory" id="apidoc.element.mathjs.sum.factory">
        function <span class="apidocSignatureSpan">mathjs.sum.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var add = load(require('../arithmetic/addScalar'));

<span class="apidocCodeCommentSpan">  /**
   * Compute the sum of a matrix or a list with values.
   * In case of a (multi dimensional) array or matrix, the sum of all
   * elements will be calculated.
   *
   * Syntax:
   *
   *     math.sum(a, b, c, ...)
   *     math.sum(A)
   *
   * Examples:
   *
   *     math.sum(2, 1, 4, 3);               // returns 10
   *     math.sum([2, 1, 4, 3]);             // returns 10
   *     math.sum([[2, 5], [4, 3], [1, 7]]); // returns 22
   *
   * See also:
   *
   *    mean, median, min, max, prod, std, var
   *
   * @param {... *} args  A single matrix or or multiple scalar values
   * @return {*} The sum of all values
   */
</span>  var sum = typed('sum', {
    'Array | Matrix': function (args) {
      // sum([a, b, c, d, ...])
      return _sum(args);
    },

    'Array | Matrix, number | BigNumber': function () {
      // sum([a, b, c, d, ...], dim)
      // TODO: implement sum(A, dim)
      throw new Error('sum(A, dim) is not yet supported');
    },

    '...': function (args) {
      // sum(a, b, c, d, ...)
      return _sum(args);
    }
  });

  sum.toTex = undefined; // use default template

  return sum;

  /**
   * Recursively calculate the sum of an n-dimensional array
   * @param {Array} array
   * @return {number} sum
   * @private
   */
  function _sum(array) {
    var sum = undefined;

    deepForEach(array, function (value) {
      sum = (sum === undefined) ? value : add(sum, value);
    });

    if (sum === undefined) {
      switch (config.number) {
        case 'number':
          return 0;
        case 'BigNumber':
          return new type.BigNumber(0);
        case 'Fraction':
          return new type.Fraction(0);
        default:
          return 0;
      }
    }

    return sum;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.tan" id="apidoc.module.mathjs.tan">module mathjs.tan</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.tan.factory" id="apidoc.element.mathjs.tan.factory">
        function <span class="apidocSignatureSpan">mathjs.tan.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
<span class="apidocCodeCommentSpan">  /**
   * Calculate the tangent of a value. `tan(x)` is equal to `sin(x) / cos(x)`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.tan(x)
   *
   * Examples:
   *
   *    math.tan(0.5);                    // returns number 0.5463024898437905
   *    math.sin(0.5) / math.cos(0.5);    // returns number 0.5463024898437905
   *    math.tan(math.pi / 4);            // returns number 1
   *    math.tan(math.unit(45, 'deg'));   // returns number 1
   *
   * See also:
   *
   *    atan, sin, cos
   *
   * @param {number | BigNumber | Complex | Unit | Array | Matrix} x  Function input
   * @return {number | BigNumber | Complex | Array | Matrix} Tangent of x
   */
</span>  var tan = typed('tan', {
    'number': Math.tan,

    'Complex': function (x) {
        return x.tan();
    },

    'BigNumber': function (x) {
      return x.tan();
    },

    'Unit': function (x) {
      if (!x.hasBase(type.Unit.BASE_UNITS.ANGLE)) {
        throw new TypeError ('Unit in function tan is no angle');
      }
      return tan(x.value);
    },

    'Array | Matrix': function (x) {
      // deep map collection, skip zeros since tan(0) = 0
      return deepMap(x, tan, true);
    }
  });

  tan.toTex = {1: '\\tan\\left(${args[0]}\\right)'};

  return tan;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.tanh" id="apidoc.module.mathjs.tanh">module mathjs.tanh</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.tanh.factory" id="apidoc.element.mathjs.tanh.factory">
        function <span class="apidocSignatureSpan">mathjs.tanh.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  /**
   * Calculate the hyperbolic tangent of a value,
   * defined as `tanh(x) = (exp(2 * x) - 1) / (exp(2 * x) + 1)`.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.tanh(x)
   *
   * Examples:
   *
   *    // tanh(x) = sinh(x) / cosh(x) = 1 / coth(x)
   *    math.tanh(0.5);                   // returns 0.46211715726000974
   *    math.sinh(0.5) / math.cosh(0.5);  // returns 0.46211715726000974
   *    1 / math.coth(0.5);               // returns 0.46211715726000974
   *
   * See also:
   *
   *    sinh, cosh, coth
   *
   * @param {number | BigNumber | Complex | Unit | Array | Matrix} x  Function input
   * @return {number | BigNumber | Complex | Array | Matrix} Hyperbolic tangent of x
   */
  var tanh = typed('tanh', {
    'number': _tanh,

    'Complex': function (x) {
        return x.tanh();
    },

    'BigNumber': function (x) {
      return x.tanh();
    },

    'Unit': function (x) {
      if (!x.hasBase(type.Unit.BASE_UNITS.ANGLE)) {
        throw new TypeError ('Unit in function tanh is no angle');
      }
      return tanh(x.value);
    },

    'Array | Matrix': function (x) {
      // deep map collection, skip zeros since tanh(0) = 0
      return deepMap(x, tanh, true);
    }
  });

  tanh.toTex = {1: '\\tanh\\left(${args[0]}\\right)'};

  return tanh;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.to" id="apidoc.module.mathjs.to">module mathjs.to</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.to.factory" id="apidoc.element.mathjs.to.factory">
        function <span class="apidocSignatureSpan">mathjs.to.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var latex = require('../../utils/latex');

  var matrix = load(require('../../type/matrix/function/matrix'));

  var algorithm13 = load(require('../../type/matrix/utils/algorithm13'));
  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));

<span class="apidocCodeCommentSpan">  /**
   * Change the unit of a value.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.to(x, unit)
   *
   * Examples:
   *
   *    math.to(math.unit('2 inch'), 'cm');                   // returns Unit 5.08 cm
   *    math.to(math.unit('2 inch'), math.unit(null, 'cm'));  // returns Unit 5.08 cm
   *    math.to(math.unit(16, 'bytes'), 'bits');              // returns Unit 128 bits
   *
   * See also:
   *
   *    unit
   *
   * @param {Unit | Array | Matrix} x     The unit to be converted.
   * @param {Unit | Array | Matrix} unit  New unit. Can be a string like "cm"
   *                                      or a unit without value.
   * @return {Unit | Array | Matrix} value with changed, fixed unit.
   */
</span>  var to = typed('to', {

    'Unit, Unit | string': function (x, unit) {
      return x.to(unit);
    },

    'Matrix, Matrix': function (x, y) {
      // SparseMatrix does not support Units
      return algorithm13(x, y, to);
    },

    'Array, Array': function (x, y) {
      // use matrix implementation
      return to(matrix(x), matrix(y)).valueOf();
    },

    'Array, Matrix': function (x, y) {
      // use matrix implementation
      return to(matrix(x), y);
    },

    'Matrix, Array': function (x, y) {
      // use matrix implementation
      return to(x, matrix(y));
    },

    'Matrix, any': function (x, y) {
      // SparseMatrix does not support Units
      return algorithm14(x, y, to, false);
    },

    'any, Matrix': function (x, y) {
      // SparseMatrix does not support Units
      return algorithm14(y, x, to, true);
    },

    'Array, any': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(x), y, to, false).valueOf();
    },

    'any, Array': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(y), x, to, true).valueOf();
    }
  });

  to.toTex = {
    2: '\\left(${args[0]}' + latex.operators['to'] + '${args[1]}\\right)'
  };

  return to;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.trace" id="apidoc.module.mathjs.trace">module mathjs.trace</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.trace.factory" id="apidoc.element.mathjs.trace.factory">
        function <span class="apidocSignatureSpan">mathjs.trace.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {

  var matrix = load(require('../../type/matrix/function/matrix'));
  var add = load(require('../arithmetic/add'));

<span class="apidocCodeCommentSpan">  /**
   * Calculate the trace of a matrix: the sum of the elements on the main
   * diagonal of a square matrix.
   *
   * Syntax:
   *
   *    math.trace(x)
   *
   * Examples:
   *
   *    math.trace([[1, 2], [3, 4]]); // returns 5
   *
   *    var A = [
   *      [1, 2, 3],
   *      [-1, 2, 3],
   *      [2, 0, 3]
   *    ]
   *    math.trace(A); // returns 6
   *
   * See also:
   *
   *    diag
   *
   * @param {Array | Matrix} x  A matrix
   *
   * @return {number} The trace of `x`
   */
</span>  var trace = typed('trace', {

    'Array': function (x) {
      // use dense matrix implementation
      return trace(matrix(x));
    },

    'Matrix': function (x) {
      // result
      var c;
      // process storage format
      switch (x.storage()) {
        case 'dense':
          c = _denseTrace(x);
          break;
        case 'sparse':
          c = _sparseTrace(x);
          break;
      }
      return c;
    },

    'any': clone
  });

  var _denseTrace = function (m) {
    // matrix size &amp; data
    var size = m._size;
    var data = m._data;

    // process dimensions
    switch (size.length) {
      case 1:
        // vector
        if (size[0] == 1) {
          // return data[0]
          return clone(data[0]);
        }
        throw new RangeError('Matrix must be square (size: ' + format(size) + ')');
      case 2:
        // two dimensional
        var rows = size[0];
        var cols = size[1];
        if (rows === cols) {
          // calulate sum
          var sum = 0;
          // loop diagonal
          for (var i = 0; i &lt; rows; i++)
            sum = add(sum, data[i][i]);
          // return trace
          return sum;
        }
        throw new RangeError('Matrix must be square (size: ' + format(size) + ')');
      default:
        // multi dimensional
        throw new RangeError('Matrix must be two dimensional (size: ' + format(size) + ')');
    }
  };

  var _sparseTrace = function (m) {
    // matrix arrays
    var values = m._values;
    var index = m._index;
    var ptr = m._ptr;
    var size = m._size;
    // check dimensions
    var rows = size[0];
    var columns = size[1];
    // matrix must be square
    if (rows === columns) {
      // calulate sum
      var sum = 0;
      // check we have data (avoid looping columns)
      if (values.length &gt; 0) {
        // loop columns
        for (var j = 0; j &lt; columns; j++) {
          // k0 &lt;= k &lt; k1 where k0 = _ptr[j] &amp;&amp; k1 = _ptr[j+1]
          var k0 = ptr[j];
          var k1 = ptr[j + 1];
          // loop k within [k0, k1[
          for (var k = k0; k &lt; k1; k++) {
            // row index
            var i = index[k];
            // check row
            if (i === j) {
              // accumulate value
              sum = add(sum, values[k]);
              // exit loop
              break;
            }
            if (i &gt; j) {
              // exit loop, no value on the diagonal for column j
              break;
            }
          }
        }
      }
      // return trace
      return sum;
    }
    throw new RangeError('Matrix must be square (size: ' + format(size) + ')');
  };

  trace.toTex = {1: '\\mathrm{tr}\\left(${args[0]}\\right)'};

  return trace;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.transpose" id="apidoc.module.mathjs.transpose">module mathjs.transpose</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.transpose.factory" id="apidoc.element.mathjs.transpose.factory">
        function <span class="apidocSignatureSpan">mathjs.transpose.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var latex = require('../../utils/latex');

  var matrix = load(require('../../type/matrix/function/matrix'));

  var DenseMatrix = type.DenseMatrix,
      SparseMatrix = type.SparseMatrix;

<span class="apidocCodeCommentSpan">  /**
   * Transpose a matrix. All values of the matrix are reflected over its
   * main diagonal. Only applicable to two dimensional matrices containing
   * a vector (i.e. having size `[1,n]` or `[n,1]`). One dimensional
   * vectors and scalars return the input unchanged.
   *
   * Syntax:
   *
   *     math.transpose(x)
   *
   * Examples:
   *
   *     var A = [[1, 2, 3], [4, 5, 6]];
   *     math.transpose(A);               // returns [[1, 4], [2, 5], [3, 6]]
   *
   * See also:
   *
   *     diag, inv, subset, squeeze
   *
   * @param {Array | Matrix} x  Matrix to be transposed
   * @return {Array | Matrix}   The transposed matrix
   */
</span>  var transpose = typed('transpose', {

    'Array': function (x) {
      // use dense matrix implementation
      return transpose(matrix(x)).valueOf();
    },

    'Matrix': function (x) {
      // matrix size
      var size = x.size();

      // result
      var c;

      // process dimensions
      switch (size.length) {
        case 1:
          // vector
          c = x.clone();
          break;

        case 2:
          // rows and columns
          var rows = size[0];
          var columns = size[1];

          // check columns
          if (columns === 0) {
            // throw exception
            throw new RangeError('Cannot transpose a 2D matrix with no columns (size: ' + format(size) + ')');
          }

          // process storage format
          switch (x.storage()) {
            case 'dense':
              c = _denseTranspose(x, rows, columns);
              break;
            case 'sparse':
              c = _sparseTranspose(x, rows, columns);
              break;
          }
          break;

        default:
          // multi dimensional
          throw new RangeError('Matrix must be a vector or two dimensional (size: ' + format(this._size) + ')');
      }
      return c;
    },

    // scalars
    'any': function (x) {
      return clone(x);
    }
  });

  var _denseTranspose = function (m, rows, columns) {
    // matrix array
    var data = m._data;
    // transposed matrix data
    var transposed = [];
    var transposedRow;
    // loop columns
    for (var j = 0; j &lt; columns; j++) {
      // initialize row
      transposedRow = transposed[j] = [];
      // loop rows
      for (var i = 0; i &lt; rows; i++) {
        // set data
        transposedRow[i] = clone(data[i][j]);
      }
    }
    // return matrix
    return new DenseMatrix({
      data: transposed,
      size: [columns, rows],
      datatype: m._datatype
    });
  };

  var _sparseTranspose = function (m, rows, columns) {
    // matrix arrays
    var values = m._values;
    var index = m._index;
    var ptr = m._ptr;
    // result matrices
    var cvalues = values ? [] : undefined;
    var cindex = [];
    var cptr = [];
    // row counts
    var w = [];
    for (var x = 0; x &lt; rows; x++)
      w[x] = 0;
    // vars
    var p, l, j;
    // loop values in matrix
    for (p = 0, l = index.length; p &lt; l; p++) {
      // number of values in row
      w[index[p]]++;
    }
    // cumulative sum
    var sum = 0;
    // initialize cptr with the cummulative sum of row counts
    for (var i = 0; i &lt; rows; i++) {
      // update cptr
      cptr.push(sum);
      // update sum
      sum += w[i];
      // update w
      w[i] = cptr[i];
    }
    // update cptr
    cptr.push(sum);
    // loop columns
    for (j = 0; j &lt; columns; j++) {
      // values &amp; index in column
      for (var k0 = ptr[j], k1 = ptr[j + 1], k = k0; k &lt; k1; k++) {
        // C values &amp; index
        var q = w[index[k]]++;
        // C[j, i] = A[i, j]
        cindex[q] = j;
        // check we need to process values (pattern matrix)
        if (values)
          cvalues[q] = clone(values[k]);
      }
    }
    // return matrix
    return new SparseMatrix({
      values: cvalues,
      index: ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.type" id="apidoc.module.mathjs.type">module mathjs.type</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber" id="apidoc.element.mathjs.type.BigNumber">
        function <span class="apidocSignatureSpan">mathjs.type.</span>BigNumber
        <span class="apidocSignatureSpan">(v)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Decimal(v) {
  var e, i, t,
    x = this;

  // Decimal called without new.
  if (!(x instanceof Decimal)) return new Decimal(v);

  // Retain a reference to this Decimal constructor, and shadow Decimal.prototype.constructor
  // which points to Object.
  x.constructor = Decimal;

  // Duplicate.
  if (v instanceof Decimal) {
    x.s = v.s;
    x.e = v.e;
    x.d = (v = v.d) ? v.slice() : v;
    return;
  }

  t = typeof v;

  if (t === 'number') {
    if (v === 0) {
      x.s = 1 / v &lt; 0 ? -1 : 1;
      x.e = 0;
      x.d = [0];
      return;
    }

    if (v &lt; 0) {
      v = -v;
      x.s = -1;
    } else {
      x.s = 1;
    }

    // Fast path for small integers.
    if (v === ~~v &amp;&amp; v &lt; 1e7) {
      for (e = 0, i = v; i &gt;= 10; i /= 10) e++;
      x.e = e;
      x.d = [v];
      return;

    // Infinity, NaN.
    } else if (v * 0 !== 0) {
      if (!v) x.s = NaN;
      x.e = NaN;
      x.d = null;
      return;
    }

    return parseDecimal(x, v.toString());

  } else if (t !== 'string') {
    throw Error(invalidArgument + v);
  }

  // Minus sign?
  if (v.charCodeAt(0) === 45) {
    v = v.slice(1);
    x.s = -1;
  } else {
    x.s = 1;
  }

  return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  setConstant(math, 'true', true);
  setConstant(math, 'false', false);
  setConstant(math, 'null', null);
  setConstant(math, 'uninitialized', require('./utils/array').UNINITIALIZED);

  if (config.number === 'BigNumber') {
setConstant(math, 'Infinity', new type.<span class="apidocCodeKeywordSpan">BigNumber</span>(Infinity));
setConstant(math, 'NaN', new type.BigNumber(NaN));

setLazyConstant(math, 'pi',  function () {return bigConstants.pi(type.BigNumber)});
setLazyConstant(math, 'tau', function () {return bigConstants.tau(type.BigNumber)});
setLazyConstant(math, 'e',   function () {return bigConstants.e(type.BigNumber)});
setLazyConstant(math, 'phi', function () {return bigConstants.phi(type.BigNumber)}); // golden ratio, (1+sqrt(5))/2
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain" id="apidoc.element.mathjs.type.Chain">
        function <span class="apidocSignatureSpan">mathjs.type.</span>Chain
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Chain(value) {
  if (!(this instanceof Chain)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  if (value &amp;&amp; value.isChain) {
    this.value = value.value;
  }
  else {
    this.value = value;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Complex" id="apidoc.element.mathjs.type.Complex">
        function <span class="apidocSignatureSpan">mathjs.type.</span>Complex
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Complex(a, b) {

  if (!(this instanceof Complex)) {
    return new Complex(a, b);
  }

  parse(a, b); // mutates P

  this["re"] = P["re"];
  this["im"] = P["im"];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
    return new type.BigNumber(x);
  }
}, {
  from: 'number',
  to: 'Complex',
  convert: function (x) {
    return new type.<span class="apidocCodeKeywordSpan">Complex</span>(x, 0);
  }
}, {
  from: 'number',
  to: 'string',
  convert: function (x) {
    return x + '';
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.DenseMatrix" id="apidoc.element.mathjs.type.DenseMatrix">
        function <span class="apidocSignatureSpan">mathjs.type.</span>DenseMatrix
        <span class="apidocSignatureSpan">(data, datatype)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DenseMatrix(data, datatype) {
  if (!(this instanceof DenseMatrix))
    throw new SyntaxError('Constructor must be called with the new operator');
  if (datatype &amp;&amp; !isString(datatype))
    throw new Error('Invalid datatype: ' + datatype);

  if (data &amp;&amp; data.isMatrix === true) {
    // check data is a DenseMatrix
    if (data.type === 'DenseMatrix') {
      // clone data &amp; size
      this._data = object.clone(data._data);
      this._size = object.clone(data._size);
      this._datatype = datatype || data._datatype;
    }
    else {
      // build data from existing matrix
      this._data = data.toArray();
      this._size = data.size();
      this._datatype = datatype || data._datatype;
    }
  }
  else if (data &amp;&amp; isArray(data.data) &amp;&amp; isArray(data.size)) {
    // initialize fields from JSON representation
    this._data = data.data;
    this._size = data.size;
    this._datatype = datatype || data.datatype;
  }
  else if (isArray(data)) {
    // replace nested Matrices with Arrays
    this._data = preprocess(data);
    // get the dimensions of the array
    this._size = array.size(this._data);
    // verify the dimensions of the array, TODO: compute size while processing array
    array.validate(this._data, this._size);
    // data type unknown
    this._datatype = datatype;
  }
  else if (data) {
    // unsupported type
    throw new TypeError('Unsupported type of data (' + util.types.type(data) + ')');
  }
  else {
    // nothing provided
    this._data = [];
    this._size = [0];
    this._datatype = datatype;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return new type.Fraction(0);
  }
}, {
  from: 'Array',
  to: 'Matrix',
  convert: function (array) {
    // TODO: how to decide on the right type of matrix to create?
    return new type.<span class="apidocCodeKeywordSpan">DenseMatrix</span>(array);
  }
}, {
  from: 'Matrix',
  to: 'Array',
  convert: function (matrix) {
    return matrix.valueOf();
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.FibonacciHeap" id="apidoc.element.mathjs.type.FibonacciHeap">
        function <span class="apidocSignatureSpan">mathjs.type.</span>FibonacciHeap
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function FibonacciHeap() {
  if (!(this instanceof FibonacciHeap))
    throw new SyntaxError('Constructor must be called with the new operator');

  // initialize fields
  this._minimum = null;
  this._size = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
function Spa() {
  if (!(this instanceof Spa))
    throw new SyntaxError('Constructor must be called with the new operator');

  // allocate vector, TODO use typed arrays
  this._values = [];
  this._heap = new type.<span class="apidocCodeKeywordSpan">FibonacciHeap</span>();
}

/**
 * Attach type information
 */
Spa.prototype.type = 'Spa';
Spa.prototype.isSpa = true;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Fraction" id="apidoc.element.mathjs.type.Fraction">
        function <span class="apidocSignatureSpan">mathjs.type.</span>Fraction
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Fraction(a, b) {

  if (!(this instanceof Fraction)) {
    return new Fraction(a, b);
  }

  parse(a, b);

  if (Fraction['REDUCE']) {
    a = gcd(P["d"], P["n"]); // Abuse a
  } else {
    a = 1;
  }

  this["s"] = P["s"];
  this["n"] = P["n"] / a;
  this["d"] = P["d"] / a;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  to: 'Fraction',
  convert: function (x) {
    if (digits(x) &gt; 15) {
      throw new TypeError('Cannot implicitly convert a number with &gt;15 significant digits to Fraction ' +
          '(value: ' + x + '). ' +
          'Use function fraction(x) to convert to Fraction.');
    }
    return new type.<span class="apidocCodeKeywordSpan">Fraction</span>(x);
  }
}, {
// FIXME: add conversion from Fraction to number, for example for `sqrt(fraction(1,3))`
//  from: 'Fraction',
//  to: 'number',
//  convert: function (x) {
//    return x.valueOf();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Help" id="apidoc.element.mathjs.type.Help">
        function <span class="apidocSignatureSpan">mathjs.type.</span>Help
        <span class="apidocSignatureSpan">(doc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Help(doc) {
  if (!(this instanceof Help)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  if (!doc)  throw new Error('Argument "doc" missing');

  this.doc = doc;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.ImmutableDenseMatrix" id="apidoc.element.mathjs.type.ImmutableDenseMatrix">
        function <span class="apidocSignatureSpan">mathjs.type.</span>ImmutableDenseMatrix
        <span class="apidocSignatureSpan">(data, datatype)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ImmutableDenseMatrix(data, datatype) {
  if (!(this instanceof ImmutableDenseMatrix))
    throw new SyntaxError('Constructor must be called with the new operator');
  if (datatype &amp;&amp; !isString(datatype))
    throw new Error('Invalid datatype: ' + datatype);

  if ((data &amp;&amp; data.isMatrix === true) || isArray(data)) {
    // use DenseMatrix implementation
    var matrix = new DenseMatrix(data, datatype);
    // internal structures
    this._data = matrix._data;
    this._size = matrix._size;
    this._datatype = matrix._datatype;
    this._min = null;
    this._max = null;
  }
  else if (data &amp;&amp; isArray(data.data) &amp;&amp; isArray(data.size)) {
    // initialize fields from JSON representation
    this._data = data.data;
    this._size = data.size;
    this._datatype = data.datatype;
    this._min = typeof data.min !== 'undefined' ? data.min : null;
    this._max = typeof data.max !== 'undefined' ? data.max : null;
  }
  else if (data) {
    // unsupported type
    throw new TypeError('Unsupported type of data (' + util.types.type(data) + ')');
  }
  else {
    // nothing provided
    this._data = [];
    this._size = [0];
    this._datatype = datatype;
    this._min = null;
    this._max = null;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // loop array elements
  for (var i = 0, l = arg.length; i &lt; l; i++) {
    if (typeof arg[i] !== 'number' || !isInteger(arg[i])) {
      throw new TypeError('Index parameters must be positive integer numbers');
    }
  }
  // create matrix
  return new type.<span class="apidocCodeKeywordSpan">ImmutableDenseMatrix</span>(arg);
}

/**
 * Create a clone of the index
 * @memberof Index
 * @return {Index} clone
 */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Index" id="apidoc.element.mathjs.type.Index">
        function <span class="apidocSignatureSpan">mathjs.type.</span>Index
        <span class="apidocSignatureSpan">(ranges)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Index(ranges) {
  if (!(this instanceof Index)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  this._dimensions = [];
  this._isScalar = true;

  for (var i = 0, ii = arguments.length; i &lt; ii; i++) {
    var arg = arguments[i];

    if (arg &amp;&amp; (arg.isRange === true)) {
      this._dimensions.push(arg);
      this._isScalar = false;
    }
    else if (arg &amp;&amp; (Array.isArray(arg) || arg.isMatrix === true)) {
      // create matrix
      var m = _createImmutableMatrix(arg.valueOf());
      this._dimensions.push(m);
      // size
      var size = m.size();
      // scalar
      if (size.length !== 1 || size[0] !== 1) {
        this._isScalar = false;
      }
    }
    else if (typeof arg === 'number') {
      this._dimensions.push(_createImmutableMatrix([arg]));
    }
    else if (typeof arg === 'string') {
      // object property (arguments.count should be 1)
      this._dimensions.push(arg);
    }
    // TODO: implement support for wildcard '*'
    else {
      throw new TypeError('Dimension must be an Array, Matrix, number, string, or Range');
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      else {
        throw new TypeError('Dimension must be an Array, Matrix, number, string, or Range');
      }

      args[i] = arg;
    }

    var res = new type.<span class="apidocCodeKeywordSpan">Index</span>();
    type.Index.apply(res, args);
    return res;
  };
}

exports.name = 'index';
exports.path = 'expression.transform';
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Matrix" id="apidoc.element.mathjs.type.Matrix">
        function <span class="apidocSignatureSpan">mathjs.type.</span>Matrix
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Matrix() {
  if (!(this instanceof Matrix)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Range" id="apidoc.element.mathjs.type.Range">
        function <span class="apidocSignatureSpan">mathjs.type.</span>Range
        <span class="apidocSignatureSpan">(start, end, step)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Range(start, end, step) {
  if (!(this instanceof Range)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  if (start != null) {
    if (start.isBigNumber === true)
      start = start.toNumber();
    else if (typeof start !== 'number')
      throw new TypeError('Parameter start must be a number');
  }
  if (end != null) {
    if (end.isBigNumber === true)
      end = end.toNumber();
    else if (typeof end !== 'number')
      throw new TypeError('Parameter end must be a number');
  }
  if (step != null) {
    if (step.isBigNumber === true)
      step = step.toNumber();
    else if (typeof step !== 'number')
      throw new TypeError('Parameter step must be a number');
  }

  this.start = (start != null) ? parseFloat(start) : 0;
  this.end   = (end != null)   ? parseFloat(end)   : 0;
  this.step  = (step != null)  ? parseFloat(step)  : 1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.ResultSet" id="apidoc.element.mathjs.type.ResultSet">
        function <span class="apidocSignatureSpan">mathjs.type.</span>ResultSet
        <span class="apidocSignatureSpan">(entries)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ResultSet(entries) {
  if (!(this instanceof ResultSet)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  this.entries = entries || [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Spa" id="apidoc.element.mathjs.type.Spa">
        function <span class="apidocSignatureSpan">mathjs.type.</span>Spa
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Spa() {
  if (!(this instanceof Spa))
    throw new SyntaxError('Constructor must be called with the new operator');

  // allocate vector, TODO use typed arrays
  this._values = [];
  this._heap = new type.FibonacciHeap();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.SparseMatrix" id="apidoc.element.mathjs.type.SparseMatrix">
        function <span class="apidocSignatureSpan">mathjs.type.</span>SparseMatrix
        <span class="apidocSignatureSpan">(data, datatype)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SparseMatrix(data, datatype) {
  if (!(this instanceof SparseMatrix))
    throw new SyntaxError('Constructor must be called with the new operator');
  if (datatype &amp;&amp; !isString(datatype))
    throw new Error('Invalid datatype: ' + datatype);

  if (data &amp;&amp; data.isMatrix === true) {
    // create from matrix
    _createFromMatrix(this, data, datatype);
  }
  else if (data &amp;&amp; isArray(data.index) &amp;&amp; isArray(data.ptr) &amp;&amp; isArray(data.size)) {
    // initialize fields
    this._values = data.values;
    this._index = data.index;
    this._ptr = data.ptr;
    this._size = data.size;
    this._datatype = datatype || data.datatype;
  }
  else if (isArray(data)) {
    // create from array
    _createFromArray(this, data, datatype);
  }
  else if (data) {
    // unsupported type
    throw new TypeError('Unsupported type of data (' + util.types.type(data) + ')');
  }
  else {
    // nothing provided
    this._values = [];
    this._index = [];
    this._ptr = [0];
    this._size = [0, 0];
    this._datatype = datatype;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Unit" id="apidoc.element.mathjs.type.Unit">
        function <span class="apidocSignatureSpan">mathjs.type.</span>Unit
        <span class="apidocSignatureSpan">(value, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Unit(value, name) {
  if (!(this instanceof Unit)) {
    throw new Error('Constructor must be called with the new operator');
  }

  if (!(value === undefined || isNumeric(value) || value.isComplex)) {
    throw new TypeError('First parameter in Unit constructor must be number, BigNumber, Fraction, Complex, or undefined');
  }
  if (name != undefined &amp;&amp; (typeof name !== 'string' || name == '')) {
    throw new TypeError('Second parameter in Unit constructor must be a string');
  }

  if (name != undefined) {
    var u = Unit.parse(name);
    this.units = u.units;
    this.dimensions = u.dimensions;
  }
  else {
    this.units = [
      {
        unit: UNIT_NONE,
        prefix: PREFIXES.NONE,  // link to a list with supported prefixes
        power: 0
      }
    ];
    this.dimensions = [];
    for(var i=0; i&lt;BASE_DIMENSIONS.length; i++) {
      this.dimensions[i] = 0;
    }
  }

  this.value = (value != undefined) ? this._normalize(value) : null;

  this.fixPrefix = false; // if true, function format will not search for the
                          // best prefix but leave it as initially provided.
                          // fixPrefix is set true by the method Unit.to

  // The justification behind this is that if the constructor is explicitly called,
  // the caller wishes the units to be returned exactly as he supplied.
  this.isUnitListSimplified = true;

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.type.BigNumber" id="apidoc.module.mathjs.type.BigNumber">module mathjs.type.BigNumber</a></h1>




    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.BigNumber" id="apidoc.element.mathjs.type.BigNumber.BigNumber">
        function <span class="apidocSignatureSpan">mathjs.type.</span>BigNumber
        <span class="apidocSignatureSpan">(v)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Decimal(v) {
  var e, i, t,
    x = this;

  // Decimal called without new.
  if (!(x instanceof Decimal)) return new Decimal(v);

  // Retain a reference to this Decimal constructor, and shadow Decimal.prototype.constructor
  // which points to Object.
  x.constructor = Decimal;

  // Duplicate.
  if (v instanceof Decimal) {
    x.s = v.s;
    x.e = v.e;
    x.d = (v = v.d) ? v.slice() : v;
    return;
  }

  t = typeof v;

  if (t === 'number') {
    if (v === 0) {
      x.s = 1 / v &lt; 0 ? -1 : 1;
      x.e = 0;
      x.d = [0];
      return;
    }

    if (v &lt; 0) {
      v = -v;
      x.s = -1;
    } else {
      x.s = 1;
    }

    // Fast path for small integers.
    if (v === ~~v &amp;&amp; v &lt; 1e7) {
      for (e = 0, i = v; i &gt;= 10; i /= 10) e++;
      x.e = e;
      x.d = [v];
      return;

    // Infinity, NaN.
    } else if (v * 0 !== 0) {
      if (!v) x.s = NaN;
      x.e = NaN;
      x.d = null;
      return;
    }

    return parseDecimal(x, v.toString());

  } else if (t !== 'string') {
    throw Error(invalidArgument + v);
  }

  // Minus sign?
  if (v.charCodeAt(0) === 45) {
    v = v.slice(1);
    x.s = -1;
  } else {
    x.s = 1;
  }

  return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  setConstant(math, 'true', true);
  setConstant(math, 'false', false);
  setConstant(math, 'null', null);
  setConstant(math, 'uninitialized', require('./utils/array').UNINITIALIZED);

  if (config.number === 'BigNumber') {
setConstant(math, 'Infinity', new type.<span class="apidocCodeKeywordSpan">BigNumber</span>(Infinity));
setConstant(math, 'NaN', new type.BigNumber(NaN));

setLazyConstant(math, 'pi',  function () {return bigConstants.pi(type.BigNumber)});
setLazyConstant(math, 'tau', function () {return bigConstants.tau(type.BigNumber)});
setLazyConstant(math, 'e',   function () {return bigConstants.e(type.BigNumber)});
setLazyConstant(math, 'phi', function () {return bigConstants.phi(type.BigNumber)}); // golden ratio, (1+sqrt(5))/2
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.abs" id="apidoc.element.mathjs.type.BigNumber.abs">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>abs
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function abs(x) {
  return new this(x).abs();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function factory (type, config, load, typed) {
/**
 * Calculate the absolute value of a number. For matrices, the function is
 * evaluated element wise.
 *
 * Syntax:
 *
 *    math.<span class="apidocCodeKeywordSpan">abs</span>(x)
 *
 * Examples:
 *
 *    math.abs(3.5);                // returns number 3.5
 *    math.abs(-4.2);               // returns number 4.2
 *
 *    math.abs([3, -5, -1, 0, 2]);  // returns Array [3, 5, 1, 0, 2]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.acos" id="apidoc.element.mathjs.type.BigNumber.acos">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>acos
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function acos(x) {
  return new this(x).acos();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Calculate the inverse cosine of a value.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">acos</span>(x)
*
* Examples:
*
*    math.acos(0.5);           // returns number 1.0471975511965979
*    math.acos(math.cos(1.5)); // returns number 1.5
*
*    math.acos(2);             // returns Complex 0 + 1.3169578969248166 i
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.acosh" id="apidoc.element.mathjs.type.BigNumber.acosh">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>acosh
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function acosh(x) {
  return new this(x).acosh();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Calculate the hyperbolic arccos of a value,
* defined as `acosh(x) = ln(sqrt(x^2 - 1) + x)`.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">acosh</span>(x)
*
* Examples:
*
*    math.acosh(1.5);       // returns 0.9624236501192069
*
* See also:
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.add" id="apidoc.element.mathjs.type.BigNumber.add">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>add
        <span class="apidocSignatureSpan">(x, y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function add(x, y) {
  return new this(x).plus(y);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
math.eval('5.08 cm to inch');     // 2 inch
math.eval('sin(45 deg) ^ 2');     // 0.5
math.eval('9 / 3 + 2i');          // 3 + 2i
math.eval('det([-1, 2; 3, 1])');  // -7

// chaining
math.chain(3)
    .<span class="apidocCodeKeywordSpan">add</span>(4)
    .multiply(2)
    .done(); // 14
```

## Browser support

Math.js works on any ES5 compatible JavaScript engine: node.js 0.10, and Internet Explorer 9 and newer, and all other browsers (
Chrome, Firefox, Safari). If support for old browsers like Internet Explorer 8 is required, the [es5-shim](https://github.com/kriskowal
/es5-shim) library has to be loaded.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.asin" id="apidoc.element.mathjs.type.BigNumber.asin">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>asin
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function asin(x) {
  return new this(x).asin();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   *
   * @param {number | Complex | Array | Matrix} x   Function input
   * @return {number | Complex | Array | Matrix} The arc cosecant of x
   */
  var acsc = typed('acsc', {
'number': function (x) {
  if (x &lt;= -1 || x &gt;= 1 || config.predictable) {
    return Math.<span class="apidocCodeKeywordSpan">asin</span>(1 / x);
  }
  return new type.Complex(x, 0).acsc();
},

'Complex': function (x) {
  return x.acsc();
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.asinh" id="apidoc.element.mathjs.type.BigNumber.asinh">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>asinh
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function asinh(x) {
  return new this(x).asinh();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  },

  'Complex': function (x) {
    return x.acsch();
  },

  'BigNumber': function (x) {
    return new type.BigNumber(1).div(x).<span class="apidocCodeKeywordSpan">asinh</span>();
  },

  'Array | Matrix': function (x) {
    return deepMap(x, acsch);
  }
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.atan" id="apidoc.element.mathjs.type.BigNumber.atan">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>atan
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function atan(x) {
  return new this(x).atan();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   *    cot, atan
   *
   * @param {number | Complex | Array | Matrix} x   Function input
   * @return {number | Complex | Array | Matrix} The arc cotangent of x
   */
  var acot = typed('acot', {
'number': function (x) {
  return Math.<span class="apidocCodeKeywordSpan">atan</span>(1 / x);
},

'Complex': function (x) {
  return x.acot();
},

'BigNumber': function (x) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.atan2" id="apidoc.element.mathjs.type.BigNumber.atan2">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>atan2
        <span class="apidocSignatureSpan">(y, x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function atan2(y, x) {
  y = new this(y);
  x = new this(x);
  var r,
    pr = this.precision,
    rm = this.rounding,
    wpr = pr + 4;

  // Either NaN
  if (!y.s || !x.s) {
    r = new this(NaN);

  // Both Â±Infinity
  } else if (!y.d &amp;&amp; !x.d) {
    r = getPi(this, wpr, 1).times(x.s &gt; 0 ? 0.25 : 0.75);
    r.s = y.s;

  // x is Â±Infinity or y is Â±0
  } else if (!x.d || y.isZero()) {
    r = x.s &lt; 0 ? getPi(this, pr, rm) : new this(0);
    r.s = y.s;

  // y is Â±Infinity or x is Â±0
  } else if (!y.d || x.isZero()) {
    r = getPi(this, wpr, 1).times(0.5);
    r.s = y.s;

  // Both non-zero and finite
  } else if (x.s &lt; 0) {
    this.precision = wpr;
    this.rounding = 1;
    r = this.atan(divide(y, x, wpr, 1));
    x = getPi(this, wpr, 1);
    this.precision = pr;
    this.rounding = rm;
    r = y.s &lt; 0 ? r.minus(x) : r.plus(x);
  } else {
    r = this.atan(divide(y, x, wpr, 1));
  }

  return r;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```js
// load math.js
var math = require('mathjs');

// functions and constants
math.round(math.e, 3);            // 2.718
math.<span class="apidocCodeKeywordSpan">atan2</span>(3, -3) / math.pi;      // 0.75
math.log(1000, 10);               // 3
math.sqrt(-4);                    // 2i
math.pow([[-1, 2], [3, 1]], 2);   // [[7, 0], [0, 7]]
math.derivative('x^2 + x', 'x');  // 2 * x + 1

// expressions
math.eval('12 / (2.3 + 0.7)');    // 4
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.atanh" id="apidoc.element.mathjs.type.BigNumber.atanh">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>atanh
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function atanh(x) {
  return new this(x).atanh();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  },

  'Complex': function (x) {
    return x.acoth();
  },

  'BigNumber': function (x) {
    return new type.BigNumber(1).div(x).<span class="apidocCodeKeywordSpan">atanh</span>();
  },

  'Array | Matrix': function (x) {
    return deepMap(x, acoth);
  }
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.cbrt" id="apidoc.element.mathjs.type.BigNumber.cbrt">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>cbrt
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cbrt(x) {
  return new this(x).cbrt();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Calculate the cubic root of a value.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">cbrt</span>(x)
*    math.cbrt(x, allRoots)
*
* Examples:
*
*    math.cbrt(27);                  // returns 3
*    math.cube(3);                   // returns 27
*    math.cbrt(-64);                 // returns -4
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.ceil" id="apidoc.element.mathjs.type.BigNumber.ceil">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>ceil
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ceil(x) {
  return finalise(x = new this(x), x.e + 1, 2);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Round a value towards plus infinity
* If `x` is complex, both real and imaginary part are rounded towards plus infinity.
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">ceil</span>(x)
*
* Examples:
*
*    math.ceil(3.2);               // returns number 4
*    math.ceil(3.8);               // returns number 4
*    math.ceil(-4.2);              // returns number -4
*    math.ceil(-4.7);              // returns number -4
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.clone" id="apidoc.element.mathjs.type.BigNumber.clone">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>clone
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function clone(obj) {
  var i, p, ps;

  /*
   * The Decimal constructor and exported function.
   * Return a new Decimal instance.
   *
   * v {number|string|Decimal} A numeric value.
   *
   */
  function Decimal(v) {
    var e, i, t,
      x = this;

    // Decimal called without new.
    if (!(x instanceof Decimal)) return new Decimal(v);

    // Retain a reference to this Decimal constructor, and shadow Decimal.prototype.constructor
    // which points to Object.
    x.constructor = Decimal;

    // Duplicate.
    if (v instanceof Decimal) {
      x.s = v.s;
      x.e = v.e;
      x.d = (v = v.d) ? v.slice() : v;
      return;
    }

    t = typeof v;

    if (t === 'number') {
      if (v === 0) {
        x.s = 1 / v &lt; 0 ? -1 : 1;
        x.e = 0;
        x.d = [0];
        return;
      }

      if (v &lt; 0) {
        v = -v;
        x.s = -1;
      } else {
        x.s = 1;
      }

      // Fast path for small integers.
      if (v === ~~v &amp;&amp; v &lt; 1e7) {
        for (e = 0, i = v; i &gt;= 10; i /= 10) e++;
        x.e = e;
        x.d = [v];
        return;

      // Infinity, NaN.
      } else if (v * 0 !== 0) {
        if (!v) x.s = NaN;
        x.e = NaN;
        x.d = null;
        return;
      }

      return parseDecimal(x, v.toString());

    } else if (t !== 'string') {
      throw Error(invalidArgument + v);
    }

    // Minus sign?
    if (v.charCodeAt(0) === 45) {
      v = v.slice(1);
      x.s = -1;
    } else {
      x.s = 1;
    }

    return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);
  }

  Decimal.prototype = P;

  Decimal.ROUND_UP = 0;
  Decimal.ROUND_DOWN = 1;
  Decimal.ROUND_CEIL = 2;
  Decimal.ROUND_FLOOR = 3;
  Decimal.ROUND_HALF_UP = 4;
  Decimal.ROUND_HALF_DOWN = 5;
  Decimal.ROUND_HALF_EVEN = 6;
  Decimal.ROUND_HALF_CEIL = 7;
  Decimal.ROUND_HALF_FLOOR = 8;
  Decimal.EUCLID = 9;

  Decimal.config = Decimal.set = config;
  Decimal.clone = clone;

  Decimal.abs = abs;
  Decimal.acos = acos;
  Decimal.acosh = acosh;        // ES6
  Decimal.add = add;
  Decimal.asin = asin;
  Decimal.asinh = asinh;        // ES6
  Decimal.atan = atan;
  Decimal.atanh = atanh;        // ES6
  Decimal.atan2 = atan2;
  Decimal.cbrt = cbrt;          // ES6
  Decimal.ceil = ceil;
  Decimal.cos = cos;
  Decimal.cosh = cosh;          // ES6
  Decimal.div = div;
  Decimal.exp = exp;
  Decimal.floor = floor;
  Decimal.hypot = hypot;        // ES6
  Decimal.ln = ln;
  Decimal.log = log;
  Decimal.log10 = log10;        // ES6
  Decimal.log2 = log2;          // ES6
  Decimal.max = max;
  Decimal.min = min;
  Decimal.mod = mod;
  Decimal.mul = mul;
  Decimal.pow = pow;
  Decimal.random = random;
  Decimal.round = round;
  Decimal.sign = sign;          // ES6
  Decimal.sin = sin;
  Decimal.sinh = sinh;          // ES6
  Decimal.sqrt = sqrt;
  Decimal.sub = sub;
  Decimal.tan = tan;
  Decimal.tanh = tanh;          // ES6
  Decimal.trunc = trunc;        // ES6

  if (obj === void 0) obj = {};
  if (obj) {
    ps = ['precision', 'rounding', 'toExpNeg', 'toExpPos', 'maxE', 'minE', 'modulo', 'crypto'];
    for (i = 0; i &lt; ps.length;) if (!obj.hasOwnProperty(p = ps[i++])) obj[p] = this[p];
  }

  Decimal.config(obj);

  return Decimal;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return desc;
};

/**
 * Export the help object to JSON
 */
Help.prototype.toJSON = function () {
  var obj = object.<span class="apidocCodeKeywordSpan">clone</span>(this.doc);
  obj.mathjs = 'Help';
  return obj;
};

/**
 * Instantiate a Help object from a JSON object
 * @param {Object} json
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.config" id="apidoc.element.mathjs.type.BigNumber.config">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>config
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function config(obj) {
  if (!obj || typeof obj !== 'object') throw Error(decimalError + 'Object expected');
  var i, p, v,
    ps = [
      'precision', 1, MAX_DIGITS,
      'rounding', 0, 8,
      'toExpNeg', -EXP_LIMIT, 0,
      'toExpPos', 0, EXP_LIMIT,
      'maxE', 0, EXP_LIMIT,
      'minE', -EXP_LIMIT, 0,
      'modulo', 0, 9
    ];

  for (i = 0; i &lt; ps.length; i += 3) {
    if ((v = obj[p = ps[i]]) !== void 0) {
      if (mathfloor(v) === v &amp;&amp; v &gt;= ps[i + 1] &amp;&amp; v &lt;= ps[i + 2]) this[p] = v;
      else throw Error(invalidArgument + p + ': ' + v);
    }
  }

  if ((v = obj[p = 'crypto']) !== void 0) {
    if (v === true || v === false || v === 0 || v === 1) {
      if (v) {
        if (typeof crypto != 'undefined' &amp;&amp; crypto &amp;&amp;
          (crypto.getRandomValues || crypto.randomBytes)) {
          this[p] = true;
        } else {
          throw Error(cryptoUnavailable);
        }
      } else {
        this[p] = false;
      }
    } else {
      throw Error(invalidArgument + p + ': ' + v);
    }
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  /**
* Set configuration options for math.js, and get current options.
* Will emit a 'config' event, with arguments (curr, prev, changes).
*
* Syntax:
*
*     math.<span class="apidocCodeKeywordSpan">config</span>(config: Object): Object
*
* Examples:
*
*     math.config().number;                // outputs 'number'
*     math.eval('0.4');                    // outputs number 0.4
*     math.config({number: 'Fraction'});
*     math.eval('0.4');                    // outputs Fraction 2/5
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.cos" id="apidoc.element.mathjs.type.BigNumber.cos">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>cos
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cos(x) {
  return new this(x).cos();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      var u1, u2,
          picked = -1;
      // We reject values outside of the interval [0, 1]
      // TODO: check if it is ok to do that?
      while (picked &lt; 0 || picked &gt; 1) {
        u1 = rng();
        u2 = rng();
        picked = 1/6 * Math.pow(-2 * Math.log(u1), 0.5) * Math.<span class="apidocCodeKeywordSpan">cos</span>(2 * Math.PI * u2) +
0.5;
      }
      return picked;
    }
  }
};

distribution.toTex = undefined; // use default template
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.cosh" id="apidoc.element.mathjs.type.BigNumber.cosh">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>cosh
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cosh(x) {
  return new this(x).cosh();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Calculate the hyperbolic cosine of a value,
* defined as `cosh(x) = 1/2 * (exp(x) + exp(-x))`.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">cosh</span>(x)
*
* Examples:
*
*    math.cosh(0.5);       // returns number 1.1276259652063807
*
* See also:
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.div" id="apidoc.element.mathjs.type.BigNumber.div">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>div
        <span class="apidocSignatureSpan">(x, y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function div(x, y) {
  return new this(x).div(y);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  setLazyConstant(math, 'e',   function () {return bigConstants.e(type.BigNumber)});
  setLazyConstant(math, 'phi', function () {return bigConstants.phi(type.BigNumber)}); // golden ratio, (1+sqrt(5))/2

  // uppercase constants (for compatibility with built-in Math)
  setLazyConstant(math, 'E',       function () {return math.e;});
  setLazyConstant(math, 'LN2',     function () {return new type.BigNumber(2).ln();});
  setLazyConstant(math, 'LN10',    function () {return new type.BigNumber(10).ln()});
  setLazyConstant(math, 'LOG2E',   function () {return new type.BigNumber(1).<span class="apidocCodeKeywordSpan">div<!--
span-->(new type.BigNumber(2).ln());});
  setLazyConstant(math, 'LOG10E',  function () {return new type.BigNumber(1).div(new type.BigNumber(10).ln())});
  setLazyConstant(math, 'PI',      function () {return math.pi});
  setLazyConstant(math, 'SQRT1_2', function () {return new type.BigNumber('0.5').sqrt()});
  setLazyConstant(math, 'SQRT2',   function () {return new type.BigNumber(2).sqrt()});
}
else {
  setConstant(math, 'Infinity', Infinity);
...</span></pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.exp" id="apidoc.element.mathjs.type.BigNumber.exp">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>exp
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function exp(x) {
  return new this(x).exp();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// https://www.wikiwand.com/en/Cube_root#/Complex_numbers

var arg_3 = x.arg() / 3;
var abs = x.abs();

// principal root:
var principal = new type.Complex(_cbrtNumber(abs), 0).mul(
    new type.Complex(0, arg_3).<span class="apidocCodeKeywordSpan">exp</span>());

if (allRoots) {
  var all = [
      principal,
      new type.Complex(_cbrtNumber(abs), 0).mul(
        new type.Complex(0, arg_3 + Math.PI * 2 / 3).exp()),
      new type.Complex(_cbrtNumber(abs), 0).mul(
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.floor" id="apidoc.element.mathjs.type.BigNumber.floor">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>floor
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function floor(x) {
  return finalise(x = new this(x), x.e + 1, 3);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   *    ceil, floor, round
   *
   * @param {number | BigNumber | Fraction | Complex | Array | Matrix} x Number to be rounded
   * @return {number | BigNumber | Fraction | Complex | Array | Matrix}            Rounded value
   */
  var fix = typed('fix', {
'number': function (x) {
  return (x &gt; 0) ? Math.<span class="apidocCodeKeywordSpan">floor</span>(x) : Math.ceil(x);
},

'Complex': function (x) {
  return new type.Complex(
      (x.re &gt; 0) ? Math.floor(x.re) : Math.ceil(x.re),
      (x.im &gt; 0) ? Math.floor(x.im) : Math.ceil(x.im)
  );
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.fromJSON" id="apidoc.element.mathjs.type.BigNumber.fromJSON">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>fromJSON
        <span class="apidocSignatureSpan">(json)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromJSON = function (json) {
  return new BigNumber(json.value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * @param {string} key
   * @param {*} value
   * @returns {*} Returns the revived object
   */
  return function reviver(key, value) {
    var constructor = type[value &amp;&amp; value.mathjs];
    if (constructor &amp;&amp; typeof constructor.fromJSON === 'function') {
      return constructor.<span class="apidocCodeKeywordSpan">fromJSON</span>(value);
    }

    return value;
  }
}

exports.name = 'reviver';
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.hypot" id="apidoc.element.mathjs.type.BigNumber.hypot">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>hypot
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hypot() {
  var i, n,
    t = new this(0);

  external = false;

  for (i = 0; i &lt; arguments.length;) {
    n = new this(arguments[i++]);
    if (!n.d) {
      if (n.s) {
        external = true;
        return new this(1 / 0);
      }
      t = n;
    } else if (t.d) {
      t = t.plus(n.times(n));
    }
  }

  external = true;

  return t.sqrt();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
*     hypot(a, b, c, ...) = sqrt(a^2 + b^2 + c^2 + ...)
*
* For matrix input, the hypotenusa is calculated for all values in the matrix.
*
* Syntax:
*
*     math.<span class="apidocCodeKeywordSpan">hypot</span>(a, b, ...)
*     math.hypot([a, b, c, ...])
*
* Examples:
*
*     math.hypot(3, 4);      // 5
*     math.hypot(3, 4, 5);   // 7.0710678118654755
*     math.hypot([3, 4, 5]); // 7.0710678118654755
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.ln" id="apidoc.element.mathjs.type.BigNumber.ln">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>ln
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ln(x) {
  return new this(x).ln();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  setLazyConstant(math, 'pi',  function () {return bigConstants.pi(type.BigNumber)});
  setLazyConstant(math, 'tau', function () {return bigConstants.tau(type.BigNumber)});
  setLazyConstant(math, 'e',   function () {return bigConstants.e(type.BigNumber)});
  setLazyConstant(math, 'phi', function () {return bigConstants.phi(type.BigNumber)}); // golden ratio, (1+sqrt(5))/2

  // uppercase constants (for compatibility with built-in Math)
  setLazyConstant(math, 'E',       function () {return math.e;});
  setLazyConstant(math, 'LN2',     function () {return new type.BigNumber(2).<span class="apidocCodeKeywordSpan">ln</span>();});
  setLazyConstant(math, 'LN10',    function () {return new type.BigNumber(10).ln()});
  setLazyConstant(math, 'LOG2E',   function () {return new type.BigNumber(1).div(new type.BigNumber(2).ln());});
  setLazyConstant(math, 'LOG10E',  function () {return new type.BigNumber(1).div(new type.BigNumber(10).ln())});
  setLazyConstant(math, 'PI',      function () {return math.pi});
  setLazyConstant(math, 'SQRT1_2', function () {return new type.BigNumber('0.5').sqrt()});
  setLazyConstant(math, 'SQRT2',   function () {return new type.BigNumber(2).sqrt()});
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.log" id="apidoc.element.mathjs.type.BigNumber.log">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>log
        <span class="apidocSignatureSpan">(x, y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function log(x, y) {
  return new this(x).log(y);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
// load math.js
var math = require('mathjs');

// functions and constants
math.round(math.e, 3);            // 2.718
math.atan2(3, -3) / math.pi;      // 0.75
math.<span class="apidocCodeKeywordSpan">log</span>(1000, 10);               // 3
math.sqrt(-4);                    // 2i
math.pow([[-1, 2], [3, 1]], 2);   // [[7, 0], [0, 7]]
math.derivative('x^2 + x', 'x');  // 2 * x + 1

// expressions
math.eval('12 / (2.3 + 0.7)');    // 4
math.eval('5.08 cm to inch');     // 2 inch
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.log10" id="apidoc.element.mathjs.type.BigNumber.log10">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>log10
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function log10(x) {
  return new this(x).log(10);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Calculate the 10-base logarithm of a value. This is the same as calculating `log(x, 10)`.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">log10</span>(x)
*
* Examples:
*
*    math.log10(0.00001);            // returns -5
*    math.log10(10000);              // returns 4
*    math.log(10000) / math.log(10); // returns 4
*    math.pow(10, 4);                // returns 10000
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.log2" id="apidoc.element.mathjs.type.BigNumber.log2">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>log2
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function log2(x) {
  return new this(x).log(2);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.max" id="apidoc.element.mathjs.type.BigNumber.max">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>max
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function max() {
  return maxOrMin(this, arguments, 'lt');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @return {number} Returns the maximum number of expected arguments.
 *                  Returns -1 when no signatures where found on the function.
 */
exports.maxArgumentCount = function (fn) {
  return Object.keys(fn.signatures || {})
      .reduce(function (args, signature) {
        var count = (signature.match(/,/g) || []).length + 1;
        return Math.<span class="apidocCodeKeywordSpan">max</span>(args, count);
      }, -1);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.min" id="apidoc.element.mathjs.type.BigNumber.min">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>min
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function min() {
  return maxOrMin(this, arguments, 'gt');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @private
 */
function _resize (array, size, dim, defaultValue) {
var i;
var elem;
var oldLen = array.length;
var newLen = size[dim];
var minLen = Math.<span class="apidocCodeKeywordSpan">min</span>(oldLen, newLen);

// apply new length
array.length = newLen;

if (dim &lt; size.length - 1) {
  // non-last dimension
  var dimNext = dim + 1;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.mod" id="apidoc.element.mathjs.type.BigNumber.mod">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>mod
        <span class="apidocSignatureSpan">(x, y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mod(x, y) {
  return new this(x).mod(y);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (!a.isInt() || !b.isInt()) {
      throw new Error('Parameters in function gcd must be integer numbers');
    }

    // http://en.wikipedia.org/wiki/Euclidean_algorithm
    var zero = new type.BigNumber(0);
    while (!b.isZero()) {
      var r = a.<span class="apidocCodeKeywordSpan">mod</span>(b);
      a = b;
      b = r;
    }
    return a.lt(zero) ? a.neg() : a;
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.mul" id="apidoc.element.mathjs.type.BigNumber.mul">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>mul
        <span class="apidocSignatureSpan">(x, y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mul(x, y) {
  return new this(x).mul(y);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  function _cbrtComplex(x, allRoots) {
// https://www.wikiwand.com/en/Cube_root#/Complex_numbers

var arg_3 = x.arg() / 3;
var abs = x.abs();

// principal root:
var principal = new type.Complex(_cbrtNumber(abs), 0).<span class="apidocCodeKeywordSpan">mul</span>(
    new type.Complex(0, arg_3).exp());

if (allRoots) {
  var all = [
      principal,
      new type.Complex(_cbrtNumber(abs), 0).mul(
        new type.Complex(0, arg_3 + Math.PI * 2 / 3).exp()),
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.pow" id="apidoc.element.mathjs.type.BigNumber.pow">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>pow
        <span class="apidocSignatureSpan">(x, y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function pow(x, y) {
  return new this(x).pow(y);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var math = require('mathjs');

// functions and constants
math.round(math.e, 3);            // 2.718
math.atan2(3, -3) / math.pi;      // 0.75
math.log(1000, 10);               // 3
math.sqrt(-4);                    // 2i
math.<span class="apidocCodeKeywordSpan">pow</span>([[-1, 2], [3, 1]], 2);   // [[7, 0], [0, 7]]
math.derivative('x^2 + x', 'x');  // 2 * x + 1

// expressions
math.eval('12 / (2.3 + 0.7)');    // 4
math.eval('5.08 cm to inch');     // 2 inch
math.eval('sin(45 deg) ^ 2');     // 0.5
math.eval('9 / 3 + 2i');          // 3 + 2i
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.random" id="apidoc.element.mathjs.type.BigNumber.random">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>random
        <span class="apidocSignatureSpan">(sd)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function random(sd) {
  var d, e, k, n,
    i = 0,
    r = new this(1),
    rd = [];

  if (sd === void 0) sd = this.precision;
  else checkInt32(sd, 1, MAX_DIGITS);

  k = Math.ceil(sd / LOG_BASE);

  if (!this.crypto) {
    for (; i &lt; k;) rd[i++] = Math.random() * 1e7 | 0;

  // Browsers supporting crypto.getRandomValues.
  } else if (crypto.getRandomValues) {
    d = crypto.getRandomValues(new Uint32Array(k));

    for (; i &lt; k;) {
      n = d[i];

      // 0 &lt;= n &lt; 4294967296
      // Probability n &gt;= 4.29e9, is 4967296 / 4294967296 = 0.00116 (1 in 865).
      if (n &gt;= 4.29e9) {
        d[i] = crypto.getRandomValues(new Uint32Array(1))[0];
      } else {

        // 0 &lt;= n &lt;= 4289999999
        // 0 &lt;= (n % 1e7) &lt;= 9999999
        rd[i++] = n % 1e7;
      }
    }

  // Node.js supporting crypto.randomBytes.
  } else if (crypto.randomBytes) {

    // buffer
    d = crypto.randomBytes(k *= 4);

    for (; i &lt; k;) {

      // 0 &lt;= n &lt; 2147483648
      n = d[i] + (d[i + 1] &lt;&lt; 8) + (d[i + 2] &lt;&lt; 16) + ((d[i + 3] &amp; 0x7f) &lt;&lt; 24);

      // Probability n &gt;= 2.14e9, is 7483648 / 2147483648 = 0.0035 (1 in 286).
      if (n &gt;= 2.14e9) {
        crypto.randomBytes(4).copy(d, i);
      } else {

        // 0 &lt;= n &lt;= 2139999999
        // 0 &lt;= (n % 1e7) &lt;= 9999999
        rd.push(n % 1e7);
        i += 4;
      }
    }

    i = k / 4;
  } else {
    throw Error(cryptoUnavailable);
  }

  k = rd[--i];
  sd %= LOG_BASE;

  // Convert trailing digits to zeros according to sd.
  if (k &amp;&amp; sd) {
    n = mathpow(10, LOG_BASE - sd);
    rd[i] = (k / n | 0) * n;
  }

  // Remove trailing words which are zero.
  for (; rd[i] === 0; i--) rd.pop();

  // Zero?
  if (i &lt; 0) {
    e = 0;
    rd = [0];
  } else {
    e = -1;

    // Remove leading words which are zero and adjust exponent accordingly.
    for (; rd[0] === 0; e -= LOG_BASE) rd.shift();

    // Count the digits of the first word of rd to determine leading zeros.
    for (k = 1, n = rd[0]; n &gt;= 10; n /= 10) k++;

    // Adjust the exponent for leading zeros of the first word of rd.
    if (k &lt; LOG_BASE) e -= LOG_BASE - k;
  }

  r.e = e;
  r.d = rd;

  return r;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var from = 0;
    var to = arr.length - 1;

    // if from == to we reached the kth element
    while (from &lt; to) {
var r = from;
var w = to;
var pivot = arr[Math.floor(Math.<span class="apidocCodeKeywordSpan">random</span>() * (to - from + 1)) + from];

// stop if the reader and writer meets
while (r &lt; w) {
  // arr[r] &gt;= pivot
  if (compare(arr[r], pivot) &gt;= 0) { // put the large values at the end
    var tmp = arr[w];
    arr[w] = arr[r];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.round" id="apidoc.element.mathjs.type.BigNumber.round">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>round
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function round(x) {
  return finalise(x = new this(x), x.e + 1, this.rounding);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
[chained operations](http://mathjs.org/docs/chained_operations.html).

```js
// load math.js
var math = require('mathjs');

// functions and constants
math.<span class="apidocCodeKeywordSpan">round</span>(math.e, 3);            // 2.718
math.atan2(3, -3) / math.pi;      // 0.75
math.log(1000, 10);               // 3
math.sqrt(-4);                    // 2i
math.pow([[-1, 2], [3, 1]], 2);   // [[7, 0], [0, 7]]
math.derivative('x^2 + x', 'x');  // 2 * x + 1

// expressions
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.set" id="apidoc.element.mathjs.type.BigNumber.set">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>set
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function config(obj) {
  if (!obj || typeof obj !== 'object') throw Error(decimalError + 'Object expected');
  var i, p, v,
    ps = [
      'precision', 1, MAX_DIGITS,
      'rounding', 0, 8,
      'toExpNeg', -EXP_LIMIT, 0,
      'toExpPos', 0, EXP_LIMIT,
      'maxE', 0, EXP_LIMIT,
      'minE', -EXP_LIMIT, 0,
      'modulo', 0, 9
    ];

  for (i = 0; i &lt; ps.length; i += 3) {
    if ((v = obj[p = ps[i]]) !== void 0) {
      if (mathfloor(v) === v &amp;&amp; v &gt;= ps[i + 1] &amp;&amp; v &lt;= ps[i + 2]) this[p] = v;
      else throw Error(invalidArgument + p + ': ' + v);
    }
  }

  if ((v = obj[p = 'crypto']) !== void 0) {
    if (v === true || v === false || v === 0 || v === 1) {
      if (v) {
        if (typeof crypto != 'undefined' &amp;&amp; crypto &amp;&amp;
          (crypto.getRandomValues || crypto.randomBytes)) {
          this[p] = true;
        } else {
          throw Error(cryptoUnavailable);
        }
      } else {
        this[p] = false;
      }
    } else {
      throw Error(invalidArgument + p + ': ' + v);
    }
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* keeps a scope containing variables in memory, which is used for all
* evaluations.
*
* Methods:
*    var result = parser.eval(expr);    // evaluate an expression
*    var value = parser.get(name);      // retrieve a variable from the parser
*    var values = parser.getAll();      // retrieve all defined variables
*    parser.<span class="apidocCodeKeywordSpan">set</span>(name, value);           // set a variable in the parser
*    parser.remove(name);               // clear a variable from the
*                                       // parsers scope
*    parser.clear();                    // clear the parsers scope
*
* Example usage:
*    var parser = new Parser();
*    // Note: there is a convenience method which can be used instead:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.sign" id="apidoc.element.mathjs.type.BigNumber.sign">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>sign
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sign(x) {
  x = new this(x);
  return x.d ? (x.d[0] ? x.s : 0 * x.s) : x.s || NaN;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* - -1 when x &lt; 0
* -  0 when x == 0
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">sign</span>(x)
*
* Examples:
*
*    math.sign(3.5);               // returns 1
*    math.sign(-4.2);              // returns -1
*    math.sign(0);                 // returns 0
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.sin" id="apidoc.element.mathjs.type.BigNumber.sin">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>sin
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sin(x) {
  return new this(x).sin();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    res = 1;                          // 0! is per definition 1
  }

  return res;
}

if (n &lt; 0.5) {
  return Math.PI / (Math.<span class="apidocCodeKeywordSpan">sin</span>(Math.PI * n) * gamma(1-n));
}

if (n &gt;= 171.35) {
  return Infinity;                    // will overflow
}

if (n &gt; 85.0) {                       // Extended Stirling Approx
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.sinh" id="apidoc.element.mathjs.type.BigNumber.sinh">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>sinh
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sinh(x) {
  return new this(x).sinh();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
*    math.csch(x)
*
* Examples:
*
*    // csch(x) = 1/ sinh(x)
*    math.csch(0.5);       // returns 1.9190347513349437
*    1 / math.<span class="apidocCodeKeywordSpan">sinh</span>(0.5);   // returns 1.9190347513349437
*
* See also:
*
*    sinh, sech, coth
*
* @param {number | Complex | Unit | Array | Matrix} x  Function input
* @return {number | Complex | Array | Matrix} Hyperbolic cosecant of x
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.sqrt" id="apidoc.element.mathjs.type.BigNumber.sqrt">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>sqrt
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sqrt(x) {
  return new this(x).sqrt();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// load math.js
var math = require('mathjs');

// functions and constants
math.round(math.e, 3);            // 2.718
math.atan2(3, -3) / math.pi;      // 0.75
math.log(1000, 10);               // 3
math.<span class="apidocCodeKeywordSpan">sqrt</span>(-4);                    // 2i
math.pow([[-1, 2], [3, 1]], 2);   // [[7, 0], [0, 7]]
math.derivative('x^2 + x', 'x');  // 2 * x + 1

// expressions
math.eval('12 / (2.3 + 0.7)');    // 4
math.eval('5.08 cm to inch');     // 2 inch
math.eval('sin(45 deg) ^ 2');     // 0.5
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.sub" id="apidoc.element.mathjs.type.BigNumber.sub">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>sub
        <span class="apidocSignatureSpan">(x, y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sub(x, y) {
  return new this(x).sub(y);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var subtract = typed('subtract', {

'number, number': function (x, y) {
  return x - y;
},

'Complex, Complex': function (x, y) {
  return x.<span class="apidocCodeKeywordSpan">sub</span>(y);
},

'BigNumber, BigNumber': function (x, y) {
  return x.minus(y);
},

'Fraction, Fraction': function (x, y) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.tan" id="apidoc.element.mathjs.type.BigNumber.tan">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>tan
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function tan(x) {
  return new this(x).tan();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Syntax:
*
*    math.atan(x)
*
* Examples:
*
*    math.atan(0.5);           // returns number 0.4636476090008061
*    math.atan(math.<span class="apidocCodeKeywordSpan">tan</span>(1.5)); // returns number 1.5
*
*    math.atan(2);             // returns Complex 1.5707963267948966 -1.3169578969248166 i
*
* See also:
*
*    tan, asin, acos
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.tanh" id="apidoc.element.mathjs.type.BigNumber.tanh">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>tanh
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function tanh(x) {
  return new this(x).tanh();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
*    math.coth(x)
*
* Examples:
*
*    // coth(x) = 1 / tanh(x)
*    math.coth(2);         // returns 1.0373147207275482
*    1 / math.<span class="apidocCodeKeywordSpan">tanh</span>(2);     // returns 1.0373147207275482
*
* See also:
*
*    sinh, tanh, cosh
*
* @param {number | Complex | Unit | Array | Matrix} x  Function input
* @return {number | Complex | Array | Matrix} Hyperbolic cotangent of x
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.trunc" id="apidoc.element.mathjs.type.BigNumber.trunc">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.</span>trunc
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function trunc(x) {
  return finalise(x = new this(x), x.e + 1, 1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.type.BigNumber.prototype" id="apidoc.module.mathjs.type.BigNumber.prototype">module mathjs.type.BigNumber.prototype</a></h1>




    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.abs" id="apidoc.element.mathjs.type.BigNumber.prototype.abs">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>abs
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">abs = function () {
  var x = new this.constructor(this);
  if (x.s &lt; 0) x.s = 1;
  return finalise(x);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function factory (type, config, load, typed) {
/**
 * Calculate the absolute value of a number. For matrices, the function is
 * evaluated element wise.
 *
 * Syntax:
 *
 *    math.<span class="apidocCodeKeywordSpan">abs</span>(x)
 *
 * Examples:
 *
 *    math.abs(3.5);                // returns number 3.5
 *    math.abs(-4.2);               // returns number 4.2
 *
 *    math.abs([3, -5, -1, 0, 2]);  // returns Array [3, 5, 1, 0, 2]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.absoluteValue" id="apidoc.element.mathjs.type.BigNumber.prototype.absoluteValue">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>absoluteValue
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">absoluteValue = function () {
  var x = new this.constructor(this);
  if (x.s &lt; 0) x.s = 1;
  return finalise(x);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.acos" id="apidoc.element.mathjs.type.BigNumber.prototype.acos">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>acos
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">acos = function () {
  var halfPi,
    x = this,
    Ctor = x.constructor,
    k = x.abs().cmp(1),
    pr = Ctor.precision,
    rm = Ctor.rounding;

  if (k !== -1) {
    return k === 0
      // |x| is 1
      ? x.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0)
      // |x| &gt; 1 or x is NaN
      : new Ctor(NaN);
  }

  if (x.isZero()) return getPi(Ctor, pr + 4, rm).times(0.5);

  // TODO? Special case acos(0.5) = pi/3 and acos(-0.5) = 2*pi/3

  Ctor.precision = pr + 6;
  Ctor.rounding = 1;

  x = x.asin();
  halfPi = getPi(Ctor, pr + 4, rm).times(0.5);

  Ctor.precision = pr;
  Ctor.rounding = rm;

  return halfPi.minus(x);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Calculate the inverse cosine of a value.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">acos</span>(x)
*
* Examples:
*
*    math.acos(0.5);           // returns number 1.0471975511965979
*    math.acos(math.cos(1.5)); // returns number 1.5
*
*    math.acos(2);             // returns Complex 0 + 1.3169578969248166 i
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.acosh" id="apidoc.element.mathjs.type.BigNumber.prototype.acosh">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>acosh
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">acosh = function () {
  var pr, rm,
    x = this,
    Ctor = x.constructor;

  if (x.lte(1)) return new Ctor(x.eq(1) ? 0 : NaN);
  if (!x.isFinite()) return new Ctor(x);

  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;
  Ctor.rounding = 1;
  external = false;

  x = x.times(x).minus(1).sqrt().plus(x);

  external = true;
  Ctor.precision = pr;
  Ctor.rounding = rm;

  return x.ln();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Calculate the hyperbolic arccos of a value,
* defined as `acosh(x) = ln(sqrt(x^2 - 1) + x)`.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">acosh</span>(x)
*
* Examples:
*
*    math.acosh(1.5);       // returns 0.9624236501192069
*
* See also:
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.add" id="apidoc.element.mathjs.type.BigNumber.prototype.add">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>add
        <span class="apidocSignatureSpan">(y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">add = function (y) {
  var carry, d, e, i, k, len, pr, rm, xd, yd,
    x = this,
    Ctor = x.constructor;

  y = new Ctor(y);

  // If either is not finite...
  if (!x.d || !y.d) {

    // Return NaN if either is NaN.
    if (!x.s || !y.s) y = new Ctor(NaN);

    // Return x if y is finite and x is Â±Infinity.
    // Return x if both are Â±Infinity with the same sign.
    // Return NaN if both are Â±Infinity with different signs.
    // Return y if x is finite and y is Â±Infinity.
    else if (!x.d) y = new Ctor(y.d || x.s === y.s ? x : NaN);

    return y;
  }

   // If signs differ...
  if (x.s != y.s) {
    y.s = -y.s;
    return x.minus(y);
  }

  xd = x.d;
  yd = y.d;
  pr = Ctor.precision;
  rm = Ctor.rounding;

  // If either is zero...
  if (!xd[0] || !yd[0]) {

    // Return x if y is zero.
    // Return y if y is non-zero.
    if (!yd[0]) y = new Ctor(x);

    return external ? finalise(y, pr, rm) : y;
  }

  // x and y are finite, non-zero numbers with the same sign.

  // Calculate base 1e7 exponents.
  k = mathfloor(x.e / LOG_BASE);
  e = mathfloor(y.e / LOG_BASE);

  xd = xd.slice();
  i = k - e;

  // If base 1e7 exponents differ...
  if (i) {

    if (i &lt; 0) {
      d = xd;
      i = -i;
      len = yd.length;
    } else {
      d = yd;
      e = k;
      len = xd.length;
    }

    // Limit number of zeros prepended to max(ceil(pr / LOG_BASE), len) + 1.
    k = Math.ceil(pr / LOG_BASE);
    len = k &gt; len ? k + 1 : len + 1;

    if (i &gt; len) {
      i = len;
      d.length = 1;
    }

    // Prepend zeros to equalise exponents. Note: Faster to use reverse then do unshifts.
    d.reverse();
    for (; i--;) d.push(0);
    d.reverse();
  }

  len = xd.length;
  i = yd.length;

  // If yd is longer than xd, swap xd and yd so xd points to the longer array.
  if (len - i &lt; 0) {
    i = len;
    d = yd;
    yd = xd;
    xd = d;
  }

  // Only start adding at yd.length - 1 as the further digits of xd can be left as they are.
  for (carry = 0; i;) {
    carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;
    xd[i] %= BASE;
  }

  if (carry) {
    xd.unshift(carry);
    ++e;
  }

  // Remove trailing zeros.
  // No need to check for zero, as +x + +y != 0 &amp;&amp; -x + -y != 0
  for (len = xd.length; xd[--len] == 0;) xd.pop();

  y.d = xd;
  y.e = getBase10Exponent(xd, e);

  return external ? finalise(y, pr, rm) : y;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
math.eval('5.08 cm to inch');     // 2 inch
math.eval('sin(45 deg) ^ 2');     // 0.5
math.eval('9 / 3 + 2i');          // 3 + 2i
math.eval('det([-1, 2; 3, 1])');  // -7

// chaining
math.chain(3)
    .<span class="apidocCodeKeywordSpan">add</span>(4)
    .multiply(2)
    .done(); // 14
```

## Browser support

Math.js works on any ES5 compatible JavaScript engine: node.js 0.10, and Internet Explorer 9 and newer, and all other browsers (
Chrome, Firefox, Safari). If support for old browsers like Internet Explorer 8 is required, the [es5-shim](https://github.com/kriskowal
/es5-shim) library has to be loaded.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.asin" id="apidoc.element.mathjs.type.BigNumber.prototype.asin">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>asin
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">asin = function () {
  var halfPi, k,
    pr, rm,
    x = this,
    Ctor = x.constructor;

  if (x.isZero()) return new Ctor(x);

  k = x.abs().cmp(1);
  pr = Ctor.precision;
  rm = Ctor.rounding;

  if (k !== -1) {

    // |x| is 1
    if (k === 0) {
      halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
      halfPi.s = x.s;
      return halfPi;
    }

    // |x| &gt; 1 or x is NaN
    return new Ctor(NaN);
  }

  // TODO? Special case asin(1/2) = pi/6 and asin(-1/2) = -pi/6

  Ctor.precision = pr + 6;
  Ctor.rounding = 1;

  x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();

  Ctor.precision = pr;
  Ctor.rounding = rm;

  return x.times(2);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   *
   * @param {number | Complex | Array | Matrix} x   Function input
   * @return {number | Complex | Array | Matrix} The arc cosecant of x
   */
  var acsc = typed('acsc', {
'number': function (x) {
  if (x &lt;= -1 || x &gt;= 1 || config.predictable) {
    return Math.<span class="apidocCodeKeywordSpan">asin</span>(1 / x);
  }
  return new type.Complex(x, 0).acsc();
},

'Complex': function (x) {
  return x.acsc();
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.asinh" id="apidoc.element.mathjs.type.BigNumber.prototype.asinh">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>asinh
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">asinh = function () {
  var pr, rm,
    x = this,
    Ctor = x.constructor;

  if (!x.isFinite() || x.isZero()) return new Ctor(x);

  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;
  Ctor.rounding = 1;
  external = false;

  x = x.times(x).plus(1).sqrt().plus(x);

  external = true;
  Ctor.precision = pr;
  Ctor.rounding = rm;

  return x.ln();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  },

  'Complex': function (x) {
    return x.acsch();
  },

  'BigNumber': function (x) {
    return new type.BigNumber(1).div(x).<span class="apidocCodeKeywordSpan">asinh</span>();
  },

  'Array | Matrix': function (x) {
    return deepMap(x, acsch);
  }
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.atan" id="apidoc.element.mathjs.type.BigNumber.prototype.atan">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>atan
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">atan = function () {
  var i, j, k, n, px, t, r, wpr, x2,
    x = this,
    Ctor = x.constructor,
    pr = Ctor.precision,
    rm = Ctor.rounding;

  if (!x.isFinite()) {
    if (!x.s) return new Ctor(NaN);
    if (pr + 4 &lt;= PI_PRECISION) {
      r = getPi(Ctor, pr + 4, rm).times(0.5);
      r.s = x.s;
      return r;
    }
  } else if (x.isZero()) {
    return new Ctor(x);
  } else if (x.abs().eq(1) &amp;&amp; pr + 4 &lt;= PI_PRECISION) {
    r = getPi(Ctor, pr + 4, rm).times(0.25);
    r.s = x.s;
    return r;
  }

  Ctor.precision = wpr = pr + 10;
  Ctor.rounding = 1;

  // TODO? if (x &gt;= 1 &amp;&amp; pr &lt;= PI_PRECISION) atan(x) = halfPi * x.s - atan(1 / x);

  // Argument reduction
  // Ensure |x| &lt; 0.42
  // atan(x) = 2 * atan(x / (1 + sqrt(1 + x^2)))

  k = Math.min(28, wpr / LOG_BASE + 2 | 0);

  for (i = k; i; --i) x = x.div(x.times(x).plus(1).sqrt().plus(1));

  external = false;

  j = Math.ceil(wpr / LOG_BASE);
  n = 1;
  x2 = x.times(x);
  r = new Ctor(x);
  px = x;

  // atan(x) = x - x^3/3 + x^5/5 - x^7/7 + ...
  for (; i !== -1;) {
    px = px.times(x2);
    t = r.minus(px.div(n += 2));

    px = px.times(x2);
    r = t.plus(px.div(n += 2));

    if (r.d[j] !== void 0) for (i = j; r.d[i] === t.d[i] &amp;&amp; i--;);
  }

  if (k) r = r.times(2 &lt;&lt; (k - 1));

  external = true;

  return finalise(r, Ctor.precision = pr, Ctor.rounding = rm, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   *    cot, atan
   *
   * @param {number | Complex | Array | Matrix} x   Function input
   * @return {number | Complex | Array | Matrix} The arc cotangent of x
   */
  var acot = typed('acot', {
'number': function (x) {
  return Math.<span class="apidocCodeKeywordSpan">atan</span>(1 / x);
},

'Complex': function (x) {
  return x.acot();
},

'BigNumber': function (x) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.atanh" id="apidoc.element.mathjs.type.BigNumber.prototype.atanh">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>atanh
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">atanh = function () {
  var pr, rm, wpr, xsd,
    x = this,
    Ctor = x.constructor;

  if (!x.isFinite()) return new Ctor(NaN);
  if (x.e &gt;= 0) return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN);

  pr = Ctor.precision;
  rm = Ctor.rounding;
  xsd = x.sd();

  if (Math.max(xsd, pr) &lt; 2 * -x.e - 1) return finalise(new Ctor(x), pr, rm, true);

  Ctor.precision = wpr = xsd - x.e;

  x = divide(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);

  Ctor.precision = pr + 4;
  Ctor.rounding = 1;

  x = x.ln();

  Ctor.precision = pr;
  Ctor.rounding = rm;

  return x.times(0.5);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  },

  'Complex': function (x) {
    return x.acoth();
  },

  'BigNumber': function (x) {
    return new type.BigNumber(1).div(x).<span class="apidocCodeKeywordSpan">atanh</span>();
  },

  'Array | Matrix': function (x) {
    return deepMap(x, acoth);
  }
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.cbrt" id="apidoc.element.mathjs.type.BigNumber.prototype.cbrt">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>cbrt
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cbrt = function () {
  var e, m, n, r, rep, s, sd, t, t3, t3plusx,
    x = this,
    Ctor = x.constructor;

  if (!x.isFinite() || x.isZero()) return new Ctor(x);
  external = false;

  // Initial estimate.
  s = x.s * Math.pow(x.s * x, 1 / 3);

   // Math.cbrt underflow/overflow?
   // Pass x to Math.pow as integer, then adjust the exponent of the result.
  if (!s || Math.abs(s) == 1 / 0) {
    n = digitsToString(x.d);
    e = x.e;

    // Adjust n exponent so it is a multiple of 3 away from x exponent.
    if (s = (e - n.length + 1) % 3) n += (s == 1 || s == -2 ? '0' : '00');
    s = Math.pow(n, 1 / 3);

    // Rarely, e may be one less than the result exponent value.
    e = mathfloor((e + 1) / 3) - (e % 3 == (e &lt; 0 ? -1 : 2));

    if (s == 1 / 0) {
      n = '5e' + e;
    } else {
      n = s.toExponential();
      n = n.slice(0, n.indexOf('e') + 1) + e;
    }

    r = new Ctor(n);
    r.s = x.s;
  } else {
    r = new Ctor(s.toString());
  }

  sd = (e = Ctor.precision) + 3;

  // Halley's method.
  // TODO? Compare Newton's method.
  for (;;) {
    t = r;
    t3 = t.times(t).times(t);
    t3plusx = t3.plus(x);
    r = divide(t3plusx.plus(x).times(t), t3plusx.plus(t3), sd + 2, 1);

    // TODO? Replace with for-loop and checkRoundingDigits.
    if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
      n = n.slice(sd - 3, sd + 1);

      // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or 4999
      // , i.e. approaching a rounding boundary, continue the iteration.
      if (n == '9999' || !rep &amp;&amp; n == '4999') {

        // On the first iteration only, check to see if rounding up gives the exact result as the
        // nines may infinitely repeat.
        if (!rep) {
          finalise(t, e + 1, 0);

          if (t.times(t).times(t).eq(x)) {
            r = t;
            break;
          }
        }

        sd += 4;
        rep = 1;
      } else {

        // If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.
        // If not, then there are further digits and m will be truthy.
        if (!+n || !+n.slice(1) &amp;&amp; n.charAt(0) == '5') {

          // Truncate to the first rounding digit.
          finalise(r, e + 1, 1);
          m = !r.times(r).times(r).eq(x);
        }

        break;
      }
    }
  }

  external = true;

  return finalise(r, e, Ctor.rounding, m);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Calculate the cubic root of a value.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">cbrt</span>(x)
*    math.cbrt(x, allRoots)
*
* Examples:
*
*    math.cbrt(27);                  // returns 3
*    math.cube(3);                   // returns 27
*    math.cbrt(-64);                 // returns -4
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.ceil" id="apidoc.element.mathjs.type.BigNumber.prototype.ceil">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>ceil
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ceil = function () {
  return finalise(new this.constructor(this), this.e + 1, 2);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Round a value towards plus infinity
* If `x` is complex, both real and imaginary part are rounded towards plus infinity.
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">ceil</span>(x)
*
* Examples:
*
*    math.ceil(3.2);               // returns number 4
*    math.ceil(3.8);               // returns number 4
*    math.ceil(-4.2);              // returns number -4
*    math.ceil(-4.7);              // returns number -4
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.cmp" id="apidoc.element.mathjs.type.BigNumber.prototype.cmp">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>cmp
        <span class="apidocSignatureSpan">(y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cmp = function (y) {
  var i, j, xdL, ydL,
    x = this,
    xd = x.d,
    yd = (y = new x.constructor(y)).d,
    xs = x.s,
    ys = y.s;

  // Either NaN or Â±Infinity?
  if (!xd || !yd) {
    return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs &lt; 0 ? 1 : -1;
  }

  // Either zero?
  if (!xd[0] || !yd[0]) return xd[0] ? xs : yd[0] ? -ys : 0;

  // Signs differ?
  if (xs !== ys) return xs;

  // Compare exponents.
  if (x.e !== y.e) return x.e &gt; y.e ^ xs &lt; 0 ? 1 : -1;

  xdL = xd.length;
  ydL = yd.length;

  // Compare digit by digit.
  for (i = 0, j = xdL &lt; ydL ? xdL : ydL; i &lt; j; ++i) {
    if (xd[i] !== yd[i]) return xd[i] &gt; yd[i] ^ xs &lt; 0 ? 1 : -1;
  }

  // Compare lengths.
  return xdL === ydL ? 0 : xdL &gt; ydL ^ xs &lt; 0 ? 1 : -1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
'number': number.sign,

'Complex': function (x) {
  return x.sign();
},

'BigNumber': function (x) {
  return new type.BigNumber(x.<span class="apidocCodeKeywordSpan">cmp</span>(0));
},

'Fraction': function (x) {
  return new type.Fraction(x.s, 1);
},

'Array | Matrix': function (x) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.comparedTo" id="apidoc.element.mathjs.type.BigNumber.prototype.comparedTo">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>comparedTo
        <span class="apidocSignatureSpan">(y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">comparedTo = function (y) {
  var i, j, xdL, ydL,
    x = this,
    xd = x.d,
    yd = (y = new x.constructor(y)).d,
    xs = x.s,
    ys = y.s;

  // Either NaN or Â±Infinity?
  if (!xd || !yd) {
    return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs &lt; 0 ? 1 : -1;
  }

  // Either zero?
  if (!xd[0] || !yd[0]) return xd[0] ? xs : yd[0] ? -ys : 0;

  // Signs differ?
  if (xs !== ys) return xs;

  // Compare exponents.
  if (x.e !== y.e) return x.e &gt; y.e ^ xs &lt; 0 ? 1 : -1;

  xdL = xd.length;
  ydL = yd.length;

  // Compare digit by digit.
  for (i = 0, j = xdL &lt; ydL ? xdL : ydL; i &lt; j; ++i) {
    if (xd[i] !== yd[i]) return xd[i] &gt; yd[i] ^ xs &lt; 0 ? 1 : -1;
  }

  // Compare lengths.
  return xdL === ydL ? 0 : xdL &gt; ydL ^ xs &lt; 0 ? 1 : -1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.cos" id="apidoc.element.mathjs.type.BigNumber.prototype.cos">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>cos
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cos = function () {
  var pr, rm,
    x = this,
    Ctor = x.constructor;

  if (!x.d) return new Ctor(NaN);

  // cos(0) = cos(-0) = 1
  if (!x.d[0]) return new Ctor(1);

  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
  Ctor.rounding = 1;

  x = cosine(Ctor, toLessThanHalfPi(Ctor, x));

  Ctor.precision = pr;
  Ctor.rounding = rm;

  return finalise(quadrant == 2 || quadrant == 3 ? x.neg() : x, pr, rm, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      var u1, u2,
          picked = -1;
      // We reject values outside of the interval [0, 1]
      // TODO: check if it is ok to do that?
      while (picked &lt; 0 || picked &gt; 1) {
        u1 = rng();
        u2 = rng();
        picked = 1/6 * Math.pow(-2 * Math.log(u1), 0.5) * Math.<span class="apidocCodeKeywordSpan">cos</span>(2 * Math.PI * u2) +
0.5;
      }
      return picked;
    }
  }
};

distribution.toTex = undefined; // use default template
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.cosh" id="apidoc.element.mathjs.type.BigNumber.prototype.cosh">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>cosh
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cosh = function () {
  var k, n, pr, rm, len,
    x = this,
    Ctor = x.constructor,
    one = new Ctor(1);

  if (!x.isFinite()) return new Ctor(x.s ? 1 / 0 : NaN);
  if (x.isZero()) return one;

  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
  Ctor.rounding = 1;
  len = x.d.length;

  // Argument reduction: cos(4x) = 1 - 8cos^2(x) + 8cos^4(x) + 1
  // i.e. cos(x) = 1 - cos^2(x/4)(8 - 8cos^2(x/4))

  // Estimate the optimum number of times to use the argument reduction.
  // TODO? Estimation reused from cosine() and may not be optimal here.
  if (len &lt; 32) {
    k = Math.ceil(len / 3);
    n = Math.pow(4, -k).toString();
  } else {
    k = 16;
    n = '2.3283064365386962890625e-10';
  }

  x = taylorSeries(Ctor, 1, x.times(n), new Ctor(1), true);

  // Reverse argument reduction
  var cosh2_x,
    i = k,
    d8 = new Ctor(8);
  for (; i--;) {
    cosh2_x = x.times(x);
    x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));
  }

  return finalise(x, Ctor.precision = pr, Ctor.rounding = rm, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Calculate the hyperbolic cosine of a value,
* defined as `cosh(x) = 1/2 * (exp(x) + exp(-x))`.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">cosh</span>(x)
*
* Examples:
*
*    math.cosh(0.5);       // returns number 1.1276259652063807
*
* See also:
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.cosine" id="apidoc.element.mathjs.type.BigNumber.prototype.cosine">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>cosine
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cosine = function () {
  var pr, rm,
    x = this,
    Ctor = x.constructor;

  if (!x.d) return new Ctor(NaN);

  // cos(0) = cos(-0) = 1
  if (!x.d[0]) return new Ctor(1);

  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
  Ctor.rounding = 1;

  x = cosine(Ctor, toLessThanHalfPi(Ctor, x));

  Ctor.precision = pr;
  Ctor.rounding = rm;

  return finalise(quadrant == 2 || quadrant == 3 ? x.neg() : x, pr, rm, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.cubeRoot" id="apidoc.element.mathjs.type.BigNumber.prototype.cubeRoot">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>cubeRoot
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cubeRoot = function () {
  var e, m, n, r, rep, s, sd, t, t3, t3plusx,
    x = this,
    Ctor = x.constructor;

  if (!x.isFinite() || x.isZero()) return new Ctor(x);
  external = false;

  // Initial estimate.
  s = x.s * Math.pow(x.s * x, 1 / 3);

   // Math.cbrt underflow/overflow?
   // Pass x to Math.pow as integer, then adjust the exponent of the result.
  if (!s || Math.abs(s) == 1 / 0) {
    n = digitsToString(x.d);
    e = x.e;

    // Adjust n exponent so it is a multiple of 3 away from x exponent.
    if (s = (e - n.length + 1) % 3) n += (s == 1 || s == -2 ? '0' : '00');
    s = Math.pow(n, 1 / 3);

    // Rarely, e may be one less than the result exponent value.
    e = mathfloor((e + 1) / 3) - (e % 3 == (e &lt; 0 ? -1 : 2));

    if (s == 1 / 0) {
      n = '5e' + e;
    } else {
      n = s.toExponential();
      n = n.slice(0, n.indexOf('e') + 1) + e;
    }

    r = new Ctor(n);
    r.s = x.s;
  } else {
    r = new Ctor(s.toString());
  }

  sd = (e = Ctor.precision) + 3;

  // Halley's method.
  // TODO? Compare Newton's method.
  for (;;) {
    t = r;
    t3 = t.times(t).times(t);
    t3plusx = t3.plus(x);
    r = divide(t3plusx.plus(x).times(t), t3plusx.plus(t3), sd + 2, 1);

    // TODO? Replace with for-loop and checkRoundingDigits.
    if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
      n = n.slice(sd - 3, sd + 1);

      // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or 4999
      // , i.e. approaching a rounding boundary, continue the iteration.
      if (n == '9999' || !rep &amp;&amp; n == '4999') {

        // On the first iteration only, check to see if rounding up gives the exact result as the
        // nines may infinitely repeat.
        if (!rep) {
          finalise(t, e + 1, 0);

          if (t.times(t).times(t).eq(x)) {
            r = t;
            break;
          }
        }

        sd += 4;
        rep = 1;
      } else {

        // If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.
        // If not, then there are further digits and m will be truthy.
        if (!+n || !+n.slice(1) &amp;&amp; n.charAt(0) == '5') {

          // Truncate to the first rounding digit.
          finalise(r, e + 1, 1);
          m = !r.times(r).times(r).eq(x);
        }

        break;
      }
    }
  }

  external = true;

  return finalise(r, e, Ctor.rounding, m);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.decimalPlaces" id="apidoc.element.mathjs.type.BigNumber.prototype.decimalPlaces">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>decimalPlaces
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decimalPlaces = function () {
  var w,
    d = this.d,
    n = NaN;

  if (d) {
    w = d.length - 1;
    n = (w - mathfloor(this.e / LOG_BASE)) * LOG_BASE;

    // Subtract the number of trailing zeros of the last word.
    w = d[w];
    if (w) for (; w % 10 == 0; w /= 10) n--;
    if (n &lt; 0) n = 0;
  }

  return n;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.div" id="apidoc.element.mathjs.type.BigNumber.prototype.div">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>div
        <span class="apidocSignatureSpan">(y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">div = function (y) {
  return divide(this, new this.constructor(y));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  setLazyConstant(math, 'e',   function () {return bigConstants.e(type.BigNumber)});
  setLazyConstant(math, 'phi', function () {return bigConstants.phi(type.BigNumber)}); // golden ratio, (1+sqrt(5))/2

  // uppercase constants (for compatibility with built-in Math)
  setLazyConstant(math, 'E',       function () {return math.e;});
  setLazyConstant(math, 'LN2',     function () {return new type.BigNumber(2).ln();});
  setLazyConstant(math, 'LN10',    function () {return new type.BigNumber(10).ln()});
  setLazyConstant(math, 'LOG2E',   function () {return new type.BigNumber(1).<span class="apidocCodeKeywordSpan">div<!--
span-->(new type.BigNumber(2).ln());});
  setLazyConstant(math, 'LOG10E',  function () {return new type.BigNumber(1).div(new type.BigNumber(10).ln())});
  setLazyConstant(math, 'PI',      function () {return math.pi});
  setLazyConstant(math, 'SQRT1_2', function () {return new type.BigNumber('0.5').sqrt()});
  setLazyConstant(math, 'SQRT2',   function () {return new type.BigNumber(2).sqrt()});
}
else {
  setConstant(math, 'Infinity', Infinity);
...</span></pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.divToInt" id="apidoc.element.mathjs.type.BigNumber.prototype.divToInt">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>divToInt
        <span class="apidocSignatureSpan">(y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">divToInt = function (y) {
  var x = this,
    Ctor = x.constructor;
  return finalise(divide(x, new Ctor(y), 0, 1, 1), Ctor.precision, Ctor.rounding);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.dividedBy" id="apidoc.element.mathjs.type.BigNumber.prototype.dividedBy">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>dividedBy
        <span class="apidocSignatureSpan">(y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dividedBy = function (y) {
  return divide(this, new this.constructor(y));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      throw new TypeError('k must be less than n in function combinations');
    }

    max = n.minus(k);
    if (k.lt(max)) max = k;
    result = one;
    for (i = one, ii = n.minus(max); i.lte(ii); i = i.plus(1)) {
      result = result.times(max.plus(i)).<span class="apidocCodeKeywordSpan">dividedBy</span>(i);
    }

    return result;
  }

  // TODO: implement support for collection in combinations
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.dividedToIntegerBy" id="apidoc.element.mathjs.type.BigNumber.prototype.dividedToIntegerBy">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>dividedToIntegerBy
        <span class="apidocSignatureSpan">(y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dividedToIntegerBy = function (y) {
  var x = this,
    Ctor = x.constructor;
  return finalise(divide(x, new Ctor(y), 0, 1, 1), Ctor.precision, Ctor.rounding);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.dp" id="apidoc.element.mathjs.type.BigNumber.prototype.dp">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>dp
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dp = function () {
  var w,
    d = this.d,
    n = NaN;

  if (d) {
    w = d.length - 1;
    n = (w - mathfloor(this.e / LOG_BASE)) * LOG_BASE;

    // Subtract the number of trailing zeros of the last word.
    w = d[w];
    if (w) for (; w % 10 == 0; w /= 10) n--;
    if (n &lt; 0) n = 0;
  }

  return n;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.eq" id="apidoc.element.mathjs.type.BigNumber.prototype.eq">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>eq
        <span class="apidocSignatureSpan">(y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eq = function (y) {
  return this.cmp(y) === 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
'number, number': function (x, y) {
  return (x === y || nearlyEqual(x, y, config.epsilon))
      ? 0
      : (x &gt; y ? 1 : -1);
},

'BigNumber, BigNumber': function (x, y) {
  return (x.<span class="apidocCodeKeywordSpan">eq</span>(y) || bigNearlyEqual(x, y, config.epsilon))
      ? new type.BigNumber(0)
      : new type.BigNumber(x.cmp(y));
},

'Fraction, Fraction': function (x, y) {
  return new type.Fraction(x.compare(y));
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.equals" id="apidoc.element.mathjs.type.BigNumber.prototype.equals">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>equals
        <span class="apidocSignatureSpan">(y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">equals = function (y) {
  return this.cmp(y) === 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (inv) {
  root = root.neg();
}

if (root.isZero()) {
  throw new Error('Root must be non-zero');
}
if (a.isNegative() &amp;&amp; !root.abs().mod(2).<span class="apidocCodeKeywordSpan">equals</span>(1)) {
  throw new Error('Root must be odd when a is negative.');
}

// edge cases zero and infinity
if (a.isZero()) {
  return inv ? new Big(Infinity) : 0;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.exp" id="apidoc.element.mathjs.type.BigNumber.prototype.exp">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>exp
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exp = function () {
  return naturalExponential(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// https://www.wikiwand.com/en/Cube_root#/Complex_numbers

var arg_3 = x.arg() / 3;
var abs = x.abs();

// principal root:
var principal = new type.Complex(_cbrtNumber(abs), 0).mul(
    new type.Complex(0, arg_3).<span class="apidocCodeKeywordSpan">exp</span>());

if (allRoots) {
  var all = [
      principal,
      new type.Complex(_cbrtNumber(abs), 0).mul(
        new type.Complex(0, arg_3 + Math.PI * 2 / 3).exp()),
      new type.Complex(_cbrtNumber(abs), 0).mul(
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.floor" id="apidoc.element.mathjs.type.BigNumber.prototype.floor">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>floor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">floor = function () {
  return finalise(new this.constructor(this), this.e + 1, 3);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   *    ceil, floor, round
   *
   * @param {number | BigNumber | Fraction | Complex | Array | Matrix} x Number to be rounded
   * @return {number | BigNumber | Fraction | Complex | Array | Matrix}            Rounded value
   */
  var fix = typed('fix', {
'number': function (x) {
  return (x &gt; 0) ? Math.<span class="apidocCodeKeywordSpan">floor</span>(x) : Math.ceil(x);
},

'Complex': function (x) {
  return new type.Complex(
      (x.re &gt; 0) ? Math.floor(x.re) : Math.ceil(x.re),
      (x.im &gt; 0) ? Math.floor(x.im) : Math.ceil(x.im)
  );
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.greaterThan" id="apidoc.element.mathjs.type.BigNumber.prototype.greaterThan">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>greaterThan
        <span class="apidocSignatureSpan">(y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">greaterThan = function (y) {
  return this.cmp(y) &gt; 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.greaterThanOrEqualTo" id="apidoc.element.mathjs.type.BigNumber.prototype.greaterThanOrEqualTo">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>greaterThanOrEqualTo
        <span class="apidocSignatureSpan">(y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">greaterThanOrEqualTo = function (y) {
  var k = this.cmp(y);
  return k == 1 || k === 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.gt" id="apidoc.element.mathjs.type.BigNumber.prototype.gt">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>gt
        <span class="apidocSignatureSpan">(y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">gt = function (y) {
  return this.cmp(y) &gt; 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {BigNumber} step
 * @returns {Array} range
 * @private
 */
function _bigRangeEx (start, end, step) {
  var array = [],
      x = start;
  if (step.<span class="apidocCodeKeywordSpan">gt</span>(ZERO)) {
    while (x.lt(end)) {
      array.push(x);
      x = x.plus(step);
    }
  }
  else if (step.lt(ZERO)) {
    while (x.gt(end)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.gte" id="apidoc.element.mathjs.type.BigNumber.prototype.gte">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>gte
        <span class="apidocSignatureSpan">(y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">gte = function (y) {
  var k = this.cmp(y);
  return k == 1 || k === 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (step.gt(ZERO)) {
    while (x.lte(end)) {
      array.push(x);
      x = x.plus(step);
    }
  }
  else if (step.lt(ZERO)) {
    while (x.<span class="apidocCodeKeywordSpan">gte</span>(end)) {
      array.push(x);
      x = x.plus(step);
    }
  }

  return array;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.hyperbolicCosine" id="apidoc.element.mathjs.type.BigNumber.prototype.hyperbolicCosine">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>hyperbolicCosine
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hyperbolicCosine = function () {
  var k, n, pr, rm, len,
    x = this,
    Ctor = x.constructor,
    one = new Ctor(1);

  if (!x.isFinite()) return new Ctor(x.s ? 1 / 0 : NaN);
  if (x.isZero()) return one;

  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
  Ctor.rounding = 1;
  len = x.d.length;

  // Argument reduction: cos(4x) = 1 - 8cos^2(x) + 8cos^4(x) + 1
  // i.e. cos(x) = 1 - cos^2(x/4)(8 - 8cos^2(x/4))

  // Estimate the optimum number of times to use the argument reduction.
  // TODO? Estimation reused from cosine() and may not be optimal here.
  if (len &lt; 32) {
    k = Math.ceil(len / 3);
    n = Math.pow(4, -k).toString();
  } else {
    k = 16;
    n = '2.3283064365386962890625e-10';
  }

  x = taylorSeries(Ctor, 1, x.times(n), new Ctor(1), true);

  // Reverse argument reduction
  var cosh2_x,
    i = k,
    d8 = new Ctor(8);
  for (; i--;) {
    cosh2_x = x.times(x);
    x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));
  }

  return finalise(x, Ctor.precision = pr, Ctor.rounding = rm, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.hyperbolicSine" id="apidoc.element.mathjs.type.BigNumber.prototype.hyperbolicSine">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>hyperbolicSine
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hyperbolicSine = function () {
  var k, pr, rm, len,
    x = this,
    Ctor = x.constructor;

  if (!x.isFinite() || x.isZero()) return new Ctor(x);

  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
  Ctor.rounding = 1;
  len = x.d.length;

  if (len &lt; 3) {
    x = taylorSeries(Ctor, 2, x, x, true);
  } else {

    // Alternative argument reduction: sinh(3x) = sinh(x)(3 + 4sinh^2(x))
    // i.e. sinh(x) = sinh(x/3)(3 + 4sinh^2(x/3))
    // 3 multiplications and 1 addition

    // Argument reduction: sinh(5x) = sinh(x)(5 + sinh^2(x)(20 + 16sinh^2(x)))
    // i.e. sinh(x) = sinh(x/5)(5 + sinh^2(x/5)(20 + 16sinh^2(x/5)))
    // 4 multiplications and 2 additions

    // Estimate the optimum number of times to use the argument reduction.
    k = 1.4 * Math.sqrt(len);
    k = k &gt; 16 ? 16 : k | 0;

    x = x.times(Math.pow(5, -k));

    x = taylorSeries(Ctor, 2, x, x, true);

    // Reverse argument reduction
    var sinh2_x,
      d5 = new Ctor(5),
      d16 = new Ctor(16),
      d20 = new Ctor(20);
    for (; k--;) {
      sinh2_x = x.times(x);
      x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));
    }
  }

  Ctor.precision = pr;
  Ctor.rounding = rm;

  return finalise(x, pr, rm, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.hyperbolicTangent" id="apidoc.element.mathjs.type.BigNumber.prototype.hyperbolicTangent">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>hyperbolicTangent
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hyperbolicTangent = function () {
  var pr, rm,
    x = this,
    Ctor = x.constructor;

  if (!x.isFinite()) return new Ctor(x.s);
  if (x.isZero()) return new Ctor(x);

  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 7;
  Ctor.rounding = 1;

  return divide(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.inverseCosine" id="apidoc.element.mathjs.type.BigNumber.prototype.inverseCosine">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>inverseCosine
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inverseCosine = function () {
  var halfPi,
    x = this,
    Ctor = x.constructor,
    k = x.abs().cmp(1),
    pr = Ctor.precision,
    rm = Ctor.rounding;

  if (k !== -1) {
    return k === 0
      // |x| is 1
      ? x.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0)
      // |x| &gt; 1 or x is NaN
      : new Ctor(NaN);
  }

  if (x.isZero()) return getPi(Ctor, pr + 4, rm).times(0.5);

  // TODO? Special case acos(0.5) = pi/3 and acos(-0.5) = 2*pi/3

  Ctor.precision = pr + 6;
  Ctor.rounding = 1;

  x = x.asin();
  halfPi = getPi(Ctor, pr + 4, rm).times(0.5);

  Ctor.precision = pr;
  Ctor.rounding = rm;

  return halfPi.minus(x);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.inverseHyperbolicCosine" id="apidoc.element.mathjs.type.BigNumber.prototype.inverseHyperbolicCosine">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>inverseHyperbolicCosine
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inverseHyperbolicCosine = function () {
  var pr, rm,
    x = this,
    Ctor = x.constructor;

  if (x.lte(1)) return new Ctor(x.eq(1) ? 0 : NaN);
  if (!x.isFinite()) return new Ctor(x);

  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;
  Ctor.rounding = 1;
  external = false;

  x = x.times(x).minus(1).sqrt().plus(x);

  external = true;
  Ctor.precision = pr;
  Ctor.rounding = rm;

  return x.ln();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.inverseHyperbolicSine" id="apidoc.element.mathjs.type.BigNumber.prototype.inverseHyperbolicSine">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>inverseHyperbolicSine
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inverseHyperbolicSine = function () {
  var pr, rm,
    x = this,
    Ctor = x.constructor;

  if (!x.isFinite() || x.isZero()) return new Ctor(x);

  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;
  Ctor.rounding = 1;
  external = false;

  x = x.times(x).plus(1).sqrt().plus(x);

  external = true;
  Ctor.precision = pr;
  Ctor.rounding = rm;

  return x.ln();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.inverseHyperbolicTangent" id="apidoc.element.mathjs.type.BigNumber.prototype.inverseHyperbolicTangent">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>inverseHyperbolicTangent
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inverseHyperbolicTangent = function () {
  var pr, rm, wpr, xsd,
    x = this,
    Ctor = x.constructor;

  if (!x.isFinite()) return new Ctor(NaN);
  if (x.e &gt;= 0) return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN);

  pr = Ctor.precision;
  rm = Ctor.rounding;
  xsd = x.sd();

  if (Math.max(xsd, pr) &lt; 2 * -x.e - 1) return finalise(new Ctor(x), pr, rm, true);

  Ctor.precision = wpr = xsd - x.e;

  x = divide(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);

  Ctor.precision = pr + 4;
  Ctor.rounding = 1;

  x = x.ln();

  Ctor.precision = pr;
  Ctor.rounding = rm;

  return x.times(0.5);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.inverseSine" id="apidoc.element.mathjs.type.BigNumber.prototype.inverseSine">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>inverseSine
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inverseSine = function () {
  var halfPi, k,
    pr, rm,
    x = this,
    Ctor = x.constructor;

  if (x.isZero()) return new Ctor(x);

  k = x.abs().cmp(1);
  pr = Ctor.precision;
  rm = Ctor.rounding;

  if (k !== -1) {

    // |x| is 1
    if (k === 0) {
      halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
      halfPi.s = x.s;
      return halfPi;
    }

    // |x| &gt; 1 or x is NaN
    return new Ctor(NaN);
  }

  // TODO? Special case asin(1/2) = pi/6 and asin(-1/2) = -pi/6

  Ctor.precision = pr + 6;
  Ctor.rounding = 1;

  x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();

  Ctor.precision = pr;
  Ctor.rounding = rm;

  return x.times(2);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.inverseTangent" id="apidoc.element.mathjs.type.BigNumber.prototype.inverseTangent">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>inverseTangent
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inverseTangent = function () {
  var i, j, k, n, px, t, r, wpr, x2,
    x = this,
    Ctor = x.constructor,
    pr = Ctor.precision,
    rm = Ctor.rounding;

  if (!x.isFinite()) {
    if (!x.s) return new Ctor(NaN);
    if (pr + 4 &lt;= PI_PRECISION) {
      r = getPi(Ctor, pr + 4, rm).times(0.5);
      r.s = x.s;
      return r;
    }
  } else if (x.isZero()) {
    return new Ctor(x);
  } else if (x.abs().eq(1) &amp;&amp; pr + 4 &lt;= PI_PRECISION) {
    r = getPi(Ctor, pr + 4, rm).times(0.25);
    r.s = x.s;
    return r;
  }

  Ctor.precision = wpr = pr + 10;
  Ctor.rounding = 1;

  // TODO? if (x &gt;= 1 &amp;&amp; pr &lt;= PI_PRECISION) atan(x) = halfPi * x.s - atan(1 / x);

  // Argument reduction
  // Ensure |x| &lt; 0.42
  // atan(x) = 2 * atan(x / (1 + sqrt(1 + x^2)))

  k = Math.min(28, wpr / LOG_BASE + 2 | 0);

  for (i = k; i; --i) x = x.div(x.times(x).plus(1).sqrt().plus(1));

  external = false;

  j = Math.ceil(wpr / LOG_BASE);
  n = 1;
  x2 = x.times(x);
  r = new Ctor(x);
  px = x;

  // atan(x) = x - x^3/3 + x^5/5 - x^7/7 + ...
  for (; i !== -1;) {
    px = px.times(x2);
    t = r.minus(px.div(n += 2));

    px = px.times(x2);
    r = t.plus(px.div(n += 2));

    if (r.d[j] !== void 0) for (i = j; r.d[i] === t.d[i] &amp;&amp; i--;);
  }

  if (k) r = r.times(2 &lt;&lt; (k - 1));

  external = true;

  return finalise(r, Ctor.precision = pr, Ctor.rounding = rm, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.isFinite" id="apidoc.element.mathjs.type.BigNumber.prototype.isFinite">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>isFinite
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isFinite = function () {
  return !!this.d;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  throw new Error('Root must be odd when a is negative.');
}

// edge cases zero and infinity
if (a.isZero()) {
  return inv ? new Big(Infinity) : 0;
}
if (!a.<span class="apidocCodeKeywordSpan">isFinite</span>()) {
  return inv ? zero : a;
}

var x = a.abs().pow(one.div(root));
// If a &lt; 0, we require that root is an odd integer,
// so (-1) ^ (1/root) = -1
x = a.isNeg() ? x.neg() : x;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.isInt" id="apidoc.element.mathjs.type.BigNumber.prototype.isInt">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>isInt
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isInt = function () {
  return !!this.d &amp;&amp; mathfloor(this.e / LOG_BASE) &gt; this.d.length - 2;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * Calculate gcd for BigNumbers
   * @param {BigNumber} a
   * @param {BigNumber} b
   * @returns {BigNumber} Returns greatest common denominator of a and b
   * @private
   */
  function _gcdBigNumber(a, b) {
if (!a.<span class="apidocCodeKeywordSpan">isInt</span>() || !b.isInt()) {
  throw new Error('Parameters in function gcd must be integer numbers');
}

// http://en.wikipedia.org/wiki/Euclidean_algorithm
var zero = new type.BigNumber(0);
while (!b.isZero()) {
  var r = a.mod(b);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.isInteger" id="apidoc.element.mathjs.type.BigNumber.prototype.isInteger">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>isInteger
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isInteger = function () {
  return !!this.d &amp;&amp; mathfloor(this.e / LOG_BASE) &gt; this.d.length - 2;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * Test whether index is an integer number with index &gt;= 0 and index &lt; length
 * when length is provided
 * @param {number} index    Zero-based index
 * @param {number} [length] Length of the array
 */
exports.validateIndex = function(index, length) {
  if (!number.isNumber(index) || !number.<span class="apidocCodeKeywordSpan">isInteger</span>(index)) {
    throw new TypeError('Index must be an integer (value: ' + index + ')');
  }
  if (index &lt; 0 || (typeof length === 'number' &amp;&amp; index &gt;= length)) {
    throw new IndexError(index, length);
  }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.isNaN" id="apidoc.element.mathjs.type.BigNumber.prototype.isNaN">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>isNaN
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isNaN = function () {
  return !this.s;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
},

'Complex, Complex': function (x, y) {
  return (x.re !== 0 || x.im !== 0) &amp;&amp; (y.re !== 0 || y.im !== 0);
},

'BigNumber, BigNumber': function (x, y) {
  return !x.isZero() &amp;&amp; !y.isZero() &amp;&amp; !x.<span class="apidocCodeKeywordSpan">isNaN</span>() &amp;&amp; !y
.isNaN();
},

'Unit, Unit': function (x, y) {
  return and(x.value, y.value);
},

'Matrix, Matrix': function (x, y) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.isNeg" id="apidoc.element.mathjs.type.BigNumber.prototype.isNeg">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>isNeg
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isNeg = function () {
  return this.s &lt; 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   if (!a.isFinite()) {
     return inv ? zero : a;
   }

   var x = a.abs().pow(one.div(root));
   // If a &lt; 0, we require that root is an odd integer,
   // so (-1) ^ (1/root) = -1
   x = a.<span class="apidocCodeKeywordSpan">isNeg</span>() ? x.neg() : x;
   return new type.BigNumber((inv ? one.div(x) : x).toPrecision(precision));
 }
}

/**
* Calculate the nth root of a, solve x^root == a
* http://rosettacode.org/wiki/Nth_root#JavaScript
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.isNegative" id="apidoc.element.mathjs.type.BigNumber.prototype.isNegative">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>isNegative
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isNegative = function () {
  return this.s &lt; 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return new type.Complex(
      (x.re &gt; 0) ? Math.floor(x.re) : Math.ceil(x.re),
      (x.im &gt; 0) ? Math.floor(x.im) : Math.ceil(x.im)
  );
},

'BigNumber': function (x) {
  return x.<span class="apidocCodeKeywordSpan">isNegative</span>() ? x.ceil() : x.floor();
},

'Fraction': function (x) {
  return x.s &lt; 0 ? x.ceil() : x.floor();
},

'Array | Matrix': function (x) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.isPos" id="apidoc.element.mathjs.type.BigNumber.prototype.isPos">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>isPos
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isPos = function () {
  return this.s &gt; 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.isPositive" id="apidoc.element.mathjs.type.BigNumber.prototype.isPositive">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>isPositive
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isPositive = function () {
  return this.s &gt; 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Test whether a value is positive: larger than zero.
* The function supports types `number`, `BigNumber`, `Fraction`, and `Unit`.
*
* The function is evaluated element-wise in case of Array or Matrix input.
*
* Syntax:
*
*     math.<span class="apidocCodeKeywordSpan">isPositive</span>(x)
*
* Examples:
*
*    math.isPositive(3);                     // returns true
*    math.isPositive(-2);                    // returns false
*    math.isPositive(0);                     // returns false
*    math.isPositive(-0);                    // returns false
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.isZero" id="apidoc.element.mathjs.type.BigNumber.prototype.isZero">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>isZero
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isZero = function () {
  return !!this.d &amp;&amp; this.d[0] === 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
},

'number': function (x) {
  return !!x;
},

'BigNumber': function (x) {
  return !x.<span class="apidocCodeKeywordSpan">isZero</span>();
},

'string': function (x) {
  // try case insensitive
  var lcase = x.toLowerCase();
  if (lcase === 'true') {
    return true;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.lessThan" id="apidoc.element.mathjs.type.BigNumber.prototype.lessThan">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>lessThan
        <span class="apidocSignatureSpan">(y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lessThan = function (y) {
  return this.cmp(y) &lt; 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.lessThanOrEqualTo" id="apidoc.element.mathjs.type.BigNumber.prototype.lessThanOrEqualTo">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>lessThanOrEqualTo
        <span class="apidocSignatureSpan">(y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lessThanOrEqualTo = function (y) {
  return this.cmp(y) &lt; 1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.ln" id="apidoc.element.mathjs.type.BigNumber.prototype.ln">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>ln
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ln = function () {
  return naturalLogarithm(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  setLazyConstant(math, 'pi',  function () {return bigConstants.pi(type.BigNumber)});
  setLazyConstant(math, 'tau', function () {return bigConstants.tau(type.BigNumber)});
  setLazyConstant(math, 'e',   function () {return bigConstants.e(type.BigNumber)});
  setLazyConstant(math, 'phi', function () {return bigConstants.phi(type.BigNumber)}); // golden ratio, (1+sqrt(5))/2

  // uppercase constants (for compatibility with built-in Math)
  setLazyConstant(math, 'E',       function () {return math.e;});
  setLazyConstant(math, 'LN2',     function () {return new type.BigNumber(2).<span class="apidocCodeKeywordSpan">ln</span>();});
  setLazyConstant(math, 'LN10',    function () {return new type.BigNumber(10).ln()});
  setLazyConstant(math, 'LOG2E',   function () {return new type.BigNumber(1).div(new type.BigNumber(2).ln());});
  setLazyConstant(math, 'LOG10E',  function () {return new type.BigNumber(1).div(new type.BigNumber(10).ln())});
  setLazyConstant(math, 'PI',      function () {return math.pi});
  setLazyConstant(math, 'SQRT1_2', function () {return new type.BigNumber('0.5').sqrt()});
  setLazyConstant(math, 'SQRT2',   function () {return new type.BigNumber(2).sqrt()});
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.log" id="apidoc.element.mathjs.type.BigNumber.prototype.log">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>log
        <span class="apidocSignatureSpan">(base)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">log = function (base) {
  var isBase10, d, denominator, k, inf, num, sd, r,
    arg = this,
    Ctor = arg.constructor,
    pr = Ctor.precision,
    rm = Ctor.rounding,
    guard = 5;

  // Default base is 10.
  if (base == null) {
    base = new Ctor(10);
    isBase10 = true;
  } else {
    base = new Ctor(base);
    d = base.d;

    // Return NaN if base is negative, or non-finite, or is 0 or 1.
    if (base.s &lt; 0 || !d || !d[0] || base.eq(1)) return new Ctor(NaN);

    isBase10 = base.eq(10);
  }

  d = arg.d;

  // Is arg negative, non-finite, 0 or 1?
  if (arg.s &lt; 0 || !d || !d[0] || arg.eq(1)) {
    return new Ctor(d &amp;&amp; !d[0] ? -1 / 0 : arg.s != 1 ? NaN : d ? 0 : 1 / 0);
  }

  // The result will have a non-terminating decimal expansion if base is 10 and arg is not an
  // integer power of 10.
  if (isBase10) {
    if (d.length &gt; 1) {
      inf = true;
    } else {
      for (k = d[0]; k % 10 === 0;) k /= 10;
      inf = k !== 1;
    }
  }

  external = false;
  sd = pr + guard;
  num = naturalLogarithm(arg, sd);
  denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);

  // The result will have 5 rounding digits.
  r = divide(num, denominator, sd, 1);

  // If at a rounding boundary, i.e. the result's rounding digits are [49]9999 or [50]0000,
  // calculate 10 further digits.
  //
  // If the result is known to have an infinite decimal expansion, repeat this until it is clear
  // that the result is above or below the boundary. Otherwise, if after calculating the 10
  // further digits, the last 14 are nines, round up and assume the result is exact.
  // Also assume the result is exact if the last 14 are zero.
  //
  // Example of a result that will be incorrectly rounded:
  // log[1048576](4503599627370502) = 2.60000000000000009610279511444746...
  // The above result correctly rounded using ROUND_CEIL to 1 decimal place should be 2.7, but it
  // will be given as 2.6 as there are 15 zeros immediately after the requested decimal place, so
  // the exact result would be assumed to be 2.6, which rounded using ROUND_CEIL to 1 decimal
  // place is still 2.6.
  if (checkRoundingDigits(r.d, k = pr, rm)) {

    do {
      sd += 10;
      num = naturalLogarithm(arg, sd);
      denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
      r = divide(num, denominator, sd, 1);

      if (!inf) {

        // Check for 14 nines from the 2nd rounding digit, as the first may be 4.
        if (+digitsToString(r.d).slice(k + 1, k + 15) + 1 == 1e14) {
          r = finalise(r, pr + 1, 0);
        }

        break;
      }
    } while (checkRoundingDigits(r.d, k += 10, rm));
  }

  external = true;

  return finalise(r, pr, rm);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
// load math.js
var math = require('mathjs');

// functions and constants
math.round(math.e, 3);            // 2.718
math.atan2(3, -3) / math.pi;      // 0.75
math.<span class="apidocCodeKeywordSpan">log</span>(1000, 10);               // 3
math.sqrt(-4);                    // 2i
math.pow([[-1, 2], [3, 1]], 2);   // [[7, 0], [0, 7]]
math.derivative('x^2 + x', 'x');  // 2 * x + 1

// expressions
math.eval('12 / (2.3 + 0.7)');    // 4
math.eval('5.08 cm to inch');     // 2 inch
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.logarithm" id="apidoc.element.mathjs.type.BigNumber.prototype.logarithm">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>logarithm
        <span class="apidocSignatureSpan">(base)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">logarithm = function (base) {
  var isBase10, d, denominator, k, inf, num, sd, r,
    arg = this,
    Ctor = arg.constructor,
    pr = Ctor.precision,
    rm = Ctor.rounding,
    guard = 5;

  // Default base is 10.
  if (base == null) {
    base = new Ctor(10);
    isBase10 = true;
  } else {
    base = new Ctor(base);
    d = base.d;

    // Return NaN if base is negative, or non-finite, or is 0 or 1.
    if (base.s &lt; 0 || !d || !d[0] || base.eq(1)) return new Ctor(NaN);

    isBase10 = base.eq(10);
  }

  d = arg.d;

  // Is arg negative, non-finite, 0 or 1?
  if (arg.s &lt; 0 || !d || !d[0] || arg.eq(1)) {
    return new Ctor(d &amp;&amp; !d[0] ? -1 / 0 : arg.s != 1 ? NaN : d ? 0 : 1 / 0);
  }

  // The result will have a non-terminating decimal expansion if base is 10 and arg is not an
  // integer power of 10.
  if (isBase10) {
    if (d.length &gt; 1) {
      inf = true;
    } else {
      for (k = d[0]; k % 10 === 0;) k /= 10;
      inf = k !== 1;
    }
  }

  external = false;
  sd = pr + guard;
  num = naturalLogarithm(arg, sd);
  denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);

  // The result will have 5 rounding digits.
  r = divide(num, denominator, sd, 1);

  // If at a rounding boundary, i.e. the result's rounding digits are [49]9999 or [50]0000,
  // calculate 10 further digits.
  //
  // If the result is known to have an infinite decimal expansion, repeat this until it is clear
  // that the result is above or below the boundary. Otherwise, if after calculating the 10
  // further digits, the last 14 are nines, round up and assume the result is exact.
  // Also assume the result is exact if the last 14 are zero.
  //
  // Example of a result that will be incorrectly rounded:
  // log[1048576](4503599627370502) = 2.60000000000000009610279511444746...
  // The above result correctly rounded using ROUND_CEIL to 1 decimal place should be 2.7, but it
  // will be given as 2.6 as there are 15 zeros immediately after the requested decimal place, so
  // the exact result would be assumed to be 2.6, which rounded using ROUND_CEIL to 1 decimal
  // place is still 2.6.
  if (checkRoundingDigits(r.d, k = pr, rm)) {

    do {
      sd += 10;
      num = naturalLogarithm(arg, sd);
      denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
      r = divide(num, denominator, sd, 1);

      if (!inf) {

        // Check for 14 nines from the 2nd rounding digit, as the first may be 4.
        if (+digitsToString(r.d).slice(k + 1, k + 15) + 1 == 1e14) {
          r = finalise(r, pr + 1, 0);
        }

        break;
      }
    } while (checkRoundingDigits(r.d, k += 10, rm));
  }

  external = true;

  return finalise(r, pr, rm);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.lt" id="apidoc.element.mathjs.type.BigNumber.prototype.lt">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>lt
        <span class="apidocSignatureSpan">(y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lt = function (y) {
  return this.cmp(y) &lt; 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   // http://en.wikipedia.org/wiki/Euclidean_algorithm
   var zero = new type.BigNumber(0);
   while (!b.isZero()) {
     var r = a.mod(b);
     a = b;
     b = r;
   }
   return a.<span class="apidocCodeKeywordSpan">lt</span>(zero) ? a.neg() : a;
 }
}

/**
* Calculate gcd for numbers
* @param {number} a
* @param {number} b
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.lte" id="apidoc.element.mathjs.type.BigNumber.prototype.lte">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>lte
        <span class="apidocSignatureSpan">(y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lte = function (y) {
  return this.cmp(y) &lt; 1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @returns {Array} range
 * @private
 */
function _bigRangeInc (start, end, step) {
  var array = [],
      x = start;
  if (step.gt(ZERO)) {
    while (x.<span class="apidocCodeKeywordSpan">lte</span>(end)) {
      array.push(x);
      x = x.plus(step);
    }
  }
  else if (step.lt(ZERO)) {
    while (x.gte(end)) {
      array.push(x);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.minus" id="apidoc.element.mathjs.type.BigNumber.prototype.minus">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>minus
        <span class="apidocSignatureSpan">(y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">minus = function (y) {
  var d, e, i, j, k, len, pr, rm, xd, xe, xLTy, yd,
    x = this,
    Ctor = x.constructor;

  y = new Ctor(y);

  // If either is not finite...
  if (!x.d || !y.d) {

    // Return NaN if either is NaN.
    if (!x.s || !y.s) y = new Ctor(NaN);

    // Return y negated if x is finite and y is Â±Infinity.
    else if (x.d) y.s = -y.s;

    // Return x if y is finite and x is Â±Infinity.
    // Return x if both are Â±Infinity with different signs.
    // Return NaN if both are Â±Infinity with the same sign.
    else y = new Ctor(y.d || x.s !== y.s ? x : NaN);

    return y;
  }

  // If signs differ...
  if (x.s != y.s) {
    y.s = -y.s;
    return x.plus(y);
  }

  xd = x.d;
  yd = y.d;
  pr = Ctor.precision;
  rm = Ctor.rounding;

  // If either is zero...
  if (!xd[0] || !yd[0]) {

    // Return y negated if x is zero and y is non-zero.
    if (yd[0]) y.s = -y.s;

    // Return x if y is zero and x is non-zero.
    else if (xd[0]) y = new Ctor(x);

    // Return zero if both are zero.
    // From IEEE 754 (2008) 6.3: 0 - 0 = -0 - -0 = -0 when rounding to -Infinity.
    else return new Ctor(rm === 3 ? -0 : 0);

    return external ? finalise(y, pr, rm) : y;
  }

  // x and y are finite, non-zero numbers with the same sign.

  // Calculate base 1e7 exponents.
  e = mathfloor(y.e / LOG_BASE);
  xe = mathfloor(x.e / LOG_BASE);

  xd = xd.slice();
  k = xe - e;

  // If base 1e7 exponents differ...
  if (k) {
    xLTy = k &lt; 0;

    if (xLTy) {
      d = xd;
      k = -k;
      len = yd.length;
    } else {
      d = yd;
      e = xe;
      len = xd.length;
    }

    // Numbers with massively different exponents would result in a very high number of
    // zeros needing to be prepended, but this can be avoided while still ensuring correct
    // rounding by limiting the number of zeros to `Math.ceil(pr / LOG_BASE) + 2`.
    i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;

    if (k &gt; i) {
      k = i;
      d.length = 1;
    }

    // Prepend zeros to equalise exponents.
    d.reverse();
    for (i = k; i--;) d.push(0);
    d.reverse();

  // Base 1e7 exponents equal.
  } else {

    // Check digits to determine which is the bigger number.

    i = xd.length;
    len = yd.length;
    xLTy = i &lt; len;
    if (xLTy) len = i;

    for (i = 0; i &lt; len; i++) {
      if (xd[i] != yd[i]) {
        xLTy = xd[i] &lt; yd[i];
        break;
      }
    }

    k = 0;
  }

  if (xLTy) {
    d = xd;
    xd = yd;
    yd = d;
    y.s = -y.s;
  }

  len = xd.length;

  // Append zeros to `xd` if shorter.
  // Don't add zeros to `yd` if shorter as subtraction only needs to start at `yd` length.
  for (i = yd.length - len; i &gt; 0; --i) xd[len++] = 0;

  // Subtract yd from xd.
  for (i = yd.length; i &gt; k;) {

    if (xd[--i] &lt; yd[i]) {
      for (j = i; j &amp;&amp; xd[--j] === 0;) xd[j] = BASE - 1;
      --xd[j];
      xd[i] += BASE;
    }

    xd[i] -= yd[i];
  }

  // Remove trailing zeros.
  for (; xd[--len] === 0;) xd.pop();

  // Remove leading zeros and adjust exponent accordingly.
  for (; xd[0] === 0; xd.shift()) --e;

  // Zero?
  if (!xd[0]) return new Ctor(rm === 3 ? -0 : 0);

  y.d = xd;
  y.e = getBase10Exponent(xd, e);

  return external ? finalise(y, pr, rm) : y;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// change last argument from one-based to zero-based
var lastIndex = args.length - 1;
var last = args[lastIndex];
if (typeof last === 'number') {
  args[lastIndex] = last - 1;
}
else if (last &amp;&amp; last.isBigNumber === true) {
  args[lastIndex] = last.<span class="apidocCodeKeywordSpan">minus</span>(1);
}

try {
  return concat.apply(null, args);
}
catch (err) {
  throw errorTransform(err);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.mod" id="apidoc.element.mathjs.type.BigNumber.prototype.mod">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>mod
        <span class="apidocSignatureSpan">(y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mod = function (y) {
  var q,
    x = this,
    Ctor = x.constructor;

  y = new Ctor(y);

  // Return NaN if x is Â±Infinity or NaN, or y is NaN or Â±0.
  if (!x.d || !y.s || y.d &amp;&amp; !y.d[0]) return new Ctor(NaN);

  // Return x if y is Â±Infinity or x is Â±0.
  if (!y.d || x.d &amp;&amp; !x.d[0]) {
    return finalise(new Ctor(x), Ctor.precision, Ctor.rounding);
  }

  // Prevent rounding of intermediate calculations.
  external = false;

  if (Ctor.modulo == 9) {

    // Euclidian division: q = sign(y) * floor(x / abs(y))
    // result = x - q * y    where  0 &lt;= result &lt; abs(y)
    q = divide(x, y.abs(), 0, 3, 1);
    q.s *= y.s;
  } else {
    q = divide(x, y, 0, Ctor.modulo, 1);
  }

  q = q.times(y);

  external = true;

  return x.minus(q);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (!a.isInt() || !b.isInt()) {
      throw new Error('Parameters in function gcd must be integer numbers');
    }

    // http://en.wikipedia.org/wiki/Euclidean_algorithm
    var zero = new type.BigNumber(0);
    while (!b.isZero()) {
      var r = a.<span class="apidocCodeKeywordSpan">mod</span>(b);
      a = b;
      b = r;
    }
    return a.lt(zero) ? a.neg() : a;
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.modulo" id="apidoc.element.mathjs.type.BigNumber.prototype.modulo">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>modulo
        <span class="apidocSignatureSpan">(y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">modulo = function (y) {
  var q,
    x = this,
    Ctor = x.constructor;

  y = new Ctor(y);

  // Return NaN if x is Â±Infinity or NaN, or y is NaN or Â±0.
  if (!x.d || !y.s || y.d &amp;&amp; !y.d[0]) return new Ctor(NaN);

  // Return x if y is Â±Infinity or x is Â±0.
  if (!y.d || x.d &amp;&amp; !x.d[0]) {
    return finalise(new Ctor(x), Ctor.precision, Ctor.rounding);
  }

  // Prevent rounding of intermediate calculations.
  external = false;

  if (Ctor.modulo == 9) {

    // Euclidian division: q = sign(y) * floor(x / abs(y))
    // result = x - q * y    where  0 &lt;= result &lt; abs(y)
    q = divide(x, y.abs(), 0, 3, 1);
    q.s *= y.s;
  } else {
    q = divide(x, y, 0, Ctor.modulo, 1);
  }

  q = q.times(y);

  external = true;

  return x.minus(q);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.mul" id="apidoc.element.mathjs.type.BigNumber.prototype.mul">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>mul
        <span class="apidocSignatureSpan">(y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mul = function (y) {
  var carry, e, i, k, r, rL, t, xdL, ydL,
    x = this,
    Ctor = x.constructor,
    xd = x.d,
    yd = (y = new Ctor(y)).d;

  y.s *= x.s;

   // If either is NaN, Â±Infinity or Â±0...
  if (!xd || !xd[0] || !yd || !yd[0]) {

    return new Ctor(!y.s || xd &amp;&amp; !xd[0] &amp;&amp; !yd || yd &amp;&amp; !yd[0] &amp;&amp; !xd

      // Return NaN if either is NaN.
      // Return NaN if x is Â±0 and y is Â±Infinity, or y is Â±0 and x is Â±Infinity.
      ? NaN

      // Return Â±Infinity if either is Â±Infinity.
      // Return Â±0 if either is Â±0.
      : !xd || !yd ? y.s / 0 : y.s * 0);
  }

  e = mathfloor(x.e / LOG_BASE) + mathfloor(y.e / LOG_BASE);
  xdL = xd.length;
  ydL = yd.length;

  // Ensure xd points to the longer array.
  if (xdL &lt; ydL) {
    r = xd;
    xd = yd;
    yd = r;
    rL = xdL;
    xdL = ydL;
    ydL = rL;
  }

  // Initialise the result array with zeros.
  r = [];
  rL = xdL + ydL;
  for (i = rL; i--;) r.push(0);

  // Multiply!
  for (i = ydL; --i &gt;= 0;) {
    carry = 0;
    for (k = xdL + i; k &gt; i;) {
      t = r[k] + yd[i] * xd[k - i - 1] + carry;
      r[k--] = t % BASE | 0;
      carry = t / BASE | 0;
    }

    r[k] = (r[k] + carry) % BASE | 0;
  }

  // Remove trailing zeros.
  for (; !r[--rL];) r.pop();

  if (carry) ++e;
  else r.shift();

  y.d = r;
  y.e = getBase10Exponent(r, e);

  return external ? finalise(y, Ctor.precision, Ctor.rounding) : y;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  function _cbrtComplex(x, allRoots) {
// https://www.wikiwand.com/en/Cube_root#/Complex_numbers

var arg_3 = x.arg() / 3;
var abs = x.abs();

// principal root:
var principal = new type.Complex(_cbrtNumber(abs), 0).<span class="apidocCodeKeywordSpan">mul</span>(
    new type.Complex(0, arg_3).exp());

if (allRoots) {
  var all = [
      principal,
      new type.Complex(_cbrtNumber(abs), 0).mul(
        new type.Complex(0, arg_3 + Math.PI * 2 / 3).exp()),
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.naturalExponential" id="apidoc.element.mathjs.type.BigNumber.prototype.naturalExponential">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>naturalExponential
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">naturalExponential = function () {
  return naturalExponential(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.naturalLogarithm" id="apidoc.element.mathjs.type.BigNumber.prototype.naturalLogarithm">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>naturalLogarithm
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">naturalLogarithm = function () {
  return naturalLogarithm(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.neg" id="apidoc.element.mathjs.type.BigNumber.prototype.neg">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>neg
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">neg = function () {
  var x = new this.constructor(this);
  x.s = -x.s;
  return finalise(x);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   // http://en.wikipedia.org/wiki/Euclidean_algorithm
   var zero = new type.BigNumber(0);
   while (!b.isZero()) {
     var r = a.mod(b);
     a = b;
     b = r;
   }
   return a.lt(zero) ? a.<span class="apidocCodeKeywordSpan">neg</span>() : a;
 }
}

/**
* Calculate gcd for numbers
* @param {number} a
* @param {number} b
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.negated" id="apidoc.element.mathjs.type.BigNumber.prototype.negated">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>negated
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">negated = function () {
  var x = new this.constructor(this);
  x.s = -x.s;
  return finalise(x);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.plus" id="apidoc.element.mathjs.type.BigNumber.prototype.plus">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>plus
        <span class="apidocSignatureSpan">(y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">plus = function (y) {
  var carry, d, e, i, k, len, pr, rm, xd, yd,
    x = this,
    Ctor = x.constructor;

  y = new Ctor(y);

  // If either is not finite...
  if (!x.d || !y.d) {

    // Return NaN if either is NaN.
    if (!x.s || !y.s) y = new Ctor(NaN);

    // Return x if y is finite and x is Â±Infinity.
    // Return x if both are Â±Infinity with the same sign.
    // Return NaN if both are Â±Infinity with different signs.
    // Return y if x is finite and y is Â±Infinity.
    else if (!x.d) y = new Ctor(y.d || x.s === y.s ? x : NaN);

    return y;
  }

   // If signs differ...
  if (x.s != y.s) {
    y.s = -y.s;
    return x.minus(y);
  }

  xd = x.d;
  yd = y.d;
  pr = Ctor.precision;
  rm = Ctor.rounding;

  // If either is zero...
  if (!xd[0] || !yd[0]) {

    // Return x if y is zero.
    // Return y if y is non-zero.
    if (!yd[0]) y = new Ctor(x);

    return external ? finalise(y, pr, rm) : y;
  }

  // x and y are finite, non-zero numbers with the same sign.

  // Calculate base 1e7 exponents.
  k = mathfloor(x.e / LOG_BASE);
  e = mathfloor(y.e / LOG_BASE);

  xd = xd.slice();
  i = k - e;

  // If base 1e7 exponents differ...
  if (i) {

    if (i &lt; 0) {
      d = xd;
      i = -i;
      len = yd.length;
    } else {
      d = yd;
      e = k;
      len = xd.length;
    }

    // Limit number of zeros prepended to max(ceil(pr / LOG_BASE), len) + 1.
    k = Math.ceil(pr / LOG_BASE);
    len = k &gt; len ? k + 1 : len + 1;

    if (i &gt; len) {
      i = len;
      d.length = 1;
    }

    // Prepend zeros to equalise exponents. Note: Faster to use reverse then do unshifts.
    d.reverse();
    for (; i--;) d.push(0);
    d.reverse();
  }

  len = xd.length;
  i = yd.length;

  // If yd is longer than xd, swap xd and yd so xd points to the longer array.
  if (len - i &lt; 0) {
    i = len;
    d = yd;
    yd = xd;
    xd = d;
  }

  // Only start adding at yd.length - 1 as the further digits of xd can be left as they are.
  for (carry = 0; i;) {
    carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;
    xd[i] %= BASE;
  }

  if (carry) {
    xd.unshift(carry);
    ++e;
  }

  // Remove trailing zeros.
  // No need to check for zero, as +x + +y != 0 &amp;&amp; -x + -y != 0
  for (len = xd.length; xd[--len] == 0;) xd.pop();

  y.d = xd;
  y.e = getBase10Exponent(xd, e);

  return external ? finalise(y, pr, rm) : y;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
},

'Complex, Complex': function (x, y) {
  return x.add(y);
},

'BigNumber, BigNumber': function (x, y) {
  return x.<span class="apidocCodeKeywordSpan">plus</span>(y);
},

'Fraction, Fraction': function (x, y) {
  return x.add(y);
},

'Unit, Unit': function (x, y) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.pow" id="apidoc.element.mathjs.type.BigNumber.prototype.pow">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>pow
        <span class="apidocSignatureSpan">(y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pow = function (y) {
  var e, k, pr, r, rm, sign, yIsInt,
    x = this,
    Ctor = x.constructor,
    yn = +(y = new Ctor(y));

  // Either Â±Infinity, NaN or Â±0?
  if (!x.d || !y.d || !x.d[0] || !y.d[0]) return  new Ctor(mathpow(+x, yn));

  x = new Ctor(x);

  if (x.eq(1)) return x;

  pr = Ctor.precision;
  rm = Ctor.rounding;

  if (y.eq(1)) return finalise(x, pr, rm);

  e = mathfloor(y.e / LOG_BASE);
  k = y.d.length - 1;
  yIsInt = e &gt;= k;
  sign = x.s;

  if (!yIsInt) {
    if (sign &lt; 0) return new Ctor(NaN);

  // If y is a small integer use the 'exponentiation by squaring' algorithm.
  } else if ((k = yn &lt; 0 ? -yn : yn) &lt;= MAX_SAFE_INTEGER) {
    r = intPow(Ctor, x, k, pr);
    return y.s &lt; 0 ? new Ctor(1).div(r) : finalise(r, pr, rm);
  }

  // Result is negative if x is negative and the last digit of integer y is odd.
  sign = sign &lt; 0 &amp;&amp; y.d[Math.max(e, k)] &amp; 1 ? -1 : 1;

  // Estimate result exponent.
  // x^y = 10^e,  where e = y * log10(x)
  // log10(x) = log10(x_significand) + x_exponent
  // log10(x_significand) = ln(x_significand) / ln(10)
  k = mathpow(+x, yn);
  e = k == 0 || !isFinite(k)
    ? mathfloor(yn * (Math.log('0.' + digitsToString(x.d)) / Math.LN10 + x.e + 1))
    : new Ctor(k + '').e;

  // Estimate may be incorrect e.g. x: 0.999999999999999999, y: 2.29, e: 0, r.e: -1.

  // Overflow/underflow?
  if (e &gt; Ctor.maxE + 1 || e &lt; Ctor.minE - 1) return new Ctor(e &gt; 0 ? sign / 0 : 0);

  external = false;
  Ctor.rounding = x.s = 1;

  // Estimate the extra guard digits needed to ensure five correct rounding digits from
  // naturalLogarithm(x). Example of failure without these extra digits (precision: 10):
  // new Decimal(2.32456).pow('2087987436534566.46411')
  // should be 1.162377823e+764914905173815, but is 1.162355823e+764914905173815
  k = Math.min(12, (e + '').length);

  // r = x^y = exp(y*ln(x))
  r = naturalExponential(y.times(naturalLogarithm(x, pr + k)), pr);

  // Truncate to the required precision plus five rounding digits.
  r = finalise(r, pr + 5, 1);

  // If the rounding digits are [49]9999 or [50]0000 increase the precision by 10 and recalculate
  // the result.
  if (checkRoundingDigits(r.d, pr, rm)) {
    e = pr + 10;

    // Truncate to the increased precision plus five rounding digits.
    r = finalise(naturalExponential(y.times(naturalLogarithm(x, e + k)), e), e + 5, 1);

    // Check for 14 nines from the 2nd rounding digit (the first rounding digit may be 4 or 9).
    if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 1e14) {
      r = finalise(r, pr + 1, 0);
    }
  }

  r.s = sign;
  external = true;
  Ctor.rounding = rm;

  return finalise(r, pr, rm);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var math = require('mathjs');

// functions and constants
math.round(math.e, 3);            // 2.718
math.atan2(3, -3) / math.pi;      // 0.75
math.log(1000, 10);               // 3
math.sqrt(-4);                    // 2i
math.<span class="apidocCodeKeywordSpan">pow</span>([[-1, 2], [3, 1]], 2);   // [[7, 0], [0, 7]]
math.derivative('x^2 + x', 'x');  // 2 * x + 1

// expressions
math.eval('12 / (2.3 + 0.7)');    // 4
math.eval('5.08 cm to inch');     // 2 inch
math.eval('sin(45 deg) ^ 2');     // 0.5
math.eval('9 / 3 + 2i');          // 3 + 2i
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.precision" id="apidoc.element.mathjs.type.BigNumber.prototype.precision">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>precision
        <span class="apidocSignatureSpan">(z)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">precision = function (z) {
  var k,
    x = this;

  if (z !== void 0 &amp;&amp; z !== !!z &amp;&amp; z !== 1 &amp;&amp; z !== 0) throw Error(invalidArgument + z);

  if (x.d) {
    k = getPrecision(x.d);
    if (z &amp;&amp; x.e + 1 &gt; k) k = x.e + 1;
  } else {
    k = NaN;
  }

  return k;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.round" id="apidoc.element.mathjs.type.BigNumber.prototype.round">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>round
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">round = function () {
  var x = this,
    Ctor = x.constructor;

  return finalise(new Ctor(x), x.e + 1, Ctor.rounding);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
[chained operations](http://mathjs.org/docs/chained_operations.html).

```js
// load math.js
var math = require('mathjs');

// functions and constants
math.<span class="apidocCodeKeywordSpan">round</span>(math.e, 3);            // 2.718
math.atan2(3, -3) / math.pi;      // 0.75
math.log(1000, 10);               // 3
math.sqrt(-4);                    // 2i
math.pow([[-1, 2], [3, 1]], 2);   // [[7, 0], [0, 7]]
math.derivative('x^2 + x', 'x');  // 2 * x + 1

// expressions
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.sd" id="apidoc.element.mathjs.type.BigNumber.prototype.sd">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>sd
        <span class="apidocSignatureSpan">(z)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sd = function (z) {
  var k,
    x = this;

  if (z !== void 0 &amp;&amp; z !== !!z &amp;&amp; z !== 1 &amp;&amp; z !== 0) throw Error(invalidArgument + z);

  if (x.d) {
    k = getPrecision(x.d);
    if (z &amp;&amp; x.e + 1 &gt; k) k = x.e + 1;
  } else {
    k = NaN;
  }

  return k;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.sin" id="apidoc.element.mathjs.type.BigNumber.prototype.sin">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>sin
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sin = function () {
  var pr, rm,
    x = this,
    Ctor = x.constructor;

  if (!x.isFinite()) return new Ctor(NaN);
  if (x.isZero()) return new Ctor(x);

  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
  Ctor.rounding = 1;

  x = sine(Ctor, toLessThanHalfPi(Ctor, x));

  Ctor.precision = pr;
  Ctor.rounding = rm;

  return finalise(quadrant &gt; 2 ? x.neg() : x, pr, rm, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    res = 1;                          // 0! is per definition 1
  }

  return res;
}

if (n &lt; 0.5) {
  return Math.PI / (Math.<span class="apidocCodeKeywordSpan">sin</span>(Math.PI * n) * gamma(1-n));
}

if (n &gt;= 171.35) {
  return Infinity;                    // will overflow
}

if (n &gt; 85.0) {                       // Extended Stirling Approx
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.sine" id="apidoc.element.mathjs.type.BigNumber.prototype.sine">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>sine
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sine = function () {
  var pr, rm,
    x = this,
    Ctor = x.constructor;

  if (!x.isFinite()) return new Ctor(NaN);
  if (x.isZero()) return new Ctor(x);

  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
  Ctor.rounding = 1;

  x = sine(Ctor, toLessThanHalfPi(Ctor, x));

  Ctor.precision = pr;
  Ctor.rounding = rm;

  return finalise(quadrant &gt; 2 ? x.neg() : x, pr, rm, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.sinh" id="apidoc.element.mathjs.type.BigNumber.prototype.sinh">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>sinh
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sinh = function () {
  var k, pr, rm, len,
    x = this,
    Ctor = x.constructor;

  if (!x.isFinite() || x.isZero()) return new Ctor(x);

  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
  Ctor.rounding = 1;
  len = x.d.length;

  if (len &lt; 3) {
    x = taylorSeries(Ctor, 2, x, x, true);
  } else {

    // Alternative argument reduction: sinh(3x) = sinh(x)(3 + 4sinh^2(x))
    // i.e. sinh(x) = sinh(x/3)(3 + 4sinh^2(x/3))
    // 3 multiplications and 1 addition

    // Argument reduction: sinh(5x) = sinh(x)(5 + sinh^2(x)(20 + 16sinh^2(x)))
    // i.e. sinh(x) = sinh(x/5)(5 + sinh^2(x/5)(20 + 16sinh^2(x/5)))
    // 4 multiplications and 2 additions

    // Estimate the optimum number of times to use the argument reduction.
    k = 1.4 * Math.sqrt(len);
    k = k &gt; 16 ? 16 : k | 0;

    x = x.times(Math.pow(5, -k));

    x = taylorSeries(Ctor, 2, x, x, true);

    // Reverse argument reduction
    var sinh2_x,
      d5 = new Ctor(5),
      d16 = new Ctor(16),
      d20 = new Ctor(20);
    for (; k--;) {
      sinh2_x = x.times(x);
      x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));
    }
  }

  Ctor.precision = pr;
  Ctor.rounding = rm;

  return finalise(x, pr, rm, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
*    math.csch(x)
*
* Examples:
*
*    // csch(x) = 1/ sinh(x)
*    math.csch(0.5);       // returns 1.9190347513349437
*    1 / math.<span class="apidocCodeKeywordSpan">sinh</span>(0.5);   // returns 1.9190347513349437
*
* See also:
*
*    sinh, sech, coth
*
* @param {number | Complex | Unit | Array | Matrix} x  Function input
* @return {number | Complex | Array | Matrix} Hyperbolic cosecant of x
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.sqrt" id="apidoc.element.mathjs.type.BigNumber.prototype.sqrt">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>sqrt
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sqrt = function () {
  var m, n, sd, r, rep, t,
    x = this,
    d = x.d,
    e = x.e,
    s = x.s,
    Ctor = x.constructor;

  // Negative/NaN/Infinity/zero?
  if (s !== 1 || !d || !d[0]) {
    return new Ctor(!s || s &lt; 0 &amp;&amp; (!d || d[0]) ? NaN : d ? x : 1 / 0);
  }

  external = false;

  // Initial estimate.
  s = Math.sqrt(+x);

  // Math.sqrt underflow/overflow?
  // Pass x to Math.sqrt as integer, then adjust the exponent of the result.
  if (s == 0 || s == 1 / 0) {
    n = digitsToString(d);

    if ((n.length + e) % 2 == 0) n += '0';
    s = Math.sqrt(n);
    e = mathfloor((e + 1) / 2) - (e &lt; 0 || e % 2);

    if (s == 1 / 0) {
      n = '1e' + e;
    } else {
      n = s.toExponential();
      n = n.slice(0, n.indexOf('e') + 1) + e;
    }

    r = new Ctor(n);
  } else {
    r = new Ctor(s.toString());
  }

  sd = (e = Ctor.precision) + 3;

  // Newton-Raphson iteration.
  for (;;) {
    t = r;
    r = t.plus(divide(x, t, sd + 2, 1)).times(0.5);

    // TODO? Replace with for-loop and checkRoundingDigits.
    if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
      n = n.slice(sd - 3, sd + 1);

      // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or
      // 4999, i.e. approaching a rounding boundary, continue the iteration.
      if (n == '9999' || !rep &amp;&amp; n == '4999') {

        // On the first iteration only, check to see if rounding up gives the exact result as the
        // nines may infinitely repeat.
        if (!rep) {
          finalise(t, e + 1, 0);

          if (t.times(t).eq(x)) {
            r = t;
            break;
          }
        }

        sd += 4;
        rep = 1;
      } else {

        // If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.
        // If not, then there are further digits and m will be truthy.
        if (!+n || !+n.slice(1) &amp;&amp; n.charAt(0) == '5') {

          // Truncate to the first rounding digit.
          finalise(r, e + 1, 1);
          m = !r.times(r).eq(x);
        }

        break;
      }
    }
  }

  external = true;

  return finalise(r, e, Ctor.rounding, m);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// load math.js
var math = require('mathjs');

// functions and constants
math.round(math.e, 3);            // 2.718
math.atan2(3, -3) / math.pi;      // 0.75
math.log(1000, 10);               // 3
math.<span class="apidocCodeKeywordSpan">sqrt</span>(-4);                    // 2i
math.pow([[-1, 2], [3, 1]], 2);   // [[7, 0], [0, 7]]
math.derivative('x^2 + x', 'x');  // 2 * x + 1

// expressions
math.eval('12 / (2.3 + 0.7)');    // 4
math.eval('5.08 cm to inch');     // 2 inch
math.eval('sin(45 deg) ^ 2');     // 0.5
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.squareRoot" id="apidoc.element.mathjs.type.BigNumber.prototype.squareRoot">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>squareRoot
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">squareRoot = function () {
  var m, n, sd, r, rep, t,
    x = this,
    d = x.d,
    e = x.e,
    s = x.s,
    Ctor = x.constructor;

  // Negative/NaN/Infinity/zero?
  if (s !== 1 || !d || !d[0]) {
    return new Ctor(!s || s &lt; 0 &amp;&amp; (!d || d[0]) ? NaN : d ? x : 1 / 0);
  }

  external = false;

  // Initial estimate.
  s = Math.sqrt(+x);

  // Math.sqrt underflow/overflow?
  // Pass x to Math.sqrt as integer, then adjust the exponent of the result.
  if (s == 0 || s == 1 / 0) {
    n = digitsToString(d);

    if ((n.length + e) % 2 == 0) n += '0';
    s = Math.sqrt(n);
    e = mathfloor((e + 1) / 2) - (e &lt; 0 || e % 2);

    if (s == 1 / 0) {
      n = '1e' + e;
    } else {
      n = s.toExponential();
      n = n.slice(0, n.indexOf('e') + 1) + e;
    }

    r = new Ctor(n);
  } else {
    r = new Ctor(s.toString());
  }

  sd = (e = Ctor.precision) + 3;

  // Newton-Raphson iteration.
  for (;;) {
    t = r;
    r = t.plus(divide(x, t, sd + 2, 1)).times(0.5);

    // TODO? Replace with for-loop and checkRoundingDigits.
    if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
      n = n.slice(sd - 3, sd + 1);

      // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or
      // 4999, i.e. approaching a rounding boundary, continue the iteration.
      if (n == '9999' || !rep &amp;&amp; n == '4999') {

        // On the first iteration only, check to see if rounding up gives the exact result as the
        // nines may infinitely repeat.
        if (!rep) {
          finalise(t, e + 1, 0);

          if (t.times(t).eq(x)) {
            r = t;
            break;
          }
        }

        sd += 4;
        rep = 1;
      } else {

        // If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.
        // If not, then there are further digits and m will be truthy.
        if (!+n || !+n.slice(1) &amp;&amp; n.charAt(0) == '5') {

          // Truncate to the first rounding digit.
          finalise(r, e + 1, 1);
          m = !r.times(r).eq(x);
        }

        break;
      }
    }
  }

  external = true;

  return finalise(r, e, Ctor.rounding, m);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.sub" id="apidoc.element.mathjs.type.BigNumber.prototype.sub">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>sub
        <span class="apidocSignatureSpan">(y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sub = function (y) {
  var d, e, i, j, k, len, pr, rm, xd, xe, xLTy, yd,
    x = this,
    Ctor = x.constructor;

  y = new Ctor(y);

  // If either is not finite...
  if (!x.d || !y.d) {

    // Return NaN if either is NaN.
    if (!x.s || !y.s) y = new Ctor(NaN);

    // Return y negated if x is finite and y is Â±Infinity.
    else if (x.d) y.s = -y.s;

    // Return x if y is finite and x is Â±Infinity.
    // Return x if both are Â±Infinity with different signs.
    // Return NaN if both are Â±Infinity with the same sign.
    else y = new Ctor(y.d || x.s !== y.s ? x : NaN);

    return y;
  }

  // If signs differ...
  if (x.s != y.s) {
    y.s = -y.s;
    return x.plus(y);
  }

  xd = x.d;
  yd = y.d;
  pr = Ctor.precision;
  rm = Ctor.rounding;

  // If either is zero...
  if (!xd[0] || !yd[0]) {

    // Return y negated if x is zero and y is non-zero.
    if (yd[0]) y.s = -y.s;

    // Return x if y is zero and x is non-zero.
    else if (xd[0]) y = new Ctor(x);

    // Return zero if both are zero.
    // From IEEE 754 (2008) 6.3: 0 - 0 = -0 - -0 = -0 when rounding to -Infinity.
    else return new Ctor(rm === 3 ? -0 : 0);

    return external ? finalise(y, pr, rm) : y;
  }

  // x and y are finite, non-zero numbers with the same sign.

  // Calculate base 1e7 exponents.
  e = mathfloor(y.e / LOG_BASE);
  xe = mathfloor(x.e / LOG_BASE);

  xd = xd.slice();
  k = xe - e;

  // If base 1e7 exponents differ...
  if (k) {
    xLTy = k &lt; 0;

    if (xLTy) {
      d = xd;
      k = -k;
      len = yd.length;
    } else {
      d = yd;
      e = xe;
      len = xd.length;
    }

    // Numbers with massively different exponents would result in a very high number of
    // zeros needing to be prepended, but this can be avoided while still ensuring correct
    // rounding by limiting the number of zeros to `Math.ceil(pr / LOG_BASE) + 2`.
    i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;

    if (k &gt; i) {
      k = i;
      d.length = 1;
    }

    // Prepend zeros to equalise exponents.
    d.reverse();
    for (i = k; i--;) d.push(0);
    d.reverse();

  // Base 1e7 exponents equal.
  } else {

    // Check digits to determine which is the bigger number.

    i = xd.length;
    len = yd.length;
    xLTy = i &lt; len;
    if (xLTy) len = i;

    for (i = 0; i &lt; len; i++) {
      if (xd[i] != yd[i]) {
        xLTy = xd[i] &lt; yd[i];
        break;
      }
    }

    k = 0;
  }

  if (xLTy) {
    d = xd;
    xd = yd;
    yd = d;
    y.s = -y.s;
  }

  len = xd.length;

  // Append zeros to `xd` if shorter.
  // Don't add zeros to `yd` if shorter as subtraction only needs to start at `yd` length.
  for (i = yd.length - len; i &gt; 0; --i) xd[len++] = 0;

  // Subtract yd from xd.
  for (i = yd.length; i &gt; k;) {

    if (xd[--i] &lt; yd[i]) {
      for (j = i; j &amp;&amp; xd[--j] === 0;) xd[j] = BASE - 1;
      --xd[j];
      xd[i] += BASE;
    }

    xd[i] -= yd[i];
  }

  // Remove trailing zeros.
  for (; xd[--len] === 0;) xd.pop();

  // Remove leading zeros and adjust exponent accordingly.
  for (; xd[0] === 0; xd.shift()) --e;

  // Zero?
  if (!xd[0]) return new Ctor(rm === 3 ? -0 : 0);

  y.d = xd;
  y.e = getBase10Exponent(xd, e);

  return external ? finalise(y, pr, rm) : y;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var subtract = typed('subtract', {

'number, number': function (x, y) {
  return x - y;
},

'Complex, Complex': function (x, y) {
  return x.<span class="apidocCodeKeywordSpan">sub</span>(y);
},

'BigNumber, BigNumber': function (x, y) {
  return x.minus(y);
},

'Fraction, Fraction': function (x, y) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.tan" id="apidoc.element.mathjs.type.BigNumber.prototype.tan">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>tan
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tan = function () {
  var pr, rm,
    x = this,
    Ctor = x.constructor;

  if (!x.isFinite()) return new Ctor(NaN);
  if (x.isZero()) return new Ctor(x);

  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 10;
  Ctor.rounding = 1;

  x = x.sin();
  x.s = 1;
  x = divide(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);

  Ctor.precision = pr;
  Ctor.rounding = rm;

  return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Syntax:
*
*    math.atan(x)
*
* Examples:
*
*    math.atan(0.5);           // returns number 0.4636476090008061
*    math.atan(math.<span class="apidocCodeKeywordSpan">tan</span>(1.5)); // returns number 1.5
*
*    math.atan(2);             // returns Complex 1.5707963267948966 -1.3169578969248166 i
*
* See also:
*
*    tan, asin, acos
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.tangent" id="apidoc.element.mathjs.type.BigNumber.prototype.tangent">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>tangent
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tangent = function () {
  var pr, rm,
    x = this,
    Ctor = x.constructor;

  if (!x.isFinite()) return new Ctor(NaN);
  if (x.isZero()) return new Ctor(x);

  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 10;
  Ctor.rounding = 1;

  x = x.sin();
  x.s = 1;
  x = divide(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);

  Ctor.precision = pr;
  Ctor.rounding = rm;

  return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.tanh" id="apidoc.element.mathjs.type.BigNumber.prototype.tanh">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>tanh
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tanh = function () {
  var pr, rm,
    x = this,
    Ctor = x.constructor;

  if (!x.isFinite()) return new Ctor(x.s);
  if (x.isZero()) return new Ctor(x);

  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 7;
  Ctor.rounding = 1;

  return divide(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
*    math.coth(x)
*
* Examples:
*
*    // coth(x) = 1 / tanh(x)
*    math.coth(2);         // returns 1.0373147207275482
*    1 / math.<span class="apidocCodeKeywordSpan">tanh</span>(2);     // returns 1.0373147207275482
*
* See also:
*
*    sinh, tanh, cosh
*
* @param {number | Complex | Unit | Array | Matrix} x  Function input
* @return {number | Complex | Array | Matrix} Hyperbolic cotangent of x
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.times" id="apidoc.element.mathjs.type.BigNumber.prototype.times">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>times
        <span class="apidocSignatureSpan">(y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">times = function (y) {
  var carry, e, i, k, r, rL, t, xdL, ydL,
    x = this,
    Ctor = x.constructor,
    xd = x.d,
    yd = (y = new Ctor(y)).d;

  y.s *= x.s;

   // If either is NaN, Â±Infinity or Â±0...
  if (!xd || !xd[0] || !yd || !yd[0]) {

    return new Ctor(!y.s || xd &amp;&amp; !xd[0] &amp;&amp; !yd || yd &amp;&amp; !yd[0] &amp;&amp; !xd

      // Return NaN if either is NaN.
      // Return NaN if x is Â±0 and y is Â±Infinity, or y is Â±0 and x is Â±Infinity.
      ? NaN

      // Return Â±Infinity if either is Â±Infinity.
      // Return Â±0 if either is Â±0.
      : !xd || !yd ? y.s / 0 : y.s * 0);
  }

  e = mathfloor(x.e / LOG_BASE) + mathfloor(y.e / LOG_BASE);
  xdL = xd.length;
  ydL = yd.length;

  // Ensure xd points to the longer array.
  if (xdL &lt; ydL) {
    r = xd;
    xd = yd;
    yd = r;
    rL = xdL;
    xdL = ydL;
    ydL = rL;
  }

  // Initialise the result array with zeros.
  r = [];
  rL = xdL + ydL;
  for (i = rL; i--;) r.push(0);

  // Multiply!
  for (i = ydL; --i &gt;= 0;) {
    carry = 0;
    for (k = xdL + i; k &gt; i;) {
      t = r[k] + yd[i] * xd[k - i - 1] + carry;
      r[k--] = t % BASE | 0;
      carry = t / BASE | 0;
    }

    r[k] = (r[k] + carry) % BASE | 0;
  }

  // Remove trailing zeros.
  for (; !r[--rL];) r.pop();

  if (carry) ++e;
  else r.shift();

  y.d = r;
  y.e = getBase10Exponent(r, e);

  return external ? finalise(y, Ctor.precision, Ctor.rounding) : y;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
},

'Complex': function (x) {
  return x.mul(x).mul(x); // Is faster than pow(x, 3)
},

'BigNumber': function (x) {
  return x.<span class="apidocCodeKeywordSpan">times</span>(x).times(x);
},

'Fraction': function (x) {
  return x.pow(3); // Is faster than mul()mul()mul()
},

'Array | Matrix': function (x) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.toBinary" id="apidoc.element.mathjs.type.BigNumber.prototype.toBinary">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>toBinary
        <span class="apidocSignatureSpan">(sd, rm)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toBinary = function (sd, rm) {
  return toStringBinary(this, 2, sd, rm);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.toDP" id="apidoc.element.mathjs.type.BigNumber.prototype.toDP">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>toDP
        <span class="apidocSignatureSpan">(dp, rm)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toDP = function (dp, rm) {
  var x = this,
    Ctor = x.constructor;

  x = new Ctor(x);
  if (dp === void 0) return x;

  checkInt32(dp, 0, MAX_DIGITS);

  if (rm === void 0) rm = Ctor.rounding;
  else checkInt32(rm, 0, 8);

  return finalise(x, dp + x.e + 1, rm);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.toDecimalPlaces" id="apidoc.element.mathjs.type.BigNumber.prototype.toDecimalPlaces">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>toDecimalPlaces
        <span class="apidocSignatureSpan">(dp, rm)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toDecimalPlaces = function (dp, rm) {
  var x = this,
    Ctor = x.constructor;

  x = new Ctor(x);
  if (dp === void 0) return x;

  checkInt32(dp, 0, MAX_DIGITS);

  if (rm === void 0) rm = Ctor.rounding;
  else checkInt32(rm, 0, 8);

  return finalise(x, dp + x.e + 1, rm);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var _n = n.toNumber();
  return x.round(_n);
},

'number, BigNumber': function (x, n) {
  if (!n.isInteger()) {throw new TypeError(NO_INT);}

  return new type.BigNumber(x).<span class="apidocCodeKeywordSpan">toDecimalPlaces</span>(n.toNumber());
},

'BigNumber': function (x) {
  return x.toDecimalPlaces(0);
},

'BigNumber, BigNumber': function (x, n) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.toExponential" id="apidoc.element.mathjs.type.BigNumber.prototype.toExponential">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>toExponential
        <span class="apidocSignatureSpan">(dp, rm)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toExponential = function (dp, rm) {
  var str,
    x = this,
    Ctor = x.constructor;

  if (dp === void 0) {
    str = finiteToString(x, true);
  } else {
    checkInt32(dp, 0, MAX_DIGITS);

    if (rm === void 0) rm = Ctor.rounding;
    else checkInt32(rm, 0, 8);

    x = finalise(new Ctor(x), dp + 1, rm);
    str = finiteToString(x, true, dp + 1);
  }

  return x.isNeg() &amp;&amp; !x.isZero() ? '-' + str : str;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  // handle the various notations
  switch (notation) {
case 'fixed':
  return exports.toFixed(value, precision);

case 'exponential':
  return exports.<span class="apidocCodeKeywordSpan">toExponential</span>(value, precision);

case 'auto':
  // determine lower and upper bound for exponential notation.
  // TODO: implement support for upper and lower to be BigNumbers themselves
  var lower = 1e-3;
  var upper = 1e5;
  if (options &amp;&amp; options.exponential) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.toFixed" id="apidoc.element.mathjs.type.BigNumber.prototype.toFixed">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>toFixed
        <span class="apidocSignatureSpan">(dp, rm)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toFixed = function (dp, rm) {
  var str, y,
    x = this,
    Ctor = x.constructor;

  if (dp === void 0) {
    str = finiteToString(x);
  } else {
    checkInt32(dp, 0, MAX_DIGITS);

    if (rm === void 0) rm = Ctor.rounding;
    else checkInt32(rm, 0, 8);

    y = finalise(new Ctor(x), dp + x.e + 1, rm);
    str = finiteToString(y, false, dp + y.e + 1);
  }

  // To determine whether to add the minus sign look at the value before it was rounded,
  // i.e. look at `x` rather than `y`.
  return x.isNeg() &amp;&amp; !x.isZero() ? '-' + str : str;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*    math.format(12.071, {notation: 'fixed'});                // returns '12'
*    math.format(2.3,    {notation: 'fixed', precision: 2});  // returns '2.30'
*    math.format(52.8,   {notation: 'exponential'});          // returns '5.28e+1'
*    math.format(12400,  {notation: 'engineering'});         // returns '12.400e+3'
*
*    function formatCurrency(value) {
*      // return currency notation with two digits:
*      return '$' + value.<span class="apidocCodeKeywordSpan">toFixed</span>(2);
*
*      // you could also use math.format inside the callback:
*      // return '$' + math.format(value, {notation: 'fixed', precision: 2});
*    }
*    math.format([2.1, 3, 0.016], formatCurrency};            // returns '[$2.10, $3.00, $0.02]'
*
* See also:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.toFraction" id="apidoc.element.mathjs.type.BigNumber.prototype.toFraction">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>toFraction
        <span class="apidocSignatureSpan">(maxD)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toFraction = function (maxD) {
  var d, d0, d1, d2, e, k, n, n0, n1, pr, q, r,
    x = this,
    xd = x.d,
    Ctor = x.constructor;

  if (!xd) return new Ctor(x);

  n1 = d0 = new Ctor(1);
  d1 = n0 = new Ctor(0);

  d = new Ctor(d1);
  e = d.e = getPrecision(xd) - x.e - 1;
  k = e % LOG_BASE;
  d.d[0] = mathpow(10, k &lt; 0 ? LOG_BASE + k : k);

  if (maxD == null) {

    // d is 10**e, the minimum max-denominator needed.
    maxD = e &gt; 0 ? d : n1;
  } else {
    n = new Ctor(maxD);
    if (!n.isInt() || n.lt(n1)) throw Error(invalidArgument + n);
    maxD = n.gt(d) ? (e &gt; 0 ? d : n1) : n;
  }

  external = false;
  n = new Ctor(digitsToString(xd));
  pr = Ctor.precision;
  Ctor.precision = e = xd.length * LOG_BASE * 2;

  for (;;)  {
    q = divide(n, d, 0, 1, 1);
    d2 = d0.plus(q.times(d1));
    if (d2.cmp(maxD) == 1) break;
    d0 = d1;
    d1 = d2;
    d2 = n1;
    n1 = n0.plus(q.times(d2));
    n0 = d2;
    d2 = d;
    d = n.minus(q.times(d2));
    n = d2;
  }

  d2 = divide(maxD.minus(d0), d1, 0, 1, 1);
  n0 = n0.plus(d2.times(n1));
  d0 = d0.plus(d2.times(d1));
  n0.s = n1.s = x.s;

  // Determine which fraction is closer to x, n0/d0 or n1/d1?
  r = divide(n1, d1, e, 1).minus(x).abs().cmp(divide(n0, d0, e, 1).minus(x).abs()) &lt; 1
      ? [n1, d1] : [n0, d0];

  Ctor.precision = pr;
  external = true;

  return r;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.toHex" id="apidoc.element.mathjs.type.BigNumber.prototype.toHex">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>toHex
        <span class="apidocSignatureSpan">(sd, rm)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toHex = function (sd, rm) {
  return toStringBinary(this, 16, sd, rm);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.toHexadecimal" id="apidoc.element.mathjs.type.BigNumber.prototype.toHexadecimal">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>toHexadecimal
        <span class="apidocSignatureSpan">(sd, rm)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toHexadecimal = function (sd, rm) {
  return toStringBinary(this, 16, sd, rm);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.toJSON" id="apidoc.element.mathjs.type.BigNumber.prototype.toJSON">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function () {
  return {
    mathjs: 'BigNumber',
    value: this.toString()
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.toNearest" id="apidoc.element.mathjs.type.BigNumber.prototype.toNearest">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>toNearest
        <span class="apidocSignatureSpan">(y, rm)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toNearest = function (y, rm) {
  var x = this,
    Ctor = x.constructor;

  x = new Ctor(x);

  if (y == null) {

    // If x is not finite, return x.
    if (!x.d) return x;

    y = new Ctor(1);
    rm = Ctor.rounding;
  } else {
    y = new Ctor(y);
    if (rm !== void 0) checkInt32(rm, 0, 8);

    // If x is not finite, return x if y is not NaN, else NaN.
    if (!x.d) return y.s ? x : y;

    // If y is not finite, return Infinity with the sign of x if y is Infinity, else NaN.
    if (!y.d) {
      if (y.s) y.s = x.s;
      return y;
    }
  }

  // If y is not zero, calculate the nearest multiple of y to x.
  if (y.d[0]) {
    external = false;
    if (rm &lt; 4) rm = [4, 5, 7, 8][rm];
    x = divide(x, y, 0, rm, 1).times(y);
    external = true;
    finalise(x);

  // If y is zero, return zero with the sign of x.
  } else {
    y.s = x.s;
    x = y;
  }

  return x;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.toNumber" id="apidoc.element.mathjs.type.BigNumber.prototype.toNumber">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>toNumber
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toNumber = function () {
  return +this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  convert: function (x) {
    return x + '';
  }
}, {
  from: 'BigNumber',
  to: 'Complex',
  convert: function (x) {
    return new type.Complex(x.<span class="apidocCodeKeywordSpan">toNumber</span>(), 0);
  }
}, {
  from: 'Fraction',
  to: 'BigNumber',
  convert: function (x) {
    throw new TypeError('Cannot implicitly convert a Fraction to BigNumber or vice versa. ' +
        'Use function bignumber(x) to convert to BigNumber or fraction(x) to convert to Fraction.');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.toOctal" id="apidoc.element.mathjs.type.BigNumber.prototype.toOctal">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>toOctal
        <span class="apidocSignatureSpan">(sd, rm)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toOctal = function (sd, rm) {
  return toStringBinary(this, 8, sd, rm);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.toPower" id="apidoc.element.mathjs.type.BigNumber.prototype.toPower">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>toPower
        <span class="apidocSignatureSpan">(y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toPower = function (y) {
  var e, k, pr, r, rm, sign, yIsInt,
    x = this,
    Ctor = x.constructor,
    yn = +(y = new Ctor(y));

  // Either Â±Infinity, NaN or Â±0?
  if (!x.d || !y.d || !x.d[0] || !y.d[0]) return  new Ctor(mathpow(+x, yn));

  x = new Ctor(x);

  if (x.eq(1)) return x;

  pr = Ctor.precision;
  rm = Ctor.rounding;

  if (y.eq(1)) return finalise(x, pr, rm);

  e = mathfloor(y.e / LOG_BASE);
  k = y.d.length - 1;
  yIsInt = e &gt;= k;
  sign = x.s;

  if (!yIsInt) {
    if (sign &lt; 0) return new Ctor(NaN);

  // If y is a small integer use the 'exponentiation by squaring' algorithm.
  } else if ((k = yn &lt; 0 ? -yn : yn) &lt;= MAX_SAFE_INTEGER) {
    r = intPow(Ctor, x, k, pr);
    return y.s &lt; 0 ? new Ctor(1).div(r) : finalise(r, pr, rm);
  }

  // Result is negative if x is negative and the last digit of integer y is odd.
  sign = sign &lt; 0 &amp;&amp; y.d[Math.max(e, k)] &amp; 1 ? -1 : 1;

  // Estimate result exponent.
  // x^y = 10^e,  where e = y * log10(x)
  // log10(x) = log10(x_significand) + x_exponent
  // log10(x_significand) = ln(x_significand) / ln(10)
  k = mathpow(+x, yn);
  e = k == 0 || !isFinite(k)
    ? mathfloor(yn * (Math.log('0.' + digitsToString(x.d)) / Math.LN10 + x.e + 1))
    : new Ctor(k + '').e;

  // Estimate may be incorrect e.g. x: 0.999999999999999999, y: 2.29, e: 0, r.e: -1.

  // Overflow/underflow?
  if (e &gt; Ctor.maxE + 1 || e &lt; Ctor.minE - 1) return new Ctor(e &gt; 0 ? sign / 0 : 0);

  external = false;
  Ctor.rounding = x.s = 1;

  // Estimate the extra guard digits needed to ensure five correct rounding digits from
  // naturalLogarithm(x). Example of failure without these extra digits (precision: 10):
  // new Decimal(2.32456).pow('2087987436534566.46411')
  // should be 1.162377823e+764914905173815, but is 1.162355823e+764914905173815
  k = Math.min(12, (e + '').length);

  // r = x^y = exp(y*ln(x))
  r = naturalExponential(y.times(naturalLogarithm(x, pr + k)), pr);

  // Truncate to the required precision plus five rounding digits.
  r = finalise(r, pr + 5, 1);

  // If the rounding digits are [49]9999 or [50]0000 increase the precision by 10 and recalculate
  // the result.
  if (checkRoundingDigits(r.d, pr, rm)) {
    e = pr + 10;

    // Truncate to the increased precision plus five rounding digits.
    r = finalise(naturalExponential(y.times(naturalLogarithm(x, e + k)), e), e + 5, 1);

    // Check for 14 nines from the 2nd rounding digit (the first rounding digit may be 4 or 9).
    if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 1e14) {
      r = finalise(r, pr + 1, 0);
    }
  }

  r.s = sign;
  external = true;
  Ctor.rounding = rm;

  return finalise(r, pr, rm);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.toPrecision" id="apidoc.element.mathjs.type.BigNumber.prototype.toPrecision">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>toPrecision
        <span class="apidocSignatureSpan">(sd, rm)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toPrecision = function (sd, rm) {
  var str,
    x = this,
    Ctor = x.constructor;

  if (sd === void 0) {
    str = finiteToString(x, x.e &lt;= Ctor.toExpNeg || x.e &gt;= Ctor.toExpPos);
  } else {
    checkInt32(sd, 1, MAX_DIGITS);

    if (rm === void 0) rm = Ctor.rounding;
    else checkInt32(rm, 0, 8);

    x = finalise(new Ctor(x), sd, rm);
    str = finiteToString(x, sd &lt;= x.e || x.e &lt;= Ctor.toExpNeg, sd);
  }

  return x.isNeg() &amp;&amp; !x.isZero() ? '-' + str : str;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     return inv ? zero : a;
   }

   var x = a.abs().pow(one.div(root));
   // If a &lt; 0, we require that root is an odd integer,
   // so (-1) ^ (1/root) = -1
   x = a.isNeg() ? x.neg() : x;
   return new type.BigNumber((inv ? one.div(x) : x).<span class="apidocCodeKeywordSpan">toPrecision</span>(precision));
 }
}

/**
* Calculate the nth root of a, solve x^root == a
* http://rosettacode.org/wiki/Nth_root#JavaScript
* @param {number} a
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.toSD" id="apidoc.element.mathjs.type.BigNumber.prototype.toSD">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>toSD
        <span class="apidocSignatureSpan">(sd, rm)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toSD = function (sd, rm) {
  var x = this,
    Ctor = x.constructor;

  if (sd === void 0) {
    sd = Ctor.precision;
    rm = Ctor.rounding;
  } else {
    checkInt32(sd, 1, MAX_DIGITS);

    if (rm === void 0) rm = Ctor.rounding;
    else checkInt32(rm, 0, 8);
  }

  return finalise(new Ctor(x), sd, rm);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.toSignificantDigits" id="apidoc.element.mathjs.type.BigNumber.prototype.toSignificantDigits">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>toSignificantDigits
        <span class="apidocSignatureSpan">(sd, rm)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toSignificantDigits = function (sd, rm) {
  var x = this,
    Ctor = x.constructor;

  if (sd === void 0) {
    sd = Ctor.precision;
    rm = Ctor.rounding;
  } else {
    checkInt32(sd, 1, MAX_DIGITS);

    if (rm === void 0) rm = Ctor.rounding;
    else checkInt32(rm, 0, 8);
  }

  return finalise(new Ctor(x), sd, rm);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (value.isZero()) return '0';

// determine whether or not to output exponential notation
var str;
var abs = value.abs();
if (abs.gte(lower) &amp;&amp; abs.lt(upper)) {
  // normal number notation
  str = value.<span class="apidocCodeKeywordSpan">toSignificantDigits</span>(precision).toFixed();
}
else {
  // exponential notation
  str = exports.toExponential(value, precision);
}

// remove trailing zeros after the decimal point
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.toString" id="apidoc.element.mathjs.type.BigNumber.prototype.toString">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
  var x = this,
    Ctor = x.constructor,
    str = finiteToString(x, x.e &lt;= Ctor.toExpNeg || x.e &gt;= Ctor.toExpPos);

  return x.isNeg() &amp;&amp; !x.isZero() ? '-' + str : str;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      }
      else {
        scope.ans = res;
        console.log(format(res));
      }
    }
    else if (res instanceof math.type.Help) {
      console.log(res.<span class="apidocCodeKeywordSpan">toString</span>());
    }
    else {
      scope.ans = res;
      console.log(format(res));
    }
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.trunc" id="apidoc.element.mathjs.type.BigNumber.prototype.trunc">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>trunc
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">trunc = function () {
  return finalise(new this.constructor(this), this.e + 1, 1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.truncated" id="apidoc.element.mathjs.type.BigNumber.prototype.truncated">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>truncated
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">truncated = function () {
  return finalise(new this.constructor(this), this.e + 1, 1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.BigNumber.prototype.valueOf" id="apidoc.element.mathjs.type.BigNumber.prototype.valueOf">
        function <span class="apidocSignatureSpan">mathjs.type.BigNumber.prototype.</span>valueOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">valueOf = function () {
  var x = this,
    Ctor = x.constructor,
    str = finiteToString(x, x.e &lt;= Ctor.toExpNeg || x.e &gt;= Ctor.toExpPos);

  return x.isNeg() ? '-' + str : str;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    throw new TypeError('Cannot implicitly convert a Fraction to BigNumber or vice versa. ' +
        'Use function bignumber(x) to convert to BigNumber or fraction(x) to convert to Fraction.');
  }
}, {
  from: 'Fraction',
  to: 'Complex',
  convert: function (x) {
    return new type.Complex(x.<span class="apidocCodeKeywordSpan">valueOf</span>(), 0);
  }
}, {
  from: 'number',
  to: 'Fraction',
  convert: function (x) {
    if (digits(x) &gt; 15) {
      throw new TypeError('Cannot implicitly convert a number with &gt;15 significant digits to Fraction ' +
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.type.Chain" id="apidoc.module.mathjs.type.Chain">module mathjs.type.Chain</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.Chain" id="apidoc.element.mathjs.type.Chain.Chain">
        function <span class="apidocSignatureSpan">mathjs.type.</span>Chain
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Chain(value) {
  if (!(this instanceof Chain)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  if (value &amp;&amp; value.isChain) {
    this.value = value.value;
  }
  else {
    this.value = value;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.createProxy" id="apidoc.element.mathjs.type.Chain.createProxy">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.</span>createProxy
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createProxy = function (arg0, arg1) {
  if (typeof arg0 === 'string') {
    // createProxy(name, value)
    createProxy(arg0, arg1);
  }
  else {
    // createProxy(values)
    for (var prop in arg0) {
      if (arg0.hasOwnProperty(prop)) {
        createProxy(prop, arg0[prop]);
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
}

/**
 * Create a proxy for a single method, or an object with multiple methods.
 * Example usage:
 *
 *   Chain.<span class="apidocCodeKeywordSpan">createProxy</span>('add', function add (x, y) {...});
 *   Chain.createProxy({
 *     add:      function add (x, y) {...},
 *     subtract: function subtract (x, y) {...}
 *   }
 *
 * @param {string | Object} arg0   A name (string), or an object with
 *                                 functions
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.type.Chain.prototype" id="apidoc.module.mathjs.type.Chain.prototype">module mathjs.type.Chain.prototype</a></h1>




    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.abs" id="apidoc.element.mathjs.type.Chain.prototype.abs">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>abs
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">abs = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function factory (type, config, load, typed) {
/**
 * Calculate the absolute value of a number. For matrices, the function is
 * evaluated element wise.
 *
 * Syntax:
 *
 *    math.<span class="apidocCodeKeywordSpan">abs</span>(x)
 *
 * Examples:
 *
 *    math.abs(3.5);                // returns number 3.5
 *    math.abs(-4.2);               // returns number 4.2
 *
 *    math.abs([3, -5, -1, 0, 2]);  // returns Array [3, 5, 1, 0, 2]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.acos" id="apidoc.element.mathjs.type.Chain.prototype.acos">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>acos
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">acos = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Calculate the inverse cosine of a value.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">acos</span>(x)
*
* Examples:
*
*    math.acos(0.5);           // returns number 1.0471975511965979
*    math.acos(math.cos(1.5)); // returns number 1.5
*
*    math.acos(2);             // returns Complex 0 + 1.3169578969248166 i
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.acosh" id="apidoc.element.mathjs.type.Chain.prototype.acosh">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>acosh
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">acosh = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Calculate the hyperbolic arccos of a value,
* defined as `acosh(x) = ln(sqrt(x^2 - 1) + x)`.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">acosh</span>(x)
*
* Examples:
*
*    math.acosh(1.5);       // returns 0.9624236501192069
*
* See also:
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.acot" id="apidoc.element.mathjs.type.Chain.prototype.acot">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>acot
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">acot = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Calculate the inverse cotangent of a value, defined as `acot(x) = atan(1/x)`.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">acot</span>(x)
*
* Examples:
*
*    math.acot(0.5);           // returns number 0.4636476090008061
*    math.acot(math.cot(1.5)); // returns number 1.5
*
*    math.acot(2);             // returns Complex 1.5707963267948966 -1.3169578969248166 i
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.acoth" id="apidoc.element.mathjs.type.Chain.prototype.acoth">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>acoth
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">acoth = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Calculate the hyperbolic arccotangent of a value,
* defined as `acoth(x) = atanh(1/x) = (ln((x+1)/x) + ln(x/(x-1))) / 2`.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">acoth</span>(x)
*
* Examples:
*
*    math.acoth(0.5);       // returns 0.8047189562170503
*
* See also:
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.acsc" id="apidoc.element.mathjs.type.Chain.prototype.acsc">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>acsc
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">acsc = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Calculate the inverse cosecant of a value, defined as `acsc(x) = asin(1/x)`.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">acsc</span>(x)
*
* Examples:
*
*    math.acsc(0.5);           // returns number 0.5235987755982989
*    math.acsc(math.csc(1.5)); // returns number ~1.5
*
*    math.acsc(2);             // returns Complex 1.5707963267948966 -1.3169578969248166 i
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.acsch" id="apidoc.element.mathjs.type.Chain.prototype.acsch">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>acsch
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">acsch = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Calculate the hyperbolic arccosecant of a value,
* defined as `acsch(x) = asinh(1/x) = ln(1/x + sqrt(1/x^2 + 1))`.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">acsch</span>(x)
*
* Examples:
*
*    math.acsch(0.5);       // returns 1.4436354751788103
*
* See also:
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.add" id="apidoc.element.mathjs.type.Chain.prototype.add">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>add
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">add = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
math.eval('5.08 cm to inch');     // 2 inch
math.eval('sin(45 deg) ^ 2');     // 0.5
math.eval('9 / 3 + 2i');          // 3 + 2i
math.eval('det([-1, 2; 3, 1])');  // -7

// chaining
math.chain(3)
    .<span class="apidocCodeKeywordSpan">add</span>(4)
    .multiply(2)
    .done(); // 14
```

## Browser support

Math.js works on any ES5 compatible JavaScript engine: node.js 0.10, and Internet Explorer 9 and newer, and all other browsers (
Chrome, Firefox, Safari). If support for old browsers like Internet Explorer 8 is required, the [es5-shim](https://github.com/kriskowal
/es5-shim) library has to be loaded.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.and" id="apidoc.element.mathjs.type.Chain.prototype.and">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>and
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">and = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  /**
* Logical `and`. Test whether two values are both defined with a nonzero/nonempty value.
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">and</span>(x, y)
*
* Examples:
*
*    math.and(2, 4);   // returns true
*
*    a = [2, 0, 0];
*    b = [3, 7, 0];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.arg" id="apidoc.element.mathjs.type.Chain.prototype.arg">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>arg
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">arg = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   *                               the principal root is returned.
   * @returns {Complex | Array.&lt;Complex&gt; | Matrix.&lt;Complex&gt;} Returns the cubic root(s) of x
   * @private
   */
  function _cbrtComplex(x, allRoots) {
// https://www.wikiwand.com/en/Cube_root#/Complex_numbers

var arg_3 = x.<span class="apidocCodeKeywordSpan">arg</span>() / 3;
var abs = x.abs();

// principal root:
var principal = new type.Complex(_cbrtNumber(abs), 0).mul(
    new type.Complex(0, arg_3).exp());

if (allRoots) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.asec" id="apidoc.element.mathjs.type.Chain.prototype.asec">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>asec
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">asec = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Calculate the inverse secant of a value. Defined as `asec(x) = acos(1/x)`.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">asec</span>(x)
*
* Examples:
*
*    math.asec(0.5);           // returns 1.0471975511965979
*    math.asec(math.sec(1.5)); // returns 1.5
*
*    math.asec(2);             // returns 0 + 1.3169578969248166 i
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.asech" id="apidoc.element.mathjs.type.Chain.prototype.asech">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>asech
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">asech = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Calculate the hyperbolic arcsecant of a value,
* defined as `asech(x) = acosh(1/x) = ln(sqrt(1/x^2 - 1) + 1/x)`.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">asech</span>(x)
*
* Examples:
*
*    math.asech(0.5);       // returns 1.3169578969248166
*
* See also:
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.asin" id="apidoc.element.mathjs.type.Chain.prototype.asin">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>asin
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">asin = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   *
   * @param {number | Complex | Array | Matrix} x   Function input
   * @return {number | Complex | Array | Matrix} The arc cosecant of x
   */
  var acsc = typed('acsc', {
'number': function (x) {
  if (x &lt;= -1 || x &gt;= 1 || config.predictable) {
    return Math.<span class="apidocCodeKeywordSpan">asin</span>(1 / x);
  }
  return new type.Complex(x, 0).acsc();
},

'Complex': function (x) {
  return x.acsc();
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.asinh" id="apidoc.element.mathjs.type.Chain.prototype.asinh">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>asinh
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">asinh = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  },

  'Complex': function (x) {
    return x.acsch();
  },

  'BigNumber': function (x) {
    return new type.BigNumber(1).div(x).<span class="apidocCodeKeywordSpan">asinh</span>();
  },

  'Array | Matrix': function (x) {
    return deepMap(x, acsch);
  }
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.atan" id="apidoc.element.mathjs.type.Chain.prototype.atan">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>atan
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">atan = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   *    cot, atan
   *
   * @param {number | Complex | Array | Matrix} x   Function input
   * @return {number | Complex | Array | Matrix} The arc cotangent of x
   */
  var acot = typed('acot', {
'number': function (x) {
  return Math.<span class="apidocCodeKeywordSpan">atan</span>(1 / x);
},

'Complex': function (x) {
  return x.acot();
},

'BigNumber': function (x) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.atan2" id="apidoc.element.mathjs.type.Chain.prototype.atan2">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>atan2
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">atan2 = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```js
// load math.js
var math = require('mathjs');

// functions and constants
math.round(math.e, 3);            // 2.718
math.<span class="apidocCodeKeywordSpan">atan2</span>(3, -3) / math.pi;      // 0.75
math.log(1000, 10);               // 3
math.sqrt(-4);                    // 2i
math.pow([[-1, 2], [3, 1]], 2);   // [[7, 0], [0, 7]]
math.derivative('x^2 + x', 'x');  // 2 * x + 1

// expressions
math.eval('12 / (2.3 + 0.7)');    // 4
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.atanh" id="apidoc.element.mathjs.type.Chain.prototype.atanh">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>atanh
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">atanh = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  },

  'Complex': function (x) {
    return x.acoth();
  },

  'BigNumber': function (x) {
    return new type.BigNumber(1).div(x).<span class="apidocCodeKeywordSpan">atanh</span>();
  },

  'Array | Matrix': function (x) {
    return deepMap(x, acoth);
  }
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.bellNumbers" id="apidoc.element.mathjs.type.Chain.prototype.bellNumbers">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>bellNumbers
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bellNumbers = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* The Bell Numbers count the number of partitions of a set. A partition is a pairwise disjoint subset of S whose union is S.
* bellNumbers only takes integer arguments.
* The following condition must be enforced: n &gt;= 0
*
* Syntax:
*
*   math.<span class="apidocCodeKeywordSpan">bellNumbers</span>(n)
*
* Examples:
*
*    math.bellNumbers(3); // returns 5;
*    math.bellNumbers(8); // returns 4140;
*
* See also:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.bignumber" id="apidoc.element.mathjs.type.Chain.prototype.bignumber">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>bignumber
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bignumber = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
ConstantNode.prototype._compile = function (defs, args) {
  switch (this.valueType) {
    case 'number':
      // TODO: replace this with using config.number
      var numConfig = defs.math.config().number;
      if (numConfig === 'BigNumber') {
        return 'math.<span class="apidocCodeKeywordSpan">bignumber</span>("' + this.value + '")';
      }
      else if (numConfig === 'Fraction') {
        return 'math.fraction("' + this.value + '")';
      }
      else {
        // remove leading zeros like '003.2' which are not allowed by JavaScript
        return this.value.replace(/^(0*)[0-9]/, function (match, zeros) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.bitAnd" id="apidoc.element.mathjs.type.Chain.prototype.bitAnd">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>bitAnd
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bitAnd = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  /**
* Bitwise AND two values, `x &amp; y`.
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">bitAnd</span>(x, y)
*
* Examples:
*
*    math.bitAnd(53, 131);               // returns number 1
*
*    math.bitAnd([1, 12, 31], 42);       // returns Array [0, 8, 10]
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.bitNot" id="apidoc.element.mathjs.type.Chain.prototype.bitNot">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>bitNot
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bitNot = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Bitwise NOT value, `~x`.
* For matrices, the function is evaluated element wise.
* For units, the function is evaluated on the best prefix base.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">bitNot</span>(x)
*
* Examples:
*
*    math.bitNot(1);               // returns number -2
*
*    math.bitNot([2, -3, 4]);      // returns Array [-3, 2, 5]
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.bitOr" id="apidoc.element.mathjs.type.Chain.prototype.bitOr">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>bitOr
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bitOr = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Bitwise OR two values, `x | y`.
* For matrices, the function is evaluated element wise.
* For units, the function is evaluated on the lowest print base.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">bitOr</span>(x, y)
*
* Examples:
*
*    math.bitOr(1, 2);               // returns number 3
*
*    math.bitOr([1, 2, 3], 4);       // returns Array [5, 6, 7]
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.bitXor" id="apidoc.element.mathjs.type.Chain.prototype.bitXor">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>bitXor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bitXor = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  /**
* Bitwise XOR two values, `x ^ y`.
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">bitXor</span>(x, y)
*
* Examples:
*
*    math.bitXor(1, 2);               // returns number 3
*
*    math.bitXor([2, 3, 4], 4);       // returns Array [6, 7, 0]
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.boolean" id="apidoc.element.mathjs.type.Chain.prototype.boolean">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>boolean
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">boolean = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* In case of a number, `true` is returned for non-zero numbers, and `false` in
* case of zero.
* Strings can be `'true'` or `'false'`, or can contain a number.
* When value is a matrix, all elements will be converted to boolean.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">boolean</span>(x)
*
* Examples:
*
*    math.boolean(0);     // returns false
*    math.boolean(1);     // returns true
*    math.boolean(-3);     // returns true
*    math.boolean('true');     // returns true
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.catalan" id="apidoc.element.mathjs.type.Chain.prototype.catalan">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>catalan
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">catalan = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* The Catalan Numbers enumerate combinatorial structures of many different types.
* catalan only takes integer arguments.
* The following condition must be enforced: n &gt;= 0
*
* Syntax:
*
*   math.<span class="apidocCodeKeywordSpan">catalan</span>(n)
*
* Examples:
*
*    math.catalan(3); // returns 5;
*    math.catalan(8); // returns 1430;
*
* See also:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.cbrt" id="apidoc.element.mathjs.type.Chain.prototype.cbrt">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>cbrt
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cbrt = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Calculate the cubic root of a value.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">cbrt</span>(x)
*    math.cbrt(x, allRoots)
*
* Examples:
*
*    math.cbrt(27);                  // returns 3
*    math.cube(3);                   // returns 27
*    math.cbrt(-64);                 // returns -4
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.ceil" id="apidoc.element.mathjs.type.Chain.prototype.ceil">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>ceil
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ceil = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Round a value towards plus infinity
* If `x` is complex, both real and imaginary part are rounded towards plus infinity.
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">ceil</span>(x)
*
* Examples:
*
*    math.ceil(3.2);               // returns number 4
*    math.ceil(3.8);               // returns number 4
*    math.ceil(-4.2);              // returns number -4
*    math.ceil(-4.7);              // returns number -4
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.chain" id="apidoc.element.mathjs.type.Chain.prototype.chain">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>chain
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">chain = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
math.eval('12 / (2.3 + 0.7)');    // 4
math.eval('5.08 cm to inch');     // 2 inch
math.eval('sin(45 deg) ^ 2');     // 0.5
math.eval('9 / 3 + 2i');          // 3 + 2i
math.eval('det([-1, 2; 3, 1])');  // -7

// chaining
math.<span class="apidocCodeKeywordSpan">chain</span>(3)
    .add(4)
    .multiply(2)
    .done(); // 14
```

## Browser support
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.clone" id="apidoc.element.mathjs.type.Chain.prototype.clone">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>clone
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clone = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return desc;
};

/**
 * Export the help object to JSON
 */
Help.prototype.toJSON = function () {
  var obj = object.<span class="apidocCodeKeywordSpan">clone</span>(this.doc);
  obj.mathjs = 'Help';
  return obj;
};

/**
 * Instantiate a Help object from a JSON object
 * @param {Object} json
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.combinations" id="apidoc.element.mathjs.type.Chain.prototype.combinations">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>combinations
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">combinations = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* possibilities.
*
* Combinations only takes integer arguments.
* The following condition must be enforced: k &lt;= n.
*
* Syntax:
*
*     math.<span class="apidocCodeKeywordSpan">combinations</span>(n, k)
*
* Examples:
*
*    math.combinations(7, 5); // returns 21
*
* See also:
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.compare" id="apidoc.element.mathjs.type.Chain.prototype.compare">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>compare
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compare = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* is smaller than the configured epsilon. The function cannot be used to
* compare values smaller than approximately 2.22e-16.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">compare</span>(x, y)
*
* Examples:
*
*    math.compare(6, 1);           // returns 1
*    math.compare(2, 3);           // returns -1
*    math.compare(7, 7);           // returns 0
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.compile" id="apidoc.element.mathjs.type.Chain.prototype.compile">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>compile
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*     parse(expr, options)
*     parse([expr1, expr2, expr3, ...])
*     parse([expr1, expr2, expr3, ...], options)
*
* Example:
*
*     var node = parse('sqrt(3^2 + 4^2)');
*     node.<span class="apidocCodeKeywordSpan">compile</span>(math).eval(); // 5
*
*     var scope = {a:3, b:4}
*     var node = parse('a * b'); // 12
*     var code = node.compile(math);
*     code.eval(scope); // 12
*     scope.a = 5;
*     code.eval(scope); // 20
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.complex" id="apidoc.element.mathjs.type.Chain.prototype.complex">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>complex
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">complex = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Syntax:
*
*    math.string(value)
*
* Examples:
*
*    math.string(4.2);               // returns string '4.2'
*    math.string(math.<span class="apidocCodeKeywordSpan">complex</span>(3, 2); // returns string '3 + 2i'
*
*    var u = math.unit(5, 'km');
*    math.string(u.to('m'));         // returns string '5000 m'
*
*    math.string([true, false]);     // returns ['true', 'false']
*
* See also:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.composition" id="apidoc.element.mathjs.type.Chain.prototype.composition">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>composition
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">composition = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* The composition counts of n into k parts.
*
* composition only takes integer arguments.
* The following condition must be enforced: k &lt;= n.
*
* Syntax:
*
*   math.<span class="apidocCodeKeywordSpan">composition</span>(n, k)
*
* Examples:
*
*    math.composition(5, 3); // returns 6
*
* See also:
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.concat" id="apidoc.element.mathjs.type.Chain.prototype.concat">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>concat
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">concat = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// figure out what number of arguments the callback function expects
var args = maxArgumentCount(callback);

var recurse = function (value, index) {
  if (Array.isArray(value)) {
    value.forEach(function (child, i) {
      // we create a copy of the index array and append the new index value
      recurse(child, index.<span class="apidocCodeKeywordSpan">concat</span>(i + 1)); // one based index, hence i+1
    });
  }
  else {
    // invoke the callback function with the right number of arguments
    if (args === 1) {
      callback(value);
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.config" id="apidoc.element.mathjs.type.Chain.prototype.config">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>config
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">config = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  /**
* Set configuration options for math.js, and get current options.
* Will emit a 'config' event, with arguments (curr, prev, changes).
*
* Syntax:
*
*     math.<span class="apidocCodeKeywordSpan">config</span>(config: Object): Object
*
* Examples:
*
*     math.config().number;                // outputs 'number'
*     math.eval('0.4');                    // outputs number 0.4
*     math.config({number: 'Fraction'});
*     math.eval('0.4');                    // outputs Fraction 2/5
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.conj" id="apidoc.element.mathjs.type.Chain.prototype.conj">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>conj
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">conj = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Compute the complex conjugate of a complex value.
* If `x = a+bi`, the complex conjugate of `x` is `a - bi`.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">conj</span>(x)
*
* Examples:
*
*    math.conj(math.complex('2 + 3i'));  // returns Complex 2 - 3i
*    math.conj(math.complex('2 - 3i'));  // returns Complex 2 + 3i
*    math.conj(math.complex('-5.2i'));  // returns Complex 5.2i
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.cos" id="apidoc.element.mathjs.type.Chain.prototype.cos">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>cos
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cos = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      var u1, u2,
          picked = -1;
      // We reject values outside of the interval [0, 1]
      // TODO: check if it is ok to do that?
      while (picked &lt; 0 || picked &gt; 1) {
        u1 = rng();
        u2 = rng();
        picked = 1/6 * Math.pow(-2 * Math.log(u1), 0.5) * Math.<span class="apidocCodeKeywordSpan">cos</span>(2 * Math.PI * u2) +
0.5;
      }
      return picked;
    }
  }
};

distribution.toTex = undefined; // use default template
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.cosh" id="apidoc.element.mathjs.type.Chain.prototype.cosh">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>cosh
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cosh = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Calculate the hyperbolic cosine of a value,
* defined as `cosh(x) = 1/2 * (exp(x) + exp(-x))`.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">cosh</span>(x)
*
* Examples:
*
*    math.cosh(0.5);       // returns number 1.1276259652063807
*
* See also:
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.cot" id="apidoc.element.mathjs.type.Chain.prototype.cot">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>cot
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cot = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Syntax:
*
*    math.acot(x)
*
* Examples:
*
*    math.acot(0.5);           // returns number 0.4636476090008061
*    math.acot(math.<span class="apidocCodeKeywordSpan">cot</span>(1.5)); // returns number 1.5
*
*    math.acot(2);             // returns Complex 1.5707963267948966 -1.3169578969248166 i
*
* See also:
*
*    cot, atan
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.coth" id="apidoc.element.mathjs.type.Chain.prototype.coth">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>coth
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">coth = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Calculate the hyperbolic cotangent of a value,
* defined as `coth(x) = 1 / tanh(x)`.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">coth</span>(x)
*
* Examples:
*
*    // coth(x) = 1 / tanh(x)
*    math.coth(2);         // returns 1.0373147207275482
*    1 / math.tanh(2);     // returns 1.0373147207275482
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.create" id="apidoc.element.mathjs.type.Chain.prototype.create">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>create
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *                              false (default), output type can vary depending
 *                              on input values. For example `math.sqrt(-4)`
 *                              returns `complex('2i')` when predictable is false, and
 *                              returns `NaN` when true.
 */
function create (config) {
  // create a new math.js instance
  var math = core.<span class="apidocCodeKeywordSpan">create</span>(config);
  math.create = create;

  // import data types, functions, constants, expression parser, etc.
  math['import'](require('./lib'));

  return math;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.createUnit" id="apidoc.element.mathjs.type.Chain.prototype.createUnit">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>createUnit
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createUnit = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.cross" id="apidoc.element.mathjs.type.Chain.prototype.cross">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>cross
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cross = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*    ]
*
* If one of the input vectors has a dimension greater than 1, the output
* vector will be a 1x3 (2-dimensional) matrix.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">cross</span>(x, y)
*
* Examples:
*
*    math.cross([1, 1, 0],   [0, 1, 1]);       // Returns [1, -1, 1]
*    math.cross([3, -3, 1],  [4, 9, 2]);       // Returns [-15, -2, 39]
*    math.cross([2, 3, 4],   [5, 6, 7]);       // Returns [-3, 6, -3]
*    math.cross([[1, 2, 3]], [[4], [5], [6]]); // Returns [[-3, 6, -3]]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.csc" id="apidoc.element.mathjs.type.Chain.prototype.csc">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>csc
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">csc = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Syntax:
*
*    math.acsc(x)
*
* Examples:
*
*    math.acsc(0.5);           // returns number 0.5235987755982989
*    math.acsc(math.<span class="apidocCodeKeywordSpan">csc</span>(1.5)); // returns number ~1.5
*
*    math.acsc(2);             // returns Complex 1.5707963267948966 -1.3169578969248166 i
*
* See also:
*
*    csc, asin, asec
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.csch" id="apidoc.element.mathjs.type.Chain.prototype.csch">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>csch
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">csch = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Calculate the hyperbolic cosecant of a value,
* defined as `csch(x) = 1 / sinh(x)`.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">csch</span>(x)
*
* Examples:
*
*    // csch(x) = 1/ sinh(x)
*    math.csch(0.5);       // returns 1.9190347513349437
*    1 / math.sinh(0.5);   // returns 1.9190347513349437
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.cube" id="apidoc.element.mathjs.type.Chain.prototype.cube">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>cube
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cube = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
*    math.cbrt(x)
*    math.cbrt(x, allRoots)
*
* Examples:
*
*    math.cbrt(27);                  // returns 3
*    math.<span class="apidocCodeKeywordSpan">cube</span>(3);                   // returns 27
*    math.cbrt(-64);                 // returns -4
*    math.cbrt(math.unit('27 m^3')); // returns Unit 3 m
*    math.cbrt([27, 64, 125]);       // returns [3, 4, 5]
*
*    var x = math.complex('8i');
*    math.cbrt(x);                   // returns Complex 1.7320508075689 + i
*    math.cbrt(x, true);             // returns Matrix [
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.deepEqual" id="apidoc.element.mathjs.type.Chain.prototype.deepEqual">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>deepEqual
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deepEqual = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (a.length != b.length) {
    return false;
  }

  for (i = 0, len = a.length; i &lt; len; i++) {
    if (!exports.<span class="apidocCodeKeywordSpan">deepEqual</span>(a[i], b[i])) {
      return false;
    }
  }
  return true;
}
else if (a instanceof Object) {
  if (Array.isArray(b) || !(b instanceof Object)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.derivative" id="apidoc.element.mathjs.type.Chain.prototype.derivative">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>derivative
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">derivative = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// functions and constants
math.round(math.e, 3);            // 2.718
math.atan2(3, -3) / math.pi;      // 0.75
math.log(1000, 10);               // 3
math.sqrt(-4);                    // 2i
math.pow([[-1, 2], [3, 1]], 2);   // [[7, 0], [0, 7]]
math.<span class="apidocCodeKeywordSpan">derivative</span>('x^2 + x', 'x');  // 2 * x + 1

// expressions
math.eval('12 / (2.3 + 0.7)');    // 4
math.eval('5.08 cm to inch');     // 2 inch
math.eval('sin(45 deg) ^ 2');     // 0.5
math.eval('9 / 3 + 2i');          // 3 + 2i
math.eval('det([-1, 2; 3, 1])');  // -7
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.det" id="apidoc.element.mathjs.type.Chain.prototype.det">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>det
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">det = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var unaryMinus = load(require('../arithmetic/unaryMinus'));

/**
 * Calculate the determinant of a matrix.
 *
 * Syntax:
 *
 *    math.<span class="apidocCodeKeywordSpan">det</span>(x)
 *
 * Examples:
 *
 *    math.det([[1, 2], [3, 4]]); // returns -2
 *
 *    var A = [
 *      [-2, 2, 3],
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.diag" id="apidoc.element.mathjs.type.Chain.prototype.diag">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>diag
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">diag = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* When `x` is a vector, a matrix with vector `x` on the diagonal will be returned.
* When `x` is a two dimensional matrix, the matrixes `k`th diagonal will be returned as vector.
* When k is positive, the values are placed on the super diagonal.
* When k is negative, the values are placed on the sub diagonal.
*
* Syntax:
*
*     math.<span class="apidocCodeKeywordSpan">diag</span>(X)
*     math.diag(X, format)
*     math.diag(X, k)
*     math.diag(X, k, format)
*
* Examples:
*
*     // create a diagonal matrix
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.distance" id="apidoc.element.mathjs.type.Chain.prototype.distance">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>distance
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">distance = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*    Distance between point and a line in 2 and 3 dimensional spaces.
*    Pairwise distance between a set of 2D or 3D points
* NOTE:
*    When substituting coefficients of a line(a, b and c), use ax + by + c = 0 instead of ax + by = c
*    For parametric equation of a 3D line, x0, y0, z0, a, b, c are from: (xâˆ’x0, yâˆ’y0, zâˆ’z0) = t(a, b, c)
*
* Syntax:
*    math.<span class="apidocCodeKeywordSpan">distance</span>([x1, y1], [x2, y2])
*-   math.distance({pointOneX: 4, pointOneY: 5}, {pointTwoX: 2, pointTwoY: 7})
*    math.distance([x1, y1, z1], [x2, y2, z2])
*    math.distance({pointOneX: 4, pointOneY: 5, pointOneZ: 8}, {pointTwoX: 2, pointTwoY: 7, pointTwoZ: 9})
*    math.distance([[A], [B], [C]...])
*    math.distance([x1, y1], [LinePtX1, LinePtY1], [LinePtX2, LinePtY2])
*    math.distance({pointX: 1, pointY: 4}, {lineOnePtX: 6, lineOnePtY: 3}, {lineTwoPtX: 2, lineTwoPtY: 8})
*    math.distance([x1, y1, z1], [LinePtX1, LinePtY1, LinePtZ1], [LinePtX2, LinePtY2, LinePtZ2])
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.divide" id="apidoc.element.mathjs.type.Chain.prototype.divide">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>divide
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">divide = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  /**
* Divide two values, `x / y`.
* To divide matrices, `x` is multiplied with the inverse of `y`: `x * inv(y)`.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">divide</span>(x, y)
*
* Examples:
*
*    math.divide(2, 3);            // returns number 0.6666666666666666
*
*    var a = math.complex(5, 14);
*    var b = math.complex(4, 1);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.done" id="apidoc.element.mathjs.type.Chain.prototype.done">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>done
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">done = function () {
  return this.value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
math.eval('9 / 3 + 2i');          // 3 + 2i
math.eval('det([-1, 2; 3, 1])');  // -7

// chaining
math.chain(3)
    .add(4)
    .multiply(2)
    .<span class="apidocCodeKeywordSpan">done</span>(); // 14
```

## Browser support

Math.js works on any ES5 compatible JavaScript engine: node.js 0.10, and Internet Explorer 9 and newer, and all other browsers (
Chrome, Firefox, Safari). If support for old browsers like Internet Explorer 8 is required, the [es5-shim](https://github.com/kriskowal
/es5-shim) library has to be loaded.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.dot" id="apidoc.element.mathjs.type.Chain.prototype.dot">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>dot
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dot = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Calculate the dot product of two vectors. The dot product of
* `A = [a1, a2, a3, ..., an]` and `B = [b1, b2, b3, ..., bn]` is defined as:
*
*    dot(A, B) = a1 * b1 + a2 * b2 + a3 * b3 + ... + an * bn
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">dot</span>(x, y)
*
* Examples:
*
*    math.dot([2, 4, 1], [2, 2, 3]);       // returns number 15
*    math.multiply([2, 4, 1], [2, 2, 3]);  // returns number 15
*
* See also:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.dotDivide" id="apidoc.element.mathjs.type.Chain.prototype.dotDivide">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>dotDivide
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dotDivide = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  /**
* Divide two matrices element wise. The function accepts both matrices and
* scalar values.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">dotDivide</span>(x, y)
*
* Examples:
*
*    math.dotDivide(2, 4);   // returns 0.5
*
*    a = [[9, 5], [6, 1]];
*    b = [[3, 2], [5, 2]];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.dotMultiply" id="apidoc.element.mathjs.type.Chain.prototype.dotMultiply">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>dotMultiply
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dotMultiply = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  /**
* Multiply two matrices element wise. The function accepts both matrices and
* scalar values.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">dotMultiply</span>(x, y)
*
* Examples:
*
*    math.dotMultiply(2, 4); // returns 8
*
*    a = [[9, 5], [6, 1]];
*    b = [[3, 2], [5, 2]];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.dotPow" id="apidoc.element.mathjs.type.Chain.prototype.dotPow">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>dotPow
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dotPow = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));

/**
 * Calculates the power of x to y element wise.
 *
 * Syntax:
 *
 *    math.<span class="apidocCodeKeywordSpan">dotPow</span>(x, y)
 *
 * Examples:
 *
 *    math.dotPow(2, 3);            // returns number 8
 *
 *    var a = [[1, 2], [4, 3]];
 *    math.dotPow(a, 2);            // returns Array [[1, 4], [16, 9]]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.emit" id="apidoc.element.mathjs.type.Chain.prototype.emit">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>emit
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">emit = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    object.deepExtend(config, options);

    var curr = object.clone(config);

    var changes = object.clone(options);

    // emit 'config' event
    math.<span class="apidocCodeKeywordSpan">emit</span>('config', curr, prev, changes);

    return curr;
  }
  else {
    return object.clone(config);
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.equal" id="apidoc.element.mathjs.type.Chain.prototype.equal">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>equal
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">equal = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
*    math.deepEqual(2, 4);   // returns false
*
*    a = [2, 5, 1];
*    b = [2, 7, 1];
*
*    math.deepEqual(a, b);   // returns false
*    math.<span class="apidocCodeKeywordSpan">equal</span>(a, b);       // returns [true, false, true]
*
* See also:
*
*    equal, unequal
*
* @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x First matrix to compare
* @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} y Second matrix to compare
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.erf" id="apidoc.element.mathjs.type.Chain.prototype.erf">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>erf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">erf = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* "Rational Chebyshev Approximations for the Error Function" by W. J. Cody
* for an explanation of this process.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">erf</span>(x)
*
* Examples:
*
*    math.erf(0.2);    // returns 0.22270258921047847
*    math.erf(-0.5);   // returns -0.5204998778130465
*    math.erf(4);      // returns 0.9999999845827421
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.eval" id="apidoc.element.mathjs.type.Chain.prototype.eval">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>eval
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eval = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
math.atan2(3, -3) / math.pi;      // 0.75
math.log(1000, 10);               // 3
math.sqrt(-4);                    // 2i
math.pow([[-1, 2], [3, 1]], 2);   // [[7, 0], [0, 7]]
math.derivative('x^2 + x', 'x');  // 2 * x + 1

// expressions
math.<span class="apidocCodeKeywordSpan">eval</span>('12 / (2.3 + 0.7)');    // 4
math.eval('5.08 cm to inch');     // 2 inch
math.eval('sin(45 deg) ^ 2');     // 0.5
math.eval('9 / 3 + 2i');          // 3 + 2i
math.eval('det([-1, 2; 3, 1])');  // -7

// chaining
math.chain(3)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.exp" id="apidoc.element.mathjs.type.Chain.prototype.exp">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>exp
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exp = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// https://www.wikiwand.com/en/Cube_root#/Complex_numbers

var arg_3 = x.arg() / 3;
var abs = x.abs();

// principal root:
var principal = new type.Complex(_cbrtNumber(abs), 0).mul(
    new type.Complex(0, arg_3).<span class="apidocCodeKeywordSpan">exp</span>());

if (allRoots) {
  var all = [
      principal,
      new type.Complex(_cbrtNumber(abs), 0).mul(
        new type.Complex(0, arg_3 + Math.PI * 2 / 3).exp()),
      new type.Complex(_cbrtNumber(abs), 0).mul(
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.eye" id="apidoc.element.mathjs.type.Chain.prototype.eye">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>eye
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eye = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  /**
* Create a 2-dimensional identity matrix with size m x n or n x n.
* The matrix has ones on the diagonal and zeros elsewhere.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">eye</span>(n)
*    math.eye(n, format)
*    math.eye(m, n)
*    math.eye(m, n, format)
*    math.eye([m, n])
*    math.eye([m, n], format)
*
* Examples:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.factorial" id="apidoc.element.mathjs.type.Chain.prototype.factorial">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>factorial
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">factorial = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Compute the factorial of a value
*
* Factorial only supports an integer value as argument.
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">factorial</span>(n)
*
* Examples:
*
*    math.factorial(5);    // returns 120
*    math.factorial(3);    // returns 6
*
* See also:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.filter" id="apidoc.element.mathjs.type.Chain.prototype.filter">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>filter
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">filter = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            }
          }
        }
      }
    }

    // remove duplicates
    matches = matches.<span class="apidocCodeKeywordSpan">filter</span>(function(elem, pos, arr) {
      return arr.indexOf(elem) == pos;
    });
  }

  return [matches, keyword];
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.fix" id="apidoc.element.mathjs.type.Chain.prototype.fix">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>fix
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fix = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function factory (type, config, load, typed) {
/**
 * Round a value towards zero.
 * For matrices, the function is evaluated element wise.
 *
 * Syntax:
 *
 *    math.<span class="apidocCodeKeywordSpan">fix</span>(x)
 *
 * Examples:
 *
 *    math.fix(3.2);                // returns number 3
 *    math.fix(3.8);                // returns number 3
 *    math.fix(-4.2);               // returns number -4
 *    math.fix(-4.7);               // returns number -4
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.flatten" id="apidoc.element.mathjs.type.Chain.prototype.flatten">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>flatten
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">flatten = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @returns {Array}               Array whose data has been formatted to fit the
 *                                specified dimensions
 *
 * @throws {DimensionError}       If the product of the new dimension sizes does
 *                                not equal that of the old ones
 */
exports.reshape = function(array, sizes) {
var flatArray = exports.<span class="apidocCodeKeywordSpan">flatten</span>(array);
var newArray;

var product = function (arr) {
  return arr.reduce(function (prev, curr) {
    return prev * curr;
  });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.floor" id="apidoc.element.mathjs.type.Chain.prototype.floor">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>floor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">floor = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   *    ceil, floor, round
   *
   * @param {number | BigNumber | Fraction | Complex | Array | Matrix} x Number to be rounded
   * @return {number | BigNumber | Fraction | Complex | Array | Matrix}            Rounded value
   */
  var fix = typed('fix', {
'number': function (x) {
  return (x &gt; 0) ? Math.<span class="apidocCodeKeywordSpan">floor</span>(x) : Math.ceil(x);
},

'Complex': function (x) {
  return new type.Complex(
      (x.re &gt; 0) ? Math.floor(x.re) : Math.ceil(x.re),
      (x.im &gt; 0) ? Math.floor(x.im) : Math.ceil(x.im)
  );
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.forEach" id="apidoc.element.mathjs.type.Chain.prototype.forEach">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>forEach
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEach = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (def.indexOf(keyword) == 0) {
      matches.push(def);
    }
  }
}

// commandline keywords
['exit', 'quit', 'clear'].<span class="apidocCodeKeywordSpan">forEach</span>(function (cmd) {
  if (cmd.indexOf(keyword) == 0) {
    matches.push(cmd);
  }
});

// math functions and constants
var ignore = ['expr', 'type'];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.format" id="apidoc.element.mathjs.type.Chain.prototype.format">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>format
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">format = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Helper function to format a value. Regular numbers will be rounded
 * to 14 digits to prevent round-off errors from showing up.
 * @param {*} value
 */
function format(value) {
var math = getMath();

return math.<span class="apidocCodeKeywordSpan">format</span>(value, {
  fn: function (value) {
    if (typeof value === 'number') {
      // round numbers
      return math.format(value, PRECISION);
    }
    else {
      return math.format(value);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.fraction" id="apidoc.element.mathjs.type.Chain.prototype.fraction">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>fraction
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fraction = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      case 'number':
// TODO: replace this with using config.number
var numConfig = defs.math.config().number;
if (numConfig === 'BigNumber') {
  return 'math.bignumber("' + this.value + '")';
}
else if (numConfig === 'Fraction') {
  return 'math.<span class="apidocCodeKeywordSpan">fraction</span>("' + this.value + '")';
}
else {
  // remove leading zeros like '003.2' which are not allowed by JavaScript
  return this.value.replace(/^(0*)[0-9]/, function (match, zeros) {
    return match.substring(zeros.length);
  });
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.gamma" id="apidoc.element.mathjs.type.Chain.prototype.gamma">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>gamma
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">gamma = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Compute the gamma function of a value using Lanczos approximation for
* small values, and an extended Stirling approximation for large values.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">gamma</span>(n)
*
* Examples:
*
*    math.gamma(5);       // returns 24
*    math.gamma(-0.5);    // returns -3.5449077018110335
*    math.gamma(math.i);  // returns -0.15494982830180973 - 0.49801566811835596i
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.gcd" id="apidoc.element.mathjs.type.Chain.prototype.gcd">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>gcd
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">gcd = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Calculate the greatest common divisor for two or more values or arrays.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">gcd</span>(a, b)
*    math.gcd(a, b, c, ...)
*
* Examples:
*
*    math.gcd(8, 12);              // returns 4
*    math.gcd(-4, 6);              // returns 2
*    math.gcd(25, 15, -10);        // returns 5
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.help" id="apidoc.element.mathjs.type.Chain.prototype.help">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>help
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">help = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Object                 | `'Object'`    | `math.typeof ({a: 2, b: 3})`
* RegExp                 | `'RegExp'`    | `math.typeof (/a regexp/)`
* undefined              | `'undefined'` | `math.typeof(undefined)`
* math.type.BigNumber    | `'BigNumber'` | `math.typeof (math.bignumber('2.3e500'))`
* math.type.Chain        | `'Chain'`     | `math.typeof (math.chain(2))`
* math.type.Complex      | `'Complex'`   | `math.typeof (math.complex(2, 3))`
* math.type.Fraction     | `'Fraction'`  | `math.typeof (math.fraction(1, 3))`
* math.type.Help         | `'Help'`      | `math.typeof (math.<span class="apidocCodeKeywordSpan">help</span>('sqrt
'))`
* math.type.Index        | `'Index'`     | `math.typeof (math.index(1, 3))`
* math.type.Matrix       | `'Matrix'`    | `math.typeof (math.matrix([[1,2], [3, 4]]))`
* math.type.Range        | `'Range'`     | `math.typeof (math.range(0, 10))`
* math.type.Unit         | `'Unit'`      | `math.typeof (math.unit('45 deg'))`
*
* Syntax:
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.hypot" id="apidoc.element.mathjs.type.Chain.prototype.hypot">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>hypot
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hypot = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
*     hypot(a, b, c, ...) = sqrt(a^2 + b^2 + c^2 + ...)
*
* For matrix input, the hypotenusa is calculated for all values in the matrix.
*
* Syntax:
*
*     math.<span class="apidocCodeKeywordSpan">hypot</span>(a, b, ...)
*     math.hypot([a, b, c, ...])
*
* Examples:
*
*     math.hypot(3, 4);      // 5
*     math.hypot(3, 4, 5);   // 7.0710678118654755
*     math.hypot([3, 4, 5]); // 7.0710678118654755
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.im" id="apidoc.element.mathjs.type.Chain.prototype.im">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>im
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">im = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Get the imaginary part of a complex number.
* For a complex number `a + bi`, the function returns `b`.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">im</span>(x)
*
* Examples:
*
*    var a = math.complex(2, 3);
*    math.re(a);                     // returns number 2
*    math.im(a);                     // returns number 3
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.import" id="apidoc.element.mathjs.type.Chain.prototype.import">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>import
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">import = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

function factory (type, config, load, typed, math) {
/**
 * Import functions from an object or a module
 *
 * Syntax:
 *
 *    math.<span class="apidocCodeKeywordSpan">import</span>(object)
 *    math.import(object, options)
 *
 * Where:
 *
 * - `object: Object`
 *   An object with functions to be imported.
 * - `options: Object` An object with import options. Available options:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.index" id="apidoc.element.mathjs.type.Chain.prototype.index">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>index
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">index = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
          '})()'
    }
    else { // ConstantNode
      return range._compile(defs, childArgs);
    }
  });

  return 'math.<span class="apidocCodeKeywordSpan">index</span>(' + dimensions.join(', ') + ')';
};

/**
 * Execute a callback for each of the child nodes of this node
 * @param {function(child: Node, path: string, parent: Node)} callback
 */
IndexNode.prototype.forEach = function (callback) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.intersect" id="apidoc.element.mathjs.type.Chain.prototype.intersect">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>intersect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">intersect = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* arrays or 1 dimensional matrices. The line intersection functions return null
* if the lines do not meet.
*
* Note: Fill the plane coefficients as `x + y + z = c` and not as `x + y + z + c = 0`.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">intersect</span>(endPoint1Line1, endPoint2Line1, endPoint1Line2, endPoint2Line2)
*    math.intersect(endPoint1, endPoint2, planeCoefficients)
*
* Examples:
*
*    math.intersect([0, 0], [10, 10], [10, 0], [0, 10]);              // Returns [5, 5]
*    math.intersect([0, 0, 0], [10, 10, 0], [10, 0, 0], [0, 10, 0]);  // Returns [5, 5, 0]
*    math.intersect([1, 0, 1],  [4, -2, 2], [1, 1, 1, 6]);            // Returns [7, -4, 3]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.inv" id="apidoc.element.mathjs.type.Chain.prototype.inv">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>inv
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inv = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var eye          = load(require('./eye'));

/**
 * Calculate the inverse of a square matrix.
 *
 * Syntax:
 *
 *     math.<span class="apidocCodeKeywordSpan">inv</span>(x)
 *
 * Examples:
 *
 *     math.inv([[1, 2], [3, 4]]);  // returns [[-2, 1], [1.5, -0.5]]
 *     math.inv(4);                 // returns 0.25
 *     1 / 4;                       // returns 0.25
 *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.isInteger" id="apidoc.element.mathjs.type.Chain.prototype.isInteger">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>isInteger
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isInteger = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * Test whether index is an integer number with index &gt;= 0 and index &lt; length
 * when length is provided
 * @param {number} index    Zero-based index
 * @param {number} [length] Length of the array
 */
exports.validateIndex = function(index, length) {
  if (!number.isNumber(index) || !number.<span class="apidocCodeKeywordSpan">isInteger</span>(index)) {
    throw new TypeError('Index must be an integer (value: ' + index + ')');
  }
  if (index &lt; 0 || (typeof length === 'number' &amp;&amp; index &gt;= length)) {
    throw new IndexError(index, length);
  }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.isNaN" id="apidoc.element.mathjs.type.Chain.prototype.isNaN">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>isNaN
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isNaN = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
},

'Complex, Complex': function (x, y) {
  return (x.re !== 0 || x.im !== 0) &amp;&amp; (y.re !== 0 || y.im !== 0);
},

'BigNumber, BigNumber': function (x, y) {
  return !x.isZero() &amp;&amp; !y.isZero() &amp;&amp; !x.<span class="apidocCodeKeywordSpan">isNaN</span>() &amp;&amp; !y
.isNaN();
},

'Unit, Unit': function (x, y) {
  return and(x.value, y.value);
},

'Matrix, Matrix': function (x, y) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.isNegative" id="apidoc.element.mathjs.type.Chain.prototype.isNegative">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>isNegative
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isNegative = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return new type.Complex(
      (x.re &gt; 0) ? Math.floor(x.re) : Math.ceil(x.re),
      (x.im &gt; 0) ? Math.floor(x.im) : Math.ceil(x.im)
  );
},

'BigNumber': function (x) {
  return x.<span class="apidocCodeKeywordSpan">isNegative</span>() ? x.ceil() : x.floor();
},

'Fraction': function (x) {
  return x.s &lt; 0 ? x.ceil() : x.floor();
},

'Array | Matrix': function (x) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.isNumeric" id="apidoc.element.mathjs.type.Chain.prototype.isNumeric">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>isNumeric
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isNumeric = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Test whether a value is an numeric value.
*
* The function is evaluated element-wise in case of Array or Matrix input.
*
* Syntax:
*
*     math.<span class="apidocCodeKeywordSpan">isNumeric</span>(x)
*
* Examples:
*
*    math.isNumeric(2);                     // returns true
*    math.isNumeric(0);                     // returns true
*    math.isNumeric(math.bignumber(500));   // returns true
*    math.isNumeric(math.fraction(4));      // returns true
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.isPositive" id="apidoc.element.mathjs.type.Chain.prototype.isPositive">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>isPositive
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isPositive = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Test whether a value is positive: larger than zero.
* The function supports types `number`, `BigNumber`, `Fraction`, and `Unit`.
*
* The function is evaluated element-wise in case of Array or Matrix input.
*
* Syntax:
*
*     math.<span class="apidocCodeKeywordSpan">isPositive</span>(x)
*
* Examples:
*
*    math.isPositive(3);                     // returns true
*    math.isPositive(-2);                    // returns false
*    math.isPositive(0);                     // returns false
*    math.isPositive(-0);                    // returns false
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.isPrime" id="apidoc.element.mathjs.type.Chain.prototype.isPrime">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>isPrime
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isPrime = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Test whether a value is prime: has no divisors other than itself and one.
* The function supports type `number`, `bignumber`.
*
* The function is evaluated element-wise in case of Array or Matrix input.
*
* Syntax:
*
*     math.<span class="apidocCodeKeywordSpan">isPrime</span>(x)
*
* Examples:
*
*    math.isPrime(3);                     // returns true
*    math.isPrime(-2);                    // returns false
*    math.isPrime(0);                     // returns false
*    math.isPrime(-0);                    // returns false
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.isZero" id="apidoc.element.mathjs.type.Chain.prototype.isZero">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>isZero
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isZero = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
},

'number': function (x) {
  return !!x;
},

'BigNumber': function (x) {
  return !x.<span class="apidocCodeKeywordSpan">isZero</span>();
},

'string': function (x) {
  // try case insensitive
  var lcase = x.toLowerCase();
  if (lcase === 'true') {
    return true;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.kldivergence" id="apidoc.element.mathjs.type.Chain.prototype.kldivergence">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>kldivergence
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">kldivergence = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var isNumeric = load(require('../utils/isNumeric'));

/**
 * Calculate the Kullback-Leibler (KL) divergence  between two distributions
 *
 * Syntax:
 *
 *     math.<span class="apidocCodeKeywordSpan">kldivergence</span>(x, y)
 *
 * Examples:
 *
 *     math.kldivergence([0.7,0.5,0.4], [0.2,0.9,0.5]);   //returns 0.24376698773121153
 *
 *
 * @param  {Array | Matrix} q    First vector
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.kron" id="apidoc.element.mathjs.type.Chain.prototype.kron">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>kron
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">kron = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* NOTE: If a one dimensional vector / matrix is given, it will be
* wrapped so its two dimensions.
* See the examples.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">kron</span>(x, y)
*
* Examples:
*
*    math.kron([[1, 0], [0, 1]], [[1, 2], [3, 4]]);
*    // returns [ [ 1, 2, 0, 0 ], [ 3, 4, 0, 0 ], [ 0, 0, 1, 2 ], [ 0, 0, 3, 4 ] ]
*
*    math.kron([1,1], [2,3,4]);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.larger" id="apidoc.element.mathjs.type.Chain.prototype.larger">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>larger
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">larger = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* Syntax:
*
*    math.largerEq(x, y)
*
* Examples:
*
*    math.<span class="apidocCodeKeywordSpan">larger</span>(2, 1 + 1);         // returns false
*    math.largerEq(2, 1 + 1);       // returns true
*
* See also:
*
*    equal, unequal, smaller, smallerEq, larger, compare
*
* @param  {number | BigNumber | Fraction | boolean | Unit | string | Array | Matrix} x First value to compare
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.largerEq" id="apidoc.element.mathjs.type.Chain.prototype.largerEq">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>largerEq
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">largerEq = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* difference between x and y is smaller than the configured epsilon. The
* function cannot be used to compare values smaller than approximately 2.22e-16.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">largerEq</span>(x, y)
*
* Examples:
*
*    math.larger(2, 1 + 1);         // returns false
*    math.largerEq(2, 1 + 1);       // returns true
*
* See also:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.lcm" id="apidoc.element.mathjs.type.Chain.prototype.lcm">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>lcm
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lcm = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
*     lcm(a, b) = abs(a * b) / gcd(a, b)
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">lcm</span>(a, b)
*    math.lcm(a, b, c, ...)
*
* Examples:
*
*    math.lcm(4, 6);               // returns 12
*    math.lcm(6, 21);              // returns 42
*    math.lcm(6, 21, 5);           // returns 210
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.leftShift" id="apidoc.element.mathjs.type.Chain.prototype.leftShift">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>leftShift
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">leftShift = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Bitwise left logical shift of a value x by y number of bits, `x &lt;&lt; y`.
* For matrices, the function is evaluated element wise.
* For units, the function is evaluated on the best prefix base.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">leftShift</span>(x, y)
*
* Examples:
*
*    math.leftShift(1, 2);               // returns number 4
*
*    math.leftShift([1, 2, 3], 4);       // returns Array [16, 32, 64]
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.log" id="apidoc.element.mathjs.type.Chain.prototype.log">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>log
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">log = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
// load math.js
var math = require('mathjs');

// functions and constants
math.round(math.e, 3);            // 2.718
math.atan2(3, -3) / math.pi;      // 0.75
math.<span class="apidocCodeKeywordSpan">log</span>(1000, 10);               // 3
math.sqrt(-4);                    // 2i
math.pow([[-1, 2], [3, 1]], 2);   // [[7, 0], [0, 7]]
math.derivative('x^2 + x', 'x');  // 2 * x + 1

// expressions
math.eval('12 / (2.3 + 0.7)');    // 4
math.eval('5.08 cm to inch');     // 2 inch
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.log10" id="apidoc.element.mathjs.type.Chain.prototype.log10">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>log10
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">log10 = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Calculate the 10-base logarithm of a value. This is the same as calculating `log(x, 10)`.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">log10</span>(x)
*
* Examples:
*
*    math.log10(0.00001);            // returns -5
*    math.log10(10000);              // returns 4
*    math.log(10000) / math.log(10); // returns 4
*    math.pow(10, 4);                // returns 10000
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.lsolve" id="apidoc.element.mathjs.type.Chain.prototype.lsolve">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>lsolve
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lsolve = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.lup" id="apidoc.element.mathjs.type.Chain.prototype.lup">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>lup
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lup = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.lusolve" id="apidoc.element.mathjs.type.Chain.prototype.lusolve">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>lusolve
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lusolve = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.mad" id="apidoc.element.mathjs.type.Chain.prototype.mad">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>mad
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mad = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Compute the median absolute deviation of a matrix or a list with values.
* The median absolute deviation is defined as the median of the absolute
* deviations from the median.
*
* Syntax:
*
*     math.<span class="apidocCodeKeywordSpan">mad</span>(a, b, c, ...)
*     math.mad(A)
*
* Examples:
*
*     math.mad(10, 20, 30);             // returns 10
*     math.mad([1, 2, 3]);              // returns 1
*     math.mad([[1, 2, 3], [4, 5, 6]]); // returns 1.5
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.map" id="apidoc.element.mathjs.type.Chain.prototype.map">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>map
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">map = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (res &amp;&amp; res.isResultSet) {
  // we can have 0 or 1 results in the ResultSet, as the CLI
  // does not allow multiple expressions separated by a return
  res = res.entries[0];
  node = node.blocks
      .filter(function (entry) { return entry.visible; })
      .<span class="apidocCodeKeywordSpan">map</span>(function (entry) { return entry.node })[0];
}

if (node) {
  if (node.isAssignmentNode) {
    var name = findSymbolName(node);
    if (name != null) {
      scope.ans = scope[name];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.matrix" id="apidoc.element.mathjs.type.Chain.prototype.matrix">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>matrix
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">matrix = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
ArrayNode.prototype._compile = function (defs, args) {
  var asMatrix = (defs.math.config().matrix !== 'Array');

  var items = this.items.map(function (node) {
    return node._compile(defs, args);
  });

  return (asMatrix ? 'math.<span class="apidocCodeKeywordSpan">matrix</span>([' : '[') +
      items.join(',') +
      (asMatrix ? '])' : ']');
};

/**
 * Execute a callback for each of the child nodes of this node
 * @param {function(child: Node, path: string, parent: Node)} callback
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.max" id="apidoc.element.mathjs.type.Chain.prototype.max">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>max
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">max = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @return {number} Returns the maximum number of expected arguments.
 *                  Returns -1 when no signatures where found on the function.
 */
exports.maxArgumentCount = function (fn) {
  return Object.keys(fn.signatures || {})
      .reduce(function (args, signature) {
        var count = (signature.match(/,/g) || []).length + 1;
        return Math.<span class="apidocCodeKeywordSpan">max</span>(args, count);
      }, -1);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.mean" id="apidoc.element.mathjs.type.Chain.prototype.mean">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>mean
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mean = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Compute the mean value of matrix or a list with values.
* In case of a multi dimensional array, the mean of the flattened array
* will be calculated. When `dim` is provided, the maximum over the selected
* dimension will be calculated. Parameter `dim` is zero-based.
*
* Syntax:
*
*     math.<span class="apidocCodeKeywordSpan">mean</span>(a, b, c, ...)
*     math.mean(A)
*     math.mean(A, dim)
*
* Examples:
*
*     math.mean(2, 1, 4, 3);                     // returns 2.5
*     math.mean([1, 2.7, 3.2, 4]);               // returns 2.725
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.median" id="apidoc.element.mathjs.type.Chain.prototype.median">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>median
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">median = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Supported types of values are: Number, BigNumber, Unit
*
* In case of a (multi dimensional) array or matrix, the median of all
* elements will be calculated.
*
* Syntax:
*
*     math.<span class="apidocCodeKeywordSpan">median</span>(a, b, c, ...)
*     math.median(A)
*
* Examples:
*
*     math.median(5, 2, 7);        // returns 5
*     math.median([3, -1, 5, 7]);  // returns 4
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.min" id="apidoc.element.mathjs.type.Chain.prototype.min">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>min
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">min = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @private
 */
function _resize (array, size, dim, defaultValue) {
var i;
var elem;
var oldLen = array.length;
var newLen = size[dim];
var minLen = Math.<span class="apidocCodeKeywordSpan">min</span>(oldLen, newLen);

// apply new length
array.length = newLen;

if (dim &lt; size.length - 1) {
  // non-last dimension
  var dimNext = dim + 1;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.mod" id="apidoc.element.mathjs.type.Chain.prototype.mod">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>mod
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mod = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (!a.isInt() || !b.isInt()) {
      throw new Error('Parameters in function gcd must be integer numbers');
    }

    // http://en.wikipedia.org/wiki/Euclidean_algorithm
    var zero = new type.BigNumber(0);
    while (!b.isZero()) {
      var r = a.<span class="apidocCodeKeywordSpan">mod</span>(b);
      a = b;
      b = r;
    }
    return a.lt(zero) ? a.neg() : a;
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.mode" id="apidoc.element.mathjs.type.Chain.prototype.mode">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>mode
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mode = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
* Computes the mode of a set of numbers or a list with values(numbers or characters).
* If there are more than one modes, it returns a list of those values.
*
* Syntax:
*
*     math.<span class="apidocCodeKeywordSpan">mode</span>(a, b, c, ...)
*     math.mode(A)
*
* Examples:
*
*     math.mode(2, 1, 4, 3, 1);                            // returns [1]
*     math.mode([1, 2.7, 3.2, 4, 2.7]);                    // returns [2.7]
*     math.mode(1, 4, 6, 1, 6)                             // returns [1, 6]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.multinomial" id="apidoc.element.mathjs.type.Chain.prototype.multinomial">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>multinomial
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">multinomial = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Multinomial Coefficients compute the number of ways of picking a1, a2, ..., ai unordered outcomes from `n` possibilities.
*
* multinomial takes one array of integers as an argument.
* The following condition must be enforced: every ai &lt;= 0
*
* Syntax:
*
*     math.<span class="apidocCodeKeywordSpan">multinomial</span>(a) // a is an array type
*
* Examples:
*
*    math.multinomial([1,2,1]); // returns 12
*
* See also:
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.multiply" id="apidoc.element.mathjs.type.Chain.prototype.multiply">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>multiply
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">multiply = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
math.eval('sin(45 deg) ^ 2');     // 0.5
math.eval('9 / 3 + 2i');          // 3 + 2i
math.eval('det([-1, 2; 3, 1])');  // -7

// chaining
math.chain(3)
    .add(4)
    .<span class="apidocCodeKeywordSpan">multiply</span>(2)
    .done(); // 14
```

## Browser support

Math.js works on any ES5 compatible JavaScript engine: node.js 0.10, and Internet Explorer 9 and newer, and all other browsers (
Chrome, Firefox, Safari). If support for old browsers like Internet Explorer 8 is required, the [es5-shim](https://github.com/kriskowal
/es5-shim) library has to be loaded.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.norm" id="apidoc.element.mathjs.type.Chain.prototype.norm">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>norm
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">norm = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Calculate the norm of a number, vector or matrix.
*
* The second parameter p is optional. If not provided, it defaults to 2.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">norm</span>(x)
*    math.norm(x, p)
*
* Examples:
*
*    math.abs(-3.5);                         // returns 3.5
*    math.norm(-3.5);                        // returns 3.5
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.not" id="apidoc.element.mathjs.type.Chain.prototype.not">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>not
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">not = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  /**
* Logical `not`. Flips boolean value of a given parameter.
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">not</span>(x)
*
* Examples:
*
*    math.not(2);      // returns false
*    math.not(0);      // returns true
*    math.not(true);   // returns false
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.nthRoot" id="apidoc.element.mathjs.type.Chain.prototype.nthRoot">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>nthRoot
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nthRoot = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
*     x^root = A
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*     math.<span class="apidocCodeKeywordSpan">nthRoot</span>(a)
*     math.nthRoot(a, root)
*
* Examples:
*
*     math.nthRoot(9, 2);    // returns 3, as 3^2 == 9
*     math.sqrt(9);          // returns 3, as 3^2 == 9
*     math.nthRoot(64, 3);   // returns 4, as 4^3 == 64
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.number" id="apidoc.element.mathjs.type.Chain.prototype.number">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>number
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">number = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function factory (type, config, load, typed) {
/**
 * Create a number or convert a string, boolean, or unit to a number.
 * When value is a matrix, all elements will be converted to number.
 *
 * Syntax:
 *
 *    math.<span class="apidocCodeKeywordSpan">number</span>(value)
 *    math.number(unit, valuelessUnit)
 *
 * Examples:
 *
 *    math.number(2);                         // returns number 2
 *    math.number('7.2');                     // returns number 7.2
 *    math.number(true);                      // returns number 1
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.off" id="apidoc.element.mathjs.type.Chain.prototype.off">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>off
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">off = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.on" id="apidoc.element.mathjs.type.Chain.prototype.on">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>on
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">on = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  // load math.js now, right *after* loading the prompt.
  var math = getMath();

  // TODO: automatic insertion of 'ans' before operators like +, -, *, /

  rl.<span class="apidocCodeKeywordSpan">on</span>('line', function(line) {
var expr = line.trim();

switch (expr.toLowerCase()) {
  case 'quit':
  case 'exit':
    // exit application
    rl.close();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.once" id="apidoc.element.mathjs.type.Chain.prototype.once">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>once
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">once = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.ones" id="apidoc.element.mathjs.type.Chain.prototype.ones">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>ones
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ones = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  /**
* Create a matrix filled with ones. The created matrix can have one or
* multiple dimensions.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">ones</span>(m)
*    math.ones(m, format)
*    math.ones(m, n)
*    math.ones(m, n, format)
*    math.ones([m, n])
*    math.ones([m, n], format)
*    math.ones([m, n, p, ...])
*    math.ones([m, n, p, ...], format)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.or" id="apidoc.element.mathjs.type.Chain.prototype.or">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>or
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">or = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  /**
* Logical `or`. Test if at least one value is defined with a nonzero/nonempty value.
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">or</span>(x, y)
*
* Examples:
*
*    math.or(2, 4);   // returns true
*
*    a = [2, 5, 0];
*    b = [0, 22, 0];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.parse" id="apidoc.element.mathjs.type.Chain.prototype.parse">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>parse
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        if (!expr) {
          break;
        }
        switch (mode) {
          case 'eval':
            // evaluate expression
            try {
var node = math.<span class="apidocCodeKeywordSpan">parse</span>(expr);
var res = node.eval(scope);

if (res &amp;&amp; res.isResultSet) {
  // we can have 0 or 1 results in the ResultSet, as the CLI
  // does not allow multiple expressions separated by a return
  res = res.entries[0];
  node = node.blocks
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.parser" id="apidoc.element.mathjs.type.Chain.prototype.parser">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>parser
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parser = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*    parser.remove(name);               // clear a variable from the
*                                       // parsers scope
*    parser.clear();                    // clear the parsers scope
*
* Example usage:
*    var parser = new Parser();
*    // Note: there is a convenience method which can be used instead:
*    // var parser = new math.<span class="apidocCodeKeywordSpan">parser</span>();
*
*    // evaluate expressions
*    parser.eval('sqrt(3^2 + 4^2)');         // 5
*    parser.eval('sqrt(-4)');                // 2i
*    parser.eval('2 inch in cm');            // 5.08 cm
*    parser.eval('cos(45 deg)');             // 0.7071067811865476
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.partitionSelect" id="apidoc.element.mathjs.type.Chain.prototype.partitionSelect">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>partitionSelect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">partitionSelect = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Partition-based selection of an array or 1D matrix.
* Will find the kth smallest value, and mutates the input array.
* Uses Quickselect.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">partitionSelect</span>(x, k)
*    math.partitionSelect(x, k, compare)
*
* Examples:
*
*    math.partitionSelect([5, 10, 1], 2);           // returns 10
*    math.partitionSelect(['C', 'B', 'A', 'D'], 1); // returns 'B'
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.permutations" id="apidoc.element.mathjs.type.Chain.prototype.permutations">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>permutations
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">permutations = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* from a set of `n` elements.
*
* Permutations only takes integer arguments.
* The following condition must be enforced: k &lt;= n.
*
* Syntax:
*
*     math.<span class="apidocCodeKeywordSpan">permutations</span>(n)
*     math.permutations(n, k)
*
* Examples:
*
*    math.permutations(5);     // 120
*    math.permutations(5, 3);  // 60
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.pow" id="apidoc.element.mathjs.type.Chain.prototype.pow">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>pow
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pow = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var math = require('mathjs');

// functions and constants
math.round(math.e, 3);            // 2.718
math.atan2(3, -3) / math.pi;      // 0.75
math.log(1000, 10);               // 3
math.sqrt(-4);                    // 2i
math.<span class="apidocCodeKeywordSpan">pow</span>([[-1, 2], [3, 1]], 2);   // [[7, 0], [0, 7]]
math.derivative('x^2 + x', 'x');  // 2 * x + 1

// expressions
math.eval('12 / (2.3 + 0.7)');    // 4
math.eval('5.08 cm to inch');     // 2 inch
math.eval('sin(45 deg) ^ 2');     // 0.5
math.eval('9 / 3 + 2i');          // 3 + 2i
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.print" id="apidoc.element.mathjs.type.Chain.prototype.print">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>print
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">print = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

function factory (type, config, load, typed) {
/**
 * Interpolate values into a string template.
 *
 * Syntax:
 *
 *     math.<span class="apidocCodeKeywordSpan">print</span>(template, values)
 *     math.print(template, values, precision)
 *     math.print(template, values, options)
 *
 * Example usage:
 *
 *     // the following outputs: 'Lucy is 5 years old'
 *     math.print('Lucy is $age years old', {age: 5});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.prod" id="apidoc.element.mathjs.type.Chain.prototype.prod">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>prod
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prod = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Compute the product of a matrix or a list with values.
* In case of a (multi dimensional) array or matrix, the sum of all
* elements will be calculated.
*
* Syntax:
*
*     math.<span class="apidocCodeKeywordSpan">prod</span>(a, b, c, ...)
*     math.prod(A)
*
* Examples:
*
*     math.multiply(2, 3);           // returns 6
*     math.prod(2, 3);               // returns 6
*     math.prod(2, 3, 4);            // returns 24
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.qr" id="apidoc.element.mathjs.type.Chain.prototype.qr">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>qr
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">qr = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.quantileSeq" id="apidoc.element.mathjs.type.Chain.prototype.quantileSeq">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>quantileSeq
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">quantileSeq = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Supported types of probability are: Number, BigNumber
*
* In case of a (multi dimensional) array or matrix, the prob order quantile
* of all elements will be calculated.
*
* Syntax:
*
*     math.<span class="apidocCodeKeywordSpan">quantileSeq</span>(A, prob[, sorted])
*     math.quantileSeq(A, [prob1, prob2, ...][, sorted])
*     math.quantileSeq(A, N[, sorted])
*
* Examples:
*
*     math.quantileSeq([3, -1, 5, 7], 0.5);         // returns 4
*     math.quantileSeq([3, -1, 5, 7], [1/3, 2/3]);  // returns [3, 5]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.range" id="apidoc.element.mathjs.type.Chain.prototype.range">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>range
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">range = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *                          the name of the argument, and the value is `true`.
 *                          The object may not be mutated, but must be
 *                          extended instead.
 * @return {string} js
 * @private
 */
RangeNode.prototype._compile = function (defs, args) {
  return 'math.<span class="apidocCodeKeywordSpan">range</span>(' +
      this.start._compile(defs, args) + ', ' +
      this.end._compile(defs, args) +
      (this.step ? (', ' + this.step._compile(defs, args)) : '') +
      ')';
};

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.re" id="apidoc.element.mathjs.type.Chain.prototype.re">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>re
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">re = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Syntax:
*
*    math.im(x)
*
* Examples:
*
*    var a = math.complex(2, 3);
*    math.<span class="apidocCodeKeywordSpan">re</span>(a);                     // returns number 2
*    math.im(a);                     // returns number 3
*
*    math.re(math.complex('-5.2i')); // returns number -5.2
*    math.re(math.complex(2.4));     // returns number 0
*
* See also:
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.reshape" id="apidoc.element.mathjs.type.Chain.prototype.reshape">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>reshape
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reshape = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var matrix = load(require('../../type/matrix/function/matrix'));

/**
 * Reshape a multi dimensional array to fit the specified dimensions
 *
 * Syntax:
 *
 *     math.<span class="apidocCodeKeywordSpan">reshape</span>(x, sizes)
 *
 * Examples:
 *
 *     math.reshape([1, 2, 3, 4, 5, 6], [2, 3]);
 *     // returns Array  [[1, 2, 3], [4, 5, 6]]
 *
 *     math.reshape([[1, 2], [3, 4]], [1, 4]);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.resize" id="apidoc.element.mathjs.type.Chain.prototype.resize">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>resize
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resize = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // get matrix storage constructor
  var F = type.Matrix.storage(format);
  // create diagonal matrix (use optimized implementation for storage format)
  return F.diagonal(size, one, 0, defaultValue);
}

// create and resize array
var res = array.<span class="apidocCodeKeywordSpan">resize</span>([], size, defaultValue);
// fill in ones on the diagonal
var minimum = rows &lt; cols ? rows : cols;
// fill diagonal
for (var d = 0; d &lt; minimum; d++) {
  res[d][d] = one;
}
return res;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.rightArithShift" id="apidoc.element.mathjs.type.Chain.prototype.rightArithShift">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>rightArithShift
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rightArithShift = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Bitwise right arithmetic shift of a value x by y number of bits, `x &gt;&gt; y`.
* For matrices, the function is evaluated element wise.
* For units, the function is evaluated on the best prefix base.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">rightArithShift</span>(x, y)
*
* Examples:
*
*    math.rightArithShift(4, 2);               // returns number 1
*
*    math.rightArithShift([16, -32, 64], 4);   // returns Array [1, -2, 3]
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.rightLogShift" id="apidoc.element.mathjs.type.Chain.prototype.rightLogShift">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>rightLogShift
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rightLogShift = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Bitwise right logical shift of value x by y number of bits, `x &gt;&gt;&gt; y`.
* For matrices, the function is evaluated element wise.
* For units, the function is evaluated on the best prefix base.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">rightLogShift</span>(x, y)
*
* Examples:
*
*    math.rightLogShift(4, 2);               // returns number 1
*
*    math.rightLogShift([16, -32, 64], 4);   // returns Array [1, 2, 3]
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.round" id="apidoc.element.mathjs.type.Chain.prototype.round">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>round
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">round = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
[chained operations](http://mathjs.org/docs/chained_operations.html).

```js
// load math.js
var math = require('mathjs');

// functions and constants
math.<span class="apidocCodeKeywordSpan">round</span>(math.e, 3);            // 2.718
math.atan2(3, -3) / math.pi;      // 0.75
math.log(1000, 10);               // 3
math.sqrt(-4);                    // 2i
math.pow([[-1, 2], [3, 1]], 2);   // [[7, 0], [0, 7]]
math.derivative('x^2 + x', 'x');  // 2 * x + 1

// expressions
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.sec" id="apidoc.element.mathjs.type.Chain.prototype.sec">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>sec
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sec = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Syntax:
*
*    math.asec(x)
*
* Examples:
*
*    math.asec(0.5);           // returns 1.0471975511965979
*    math.asec(math.<span class="apidocCodeKeywordSpan">sec</span>(1.5)); // returns 1.5
*
*    math.asec(2);             // returns 0 + 1.3169578969248166 i
*
* See also:
*
*    acos, acot, acsc
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.sech" id="apidoc.element.mathjs.type.Chain.prototype.sech">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>sech
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sech = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Calculate the hyperbolic secant of a value,
* defined as `sech(x) = 1 / cosh(x)`.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">sech</span>(x)
*
* Examples:
*
*    // sech(x) = 1/ cosh(x)
*    math.sech(0.5);       // returns 0.886818883970074
*    1 / math.cosh(0.5);   // returns 0.886818883970074
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.sign" id="apidoc.element.mathjs.type.Chain.prototype.sign">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>sign
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sign = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* - -1 when x &lt; 0
* -  0 when x == 0
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">sign</span>(x)
*
* Examples:
*
*    math.sign(3.5);               // returns 1
*    math.sign(-4.2);              // returns -1
*    math.sign(0);                 // returns 0
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.simplify" id="apidoc.element.mathjs.type.Chain.prototype.simplify">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>simplify
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">simplify = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Syntax:
*
*     simplify(expr)
*     simplify(expr, rules)
*
* Examples:
*
*     math.<span class="apidocCodeKeywordSpan">simplify</span>('2 * 1 * x ^ (2 - 1)');      // Node {2 * x}
*     var f = math.parse('2 * 1 * x ^ (2 - 1)');
*     math.simplify(f);                          // Node {2 * x}
*
* See also:
*
*     derivative, parse, eval
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.sin" id="apidoc.element.mathjs.type.Chain.prototype.sin">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>sin
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sin = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    res = 1;                          // 0! is per definition 1
  }

  return res;
}

if (n &lt; 0.5) {
  return Math.PI / (Math.<span class="apidocCodeKeywordSpan">sin</span>(Math.PI * n) * gamma(1-n));
}

if (n &gt;= 171.35) {
  return Infinity;                    // will overflow
}

if (n &gt; 85.0) {                       // Extended Stirling Approx
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.sinh" id="apidoc.element.mathjs.type.Chain.prototype.sinh">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>sinh
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sinh = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
*    math.csch(x)
*
* Examples:
*
*    // csch(x) = 1/ sinh(x)
*    math.csch(0.5);       // returns 1.9190347513349437
*    1 / math.<span class="apidocCodeKeywordSpan">sinh</span>(0.5);   // returns 1.9190347513349437
*
* See also:
*
*    sinh, sech, coth
*
* @param {number | Complex | Unit | Array | Matrix} x  Function input
* @return {number | Complex | Array | Matrix} Hyperbolic cosecant of x
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.size" id="apidoc.element.mathjs.type.Chain.prototype.size">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>size
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">size = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

if (!Array.isArray(array) || !Array.isArray(sizes)) {
  throw new TypeError('Array expected');
}

if (sizes.length === 0) {
  throw new DimensionError(0, product(exports.<span class="apidocCodeKeywordSpan">size</span>(array)), '!=');
}

try {
  newArray  = _reshape(flatArray, sizes);
} catch (e) {
  if (e instanceof DimensionError) {
    throw new DimensionError(
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.slu" id="apidoc.element.mathjs.type.Chain.prototype.slu">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>slu
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">slu = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.smaller" id="apidoc.element.mathjs.type.Chain.prototype.smaller">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>smaller
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">smaller = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* Syntax:
*
*    math.smallerEq(x, y)
*
* Examples:
*
*    math.<span class="apidocCodeKeywordSpan">smaller</span>(1 + 2, 3);        // returns false
*    math.smallerEq(1 + 2, 3);      // returns true
*
* See also:
*
*    equal, unequal, smaller, larger, largerEq, compare
*
* @param  {number | BigNumber | Fraction | boolean | Unit | string | Array | Matrix} x First value to compare
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.smallerEq" id="apidoc.element.mathjs.type.Chain.prototype.smallerEq">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>smallerEq
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">smallerEq = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* The function returns true when x is smaller than y or the relative
* difference between x and y is smaller than the configured epsilon. The
* function cannot be used to compare values smaller than approximately 2.22e-16.
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">smallerEq</span>(x, y)
*
* Examples:
*
*    math.smaller(1 + 2, 3);        // returns false
*    math.smallerEq(1 + 2, 3);      // returns true
*
* See also:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.sort" id="apidoc.element.mathjs.type.Chain.prototype.sort">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>sort
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sort = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

/**
 * Sort the items in a matrix.
 *
 * Syntax:
 *
 *    math.<span class="apidocCodeKeywordSpan">sort</span>(x)
 *    math.sort(x, compare)
 *
 * Examples:
 *
 *    math.sort([5, 10, 1]); // returns [1, 5, 10]
 *    math.sort(['C', 'B', 'A', 'D']); // returns ['A', 'B', 'C
', 'D']
 *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.sparse" id="apidoc.element.mathjs.type.Chain.prototype.sparse">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>sparse
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sparse = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.splitUnit" id="apidoc.element.mathjs.type.Chain.prototype.splitUnit">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>splitUnit
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">splitUnit = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * Returns an array of units whose sum is equal to this unit
   * @memberof Unit
   * @param {Array} [parts] An array of strings or valueless units.
   *
   *   Example:
   *
   *   var u = new Unit(1, 'm');
   *   u.<span class="apidocCodeKeywordSpan">splitUnit</span>(['feet', 'inch']);
   *     [ 3 feet, 3.3700787401575 inch ]
   *
   * @return {Array} An array of units.
   */
  Unit.prototype.splitUnit = function(parts) {

var x = this.clone();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.sqrt" id="apidoc.element.mathjs.type.Chain.prototype.sqrt">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>sqrt
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sqrt = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// load math.js
var math = require('mathjs');

// functions and constants
math.round(math.e, 3);            // 2.718
math.atan2(3, -3) / math.pi;      // 0.75
math.log(1000, 10);               // 3
math.<span class="apidocCodeKeywordSpan">sqrt</span>(-4);                    // 2i
math.pow([[-1, 2], [3, 1]], 2);   // [[7, 0], [0, 7]]
math.derivative('x^2 + x', 'x');  // 2 * x + 1

// expressions
math.eval('12 / (2.3 + 0.7)');    // 4
math.eval('5.08 cm to inch');     // 2 inch
math.eval('sin(45 deg) ^ 2');     // 0.5
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.square" id="apidoc.element.mathjs.type.Chain.prototype.square">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>square
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">square = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Syntax:
*
*    math.sqrt(x)
*
* Examples:
*
*    math.sqrt(25);                // returns 5
*    math.<span class="apidocCodeKeywordSpan">square</span>(5);               // returns 25
*    math.sqrt(-4);                // returns Complex 2i
*
* See also:
*
*    square, multiply, cube, cbrt
*
* @param {number | BigNumber | Complex | Array | Matrix | Unit} x
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.squeeze" id="apidoc.element.mathjs.type.Chain.prototype.squeeze">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>squeeze
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">squeeze = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * @param {Array} y  Second vector
   * @returns {Array} Returns the cross product of x and y
   * @private
   */
  function _cross(x, y) {
var highestDimension = Math.max(array.size(x).length, array.size(y).length);

x = array.<span class="apidocCodeKeywordSpan">squeeze</span>(x);
y = array.squeeze(y);

var xSize = array.size(x);
var ySize = array.size(y);

if (xSize.length != 1 || ySize.length != 1 || xSize[0] != 3 || ySize[0] != 3) {
  throw new RangeError('Vectors with length 3 expected ' +
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.std" id="apidoc.element.mathjs.type.Chain.prototype.std">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>std
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">std = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* - 'unbiased' (default) The sum of squared errors is divided by (n - 1)
* - 'uncorrected'        The sum of squared errors is divided by n
* - 'biased'             The sum of squared errors is divided by (n + 1)
*
* Syntax:
*
*     math.<span class="apidocCodeKeywordSpan">std</span>(a, b, c, ...)
*     math.std(A)
*     math.std(A, normalization)
*
* Examples:
*
*     math.std(2, 4, 6);                     // returns 2
*     math.std([2, 4, 6, 8]);                // returns 2.581988897471611
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.stirlingS2" id="apidoc.element.mathjs.type.Chain.prototype.stirlingS2">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>stirlingS2
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stirlingS2 = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* stirlingS2 only takes integer arguments.
* The following condition must be enforced: k &lt;= n.
*
*  If n = k or k = 1, then s(n,k) = 1
*
* Syntax:
*
*   math.<span class="apidocCodeKeywordSpan">stirlingS2</span>(n, k)
*
* Examples:
*
*    math.stirlingS2(5, 3); //returns 25
*
* See also:
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.string" id="apidoc.element.mathjs.type.Chain.prototype.string">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>string
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">string = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function factory (type, config, load, typed) {
/**
 * Create a string or convert any object into a string.
 * Elements of Arrays and Matrices are processed element wise.
 *
 * Syntax:
 *
 *    math.<span class="apidocCodeKeywordSpan">string</span>(value)
 *
 * Examples:
 *
 *    math.string(4.2);               // returns string '4.2'
 *    math.string(math.complex(3, 2); // returns string '3 + 2i'
 *
 *    var u = math.unit(5, 'km');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.subset" id="apidoc.element.mathjs.type.Chain.prototype.subset">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>subset
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">subset = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function factory (type, config, load, typed) {
var matrix = load(require('../../type/matrix/function/matrix'));

/**
 * Get or set a subset of a matrix or string.
 *
 * Syntax:
 *     math.<span class="apidocCodeKeywordSpan">subset</span>(value, index)                                // retrieve a subset
 *     math.subset(value, index, replacement [, defaultValue])  // replace a subset
 *
 * Examples:
 *
 *     // get a subset
 *     var d = [[1, 2], [3, 4]];
 *     math.subset(d, math.index(1, 0));        // returns 3
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.subtract" id="apidoc.element.mathjs.type.Chain.prototype.subtract">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>subtract
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">subtract = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  /**
* Subtract two values, `x - y`.
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">subtract</span>(x, y)
*
* Examples:
*
*    math.subtract(5.3, 2);        // returns number 3.3
*
*    var a = math.complex(2, 3);
*    var b = math.complex(4, 1);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.sum" id="apidoc.element.mathjs.type.Chain.prototype.sum">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>sum
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sum = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Compute the sum of a matrix or a list with values.
* In case of a (multi dimensional) array or matrix, the sum of all
* elements will be calculated.
*
* Syntax:
*
*     math.<span class="apidocCodeKeywordSpan">sum</span>(a, b, c, ...)
*     math.sum(A)
*
* Examples:
*
*     math.sum(2, 1, 4, 3);               // returns 10
*     math.sum([2, 1, 4, 3]);             // returns 10
*     math.sum([[2, 5], [4, 3], [1, 7]]); // returns 22
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.tan" id="apidoc.element.mathjs.type.Chain.prototype.tan">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>tan
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tan = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Syntax:
*
*    math.atan(x)
*
* Examples:
*
*    math.atan(0.5);           // returns number 0.4636476090008061
*    math.atan(math.<span class="apidocCodeKeywordSpan">tan</span>(1.5)); // returns number 1.5
*
*    math.atan(2);             // returns Complex 1.5707963267948966 -1.3169578969248166 i
*
* See also:
*
*    tan, asin, acos
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.tanh" id="apidoc.element.mathjs.type.Chain.prototype.tanh">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>tanh
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tanh = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
*    math.coth(x)
*
* Examples:
*
*    // coth(x) = 1 / tanh(x)
*    math.coth(2);         // returns 1.0373147207275482
*    1 / math.<span class="apidocCodeKeywordSpan">tanh</span>(2);     // returns 1.0373147207275482
*
* See also:
*
*    sinh, tanh, cosh
*
* @param {number | Complex | Unit | Array | Matrix} x  Function input
* @return {number | Complex | Array | Matrix} Hyperbolic cotangent of x
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.to" id="apidoc.element.mathjs.type.Chain.prototype.to">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>to
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">to = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* Examples:
*
*    math.string(4.2);               // returns string '4.2'
*    math.string(math.complex(3, 2); // returns string '3 + 2i'
*
*    var u = math.unit(5, 'km');
*    math.string(u.<span class="apidocCodeKeywordSpan">to</span>('m'));         // returns string '5000 m'
*
*    math.string([true, false]);     // returns ['true', 'false']
*
* See also:
*
*    bignumber, boolean, complex, index, matrix, number, unit
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.toString" id="apidoc.element.mathjs.type.Chain.prototype.toString">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
  return format(this.value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      }
      else {
        scope.ans = res;
        console.log(format(res));
      }
    }
    else if (res instanceof math.type.Help) {
      console.log(res.<span class="apidocCodeKeywordSpan">toString</span>());
    }
    else {
      scope.ans = res;
      console.log(format(res));
    }
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.trace" id="apidoc.element.mathjs.type.Chain.prototype.trace">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>trace
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">trace = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  /**
* Calculate the trace of a matrix: the sum of the elements on the main
* diagonal of a square matrix.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">trace</span>(x)
*
* Examples:
*
*    math.trace([[1, 2], [3, 4]]); // returns 5
*
*    var A = [
*      [1, 2, 3],
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.transpose" id="apidoc.element.mathjs.type.Chain.prototype.transpose">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>transpose
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">transpose = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Transpose a matrix. All values of the matrix are reflected over its
* main diagonal. Only applicable to two dimensional matrices containing
* a vector (i.e. having size `[1,n]` or `[n,1]`). One dimensional
* vectors and scalars return the input unchanged.
*
* Syntax:
*
*     math.<span class="apidocCodeKeywordSpan">transpose</span>(x)
*
* Examples:
*
*     var A = [[1, 2, 3], [4, 5, 6]];
*     math.transpose(A);               // returns [[1, 4], [2, 5], [3, 6]]
*
* See also:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.typed" id="apidoc.element.mathjs.type.Chain.prototype.typed">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>typed
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">typed = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.typeof" id="apidoc.element.mathjs.type.Chain.prototype.typeof">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>typeof
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">typeof = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Determine the type of a variable.
*
* Function `typeof` recognizes the following types of objects:
*
* Object                 | Returns       | Example
* ---------------------- | ------------- | ------------------------------------------
* null                   | `'null'`      | `math.<span class="apidocCodeKeywordSpan">typeof</span>(null)`
* number                 | `'number'`    | `math.typeof(3.5)`
* boolean                | `'boolean'`   | `math.typeof (true)`
* string                 | `'string'`    | `math.typeof ('hello world')`
* Array                  | `'Array'`     | `math.typeof ([1, 2, 3])`
* Date                   | `'Date'`      | `math.typeof (new Date())`
* Function               | `'Function'`  | `math.typeof (function () {})`
* Object                 | `'Object'`    | `math.typeof ({a: 2, b: 3})`
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.unaryMinus" id="apidoc.element.mathjs.type.Chain.prototype.unaryMinus">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>unaryMinus
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unaryMinus = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* For matrices, the function is evaluated element wise. Boolean values and
* strings will be converted to a number. For complex numbers, both real and
* complex value are inverted.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">unaryMinus</span>(x)
*
* Examples:
*
*    math.unaryMinus(3.5);      // returns -3.5
*    math.unaryMinus(-4.2);     // returns 4.2
*
* See also:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.unaryPlus" id="apidoc.element.mathjs.type.Chain.prototype.unaryPlus">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>unaryPlus
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unaryPlus = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Unary plus operation.
* Boolean values and strings will be converted to a number, numeric values will be returned as is.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">unaryPlus</span>(x)
*
* Examples:
*
*    math.unaryPlus(3.5);      // returns 3.5
*    math.unaryPlus(1);     // returns 1
*
* See also:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.unequal" id="apidoc.element.mathjs.type.Chain.prototype.unequal">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>unequal
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unequal = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* Values `null` and `undefined` are compared strictly, thus `null` is unequal
* with everything except `null`, and `undefined` is unequal with everying
* except. `undefined`.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">unequal</span>(x, y)
*
* Examples:
*
*    math.unequal(2 + 2, 3);       // returns true
*    math.unequal(2 + 2, 4);       // returns false
*
*    var a = math.unit('50 cm');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.unit" id="apidoc.element.mathjs.type.Chain.prototype.unit">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>unit
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unit = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* Examples:
*
*    math.number(2);                         // returns number 2
*    math.number('7.2');                     // returns number 7.2
*    math.number(true);                      // returns number 1
*    math.number([true, false, true, true]); // returns [1, 0, 1, 1]
*    math.number(math.<span class="apidocCodeKeywordSpan">unit</span>('52cm'), 'm');    // returns 0.52
*
* See also:
*
*    bignumber, boolean, complex, index, matrix, string, unit
*
* @param {string | number | BigNumber | Fraction | boolean | Array | Matrix | Unit | null} [value]  Value to be converted
* @param {Unit | string} [valuelessUnit] A valueless unit, used to convert a unit to a number
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.usolve" id="apidoc.element.mathjs.type.Chain.prototype.usolve">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>usolve
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">usolve = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.valueOf" id="apidoc.element.mathjs.type.Chain.prototype.valueOf">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>valueOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">valueOf = function () {
  return this.value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    throw new TypeError('Cannot implicitly convert a Fraction to BigNumber or vice versa. ' +
        'Use function bignumber(x) to convert to BigNumber or fraction(x) to convert to Fraction.');
  }
}, {
  from: 'Fraction',
  to: 'Complex',
  convert: function (x) {
    return new type.Complex(x.<span class="apidocCodeKeywordSpan">valueOf</span>(), 0);
  }
}, {
  from: 'number',
  to: 'Fraction',
  convert: function (x) {
    if (digits(x) &gt; 15) {
      throw new TypeError('Cannot implicitly convert a number with &gt;15 significant digits to Fraction ' +
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.var" id="apidoc.element.mathjs.type.Chain.prototype.var">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>var
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">var = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* - 'unbiased' (default) The sum of squared errors is divided by (n - 1)
* - 'uncorrected'        The sum of squared errors is divided by n
* - 'biased'             The sum of squared errors is divided by (n + 1)
*
* Note that older browser may not like the variable name `var`. In that
* case, the function can be called as `math['var'](...)` instead of
* `math.<span class="apidocCodeKeywordSpan">var</span>(...)`.
*
* Syntax:
*
*     math.var(a, b, c, ...)
*     math.var(A)
*     math.var(A, normalization)
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.xgcd" id="apidoc.element.mathjs.type.Chain.prototype.xgcd">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>xgcd
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">xgcd = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  /**
* Calculate the extended greatest common divisor for two values.
* See http://en.wikipedia.org/wiki/Extended_Euclidean_algorithm.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">xgcd</span>(a, b)
*
* Examples:
*
*    math.xgcd(8, 12);             // returns [4, -1, 1]
*    math.gcd(8, 12);              // returns 4
*    math.xgcd(36163, 21199);      // returns [1247, -7, 12]
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.xor" id="apidoc.element.mathjs.type.Chain.prototype.xor">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>xor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">xor = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  /**
* Logical `xor`. Test whether one and only one value is defined with a nonzero/nonempty value.
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">xor</span>(x, y)
*
* Examples:
*
*    math.xor(2, 4);   // returns false
*
*    a = [2, 0, 0];
*    b = [2, 7, 0];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Chain.prototype.zeros" id="apidoc.element.mathjs.type.Chain.prototype.zeros">
        function <span class="apidocSignatureSpan">mathjs.type.Chain.prototype.</span>zeros
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">zeros = function () {
  var args = [this.value];  // `this` will be the context of a Chain instance
  for (var i = 0; i &lt; arguments.length; i++) {
    args[i + 1] = arguments[i];
  }

  return new Chain(fn.apply(fn, args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*     math.squeeze(x)
*
* Examples:
*
*     math.squeeze([3]);           // returns 3
*     math.squeeze([[3]]);         // returns 3
*
*     var A = math.<span class="apidocCodeKeywordSpan">zeros</span>(3, 1);    // returns [[0], [0], [0]] (size 3x1)
*     math.squeeze(A);             // returns [0, 0, 0] (size 3)
*
*     var B = math.zeros(1, 3);    // returns [[0, 0, 0]] (size 1x3)
*     math.squeeze(B);             // returns [0, 0, 0] (size 3)
*
*     // only inner and outer dimensions are removed
*     var C = math.zeros(2, 1, 3); // returns [[[0, 0, 0]], [[0, 0, 0]]] (size 2x1x3)
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.type.Complex" id="apidoc.module.mathjs.type.Complex">module mathjs.type.Complex</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.type.Complex.Complex" id="apidoc.element.mathjs.type.Complex.Complex">
        function <span class="apidocSignatureSpan">mathjs.type.</span>Complex
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Complex(a, b) {

  if (!(this instanceof Complex)) {
    return new Complex(a, b);
  }

  parse(a, b); // mutates P

  this["re"] = P["re"];
  this["im"] = P["im"];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
    return new type.BigNumber(x);
  }
}, {
  from: 'number',
  to: 'Complex',
  convert: function (x) {
    return new type.<span class="apidocCodeKeywordSpan">Complex</span>(x, 0);
  }
}, {
  from: 'number',
  to: 'string',
  convert: function (x) {
    return x + '';
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Complex.fromJSON" id="apidoc.element.mathjs.type.Complex.fromJSON">
        function <span class="apidocSignatureSpan">mathjs.type.Complex.</span>fromJSON
        <span class="apidocSignatureSpan">(json)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromJSON = function (json) {
  return new Complex(json);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * @param {string} key
   * @param {*} value
   * @returns {*} Returns the revived object
   */
  return function reviver(key, value) {
    var constructor = type[value &amp;&amp; value.mathjs];
    if (constructor &amp;&amp; typeof constructor.fromJSON === 'function') {
      return constructor.<span class="apidocCodeKeywordSpan">fromJSON</span>(value);
    }

    return value;
  }
}

exports.name = 'reviver';
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Complex.fromPolar" id="apidoc.element.mathjs.type.Complex.fromPolar">
        function <span class="apidocSignatureSpan">mathjs.type.Complex.</span>fromPolar
        <span class="apidocSignatureSpan">(args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromPolar = function (args) {
  switch (arguments.length) {
    case 1:
      var arg = arguments[0];
      if (typeof arg === 'object') {
        return Complex(arg);
      }
      throw new TypeError('Input has to be an object with r and phi keys.');

    case 2:
      var r = arguments[0],
          phi = arguments[1];
      if (isNumber(r)) {
        if (phi &amp;&amp; phi.isUnit &amp;&amp; phi.hasBase('ANGLE')) {
          // convert unit to a number in radians
          phi = phi.toNumber('rad');
        }

        if (isNumber(phi)) {
          return new Complex({r: r, phi: phi});
        }

        throw new TypeError('Phi is not a number nor an angle unit.');
      } else {
        throw new TypeError('Radius r is not a number.');
      }

    default:
      throw new SyntaxError('Wrong number of arguments in function fromPolar');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

/**
 * Create a complex number from polar coordinates
 *
 * Usage:
 *
 *     Complex.<span class="apidocCodeKeywordSpan">fromPolar</span>(r: number, phi: number) : Complex
 *     Complex.fromPolar({r: number, phi: number}) : Complex
 *
 * @param {*} args...
 * @return {Complex}
 */
Complex.fromPolar = function (args) {
  switch (arguments.length) {
...</pre></li>
    </ul>














</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.type.Complex.prototype" id="apidoc.module.mathjs.type.Complex.prototype">module mathjs.type.Complex.prototype</a></h1>




    <h2>
        <a href="#apidoc.element.mathjs.type.Complex.prototype.abs" id="apidoc.element.mathjs.type.Complex.prototype.abs">
        function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>abs
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">abs = function () {

  var a = Math.abs(this["re"]);
  var b = Math.abs(this["im"]);

  if (a &lt; 3000 &amp;&amp; b &lt; 3000) {
    return Math.sqrt(a * a + b * b);
  }

  if (a &lt; b) {
    a = b;
    b = this["re"] / this["im"];
  } else {
    b = this["im"] / this["re"];
  }
  return a * Math.sqrt(1 + b * b);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function factory (type, config, load, typed) {
/**
 * Calculate the absolute value of a number. For matrices, the function is
 * evaluated element wise.
 *
 * Syntax:
 *
 *    math.<span class="apidocCodeKeywordSpan">abs</span>(x)
 *
 * Examples:
 *
 *    math.abs(3.5);                // returns number 3.5
 *    math.abs(-4.2);               // returns number 4.2
 *
 *    math.abs([3, -5, -1, 0, 2]);  // returns Array [3, 5, 1, 0, 2]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Complex.prototype.acos" id="apidoc.element.mathjs.type.Complex.prototype.acos">
        function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>acos
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">acos = function () {

  var a = this["re"];
  var b = this["im"];

  var t1 = new Complex(
           b * b - a * a + 1,
          -2 * a * b)['sqrt']();

  var t2 = new Complex(
          t1["re"] - b,
          t1["im"] + a)['log']();

  return new Complex(Math.PI / 2 - t2["im"], t2["re"]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Calculate the inverse cosine of a value.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">acos</span>(x)
*
* Examples:
*
*    math.acos(0.5);           // returns number 1.0471975511965979
*    math.acos(math.cos(1.5)); // returns number 1.5
*
*    math.acos(2);             // returns Complex 0 + 1.3169578969248166 i
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Complex.prototype.acosh" id="apidoc.element.mathjs.type.Complex.prototype.acosh">
        function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>acosh
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">acosh = function () {

  var tmp;
  var res = this["acos"]();
  if (res["im"] &lt;= 0) {
    tmp = res["re"];
    res["re"] = -res["im"];
    res["im"] = tmp;
  } else {
    tmp = res["im"];
    res["im"] = -res["re"];
    res["re"] = tmp;
  }
  return res;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Calculate the hyperbolic arccos of a value,
* defined as `acosh(x) = ln(sqrt(x^2 - 1) + x)`.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">acosh</span>(x)
*
* Examples:
*
*    math.acosh(1.5);       // returns 0.9624236501192069
*
* See also:
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Complex.prototype.acot" id="apidoc.element.mathjs.type.Complex.prototype.acot">
        function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>acot
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">acot = function () {

  var a = this["re"];
  var b = this["im"];

  if (b === 0) {
    return new Complex(Math.atan2(1, a), 0);
  }

  var d = a * a + b * b;
  return (d !== 0)
          ? new Complex(
                  a / d,
                 -b / d).atan()
          : new Complex(
                  (a !== 0) ? a / 0 : 0,
                  (b !== 0) ?-b / 0 : 0).atan();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Calculate the inverse cotangent of a value, defined as `acot(x) = atan(1/x)`.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">acot</span>(x)
*
* Examples:
*
*    math.acot(0.5);           // returns number 0.4636476090008061
*    math.acot(math.cot(1.5)); // returns number 1.5
*
*    math.acot(2);             // returns Complex 1.5707963267948966 -1.3169578969248166 i
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Complex.prototype.acoth" id="apidoc.element.mathjs.type.Complex.prototype.acoth">
        function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>acoth
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">acoth = function () {

  var a = this["re"];
  var b = this["im"];

  if (a === 0 &amp;&amp; b === 0) {

    return new Complex(0, Math.PI / 2);
  }

  var d = a * a + b * b;
  return (d !== 0)
          ? new Complex(
                  a / d,
                 -b / d).atanh()
          : new Complex(
                  (a !== 0) ? a / 0 : 0,
                  (b !== 0) ?-b / 0 : 0).atanh();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Calculate the hyperbolic arccotangent of a value,
* defined as `acoth(x) = atanh(1/x) = (ln((x+1)/x) + ln(x/(x-1))) / 2`.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">acoth</span>(x)
*
* Examples:
*
*    math.acoth(0.5);       // returns 0.8047189562170503
*
* See also:
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Complex.prototype.acsc" id="apidoc.element.mathjs.type.Complex.prototype.acsc">
        function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>acsc
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">acsc = function () {

  var a = this["re"];
  var b = this["im"];

  if (a === 0 &amp;&amp; b === 0) {
    return new Complex(Math.PI / 2, Infinity);
  }

  var d = a * a + b * b;
  return (d !== 0)
          ? new Complex(
                  a / d,
                 -b / d).asin()
          : new Complex(
                  (a !== 0) ? a / 0 : 0,
                  (b !== 0) ?-b / 0 : 0).asin();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Calculate the inverse cosecant of a value, defined as `acsc(x) = asin(1/x)`.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">acsc</span>(x)
*
* Examples:
*
*    math.acsc(0.5);           // returns number 0.5235987755982989
*    math.acsc(math.csc(1.5)); // returns number ~1.5
*
*    math.acsc(2);             // returns Complex 1.5707963267948966 -1.3169578969248166 i
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Complex.prototype.acsch" id="apidoc.element.mathjs.type.Complex.prototype.acsch">
        function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>acsch
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">acsch = function () {

  var a = this["re"];
  var b = this["im"];

  if (b === 0) {

    return new Complex(
            (a !== 0)
            ? Math.log(a + Math.sqrt(a * a + 1))
            : Infinity, 0);
  }

  var d = a * a + b * b;
  return (d !== 0)
          ? new Complex(
                  a / d,
                  -b / d).asinh()
          : new Complex(
                  (a !== 0) ? a / 0 : 0,
                  (b !== 0) ?-b / 0 : 0).asinh();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Calculate the hyperbolic arccosecant of a value,
* defined as `acsch(x) = asinh(1/x) = ln(1/x + sqrt(1/x^2 + 1))`.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">acsch</span>(x)
*
* Examples:
*
*    math.acsch(0.5);       // returns 1.4436354751788103
*
* See also:
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Complex.prototype.add" id="apidoc.element.mathjs.type.Complex.prototype.add">
        function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>add
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">add = function (a, b) {

  parse(a, b); // mutates P

  return new Complex(
          this["re"] + P["re"],
          this["im"] + P["im"]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
math.eval('5.08 cm to inch');     // 2 inch
math.eval('sin(45 deg) ^ 2');     // 0.5
math.eval('9 / 3 + 2i');          // 3 + 2i
math.eval('det([-1, 2; 3, 1])');  // -7

// chaining
math.chain(3)
    .<span class="apidocCodeKeywordSpan">add</span>(4)
    .multiply(2)
    .done(); // 14
```

## Browser support

Math.js works on any ES5 compatible JavaScript engine: node.js 0.10, and Internet Explorer 9 and newer, and all other browsers (
Chrome, Firefox, Safari). If support for old browsers like Internet Explorer 8 is required, the [es5-shim](https://github.com/kriskowal
/es5-shim) library has to be loaded.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Complex.prototype.arg" id="apidoc.element.mathjs.type.Complex.prototype.arg">
        function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>arg
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">arg = function () {

  return Math.atan2(this["im"], this["re"]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   *                               the principal root is returned.
   * @returns {Complex | Array.&lt;Complex&gt; | Matrix.&lt;Complex&gt;} Returns the cubic root(s) of x
   * @private
   */
  function _cbrtComplex(x, allRoots) {
// https://www.wikiwand.com/en/Cube_root#/Complex_numbers

var arg_3 = x.<span class="apidocCodeKeywordSpan">arg</span>() / 3;
var abs = x.abs();

// principal root:
var principal = new type.Complex(_cbrtNumber(abs), 0).mul(
    new type.Complex(0, arg_3).exp());

if (allRoots) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Complex.prototype.asec" id="apidoc.element.mathjs.type.Complex.prototype.asec">
        function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>asec
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">asec = function () {

  var a = this["re"];
  var b = this["im"];

  if (a === 0 &amp;&amp; b === 0) {
    return new Complex(0, Infinity);
  }

  var d = a * a + b * b;
  return (d !== 0)
          ? new Complex(
                  a / d,
                  -b / d).acos()
          : new Complex(
                  (a !== 0) ? a / 0 : 0,
                  (b !== 0) ?-b / 0 : 0).acos();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Calculate the inverse secant of a value. Defined as `asec(x) = acos(1/x)`.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">asec</span>(x)
*
* Examples:
*
*    math.asec(0.5);           // returns 1.0471975511965979
*    math.asec(math.sec(1.5)); // returns 1.5
*
*    math.asec(2);             // returns 0 + 1.3169578969248166 i
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Complex.prototype.asech" id="apidoc.element.mathjs.type.Complex.prototype.asech">
        function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>asech
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">asech = function () {

  var a = this["re"];
  var b = this["im"];

  if (a === 0 &amp;&amp; b === 0) {
    return new Complex(Infinity, 0);
  }

  var d = a * a + b * b;
  return (d !== 0)
          ? new Complex(
                  a / d,
                 -b / d).acosh()
          : new Complex(
                  (a !== 0) ? a / 0 : 0,
                  (b !== 0) ?-b / 0 : 0).acosh();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Calculate the hyperbolic arcsecant of a value,
* defined as `asech(x) = acosh(1/x) = ln(sqrt(1/x^2 - 1) + 1/x)`.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">asech</span>(x)
*
* Examples:
*
*    math.asech(0.5);       // returns 1.3169578969248166
*
* See also:
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Complex.prototype.asin" id="apidoc.element.mathjs.type.Complex.prototype.asin">
        function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>asin
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">asin = function () {

  var a = this["re"];
  var b = this["im"];

  var t1 = new Complex(
           b * b - a * a + 1,
          -2 * a * b)['sqrt']();

  var t2 = new Complex(
          t1['re'] - b,
          t1['im'] + a)['log']();

  return new Complex(t2['im'], -t2['re']);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   *
   * @param {number | Complex | Array | Matrix} x   Function input
   * @return {number | Complex | Array | Matrix} The arc cosecant of x
   */
  var acsc = typed('acsc', {
'number': function (x) {
  if (x &lt;= -1 || x &gt;= 1 || config.predictable) {
    return Math.<span class="apidocCodeKeywordSpan">asin</span>(1 / x);
  }
  return new type.Complex(x, 0).acsc();
},

'Complex': function (x) {
  return x.acsc();
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Complex.prototype.asinh" id="apidoc.element.mathjs.type.Complex.prototype.asinh">
        function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>asinh
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">asinh = function () {

  var tmp = this["im"];
  this["im"] = -this["re"];
  this["re"] = tmp;
  var res = this["asin"]();

  this["re"] = -this["im"];
  this["im"] = tmp;
  tmp = res["re"];

  res["re"] = -res["im"];
  res["im"] = tmp;
  return res;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  },

  'Complex': function (x) {
    return x.acsch();
  },

  'BigNumber': function (x) {
    return new type.BigNumber(1).div(x).<span class="apidocCodeKeywordSpan">asinh</span>();
  },

  'Array | Matrix': function (x) {
    return deepMap(x, acsch);
  }
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Complex.prototype.atan" id="apidoc.element.mathjs.type.Complex.prototype.atan">
        function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>atan
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">atan = function () {

  var a = this["re"];
  var b = this["im"];

  if (a === 0) {

    if (b === 1) {
      return new Complex(0, Infinity);
    }

    if (b === -1) {
      return new Complex(0, -Infinity);
    }
  }

  var d = a * a + (1.0 - b) * (1.0 - b);

  var t1 = new Complex(
          (1 - b * b - a * a) / d,
          -2 * a / d).log();

  return new Complex(-0.5 * t1["im"], 0.5 * t1["re"]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   *    cot, atan
   *
   * @param {number | Complex | Array | Matrix} x   Function input
   * @return {number | Complex | Array | Matrix} The arc cotangent of x
   */
  var acot = typed('acot', {
'number': function (x) {
  return Math.<span class="apidocCodeKeywordSpan">atan</span>(1 / x);
},

'Complex': function (x) {
  return x.acot();
},

'BigNumber': function (x) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Complex.prototype.atanh" id="apidoc.element.mathjs.type.Complex.prototype.atanh">
        function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>atanh
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">atanh = function () {

  var a = this["re"];
  var b = this["im"];

  var noIM = a &gt; 1 &amp;&amp; b === 0;
  var oneMinus = 1 - a;
  var onePlus = 1 + a;
  var d = oneMinus * oneMinus + b * b;

  var x = (d !== 0)
          ? new Complex(
                  (onePlus * oneMinus - b * b) / d,
                  (b * oneMinus + onePlus * b) / d)
          : new Complex(
                  (a !== -1) ? (a / 0) : 0,
                  (b !== 0) ? (b / 0) : 0);

  var temp = x["re"];
  x["re"] = logHypot(x["re"], x["im"]) / 2;
  x["im"] = Math.atan2(x["im"], temp) / 2;
  if (noIM) {
    x["im"] = -x["im"];
  }
  return x;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  },

  'Complex': function (x) {
    return x.acoth();
  },

  'BigNumber': function (x) {
    return new type.BigNumber(1).div(x).<span class="apidocCodeKeywordSpan">atanh</span>();
  },

  'Array | Matrix': function (x) {
    return deepMap(x, acoth);
  }
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Complex.prototype.ceil" id="apidoc.element.mathjs.type.Complex.prototype.ceil">
        function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>ceil
        <span class="apidocSignatureSpan">(places)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ceil = function (places) {

  places = Math.pow(10, places || 0);

  return new Complex(
          Math.ceil(this["re"] * places) / places,
          Math.ceil(this["im"] * places) / places);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Round a value towards plus infinity
* If `x` is complex, both real and imaginary part are rounded towards plus infinity.
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">ceil</span>(x)
*
* Examples:
*
*    math.ceil(3.2);               // returns number 4
*    math.ceil(3.8);               // returns number 4
*    math.ceil(-4.2);              // returns number -4
*    math.ceil(-4.7);              // returns number -4
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Complex.prototype.clone" id="apidoc.element.mathjs.type.Complex.prototype.clone">
        function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>clone
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clone = function () {

  return new Complex(this["re"], this["im"]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return desc;
};

/**
 * Export the help object to JSON
 */
Help.prototype.toJSON = function () {
  var obj = object.<span class="apidocCodeKeywordSpan">clone</span>(this.doc);
  obj.mathjs = 'Help';
  return obj;
};

/**
 * Instantiate a Help object from a JSON object
 * @param {Object} json
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Complex.prototype.conjugate" id="apidoc.element.mathjs.type.Complex.prototype.conjugate">
        function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>conjugate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">conjugate = function () {

  return new Complex(this["re"], -this["im"]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  },

  'BigNumber': function (x) {
    return x;
  },

  'Complex': function (x) {
    return x.<span class="apidocCodeKeywordSpan">conjugate</span>();
  },

  'Array | Matrix': function (x) {
    return deepMap(x, conj);
  }
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Complex.prototype.cos" id="apidoc.element.mathjs.type.Complex.prototype.cos">
        function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>cos
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cos = function () {

  var a = this["re"];
  var b = this["im"];

  return new Complex(
          Math.cos(a) * Math.cosh(b),
         -Math.sin(a) * Math.sinh(b));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      var u1, u2,
          picked = -1;
      // We reject values outside of the interval [0, 1]
      // TODO: check if it is ok to do that?
      while (picked &lt; 0 || picked &gt; 1) {
        u1 = rng();
        u2 = rng();
        picked = 1/6 * Math.pow(-2 * Math.log(u1), 0.5) * Math.<span class="apidocCodeKeywordSpan">cos</span>(2 * Math.PI * u2) +
0.5;
      }
      return picked;
    }
  }
};

distribution.toTex = undefined; // use default template
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Complex.prototype.cosh" id="apidoc.element.mathjs.type.Complex.prototype.cosh">
        function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>cosh
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cosh = function () {

  var a = this["re"];
  var b = this["im"];

  return new Complex(
          Math.cosh(a) * Math.cos(b),
          Math.sinh(a) * Math.sin(b));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Calculate the hyperbolic cosine of a value,
* defined as `cosh(x) = 1/2 * (exp(x) + exp(-x))`.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">cosh</span>(x)
*
* Examples:
*
*    math.cosh(0.5);       // returns number 1.1276259652063807
*
* See also:
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Complex.prototype.cot" id="apidoc.element.mathjs.type.Complex.prototype.cot">
        function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>cot
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cot = function () {

  var a = 2 * this["re"];
  var b = 2 * this["im"];
  var d = Math.cos(a) - Math.cosh(b);

  return new Complex(
         -Math.sin(a) / d,
          Math.sinh(b) / d);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Syntax:
*
*    math.acot(x)
*
* Examples:
*
*    math.acot(0.5);           // returns number 0.4636476090008061
*    math.acot(math.<span class="apidocCodeKeywordSpan">cot</span>(1.5)); // returns number 1.5
*
*    math.acot(2);             // returns Complex 1.5707963267948966 -1.3169578969248166 i
*
* See also:
*
*    cot, atan
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Complex.prototype.coth" id="apidoc.element.mathjs.type.Complex.prototype.coth">
        function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>coth
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">coth = function () {

  var a = 2 * this["re"];
  var b = 2 * this["im"];
  var d = Math.cosh(a) - Math.cos(b);

  return new Complex(
          Math.sinh(a) / d,
         -Math.sin(b) / d);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Calculate the hyperbolic cotangent of a value,
* defined as `coth(x) = 1 / tanh(x)`.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">coth</span>(x)
*
* Examples:
*
*    // coth(x) = 1 / tanh(x)
*    math.coth(2);         // returns 1.0373147207275482
*    1 / math.tanh(2);     // returns 1.0373147207275482
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Complex.prototype.csc" id="apidoc.element.mathjs.type.Complex.prototype.csc">
        function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>csc
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">csc = function () {

  var a = this["re"];
  var b = this["im"];
  var d = 0.5 * Math.cosh(2 * b) - 0.5 * Math.cos(2 * a);

  return new Complex(
          Math.sin(a) * Math.cosh(b) / d,
         -Math.cos(a) * Math.sinh(b) / d);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Syntax:
*
*    math.acsc(x)
*
* Examples:
*
*    math.acsc(0.5);           // returns number 0.5235987755982989
*    math.acsc(math.<span class="apidocCodeKeywordSpan">csc</span>(1.5)); // returns number ~1.5
*
*    math.acsc(2);             // returns Complex 1.5707963267948966 -1.3169578969248166 i
*
* See also:
*
*    csc, asin, asec
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Complex.prototype.csch" id="apidoc.element.mathjs.type.Complex.prototype.csch">
        function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>csch
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">csch = function () {

  var a = this["re"];
  var b = this["im"];
  var d = Math.cos(2 * b) - Math.cosh(2 * a);

  return new Complex(
       -2 * Math.sinh(a) * Math.cos(b) / d,
        2 * Math.cosh(a) * Math.sin(b) / d);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Calculate the hyperbolic cosecant of a value,
* defined as `csch(x) = 1 / sinh(x)`.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">csch</span>(x)
*
* Examples:
*
*    // csch(x) = 1/ sinh(x)
*    math.csch(0.5);       // returns 1.9190347513349437
*    1 / math.sinh(0.5);   // returns 1.9190347513349437
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Complex.prototype.div" id="apidoc.element.mathjs.type.Complex.prototype.div">
        function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>div
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">div = function (a, b) {

  parse(a, b); // mutates P

  a = this["re"];
  b = this["im"];

  var c = P["re"];
  var d = P["im"];
  var t, x;

  // Divisor is zero
  if (0 === c &amp;&amp; 0 === d) {
    return new Complex(
            (a !== 0) ? (a / 0) : 0,
            (b !== 0) ? (b / 0) : 0);
  }

  // Divisor is rational
  if (0 === d) {
    return new Complex(a / c, b / c);
  }

  if (Math.abs(c) &lt; Math.abs(d)) {

    x = c / d;
    t = c * x + d;

    return new Complex(
            (a * x + b) / t,
            (b * x - a) / t);

  } else {

    x = d / c;
    t = d * x + c;

    return new Complex(
            (a + b * x) / t,
            (b - a * x) / t);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  setLazyConstant(math, 'e',   function () {return bigConstants.e(type.BigNumber)});
  setLazyConstant(math, 'phi', function () {return bigConstants.phi(type.BigNumber)}); // golden ratio, (1+sqrt(5))/2

  // uppercase constants (for compatibility with built-in Math)
  setLazyConstant(math, 'E',       function () {return math.e;});
  setLazyConstant(math, 'LN2',     function () {return new type.BigNumber(2).ln();});
  setLazyConstant(math, 'LN10',    function () {return new type.BigNumber(10).ln()});
  setLazyConstant(math, 'LOG2E',   function () {return new type.BigNumber(1).<span class="apidocCodeKeywordSpan">div<!--
span-->(new type.BigNumber(2).ln());});
  setLazyConstant(math, 'LOG10E',  function () {return new type.BigNumber(1).div(new type.BigNumber(10).ln())});
  setLazyConstant(math, 'PI',      function () {return math.pi});
  setLazyConstant(math, 'SQRT1_2', function () {return new type.BigNumber('0.5').sqrt()});
  setLazyConstant(math, 'SQRT2',   function () {return new type.BigNumber(2).sqrt()});
}
else {
  setConstant(math, 'Infinity', Infinity);
...</span></pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Complex.prototype.equals" id="apidoc.element.mathjs.type.Complex.prototype.equals">
        function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>equals
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">equals = function (a, b) {

  parse(a, b); // mutates P

  return Math.abs(P["re"] - this["re"]) &lt;= Complex["EPSILON"] &amp;&amp;
         Math.abs(P["im"] - this["im"]) &lt;= Complex["EPSILON"];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (inv) {
  root = root.neg();
}

if (root.isZero()) {
  throw new Error('Root must be non-zero');
}
if (a.isNegative() &amp;&amp; !root.abs().mod(2).<span class="apidocCodeKeywordSpan">equals</span>(1)) {
  throw new Error('Root must be odd when a is negative.');
}

// edge cases zero and infinity
if (a.isZero()) {
  return inv ? new Big(Infinity) : 0;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Complex.prototype.exp" id="apidoc.element.mathjs.type.Complex.prototype.exp">
        function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>exp
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exp = function () {

  var tmp = Math.exp(this["re"]);

  if (this["im"] === 0) {
    //return new Complex(tmp, 0);
  }
  return new Complex(
          tmp * Math.cos(this["im"]),
          tmp * Math.sin(this["im"]));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// https://www.wikiwand.com/en/Cube_root#/Complex_numbers

var arg_3 = x.arg() / 3;
var abs = x.abs();

// principal root:
var principal = new type.Complex(_cbrtNumber(abs), 0).mul(
    new type.Complex(0, arg_3).<span class="apidocCodeKeywordSpan">exp</span>());

if (allRoots) {
  var all = [
      principal,
      new type.Complex(_cbrtNumber(abs), 0).mul(
        new type.Complex(0, arg_3 + Math.PI * 2 / 3).exp()),
      new type.Complex(_cbrtNumber(abs), 0).mul(
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Complex.prototype.floor" id="apidoc.element.mathjs.type.Complex.prototype.floor">
        function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>floor
        <span class="apidocSignatureSpan">(places)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">floor = function (places) {

  places = Math.pow(10, places || 0);

  return new Complex(
          Math.floor(this["re"] * places) / places,
          Math.floor(this["im"] * places) / places);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   *    ceil, floor, round
   *
   * @param {number | BigNumber | Fraction | Complex | Array | Matrix} x Number to be rounded
   * @return {number | BigNumber | Fraction | Complex | Array | Matrix}            Rounded value
   */
  var fix = typed('fix', {
'number': function (x) {
  return (x &gt; 0) ? Math.<span class="apidocCodeKeywordSpan">floor</span>(x) : Math.ceil(x);
},

'Complex': function (x) {
  return new type.Complex(
      (x.re &gt; 0) ? Math.floor(x.re) : Math.ceil(x.re),
      (x.im &gt; 0) ? Math.floor(x.im) : Math.ceil(x.im)
  );
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Complex.prototype.format" id="apidoc.element.mathjs.type.Complex.prototype.format">
        function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>format
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">format = function (options) {
  var str = '';
  var im = this.im;
  var re = this.re;
  var strRe = format(this.re, options);
  var strIm = format(this.im, options);

  // round either re or im when smaller than the configured precision
  var precision = isNumber(options) ? options : options ? options.precision : null;
  if (precision !== null) {
    var epsilon = Math.pow(10, -precision);
    if (Math.abs(re / im) &lt; epsilon) {
      re = 0;
    }
    if (Math.abs(im / re) &lt; epsilon) {
      im = 0;
    }
  }

  if (im == 0) {
    // real value
    str = strRe;
  } else if (re == 0) {
    // purely complex value
    if (im == 1) {
      str = 'i';
    } else if (im == -1) {
      str = '-i';
    } else {
      str = strIm + 'i';
    }
  } else {
    // complex value
    if (im &gt; 0) {
      if (im == 1) {
        str = strRe + ' + i';
      } else {
        str = strRe + ' + ' + strIm + 'i';
      }
    } else {
      if (im == -1) {
        str = strRe + ' - i';
      } else {
        str = strRe + ' - ' + strIm.substring(1) + 'i';
      }
    }
  }
  return str;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Helper function to format a value. Regular numbers will be rounded
 * to 14 digits to prevent round-off errors from showing up.
 * @param {*} value
 */
function format(value) {
var math = getMath();

return math.<span class="apidocCodeKeywordSpan">format</span>(value, {
  fn: function (value) {
    if (typeof value === 'number') {
      // round numbers
      return math.format(value, PRECISION);
    }
    else {
      return math.format(value);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Complex.prototype.inverse" id="apidoc.element.mathjs.type.Complex.prototype.inverse">
        function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>inverse
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inverse = function () {

  var a = this["re"];
  var b = this["im"];

  var d = a * a + b * b;

  return new Complex(
          a !== 0 ? a / d : 0,
          b !== 0 ?-b / d : 0);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Complex.prototype.isNaN" id="apidoc.element.mathjs.type.Complex.prototype.isNaN">
        function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>isNaN
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isNaN = function () {
  return isNaN(this['re']) || isNaN(this['im']);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
},

'Complex, Complex': function (x, y) {
  return (x.re !== 0 || x.im !== 0) &amp;&amp; (y.re !== 0 || y.im !== 0);
},

'BigNumber, BigNumber': function (x, y) {
  return !x.isZero() &amp;&amp; !y.isZero() &amp;&amp; !x.<span class="apidocCodeKeywordSpan">isNaN</span>() &amp;&amp; !y
.isNaN();
},

'Unit, Unit': function (x, y) {
  return and(x.value, y.value);
},

'Matrix, Matrix': function (x, y) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Complex.prototype.log" id="apidoc.element.mathjs.type.Complex.prototype.log">
        function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>log
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">log = function () {

  var a = this["re"];
  var b = this["im"];

  if (b === 0 &amp;&amp; a &gt; 0) {
    //return new Complex(Math.log(a), 0);
  }

  return new Complex(
          logHypot(a, b),
          Math.atan2(b, a));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
// load math.js
var math = require('mathjs');

// functions and constants
math.round(math.e, 3);            // 2.718
math.atan2(3, -3) / math.pi;      // 0.75
math.<span class="apidocCodeKeywordSpan">log</span>(1000, 10);               // 3
math.sqrt(-4);                    // 2i
math.pow([[-1, 2], [3, 1]], 2);   // [[7, 0], [0, 7]]
math.derivative('x^2 + x', 'x');  // 2 * x + 1

// expressions
math.eval('12 / (2.3 + 0.7)');    // 4
math.eval('5.08 cm to inch');     // 2 inch
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Complex.prototype.mul" id="apidoc.element.mathjs.type.Complex.prototype.mul">
        function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>mul
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mul = function (a, b) {

  parse(a, b); // mutates P

  // Besides the addition/subtraction, this helps having a solution for rational Infinity
  if (P['im'] === 0 &amp;&amp; this['im'] === 0) {
    return new Complex(this['re'] * P['re'], 0);
  }

  return new Complex(
          this["re"] * P["re"] - this["im"] * P["im"],
          this["re"] * P["im"] + this["im"] * P["re"]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  function _cbrtComplex(x, allRoots) {
// https://www.wikiwand.com/en/Cube_root#/Complex_numbers

var arg_3 = x.arg() / 3;
var abs = x.abs();

// principal root:
var principal = new type.Complex(_cbrtNumber(abs), 0).<span class="apidocCodeKeywordSpan">mul</span>(
    new type.Complex(0, arg_3).exp());

if (allRoots) {
  var all = [
      principal,
      new type.Complex(_cbrtNumber(abs), 0).mul(
        new type.Complex(0, arg_3 + Math.PI * 2 / 3).exp()),
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Complex.prototype.neg" id="apidoc.element.mathjs.type.Complex.prototype.neg">
        function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>neg
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">neg = function () {

  return new Complex(-this["re"], -this["im"]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   // http://en.wikipedia.org/wiki/Euclidean_algorithm
   var zero = new type.BigNumber(0);
   while (!b.isZero()) {
     var r = a.mod(b);
     a = b;
     b = r;
   }
   return a.lt(zero) ? a.<span class="apidocCodeKeywordSpan">neg</span>() : a;
 }
}

/**
* Calculate gcd for numbers
* @param {number} a
* @param {number} b
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Complex.prototype.pow" id="apidoc.element.mathjs.type.Complex.prototype.pow">
        function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>pow
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pow = function (a, b) {

  parse(a, b); // mutates P

  a = this["re"];
  b = this["im"];

  if (a === 0 &amp;&amp; b === 0) {
    return new Complex(0, 0);
  }

  var arg = Math.atan2(b, a);
  var loh = logHypot(a, b);

  if (P["im"] === 0) {

    if (b === 0 &amp;&amp; a &gt;= 0) {

      return new Complex(Math.pow(a, P["re"]), 0);

    } else if (a === 0) {

      switch (P["re"] % 4) {
        case 0:
          return new Complex(Math.pow(b, P["re"]), 0);
        case 1:
          return new Complex(0, Math.pow(b, P["re"]));
        case 2:
          return new Complex(-Math.pow(b, P["re"]), 0);
        case 3:
          return new Complex(0, -Math.pow(b, P["re"]));
      }
    }
  }

<span class="apidocCodeCommentSpan">  /* I couldn"t find a good formula, so here is a derivation and optimization
   *
   * z_1^z_2 = (a + bi)^(c + di)
   *         = exp((c + di) * log(a + bi)
   *         = pow(a^2 + b^2, (c + di) / 2) * exp(i(c + di)atan2(b, a))
   * =&gt;...
   * Re = (pow(a^2 + b^2, c / 2) * exp(-d * atan2(b, a))) * cos(d * log(a^2 + b^2) / 2 + c * atan2(b, a))
   * Im = (pow(a^2 + b^2, c / 2) * exp(-d * atan2(b, a))) * sin(d * log(a^2 + b^2) / 2 + c * atan2(b, a))
   *
   * =&gt;...
   * Re = exp(c * log(sqrt(a^2 + b^2)) - d * atan2(b, a)) * cos(d * log(sqrt(a^2 + b^2)) + c * atan2(b, a))
   * Im = exp(c * log(sqrt(a^2 + b^2)) - d * atan2(b, a)) * sin(d * log(sqrt(a^2 + b^2)) + c * atan2(b, a))
   *
   * =&gt;
   * Re = exp(c * logsq2 - d * arg(z_1)) * cos(d * logsq2 + c * arg(z_1))
   * Im = exp(c * logsq2 - d * arg(z_1)) * sin(d * logsq2 + c * arg(z_1))
   *
   */
</span>
  a = Math.exp(P["re"] * loh - P["im"] * arg);
  b = P["im"] * loh + P["re"] * arg;
  return new Complex(
          a * Math.cos(b),
          a * Math.sin(b));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var math = require('mathjs');

// functions and constants
math.round(math.e, 3);            // 2.718
math.atan2(3, -3) / math.pi;      // 0.75
math.log(1000, 10);               // 3
math.sqrt(-4);                    // 2i
math.<span class="apidocCodeKeywordSpan">pow</span>([[-1, 2], [3, 1]], 2);   // [[7, 0], [0, 7]]
math.derivative('x^2 + x', 'x');  // 2 * x + 1

// expressions
math.eval('12 / (2.3 + 0.7)');    // 4
math.eval('5.08 cm to inch');     // 2 inch
math.eval('sin(45 deg) ^ 2');     // 0.5
math.eval('9 / 3 + 2i');          // 3 + 2i
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Complex.prototype.round" id="apidoc.element.mathjs.type.Complex.prototype.round">
        function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>round
        <span class="apidocSignatureSpan">(places)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">round = function (places) {

  places = Math.pow(10, places || 0);

  return new Complex(
          Math.round(this["re"] * places) / places,
          Math.round(this["im"] * places) / places);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
[chained operations](http://mathjs.org/docs/chained_operations.html).

```js
// load math.js
var math = require('mathjs');

// functions and constants
math.<span class="apidocCodeKeywordSpan">round</span>(math.e, 3);            // 2.718
math.atan2(3, -3) / math.pi;      // 0.75
math.log(1000, 10);               // 3
math.sqrt(-4);                    // 2i
math.pow([[-1, 2], [3, 1]], 2);   // [[7, 0], [0, 7]]
math.derivative('x^2 + x', 'x');  // 2 * x + 1

// expressions
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Complex.prototype.sec" id="apidoc.element.mathjs.type.Complex.prototype.sec">
        function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>sec
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sec = function () {

  var a = this["re"];
  var b = this["im"];
  var d = 0.5 * Math.cosh(2 * b) + 0.5 * Math.cos(2 * a);

  return new Complex(
          Math.cos(a) * Math.cosh(b) / d,
          Math.sin(a) * Math.sinh(b) / d);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Syntax:
*
*    math.asec(x)
*
* Examples:
*
*    math.asec(0.5);           // returns 1.0471975511965979
*    math.asec(math.<span class="apidocCodeKeywordSpan">sec</span>(1.5)); // returns 1.5
*
*    math.asec(2);             // returns 0 + 1.3169578969248166 i
*
* See also:
*
*    acos, acot, acsc
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Complex.prototype.sech" id="apidoc.element.mathjs.type.Complex.prototype.sech">
        function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>sech
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sech = function () {

  var a = this["re"];
  var b = this["im"];
  var d = Math.cos(2 * b) + Math.cosh(2 * a);

  return new Complex(
          2 * Math.cosh(a) * Math.cos(b) / d,
         -2 * Math.sinh(a) * Math.sin(b) / d);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Calculate the hyperbolic secant of a value,
* defined as `sech(x) = 1 / cosh(x)`.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">sech</span>(x)
*
* Examples:
*
*    // sech(x) = 1/ cosh(x)
*    math.sech(0.5);       // returns 0.886818883970074
*    1 / math.cosh(0.5);   // returns 0.886818883970074
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Complex.prototype.sign" id="apidoc.element.mathjs.type.Complex.prototype.sign">
        function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>sign
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sign = function () {

  var abs = this["abs"]();

  return new Complex(
          this["re"] / abs,
          this["im"] / abs);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* - -1 when x &lt; 0
* -  0 when x == 0
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">sign</span>(x)
*
* Examples:
*
*    math.sign(3.5);               // returns 1
*    math.sign(-4.2);              // returns -1
*    math.sign(0);                 // returns 0
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Complex.prototype.sin" id="apidoc.element.mathjs.type.Complex.prototype.sin">
        function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>sin
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sin = function () {

  var a = this["re"];
  var b = this["im"];

  return new Complex(
          Math.sin(a) * Math.cosh(b),
          Math.cos(a) * Math.sinh(b));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    res = 1;                          // 0! is per definition 1
  }

  return res;
}

if (n &lt; 0.5) {
  return Math.PI / (Math.<span class="apidocCodeKeywordSpan">sin</span>(Math.PI * n) * gamma(1-n));
}

if (n &gt;= 171.35) {
  return Infinity;                    // will overflow
}

if (n &gt; 85.0) {                       // Extended Stirling Approx
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Complex.prototype.sinh" id="apidoc.element.mathjs.type.Complex.prototype.sinh">
        function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>sinh
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sinh = function () {

  var a = this["re"];
  var b = this["im"];

  return new Complex(
          Math.sinh(a) * Math.cos(b),
          Math.cosh(a) * Math.sin(b));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
*    math.csch(x)
*
* Examples:
*
*    // csch(x) = 1/ sinh(x)
*    math.csch(0.5);       // returns 1.9190347513349437
*    1 / math.<span class="apidocCodeKeywordSpan">sinh</span>(0.5);   // returns 1.9190347513349437
*
* See also:
*
*    sinh, sech, coth
*
* @param {number | Complex | Unit | Array | Matrix} x  Function input
* @return {number | Complex | Array | Matrix} Hyperbolic cosecant of x
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Complex.prototype.sqrt" id="apidoc.element.mathjs.type.Complex.prototype.sqrt">
        function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>sqrt
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sqrt = function () {

  var a = this["re"];
  var b = this["im"];
  var r = this["abs"]();

  var re, im;

  if (a &gt;= 0 &amp;&amp; b === 0) {
    return new Complex(Math.sqrt(a), 0);
  }

  if (a &gt;= 0) {
    re = 0.5 * Math.sqrt(2.0 * (r + a));
  } else {
    re = Math.abs(b) / Math.sqrt(2 * (r - a));
  }

  if (a &lt;= 0) {
    im = 0.5 * Math.sqrt(2.0 * (r - a));
  } else {
    im = Math.abs(b) / Math.sqrt(2 * (r + a));
  }

  return new Complex(re, b &gt;= 0 ? im : -im);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// load math.js
var math = require('mathjs');

// functions and constants
math.round(math.e, 3);            // 2.718
math.atan2(3, -3) / math.pi;      // 0.75
math.log(1000, 10);               // 3
math.<span class="apidocCodeKeywordSpan">sqrt</span>(-4);                    // 2i
math.pow([[-1, 2], [3, 1]], 2);   // [[7, 0], [0, 7]]
math.derivative('x^2 + x', 'x');  // 2 * x + 1

// expressions
math.eval('12 / (2.3 + 0.7)');    // 4
math.eval('5.08 cm to inch');     // 2 inch
math.eval('sin(45 deg) ^ 2');     // 0.5
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Complex.prototype.sub" id="apidoc.element.mathjs.type.Complex.prototype.sub">
        function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>sub
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sub = function (a, b) {

  parse(a, b); // mutates P

  return new Complex(
          this["re"] - P["re"],
          this["im"] - P["im"]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var subtract = typed('subtract', {

'number, number': function (x, y) {
  return x - y;
},

'Complex, Complex': function (x, y) {
  return x.<span class="apidocCodeKeywordSpan">sub</span>(y);
},

'BigNumber, BigNumber': function (x, y) {
  return x.minus(y);
},

'Fraction, Fraction': function (x, y) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Complex.prototype.tan" id="apidoc.element.mathjs.type.Complex.prototype.tan">
        function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>tan
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tan = function () {

  var a = 2 * this["re"];
  var b = 2 * this["im"];
  var d = Math.cos(a) + Math.cosh(b);

  return new Complex(
          Math.sin(a) / d,
          Math.sinh(b) / d);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Syntax:
*
*    math.atan(x)
*
* Examples:
*
*    math.atan(0.5);           // returns number 0.4636476090008061
*    math.atan(math.<span class="apidocCodeKeywordSpan">tan</span>(1.5)); // returns number 1.5
*
*    math.atan(2);             // returns Complex 1.5707963267948966 -1.3169578969248166 i
*
* See also:
*
*    tan, asin, acos
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Complex.prototype.tanh" id="apidoc.element.mathjs.type.Complex.prototype.tanh">
        function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>tanh
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tanh = function () {

  var a = 2 * this["re"];
  var b = 2 * this["im"];
  var d = Math.cosh(a) + Math.cos(b);

  return new Complex(
          Math.sinh(a) / d,
          Math.sin(b) / d);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
*    math.coth(x)
*
* Examples:
*
*    // coth(x) = 1 / tanh(x)
*    math.coth(2);         // returns 1.0373147207275482
*    1 / math.<span class="apidocCodeKeywordSpan">tanh</span>(2);     // returns 1.0373147207275482
*
* See also:
*
*    sinh, tanh, cosh
*
* @param {number | Complex | Unit | Array | Matrix} x  Function input
* @return {number | Complex | Array | Matrix} Hyperbolic cotangent of x
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Complex.prototype.toJSON" id="apidoc.element.mathjs.type.Complex.prototype.toJSON">
        function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function () {
  return {
    mathjs: 'Complex',
    re: this.re,
    im: this.im
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Complex.prototype.toPolar" id="apidoc.element.mathjs.type.Complex.prototype.toPolar">
        function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>toPolar
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toPolar = function () {
  return {
    r: this.abs(),
    phi: this.arg()
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Complex.prototype.toString" id="apidoc.element.mathjs.type.Complex.prototype.toString">
        function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {

  var a = this["re"];
  var b = this["im"];
  var ret = "";

  if (isNaN(a) || isNaN(b)) {
    return "NaN";
  }

  if (a !== 0) {
    ret+= a;
  }

  if (b !== 0) {

    if (a !== 0) {
      ret+= b &lt; 0 ? " - " : " + ";
    } else if (b &lt; 0) {
      ret+= "-";
    }

    b = Math.abs(b);

    if (1 !== b) {
      ret+= b;
    }
    ret+= "i";
  }

  if (!ret)
    return "0";

  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      }
      else {
        scope.ans = res;
        console.log(format(res));
      }
    }
    else if (res instanceof math.type.Help) {
      console.log(res.<span class="apidocCodeKeywordSpan">toString</span>());
    }
    else {
      scope.ans = res;
      console.log(format(res));
    }
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Complex.prototype.toVector" id="apidoc.element.mathjs.type.Complex.prototype.toVector">
        function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>toVector
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toVector = function () {

  return [this["re"], this["im"]];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Complex.prototype.valueOf" id="apidoc.element.mathjs.type.Complex.prototype.valueOf">
        function <span class="apidocSignatureSpan">mathjs.type.Complex.prototype.</span>valueOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">valueOf = function () {

  var a = this["re"];
  var b = this["im"];
  var ret = "";

  if (isNaN(a) || isNaN(b)) {
    return "NaN";
  }

  if (a !== 0) {
    ret+= a;
  }

  if (b !== 0) {

    if (a !== 0) {
      ret+= b &lt; 0 ? " - " : " + ";
    } else if (b &lt; 0) {
      ret+= "-";
    }

    b = Math.abs(b);

    if (1 !== b) {
      ret+= b;
    }
    ret+= "i";
  }

  if (!ret)
    return "0";

  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    throw new TypeError('Cannot implicitly convert a Fraction to BigNumber or vice versa. ' +
        'Use function bignumber(x) to convert to BigNumber or fraction(x) to convert to Fraction.');
  }
}, {
  from: 'Fraction',
  to: 'Complex',
  convert: function (x) {
    return new type.Complex(x.<span class="apidocCodeKeywordSpan">valueOf</span>(), 0);
  }
}, {
  from: 'number',
  to: 'Fraction',
  convert: function (x) {
    if (digits(x) &gt; 15) {
      throw new TypeError('Cannot implicitly convert a number with &gt;15 significant digits to Fraction ' +
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.type.DenseMatrix" id="apidoc.module.mathjs.type.DenseMatrix">module mathjs.type.DenseMatrix</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.type.DenseMatrix.DenseMatrix" id="apidoc.element.mathjs.type.DenseMatrix.DenseMatrix">
        function <span class="apidocSignatureSpan">mathjs.type.</span>DenseMatrix
        <span class="apidocSignatureSpan">(data, datatype)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DenseMatrix(data, datatype) {
  if (!(this instanceof DenseMatrix))
    throw new SyntaxError('Constructor must be called with the new operator');
  if (datatype &amp;&amp; !isString(datatype))
    throw new Error('Invalid datatype: ' + datatype);

  if (data &amp;&amp; data.isMatrix === true) {
    // check data is a DenseMatrix
    if (data.type === 'DenseMatrix') {
      // clone data &amp; size
      this._data = object.clone(data._data);
      this._size = object.clone(data._size);
      this._datatype = datatype || data._datatype;
    }
    else {
      // build data from existing matrix
      this._data = data.toArray();
      this._size = data.size();
      this._datatype = datatype || data._datatype;
    }
  }
  else if (data &amp;&amp; isArray(data.data) &amp;&amp; isArray(data.size)) {
    // initialize fields from JSON representation
    this._data = data.data;
    this._size = data.size;
    this._datatype = datatype || data.datatype;
  }
  else if (isArray(data)) {
    // replace nested Matrices with Arrays
    this._data = preprocess(data);
    // get the dimensions of the array
    this._size = array.size(this._data);
    // verify the dimensions of the array, TODO: compute size while processing array
    array.validate(this._data, this._size);
    // data type unknown
    this._datatype = datatype;
  }
  else if (data) {
    // unsupported type
    throw new TypeError('Unsupported type of data (' + util.types.type(data) + ')');
  }
  else {
    // nothing provided
    this._data = [];
    this._size = [0];
    this._datatype = datatype;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return new type.Fraction(0);
  }
}, {
  from: 'Array',
  to: 'Matrix',
  convert: function (array) {
    // TODO: how to decide on the right type of matrix to create?
    return new type.<span class="apidocCodeKeywordSpan">DenseMatrix</span>(array);
  }
}, {
  from: 'Matrix',
  to: 'Array',
  convert: function (matrix) {
    return matrix.valueOf();
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.DenseMatrix._swapRows" id="apidoc.element.mathjs.type.DenseMatrix._swapRows">
        function <span class="apidocSignatureSpan">mathjs.type.DenseMatrix.</span>_swapRows
        <span class="apidocSignatureSpan">(i, j, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_swapRows = function (i, j, data) {
  // swap values i &lt;-&gt; j
  var vi = data[i];
  data[i] = data[j];
  data[j] = vi;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    throw new Error('Only two dimensional matrix is supported');
  }
  // validate index
  validateIndex(i, this._size[0]);
  validateIndex(j, this._size[0]);

  // swap rows
  DenseMatrix.<span class="apidocCodeKeywordSpan">_swapRows</span>(i, j, this._data);
  // return current instance
  return this;
};

/**
 * Swap rows i and j in Dense Matrix data structure.
 *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.DenseMatrix.diagonal" id="apidoc.element.mathjs.type.DenseMatrix.diagonal">
        function <span class="apidocSignatureSpan">mathjs.type.DenseMatrix.</span>diagonal
        <span class="apidocSignatureSpan">(size, value, k, defaultValue, datatype)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">diagonal = function (size, value, k, defaultValue, datatype) {
  if (!isArray(size))
    throw new TypeError('Array expected, size parameter');
  if (size.length !== 2)
    throw new Error('Only two dimensions matrix are supported');

  // map size &amp; validate
  size = size.map(function (s) {
    // check it is a big number
    if (s &amp;&amp; s.isBigNumber === true) {
      // convert it
      s = s.toNumber();
    }
    // validate arguments
    if (!isNumber(s) || !isInteger(s) || s &lt; 1) {
      throw new Error('Size values must be positive integers');
    }
    return s;
  });

  // validate k if any
  if (k) {
    // convert BigNumber to a number
    if (k &amp;&amp; k.isBigNumber === true)
      k = k.toNumber();
    // is must be an integer
    if (!isNumber(k) || !isInteger(k)) {
      throw new TypeError ('The parameter k must be an integer number');
    }
  }
  else {
    // default value
    k = 0;
  }

  if (defaultValue &amp;&amp; isString(datatype)) {
    // convert defaultValue to the same datatype
    defaultValue = typed.convert(defaultValue, datatype);
  }

  var kSuper = k &gt; 0 ? k : 0;
  var kSub = k &lt; 0 ? -k : 0;

  // rows and columns
  var rows = size[0];
  var columns = size[1];

  // number of non-zero items
  var n = Math.min(rows - kSub, columns -  kSuper);

  // value extraction function
  var _value;

  // check value
  if (isArray(value)) {
    // validate array
    if (value.length !== n) {
      // number of values in array must be n
      throw new Error('Invalid value array length');
    }
    // define function
    _value = function (i) {
      // return value @ i
      return value[i];
    };
  }
  else if (value &amp;&amp; value.isMatrix === true) {
    // matrix size
    var ms = value.size();
    // validate matrix
    if (ms.length !== 1 || ms[0] !== n) {
      // number of values in array must be n
      throw new Error('Invalid matrix length');
    }
    // define function
    _value = function (i) {
      // return value @ i
      return value.get([i]);
    };
  }
  else {
    // define function
    _value = function () {
      // return value
      return value;
    };
  }

  // discover default value if needed
  if (!defaultValue) {
    // check first value in array
    defaultValue = (_value(0) &amp;&amp; _value(0).isBigNumber === true) ? new type.BigNumber(0) : 0;
  }

  // empty array
  var data = [];

  // check we need to resize array
  if (size.length &gt; 0) {
    // resize array
    data = array.resize(data, size, defaultValue);
    // fill diagonal
    for (var d = 0; d &lt; n; d++) {
      data[d + kSub][d + kSuper] = _value(d);
    }
  }

  // create DenseMatrix
  return new DenseMatrix({
    data: data,
    size: [rows, columns]
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

function _createDiagonalMatrix(x, k, format, l, kSub, kSuper) {
  // matrix size
  var ms = [l + kSub, l + kSuper];
  // get matrix constructor
  var F = type.Matrix.storage(format || 'dense');
  // create diagonal matrix
  var m = F.<span class="apidocCodeKeywordSpan">diagonal</span>(ms, x, k);
  // check we need to return a matrix
  return format !== null ? m : m.valueOf();
}

function _getDiagonal(x, k, format, s, kSub, kSuper) {
  // check x is a Matrix
  if (x &amp;&amp; x.isMatrix === true) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.DenseMatrix.fromJSON" id="apidoc.element.mathjs.type.DenseMatrix.fromJSON">
        function <span class="apidocSignatureSpan">mathjs.type.DenseMatrix.</span>fromJSON
        <span class="apidocSignatureSpan">(json)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromJSON = function (json) {
  return new DenseMatrix(json);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * @param {string} key
   * @param {*} value
   * @returns {*} Returns the revived object
   */
  return function reviver(key, value) {
    var constructor = type[value &amp;&amp; value.mathjs];
    if (constructor &amp;&amp; typeof constructor.fromJSON === 'function') {
      return constructor.<span class="apidocCodeKeywordSpan">fromJSON</span>(value);
    }

    return value;
  }
}

exports.name = 'reviver';
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.type.DenseMatrix.prototype" id="apidoc.module.mathjs.type.DenseMatrix.prototype">module mathjs.type.DenseMatrix.prototype</a></h1>




    <h2>
        <a href="#apidoc.element.mathjs.type.DenseMatrix.prototype.clone" id="apidoc.element.mathjs.type.DenseMatrix.prototype.clone">
        function <span class="apidocSignatureSpan">mathjs.type.DenseMatrix.prototype.</span>clone
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clone = function () {
  var m = new DenseMatrix({
    data: object.clone(this._data),
    size: object.clone(this._size),
    datatype: this._datatype
  });
  return m;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return desc;
};

/**
 * Export the help object to JSON
 */
Help.prototype.toJSON = function () {
  var obj = object.<span class="apidocCodeKeywordSpan">clone</span>(this.doc);
  obj.mathjs = 'Help';
  return obj;
};

/**
 * Instantiate a Help object from a JSON object
 * @param {Object} json
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.DenseMatrix.prototype.create" id="apidoc.element.mathjs.type.DenseMatrix.prototype.create">
        function <span class="apidocSignatureSpan">mathjs.type.DenseMatrix.prototype.</span>create
        <span class="apidocSignatureSpan">(data, datatype)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function (data, datatype) {
  return new DenseMatrix(data, datatype);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *                              false (default), output type can vary depending
 *                              on input values. For example `math.sqrt(-4)`
 *                              returns `complex('2i')` when predictable is false, and
 *                              returns `NaN` when true.
 */
function create (config) {
  // create a new math.js instance
  var math = core.<span class="apidocCodeKeywordSpan">create</span>(config);
  math.create = create;

  // import data types, functions, constants, expression parser, etc.
  math['import'](require('./lib'));

  return math;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.DenseMatrix.prototype.datatype" id="apidoc.element.mathjs.type.DenseMatrix.prototype.datatype">
        function <span class="apidocSignatureSpan">mathjs.type.DenseMatrix.prototype.</span>datatype
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">datatype = function () {
  return this._datatype;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return 'dense';
};

/**
 * Get the datatype of the data stored in the matrix.
 *
 * Usage:
 *     var format = matrix.<span class="apidocCodeKeywordSpan">datatype</span>()                   // retrieve matrix datatype
 *
 * @memberof DenseMatrix
 * @return {string}           The datatype.
 */
DenseMatrix.prototype.datatype = function () {
  return this._datatype;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.DenseMatrix.prototype.diagonal" id="apidoc.element.mathjs.type.DenseMatrix.prototype.diagonal">
        function <span class="apidocSignatureSpan">mathjs.type.DenseMatrix.prototype.</span>diagonal
        <span class="apidocSignatureSpan">(k)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">diagonal = function (k) {
  // validate k if any
  if (k) {
    // convert BigNumber to a number
    if (k.isBigNumber === true)
      k = k.toNumber();
    // is must be an integer
    if (!isNumber(k) || !isInteger(k)) {
      throw new TypeError ('The parameter k must be an integer number');
    }
  }
  else {
    // default value
    k = 0;
  }

  var kSuper = k &gt; 0 ? k : 0;
  var kSub = k &lt; 0 ? -k : 0;

  // rows &amp; columns
  var rows = this._size[0];
  var columns = this._size[1];

  // number diagonal values
  var n = Math.min(rows - kSub, columns -  kSuper);

  // x is a matrix get diagonal from matrix
  var data = [];

  // loop rows
  for (var i = 0; i &lt; n; i++) {
    data[i] = this._data[i + kSub][i + kSuper];
  }

  // create DenseMatrix
  return new DenseMatrix({
    data: data,
    size: [n],
    datatype: this._datatype
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

function _createDiagonalMatrix(x, k, format, l, kSub, kSuper) {
  // matrix size
  var ms = [l + kSub, l + kSuper];
  // get matrix constructor
  var F = type.Matrix.storage(format || 'dense');
  // create diagonal matrix
  var m = F.<span class="apidocCodeKeywordSpan">diagonal</span>(ms, x, k);
  // check we need to return a matrix
  return format !== null ? m : m.valueOf();
}

function _getDiagonal(x, k, format, s, kSub, kSuper) {
  // check x is a Matrix
  if (x &amp;&amp; x.isMatrix === true) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.DenseMatrix.prototype.forEach" id="apidoc.element.mathjs.type.DenseMatrix.prototype.forEach">
        function <span class="apidocSignatureSpan">mathjs.type.DenseMatrix.prototype.</span>forEach
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEach = function (callback) {
  // matrix instance
  var me = this;
  var recurse = function (value, index) {
    if (isArray(value)) {
      value.forEach(function (child, i) {
        recurse(child, index.concat(i));
      });
    }
    else {
      callback(value, index, me);
    }
  };
  recurse(this._data, []);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (def.indexOf(keyword) == 0) {
      matches.push(def);
    }
  }
}

// commandline keywords
['exit', 'quit', 'clear'].<span class="apidocCodeKeywordSpan">forEach</span>(function (cmd) {
  if (cmd.indexOf(keyword) == 0) {
    matches.push(cmd);
  }
});

// math functions and constants
var ignore = ['expr', 'type'];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.DenseMatrix.prototype.format" id="apidoc.element.mathjs.type.DenseMatrix.prototype.format">
        function <span class="apidocSignatureSpan">mathjs.type.DenseMatrix.prototype.</span>format
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">format = function (options) {
  return string.format(this._data, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Helper function to format a value. Regular numbers will be rounded
 * to 14 digits to prevent round-off errors from showing up.
 * @param {*} value
 */
function format(value) {
var math = getMath();

return math.<span class="apidocCodeKeywordSpan">format</span>(value, {
  fn: function (value) {
    if (typeof value === 'number') {
      // round numbers
      return math.format(value, PRECISION);
    }
    else {
      return math.format(value);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.DenseMatrix.prototype.get" id="apidoc.element.mathjs.type.DenseMatrix.prototype.get">
        function <span class="apidocSignatureSpan">mathjs.type.DenseMatrix.prototype.</span>get
        <span class="apidocSignatureSpan">(index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get = function (index) {
  if (!isArray(index))
    throw new TypeError('Array expected');
  if (index.length != this._size.length)
    throw new DimensionError(index.length, this._size.length);

  // check index
  for (var x = 0; x &lt; index.length; x++)
    validateIndex(index[x], this._size[x]);

  var data = this._data;
  for (var i = 0, ii = index.length; i &lt; ii; i++) {
    var index_i = index[i];
    validateIndex(index_i, data.length);
    data = data[index_i];
  }

  return data;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Parser contains methods to evaluate or parse expressions, and has a number
* of convenience methods to get, set, and remove variables from memory. Parser
* keeps a scope containing variables in memory, which is used for all
* evaluations.
*
* Methods:
*    var result = parser.eval(expr);    // evaluate an expression
*    var value = parser.<span class="apidocCodeKeywordSpan">get</span>(name);      // retrieve a variable from the parser
*    var values = parser.getAll();      // retrieve all defined variables
*    parser.set(name, value);           // set a variable in the parser
*    parser.remove(name);               // clear a variable from the
*                                       // parsers scope
*    parser.clear();                    // clear the parsers scope
*
* Example usage:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.DenseMatrix.prototype.map" id="apidoc.element.mathjs.type.DenseMatrix.prototype.map">
        function <span class="apidocSignatureSpan">mathjs.type.DenseMatrix.prototype.</span>map
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">map = function (callback) {
  // matrix instance
  var me = this;
  var recurse = function (value, index) {
    if (isArray(value)) {
      return value.map(function (child, i) {
        return recurse(child, index.concat(i));
      });
    }
    else {
      return callback(value, index, me);
    }
  };
  // return dense format
  return new DenseMatrix({
    data: recurse(this._data, []),
    size: object.clone(this._size),
    datatype: this._datatype
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (res &amp;&amp; res.isResultSet) {
  // we can have 0 or 1 results in the ResultSet, as the CLI
  // does not allow multiple expressions separated by a return
  res = res.entries[0];
  node = node.blocks
      .filter(function (entry) { return entry.visible; })
      .<span class="apidocCodeKeywordSpan">map</span>(function (entry) { return entry.node })[0];
}

if (node) {
  if (node.isAssignmentNode) {
    var name = findSymbolName(node);
    if (name != null) {
      scope.ans = scope[name];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.DenseMatrix.prototype.reshape" id="apidoc.element.mathjs.type.DenseMatrix.prototype.reshape">
        function <span class="apidocSignatureSpan">mathjs.type.DenseMatrix.prototype.</span>reshape
        <span class="apidocSignatureSpan">(size, copy)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reshape = function (size, copy) {
  var m = copy ? this.clone() : this;

  m._data = array.reshape(m._data, size);
  m._size = size.slice(0);
  return m;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var matrix = load(require('../../type/matrix/function/matrix'));

/**
 * Reshape a multi dimensional array to fit the specified dimensions
 *
 * Syntax:
 *
 *     math.<span class="apidocCodeKeywordSpan">reshape</span>(x, sizes)
 *
 * Examples:
 *
 *     math.reshape([1, 2, 3, 4, 5, 6], [2, 3]);
 *     // returns Array  [[1, 2, 3], [4, 5, 6]]
 *
 *     math.reshape([[1, 2], [3, 4]], [1, 4]);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.DenseMatrix.prototype.resize" id="apidoc.element.mathjs.type.DenseMatrix.prototype.resize">
        function <span class="apidocSignatureSpan">mathjs.type.DenseMatrix.prototype.</span>resize
        <span class="apidocSignatureSpan">(size, defaultValue, copy)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resize = function (size, defaultValue, copy) {
  // validate arguments
  if (!isArray(size))
    throw new TypeError('Array expected');

  // matrix to resize
  var m = copy ? this.clone() : this;
  // resize matrix
  return _resize(m, size, defaultValue);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // get matrix storage constructor
  var F = type.Matrix.storage(format);
  // create diagonal matrix (use optimized implementation for storage format)
  return F.diagonal(size, one, 0, defaultValue);
}

// create and resize array
var res = array.<span class="apidocCodeKeywordSpan">resize</span>([], size, defaultValue);
// fill in ones on the diagonal
var minimum = rows &lt; cols ? rows : cols;
// fill diagonal
for (var d = 0; d &lt; minimum; d++) {
  res[d][d] = one;
}
return res;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.DenseMatrix.prototype.set" id="apidoc.element.mathjs.type.DenseMatrix.prototype.set">
        function <span class="apidocSignatureSpan">mathjs.type.DenseMatrix.prototype.</span>set
        <span class="apidocSignatureSpan">(index, value, defaultValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">set = function (index, value, defaultValue) {
  if (!isArray(index))
    throw new TypeError('Array expected');
  if (index.length &lt; this._size.length)
    throw new DimensionError(index.length, this._size.length, '&lt;');

  var i, ii, index_i;

  // enlarge matrix when needed
  var size = index.map(function (i) {
    return i + 1;
  });
  _fit(this, size, defaultValue);

  // traverse over the dimensions
  var data = this._data;
  for (i = 0, ii = index.length - 1; i &lt; ii; i++) {
    index_i = index[i];
    validateIndex(index_i, data.length);
    data = data[index_i];
  }

  // set new value
  index_i = index[index.length - 1];
  validateIndex(index_i, data.length);
  data[index_i] = value;

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* keeps a scope containing variables in memory, which is used for all
* evaluations.
*
* Methods:
*    var result = parser.eval(expr);    // evaluate an expression
*    var value = parser.get(name);      // retrieve a variable from the parser
*    var values = parser.getAll();      // retrieve all defined variables
*    parser.<span class="apidocCodeKeywordSpan">set</span>(name, value);           // set a variable in the parser
*    parser.remove(name);               // clear a variable from the
*                                       // parsers scope
*    parser.clear();                    // clear the parsers scope
*
* Example usage:
*    var parser = new Parser();
*    // Note: there is a convenience method which can be used instead:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.DenseMatrix.prototype.size" id="apidoc.element.mathjs.type.DenseMatrix.prototype.size">
        function <span class="apidocSignatureSpan">mathjs.type.DenseMatrix.prototype.</span>size
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">size = function () {
  return this._size.slice(0); // return a clone of _size
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

if (!Array.isArray(array) || !Array.isArray(sizes)) {
  throw new TypeError('Array expected');
}

if (sizes.length === 0) {
  throw new DimensionError(0, product(exports.<span class="apidocCodeKeywordSpan">size</span>(array)), '!=');
}

try {
  newArray  = _reshape(flatArray, sizes);
} catch (e) {
  if (e instanceof DimensionError) {
    throw new DimensionError(
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.DenseMatrix.prototype.storage" id="apidoc.element.mathjs.type.DenseMatrix.prototype.storage">
        function <span class="apidocSignatureSpan">mathjs.type.DenseMatrix.prototype.</span>storage
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">storage = function () {
  return 'dense';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// we extend the signatures of addScalar with signatures dealing with matrices

'Matrix, Matrix': function (x, y) {
  // result
  var c;

  // process matrix storage
  switch (x.<span class="apidocCodeKeywordSpan">storage</span>()) {
    case 'sparse':
      switch (y.storage()) {
        case 'sparse':
          // sparse + sparse
          c = algorithm04(x, y, addScalar);
          break;
        default:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.DenseMatrix.prototype.subset" id="apidoc.element.mathjs.type.DenseMatrix.prototype.subset">
        function <span class="apidocSignatureSpan">mathjs.type.DenseMatrix.prototype.</span>subset
        <span class="apidocSignatureSpan">(index, replacement, defaultValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">subset = function (index, replacement, defaultValue) {
  switch (arguments.length) {
    case 1:
      return _get(this, index);

      // intentional fall through
    case 2:
    case 3:
      return _set(this, index, replacement, defaultValue);

    default:
      throw new SyntaxError('Wrong number of arguments');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function factory (type, config, load, typed) {
var matrix = load(require('../../type/matrix/function/matrix'));

/**
 * Get or set a subset of a matrix or string.
 *
 * Syntax:
 *     math.<span class="apidocCodeKeywordSpan">subset</span>(value, index)                                // retrieve a subset
 *     math.subset(value, index, replacement [, defaultValue])  // replace a subset
 *
 * Examples:
 *
 *     // get a subset
 *     var d = [[1, 2], [3, 4]];
 *     math.subset(d, math.index(1, 0));        // returns 3
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.DenseMatrix.prototype.swapRows" id="apidoc.element.mathjs.type.DenseMatrix.prototype.swapRows">
        function <span class="apidocSignatureSpan">mathjs.type.DenseMatrix.prototype.</span>swapRows
        <span class="apidocSignatureSpan">(i, j)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">swapRows = function (i, j) {
  // check index
  if (!isNumber(i) || !isInteger(i) || !isNumber(j) || !isInteger(j)) {
    throw new Error('Row index must be positive integers');
  }
  // check dimensions
  if (this._size.length !== 2) {
    throw new Error('Only two dimensional matrix is supported');
  }
  // validate index
  validateIndex(i, this._size[0]);
  validateIndex(j, this._size[0]);

  // swap rows
  DenseMatrix._swapRows(i, j, this._data);
  // return current instance
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.DenseMatrix.prototype.toArray" id="apidoc.element.mathjs.type.DenseMatrix.prototype.toArray">
        function <span class="apidocSignatureSpan">mathjs.type.DenseMatrix.prototype.</span>toArray
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toArray = function () {
  return object.clone(this._data);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  '... number | BigNumber': _hypot,

  'Array': function (x) {
    return hypot.apply(hypot, flatten(x));
  },

  'Matrix': function (x) {
    return hypot.apply(hypot, flatten(x.<span class="apidocCodeKeywordSpan">toArray</span>()));
  }
});

/**
 * Calculate the hypotenusa for an Array with values
 * @param {Array.&lt;number | BigNumber&gt;} args
 * @return {number | BigNumber} Returns the result
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.DenseMatrix.prototype.toJSON" id="apidoc.element.mathjs.type.DenseMatrix.prototype.toJSON">
        function <span class="apidocSignatureSpan">mathjs.type.DenseMatrix.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function () {
  return {
    mathjs: 'DenseMatrix',
    data: this._data,
    size: this._size,
    datatype: this._datatype
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.DenseMatrix.prototype.toString" id="apidoc.element.mathjs.type.DenseMatrix.prototype.toString">
        function <span class="apidocSignatureSpan">mathjs.type.DenseMatrix.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
  return string.format(this._data);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      }
      else {
        scope.ans = res;
        console.log(format(res));
      }
    }
    else if (res instanceof math.type.Help) {
      console.log(res.<span class="apidocCodeKeywordSpan">toString</span>());
    }
    else {
      scope.ans = res;
      console.log(format(res));
    }
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.DenseMatrix.prototype.valueOf" id="apidoc.element.mathjs.type.DenseMatrix.prototype.valueOf">
        function <span class="apidocSignatureSpan">mathjs.type.DenseMatrix.prototype.</span>valueOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">valueOf = function () {
  return this._data;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    throw new TypeError('Cannot implicitly convert a Fraction to BigNumber or vice versa. ' +
        'Use function bignumber(x) to convert to BigNumber or fraction(x) to convert to Fraction.');
  }
}, {
  from: 'Fraction',
  to: 'Complex',
  convert: function (x) {
    return new type.Complex(x.<span class="apidocCodeKeywordSpan">valueOf</span>(), 0);
  }
}, {
  from: 'number',
  to: 'Fraction',
  convert: function (x) {
    if (digits(x) &gt; 15) {
      throw new TypeError('Cannot implicitly convert a number with &gt;15 significant digits to Fraction ' +
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.type.FibonacciHeap" id="apidoc.module.mathjs.type.FibonacciHeap">module mathjs.type.FibonacciHeap</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.type.FibonacciHeap.FibonacciHeap" id="apidoc.element.mathjs.type.FibonacciHeap.FibonacciHeap">
        function <span class="apidocSignatureSpan">mathjs.type.</span>FibonacciHeap
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function FibonacciHeap() {
  if (!(this instanceof FibonacciHeap))
    throw new SyntaxError('Constructor must be called with the new operator');

  // initialize fields
  this._minimum = null;
  this._size = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
function Spa() {
  if (!(this instanceof Spa))
    throw new SyntaxError('Constructor must be called with the new operator');

  // allocate vector, TODO use typed arrays
  this._values = [];
  this._heap = new type.<span class="apidocCodeKeywordSpan">FibonacciHeap</span>();
}

/**
 * Attach type information
 */
Spa.prototype.type = 'Spa';
Spa.prototype.isSpa = true;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.type.FibonacciHeap.prototype" id="apidoc.module.mathjs.type.FibonacciHeap.prototype">module mathjs.type.FibonacciHeap.prototype</a></h1>




    <h2>
        <a href="#apidoc.element.mathjs.type.FibonacciHeap.prototype.clear" id="apidoc.element.mathjs.type.FibonacciHeap.prototype.clear">
        function <span class="apidocSignatureSpan">mathjs.type.FibonacciHeap.prototype.</span>clear
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clear = function () {
  this._minimum = null;
  this._size = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Methods:
*    var result = parser.eval(expr);    // evaluate an expression
*    var value = parser.get(name);      // retrieve a variable from the parser
*    var values = parser.getAll();      // retrieve all defined variables
*    parser.set(name, value);           // set a variable in the parser
*    parser.remove(name);               // clear a variable from the
*                                       // parsers scope
*    parser.<span class="apidocCodeKeywordSpan">clear</span>();                    // clear the parsers scope
*
* Example usage:
*    var parser = new Parser();
*    // Note: there is a convenience method which can be used instead:
*    // var parser = new math.parser();
*
*    // evaluate expressions
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.FibonacciHeap.prototype.extractMinimum" id="apidoc.element.mathjs.type.FibonacciHeap.prototype.extractMinimum">
        function <span class="apidocSignatureSpan">mathjs.type.FibonacciHeap.prototype.</span>extractMinimum
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extractMinimum = function () {
  // node to remove
  var node = this._minimum;
  // check we have a minimum
  if (node === null)
    return node;
  // current minimum
  var minimum = this._minimum;
  // get number of children
  var numberOfChildren = node.degree;
  // pointer to the first child
  var x = node.child;
  // for each child of node do...
  while (numberOfChildren &gt; 0) {
    // store node in right side
    var tempRight = x.right;
    // remove x from child list
    x.left.right = x.right;
    x.right.left = x.left;
    // add x to root list of heap
    x.left = minimum;
    x.right = minimum.right;
    minimum.right = x;
    x.right.left = x;
    // set Parent[x] to null
    x.parent = null;
    x = tempRight;
    numberOfChildren--;
  }
  // remove node from root list of heap
  node.left.right = node.right;
  node.right.left = node.left;
  // update minimum
  if (node == node.right) {
    // empty
    minimum = null;
  }
  else {
    // update minimum
    minimum = node.right;
    // we need to update the pointer to the root with minimum key
    minimum = _findMinimumNode(minimum, this._size);
  }
  // decrement size of heap
  this._size--;
  // update minimum
  this._minimum = minimum;
  // return node
  return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Running time: O(log n) amortized.
 * @memberof FibonacciHeap
 */
FibonacciHeap.prototype.remove = function (node) {
  // decrease key value
  this._minimum = _decreaseKey(this._minimum, node, -1);
  // remove the smallest
  this.<span class="apidocCodeKeywordSpan">extractMinimum</span>();
};

/**
 * Decreases the key value for a heap node, given the new value to take on.
 * The structure of the heap may be changed and will not be consolidated.
 * Running time: O(1) amortized.
 * @memberof FibonacciHeap
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.FibonacciHeap.prototype.insert" id="apidoc.element.mathjs.type.FibonacciHeap.prototype.insert">
        function <span class="apidocSignatureSpan">mathjs.type.FibonacciHeap.prototype.</span>insert
        <span class="apidocSignatureSpan">(key, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">insert = function (key, value) {
  // create node
  var node = {
    key: key,
    value: value,
    degree: 0
  };
  // check we have a node in the minimum
  if (this._minimum) {
    // minimum node
    var minimum = this._minimum;
    // update left &amp; right of node
    node.left = minimum;
    node.right = minimum.right;
    minimum.right = node;
    node.right.left = node;
    // update minimum node in heap if needed
    if (smaller(key, minimum.key)) {
      // node has a smaller key, use it as minimum
      this._minimum = node;
    }
  }
  else {
    // set left &amp; right
    node.left = node;
    node.right = node;
    // this is the first node
    this._minimum = node;
  }
  // increment number of nodes in heap
  this._size++;
  // return node
  return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {number} i                       The index
 * @param {number | BigNumber | Complex}   The value at index i
 */
Spa.prototype.set = function (i, v) {
  // check we have a value @ i
  if (!this._values[i]) {
    // insert in heap
    var node = this._heap.<span class="apidocCodeKeywordSpan">insert</span>(i, v);
    // set the value @ i
    this._values[i] = node;
  }
  else {
    // update the value @ i
    this._values[i].value = v;
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.FibonacciHeap.prototype.isEmpty" id="apidoc.element.mathjs.type.FibonacciHeap.prototype.isEmpty">
        function <span class="apidocSignatureSpan">mathjs.type.FibonacciHeap.prototype.</span>isEmpty
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isEmpty = function () {
  return !!this._minimum;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.FibonacciHeap.prototype.remove" id="apidoc.element.mathjs.type.FibonacciHeap.prototype.remove">
        function <span class="apidocSignatureSpan">mathjs.type.FibonacciHeap.prototype.</span>remove
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">remove = function (node) {
  // decrease key value
  this._minimum = _decreaseKey(this._minimum, node, -1);
  // remove the smallest
  this.extractMinimum();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* evaluations.
*
* Methods:
*    var result = parser.eval(expr);    // evaluate an expression
*    var value = parser.get(name);      // retrieve a variable from the parser
*    var values = parser.getAll();      // retrieve all defined variables
*    parser.set(name, value);           // set a variable in the parser
*    parser.<span class="apidocCodeKeywordSpan">remove</span>(name);               // clear a variable from the
*                                       // parsers scope
*    parser.clear();                    // clear the parsers scope
*
* Example usage:
*    var parser = new Parser();
*    // Note: there is a convenience method which can be used instead:
*    // var parser = new math.parser();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.FibonacciHeap.prototype.size" id="apidoc.element.mathjs.type.FibonacciHeap.prototype.size">
        function <span class="apidocSignatureSpan">mathjs.type.FibonacciHeap.prototype.</span>size
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">size = function () {
  return this._size;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

if (!Array.isArray(array) || !Array.isArray(sizes)) {
  throw new TypeError('Array expected');
}

if (sizes.length === 0) {
  throw new DimensionError(0, product(exports.<span class="apidocCodeKeywordSpan">size</span>(array)), '!=');
}

try {
  newArray  = _reshape(flatArray, sizes);
} catch (e) {
  if (e instanceof DimensionError) {
    throw new DimensionError(
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.type.Fraction" id="apidoc.module.mathjs.type.Fraction">module mathjs.type.Fraction</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.type.Fraction.Fraction" id="apidoc.element.mathjs.type.Fraction.Fraction">
        function <span class="apidocSignatureSpan">mathjs.type.</span>Fraction
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Fraction(a, b) {

  if (!(this instanceof Fraction)) {
    return new Fraction(a, b);
  }

  parse(a, b);

  if (Fraction['REDUCE']) {
    a = gcd(P["d"], P["n"]); // Abuse a
  } else {
    a = 1;
  }

  this["s"] = P["s"];
  this["n"] = P["n"] / a;
  this["d"] = P["d"] / a;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  to: 'Fraction',
  convert: function (x) {
    if (digits(x) &gt; 15) {
      throw new TypeError('Cannot implicitly convert a number with &gt;15 significant digits to Fraction ' +
          '(value: ' + x + '). ' +
          'Use function fraction(x) to convert to Fraction.');
    }
    return new type.<span class="apidocCodeKeywordSpan">Fraction</span>(x);
  }
}, {
// FIXME: add conversion from Fraction to number, for example for `sqrt(fraction(1,3))`
//  from: 'Fraction',
//  to: 'number',
//  convert: function (x) {
//    return x.valueOf();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Fraction.DivisionByZero" id="apidoc.element.mathjs.type.Fraction.DivisionByZero">
        function <span class="apidocSignatureSpan">mathjs.type.Fraction.</span>DivisionByZero
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">DivisionByZero = function () {
  var temp = Error.apply(this, arguments);
  temp.name = this.name = name;
  this.stack = temp.stack;
  this.message = temp.message;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Fraction.InvalidParameter" id="apidoc.element.mathjs.type.Fraction.InvalidParameter">
        function <span class="apidocSignatureSpan">mathjs.type.Fraction.</span>InvalidParameter
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">InvalidParameter = function () {
  var temp = Error.apply(this, arguments);
  temp.name = this.name = name;
  this.stack = temp.stack;
  this.message = temp.message;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Fraction.fromJSON" id="apidoc.element.mathjs.type.Fraction.fromJSON">
        function <span class="apidocSignatureSpan">mathjs.type.Fraction.</span>fromJSON
        <span class="apidocSignatureSpan">(json)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromJSON = function (json) {
  return new Fraction(json);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * @param {string} key
   * @param {*} value
   * @returns {*} Returns the revived object
   */
  return function reviver(key, value) {
    var constructor = type[value &amp;&amp; value.mathjs];
    if (constructor &amp;&amp; typeof constructor.fromJSON === 'function') {
      return constructor.<span class="apidocCodeKeywordSpan">fromJSON</span>(value);
    }

    return value;
  }
}

exports.name = 'reviver';
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.type.Fraction.prototype" id="apidoc.module.mathjs.type.Fraction.prototype">module mathjs.type.Fraction.prototype</a></h1>




    <h2>
        <a href="#apidoc.element.mathjs.type.Fraction.prototype.abs" id="apidoc.element.mathjs.type.Fraction.prototype.abs">
        function <span class="apidocSignatureSpan">mathjs.type.Fraction.prototype.</span>abs
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">abs = function () {

  return new Fraction(this["n"], this["d"]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function factory (type, config, load, typed) {
/**
 * Calculate the absolute value of a number. For matrices, the function is
 * evaluated element wise.
 *
 * Syntax:
 *
 *    math.<span class="apidocCodeKeywordSpan">abs</span>(x)
 *
 * Examples:
 *
 *    math.abs(3.5);                // returns number 3.5
 *    math.abs(-4.2);               // returns number 4.2
 *
 *    math.abs([3, -5, -1, 0, 2]);  // returns Array [3, 5, 1, 0, 2]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Fraction.prototype.add" id="apidoc.element.mathjs.type.Fraction.prototype.add">
        function <span class="apidocSignatureSpan">mathjs.type.Fraction.prototype.</span>add
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">add = function (a, b) {

  parse(a, b);
  return new Fraction(
          this["s"] * this["n"] * P["d"] + P["s"] * this["d"] * P["n"],
          this["d"] * P["d"]
          );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
math.eval('5.08 cm to inch');     // 2 inch
math.eval('sin(45 deg) ^ 2');     // 0.5
math.eval('9 / 3 + 2i');          // 3 + 2i
math.eval('det([-1, 2; 3, 1])');  // -7

// chaining
math.chain(3)
    .<span class="apidocCodeKeywordSpan">add</span>(4)
    .multiply(2)
    .done(); // 14
```

## Browser support

Math.js works on any ES5 compatible JavaScript engine: node.js 0.10, and Internet Explorer 9 and newer, and all other browsers (
Chrome, Firefox, Safari). If support for old browsers like Internet Explorer 8 is required, the [es5-shim](https://github.com/kriskowal
/es5-shim) library has to be loaded.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Fraction.prototype.ceil" id="apidoc.element.mathjs.type.Fraction.prototype.ceil">
        function <span class="apidocSignatureSpan">mathjs.type.Fraction.prototype.</span>ceil
        <span class="apidocSignatureSpan">(places)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ceil = function (places) {

  places = Math.pow(10, places || 0);

  if (isNaN(this["n"]) || isNaN(this["d"])) {
    return new Fraction(NaN);
  }
  return new Fraction(Math.ceil(places * this["s"] * this["n"] / this["d"]), places);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Round a value towards plus infinity
* If `x` is complex, both real and imaginary part are rounded towards plus infinity.
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">ceil</span>(x)
*
* Examples:
*
*    math.ceil(3.2);               // returns number 4
*    math.ceil(3.8);               // returns number 4
*    math.ceil(-4.2);              // returns number -4
*    math.ceil(-4.7);              // returns number -4
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Fraction.prototype.clone" id="apidoc.element.mathjs.type.Fraction.prototype.clone">
        function <span class="apidocSignatureSpan">mathjs.type.Fraction.prototype.</span>clone
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clone = function () {
  return new Fraction(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return desc;
};

/**
 * Export the help object to JSON
 */
Help.prototype.toJSON = function () {
  var obj = object.<span class="apidocCodeKeywordSpan">clone</span>(this.doc);
  obj.mathjs = 'Help';
  return obj;
};

/**
 * Instantiate a Help object from a JSON object
 * @param {Object} json
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Fraction.prototype.compare" id="apidoc.element.mathjs.type.Fraction.prototype.compare">
        function <span class="apidocSignatureSpan">mathjs.type.Fraction.prototype.</span>compare
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compare = function (a, b) {

  parse(a, b);
  var t = (this["s"] * this["n"] * P["d"] - P["s"] * P["n"] * this["d"]);
  return (0 &lt; t) - (t &lt; 0);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* is smaller than the configured epsilon. The function cannot be used to
* compare values smaller than approximately 2.22e-16.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">compare</span>(x, y)
*
* Examples:
*
*    math.compare(6, 1);           // returns 1
*    math.compare(2, 3);           // returns -1
*    math.compare(7, 7);           // returns 0
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Fraction.prototype.div" id="apidoc.element.mathjs.type.Fraction.prototype.div">
        function <span class="apidocSignatureSpan">mathjs.type.Fraction.prototype.</span>div
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">div = function (a, b) {

  parse(a, b);
  return new Fraction(
          this["s"] * P["s"] * this["n"] * P["d"],
          this["d"] * P["n"]
          );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  setLazyConstant(math, 'e',   function () {return bigConstants.e(type.BigNumber)});
  setLazyConstant(math, 'phi', function () {return bigConstants.phi(type.BigNumber)}); // golden ratio, (1+sqrt(5))/2

  // uppercase constants (for compatibility with built-in Math)
  setLazyConstant(math, 'E',       function () {return math.e;});
  setLazyConstant(math, 'LN2',     function () {return new type.BigNumber(2).ln();});
  setLazyConstant(math, 'LN10',    function () {return new type.BigNumber(10).ln()});
  setLazyConstant(math, 'LOG2E',   function () {return new type.BigNumber(1).<span class="apidocCodeKeywordSpan">div<!--
span-->(new type.BigNumber(2).ln());});
  setLazyConstant(math, 'LOG10E',  function () {return new type.BigNumber(1).div(new type.BigNumber(10).ln())});
  setLazyConstant(math, 'PI',      function () {return math.pi});
  setLazyConstant(math, 'SQRT1_2', function () {return new type.BigNumber('0.5').sqrt()});
  setLazyConstant(math, 'SQRT2',   function () {return new type.BigNumber(2).sqrt()});
}
else {
  setConstant(math, 'Infinity', Infinity);
...</span></pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Fraction.prototype.divisible" id="apidoc.element.mathjs.type.Fraction.prototype.divisible">
        function <span class="apidocSignatureSpan">mathjs.type.Fraction.prototype.</span>divisible
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">divisible = function (a, b) {

  parse(a, b);
  return !(!(P["n"] * this["d"]) || ((this["n"] * P["d"]) % (P["n"] * this["d"])));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Fraction.prototype.equals" id="apidoc.element.mathjs.type.Fraction.prototype.equals">
        function <span class="apidocSignatureSpan">mathjs.type.Fraction.prototype.</span>equals
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">equals = function (a, b) {

  parse(a, b);
  return this["s"] * this["n"] * P["d"] === P["s"] * P["n"] * this["d"]; // Same as compare() === 0
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (inv) {
  root = root.neg();
}

if (root.isZero()) {
  throw new Error('Root must be non-zero');
}
if (a.isNegative() &amp;&amp; !root.abs().mod(2).<span class="apidocCodeKeywordSpan">equals</span>(1)) {
  throw new Error('Root must be odd when a is negative.');
}

// edge cases zero and infinity
if (a.isZero()) {
  return inv ? new Big(Infinity) : 0;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Fraction.prototype.floor" id="apidoc.element.mathjs.type.Fraction.prototype.floor">
        function <span class="apidocSignatureSpan">mathjs.type.Fraction.prototype.</span>floor
        <span class="apidocSignatureSpan">(places)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">floor = function (places) {

  places = Math.pow(10, places || 0);

  if (isNaN(this["n"]) || isNaN(this["d"])) {
    return new Fraction(NaN);
  }
  return new Fraction(Math.floor(places * this["s"] * this["n"] / this["d"]), places);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   *    ceil, floor, round
   *
   * @param {number | BigNumber | Fraction | Complex | Array | Matrix} x Number to be rounded
   * @return {number | BigNumber | Fraction | Complex | Array | Matrix}            Rounded value
   */
  var fix = typed('fix', {
'number': function (x) {
  return (x &gt; 0) ? Math.<span class="apidocCodeKeywordSpan">floor</span>(x) : Math.ceil(x);
},

'Complex': function (x) {
  return new type.Complex(
      (x.re &gt; 0) ? Math.floor(x.re) : Math.ceil(x.re),
      (x.im &gt; 0) ? Math.floor(x.im) : Math.ceil(x.im)
  );
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Fraction.prototype.gcd" id="apidoc.element.mathjs.type.Fraction.prototype.gcd">
        function <span class="apidocSignatureSpan">mathjs.type.Fraction.prototype.</span>gcd
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">gcd = function (a, b) {

  parse(a, b);

  // gcd(a / b, c / d) = gcd(a, c) / lcm(b, d)

  return new Fraction(gcd(P["n"], this["n"]), P["d"] * this["d"] / gcd(P["d"], this["d"]));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  /**
* Calculate the greatest common divisor for two or more values or arrays.
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">gcd</span>(a, b)
*    math.gcd(a, b, c, ...)
*
* Examples:
*
*    math.gcd(8, 12);              // returns 4
*    math.gcd(-4, 6);              // returns 2
*    math.gcd(25, 15, -10);        // returns 5
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Fraction.prototype.inverse" id="apidoc.element.mathjs.type.Fraction.prototype.inverse">
        function <span class="apidocSignatureSpan">mathjs.type.Fraction.prototype.</span>inverse
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inverse = function () {

  return new Fraction(this["s"] * this["d"], this["n"]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Fraction.prototype.lcm" id="apidoc.element.mathjs.type.Fraction.prototype.lcm">
        function <span class="apidocSignatureSpan">mathjs.type.Fraction.prototype.</span>lcm
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lcm = function (a, b) {

  parse(a, b);

  // lcm(a / b, c / d) = lcm(a, c) / gcd(b, d)

  if (P["n"] === 0 &amp;&amp; this["n"] === 0) {
    return new Fraction;
  }
  return new Fraction(P["n"] * this["n"] / gcd(P["n"], this["n"]), gcd(P["d"], this["d"]));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
*     lcm(a, b) = abs(a * b) / gcd(a, b)
*
* For matrices, the function is evaluated element wise.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">lcm</span>(a, b)
*    math.lcm(a, b, c, ...)
*
* Examples:
*
*    math.lcm(4, 6);               // returns 12
*    math.lcm(6, 21);              // returns 42
*    math.lcm(6, 21, 5);           // returns 210
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Fraction.prototype.mod" id="apidoc.element.mathjs.type.Fraction.prototype.mod">
        function <span class="apidocSignatureSpan">mathjs.type.Fraction.prototype.</span>mod
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mod = function (a, b) {

  if (isNaN(this['n']) || isNaN(this['d'])) {
    return new Fraction(NaN);
  }

  if (a === undefined) {
    return new Fraction(this["s"] * this["n"] % this["d"], 1);
  }

  parse(a, b);
  if (0 === P["n"] &amp;&amp; 0 === this["d"]) {
    Fraction(0, 0); // Throw DivisionByZero
  }

<span class="apidocCodeCommentSpan">  /*
   * First silly attempt, kinda slow
   *
   return that["sub"]({
   "n": num["n"] * Math.floor((this.n / this.d) / (num.n / num.d)),
   "d": num["d"],
   "s": this["s"]
   });*/
</span>
  /*
   * New attempt: a1 / b1 = a2 / b2 * q + r
   * =&gt; b2 * a1 = a2 * b1 * q + b1 * b2 * r
   * =&gt; (b2 * a1 % a2 * b1) / (b1 * b2)
   */
  return new Fraction(
          (this["s"] * P["d"] * this["n"]) % (P["n"] * this["d"]),
          P["d"] * this["d"]
          );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (!a.isInt() || !b.isInt()) {
      throw new Error('Parameters in function gcd must be integer numbers');
    }

    // http://en.wikipedia.org/wiki/Euclidean_algorithm
    var zero = new type.BigNumber(0);
    while (!b.isZero()) {
      var r = a.<span class="apidocCodeKeywordSpan">mod</span>(b);
      a = b;
      b = r;
    }
    return a.lt(zero) ? a.neg() : a;
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Fraction.prototype.mul" id="apidoc.element.mathjs.type.Fraction.prototype.mul">
        function <span class="apidocSignatureSpan">mathjs.type.Fraction.prototype.</span>mul
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mul = function (a, b) {

  parse(a, b);
  return new Fraction(
          this["s"] * P["s"] * this["n"] * P["n"],
          this["d"] * P["d"]
          );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  function _cbrtComplex(x, allRoots) {
// https://www.wikiwand.com/en/Cube_root#/Complex_numbers

var arg_3 = x.arg() / 3;
var abs = x.abs();

// principal root:
var principal = new type.Complex(_cbrtNumber(abs), 0).<span class="apidocCodeKeywordSpan">mul</span>(
    new type.Complex(0, arg_3).exp());

if (allRoots) {
  var all = [
      principal,
      new type.Complex(_cbrtNumber(abs), 0).mul(
        new type.Complex(0, arg_3 + Math.PI * 2 / 3).exp()),
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Fraction.prototype.neg" id="apidoc.element.mathjs.type.Fraction.prototype.neg">
        function <span class="apidocSignatureSpan">mathjs.type.Fraction.prototype.</span>neg
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">neg = function () {

  return new Fraction(-this["s"] * this["n"], this["d"]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   // http://en.wikipedia.org/wiki/Euclidean_algorithm
   var zero = new type.BigNumber(0);
   while (!b.isZero()) {
     var r = a.mod(b);
     a = b;
     b = r;
   }
   return a.lt(zero) ? a.<span class="apidocCodeKeywordSpan">neg</span>() : a;
 }
}

/**
* Calculate gcd for numbers
* @param {number} a
* @param {number} b
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Fraction.prototype.pow" id="apidoc.element.mathjs.type.Fraction.prototype.pow">
        function <span class="apidocSignatureSpan">mathjs.type.Fraction.prototype.</span>pow
        <span class="apidocSignatureSpan">(m)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pow = function (m) {

  if (m &lt; 0) {
    return new Fraction(Math.pow(this['s'] * this["d"],-m), Math.pow(this["n"],-m));
  } else {
    return new Fraction(Math.pow(this['s'] * this["n"], m), Math.pow(this["d"], m));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var math = require('mathjs');

// functions and constants
math.round(math.e, 3);            // 2.718
math.atan2(3, -3) / math.pi;      // 0.75
math.log(1000, 10);               // 3
math.sqrt(-4);                    // 2i
math.<span class="apidocCodeKeywordSpan">pow</span>([[-1, 2], [3, 1]], 2);   // [[7, 0], [0, 7]]
math.derivative('x^2 + x', 'x');  // 2 * x + 1

// expressions
math.eval('12 / (2.3 + 0.7)');    // 4
math.eval('5.08 cm to inch');     // 2 inch
math.eval('sin(45 deg) ^ 2');     // 0.5
math.eval('9 / 3 + 2i');          // 3 + 2i
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Fraction.prototype.round" id="apidoc.element.mathjs.type.Fraction.prototype.round">
        function <span class="apidocSignatureSpan">mathjs.type.Fraction.prototype.</span>round
        <span class="apidocSignatureSpan">(places)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">round = function (places) {

  places = Math.pow(10, places || 0);

  if (isNaN(this["n"]) || isNaN(this["d"])) {
    return new Fraction(NaN);
  }
  return new Fraction(Math.round(places * this["s"] * this["n"] / this["d"]), places);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
[chained operations](http://mathjs.org/docs/chained_operations.html).

```js
// load math.js
var math = require('mathjs');

// functions and constants
math.<span class="apidocCodeKeywordSpan">round</span>(math.e, 3);            // 2.718
math.atan2(3, -3) / math.pi;      // 0.75
math.log(1000, 10);               // 3
math.sqrt(-4);                    // 2i
math.pow([[-1, 2], [3, 1]], 2);   // [[7, 0], [0, 7]]
math.derivative('x^2 + x', 'x');  // 2 * x + 1

// expressions
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Fraction.prototype.sub" id="apidoc.element.mathjs.type.Fraction.prototype.sub">
        function <span class="apidocSignatureSpan">mathjs.type.Fraction.prototype.</span>sub
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sub = function (a, b) {

  parse(a, b);
  return new Fraction(
          this["s"] * this["n"] * P["d"] - P["s"] * this["d"] * P["n"],
          this["d"] * P["d"]
          );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var subtract = typed('subtract', {

'number, number': function (x, y) {
  return x - y;
},

'Complex, Complex': function (x, y) {
  return x.<span class="apidocCodeKeywordSpan">sub</span>(y);
},

'BigNumber, BigNumber': function (x, y) {
  return x.minus(y);
},

'Fraction, Fraction': function (x, y) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Fraction.prototype.toContinued" id="apidoc.element.mathjs.type.Fraction.prototype.toContinued">
        function <span class="apidocSignatureSpan">mathjs.type.Fraction.prototype.</span>toContinued
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toContinued = function () {

  var t;
  var a = this['n'];
  var b = this['d'];
  var res = [];

  do {
    res.push(Math.floor(a / b));
    t = a % b;
    a = b;
    b = t;
  } while (a !== 1);

  return res;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Fraction.prototype.toFraction" id="apidoc.element.mathjs.type.Fraction.prototype.toFraction">
        function <span class="apidocSignatureSpan">mathjs.type.Fraction.prototype.</span>toFraction
        <span class="apidocSignatureSpan">(excludeWhole)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toFraction = function (excludeWhole) {

  var whole, str = "";
  var n = this["n"];
  var d = this["d"];
  if (this["s"] &lt; 0) {
    str+= '-';
  }

  if (d === 1) {
    str+= n;
  } else {

    if (excludeWhole &amp;&amp; (whole = Math.floor(n / d)) &gt; 0) {
      str+= whole;
      str+= " ";
      n%= d;
    }

    str+= n;
    str+= '/';
    str+= d;
  }
  return str;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Fraction.prototype.toJSON" id="apidoc.element.mathjs.type.Fraction.prototype.toJSON">
        function <span class="apidocSignatureSpan">mathjs.type.Fraction.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function () {
  return {
    mathjs: 'Fraction',
    n: this.s * this.n,
    d: this.d
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Fraction.prototype.toLatex" id="apidoc.element.mathjs.type.Fraction.prototype.toLatex">
        function <span class="apidocSignatureSpan">mathjs.type.Fraction.prototype.</span>toLatex
        <span class="apidocSignatureSpan">(excludeWhole)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toLatex = function (excludeWhole) {

  var whole, str = "";
  var n = this["n"];
  var d = this["d"];
  if (this["s"] &lt; 0) {
    str+= '-';
  }

  if (d === 1) {
    str+= n;
  } else {

    if (excludeWhole &amp;&amp; (whole = Math.floor(n / d)) &gt; 0) {
      str+= whole;
      n%= d;
    }

    str+= "\\frac{";
    str+= n;
    str+= '}{';
    str+= d;
    str+= '}';
  }
  return str;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Fraction.prototype.toString" id="apidoc.element.mathjs.type.Fraction.prototype.toString">
        function <span class="apidocSignatureSpan">mathjs.type.Fraction.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {

  var g;
  var N = this["n"];
  var D = this["d"];

  if (isNaN(N) || isNaN(D)) {
    return "NaN";
  }

  if (!Fraction['REDUCE']) {
    g = gcd(N, D);
    N/= g;
    D/= g;
  }

  var p = String(N).split(""); // Numerator chars
  var t = 0; // Tmp var

  var ret = [~this["s"] ? "" : "-", "", ""]; // Return array, [0] is zero sign, [1] before comma, [2] after
  var zeros = ""; // Collection variable for zeros

  var cycLen = cycleLen(N, D); // Cycle length
  var cycOff = cycleStart(N, D, cycLen); // Cycle start

  var j = -1;
  var n = 1; // str index

  // rough estimate to fill zeros
  var length = 15 + cycLen + cycOff + p.length; // 15 = decimal places when no repitation

  for (var i = 0; i &lt; length; i++, t*= 10) {

    if (i &lt; p.length) {
      t+= Number(p[i]);
    } else {
      n = 2;
      j++; // Start now =&gt; after comma
    }

    if (cycLen &gt; 0) { // If we have a repeating part
      if (j === cycOff) {
        ret[n]+= zeros + "(";
        zeros = "";
      } else if (j === cycLen + cycOff) {
        ret[n]+= zeros + ")";
        break;
      }
    }

    if (t &gt;= D) {
      ret[n]+= zeros + ((t / D) | 0); // Flush zeros, Add current digit
      zeros = "";
      t = t % D;
    } else if (n &gt; 1) { // Add zeros to the zero buffer
      zeros+= "0";
    } else if (ret[n]) { // If before comma, add zero only if already something was added
      ret[n]+= "0";
    }
  }

  // If it's empty, it's a leading zero only
  ret[0]+= ret[1] || "0";

  // If there is something after the comma, add the comma sign
  if (ret[2]) {
    return ret[0] + "." + ret[2];
  }
  return ret[0];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      }
      else {
        scope.ans = res;
        console.log(format(res));
      }
    }
    else if (res instanceof math.type.Help) {
      console.log(res.<span class="apidocCodeKeywordSpan">toString</span>());
    }
    else {
      scope.ans = res;
      console.log(format(res));
    }
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Fraction.prototype.valueOf" id="apidoc.element.mathjs.type.Fraction.prototype.valueOf">
        function <span class="apidocSignatureSpan">mathjs.type.Fraction.prototype.</span>valueOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">valueOf = function () {

  return this["s"] * this["n"] / this["d"];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    throw new TypeError('Cannot implicitly convert a Fraction to BigNumber or vice versa. ' +
        'Use function bignumber(x) to convert to BigNumber or fraction(x) to convert to Fraction.');
  }
}, {
  from: 'Fraction',
  to: 'Complex',
  convert: function (x) {
    return new type.Complex(x.<span class="apidocCodeKeywordSpan">valueOf</span>(), 0);
  }
}, {
  from: 'number',
  to: 'Fraction',
  convert: function (x) {
    if (digits(x) &gt; 15) {
      throw new TypeError('Cannot implicitly convert a number with &gt;15 significant digits to Fraction ' +
...</pre></li>
    </ul>










</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.type.Help" id="apidoc.module.mathjs.type.Help">module mathjs.type.Help</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.type.Help.Help" id="apidoc.element.mathjs.type.Help.Help">
        function <span class="apidocSignatureSpan">mathjs.type.</span>Help
        <span class="apidocSignatureSpan">(doc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Help(doc) {
  if (!(this instanceof Help)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  if (!doc)  throw new Error('Argument "doc" missing');

  this.doc = doc;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Help.fromJSON" id="apidoc.element.mathjs.type.Help.fromJSON">
        function <span class="apidocSignatureSpan">mathjs.type.Help.</span>fromJSON
        <span class="apidocSignatureSpan">(json)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromJSON = function (json) {
  var doc = {};
  for (var prop in json) {
    if (prop !== 'mathjs') { // ignore mathjs field
      doc[prop] = json[prop];
    }
  }
  return new Help(doc);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * @param {string} key
   * @param {*} value
   * @returns {*} Returns the revived object
   */
  return function reviver(key, value) {
    var constructor = type[value &amp;&amp; value.mathjs];
    if (constructor &amp;&amp; typeof constructor.fromJSON === 'function') {
      return constructor.<span class="apidocCodeKeywordSpan">fromJSON</span>(value);
    }

    return value;
  }
}

exports.name = 'reviver';
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.type.Help.prototype" id="apidoc.module.mathjs.type.Help.prototype">module mathjs.type.Help.prototype</a></h1>




    <h2>
        <a href="#apidoc.element.mathjs.type.Help.prototype.toJSON" id="apidoc.element.mathjs.type.Help.prototype.toJSON">
        function <span class="apidocSignatureSpan">mathjs.type.Help.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function () {
  var obj = object.clone(this.doc);
  obj.mathjs = 'Help';
  return obj;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Help.prototype.toString" id="apidoc.element.mathjs.type.Help.prototype.toString">
        function <span class="apidocSignatureSpan">mathjs.type.Help.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
  var doc = this.doc || {};
  var desc = '\n';

  if (doc.name) {
    desc += 'Name: ' + doc.name + '\n\n';
  }
  if (doc.category) {
    desc += 'Category: ' + doc.category + '\n\n';
  }
  if (doc.description) {
    desc += 'Description:\n    ' + doc.description + '\n\n';
  }
  if (doc.syntax) {
    desc += 'Syntax:\n    ' + doc.syntax.join('\n    ') + '\n\n';
  }
  if (doc.examples) {
    desc += 'Examples:\n';
    for (var i = 0; i &lt; doc.examples.length; i++) {
      var expr = doc.examples[i];
      desc += '    ' + expr + '\n';

      var res;
      try {
        res = parser.eval(expr);
      }
      catch (e) {
        res = e;
      }
      if (res &amp;&amp; !res.isHelp) {
        desc += '        ' + string.format(res, {precision: 14}) + '\n';
      }
    }
    desc += '\n';
  }
  if (doc.seealso) {
    desc += 'See also: ' + doc.seealso.join(', ') + '\n';
  }

  return desc;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      }
      else {
        scope.ans = res;
        console.log(format(res));
      }
    }
    else if (res instanceof math.type.Help) {
      console.log(res.<span class="apidocCodeKeywordSpan">toString</span>());
    }
    else {
      scope.ans = res;
      console.log(format(res));
    }
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Help.prototype.valueOf" id="apidoc.element.mathjs.type.Help.prototype.valueOf">
        function <span class="apidocSignatureSpan">mathjs.type.Help.prototype.</span>valueOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">valueOf = function () {
  var doc = this.doc || {};
  var desc = '\n';

  if (doc.name) {
    desc += 'Name: ' + doc.name + '\n\n';
  }
  if (doc.category) {
    desc += 'Category: ' + doc.category + '\n\n';
  }
  if (doc.description) {
    desc += 'Description:\n    ' + doc.description + '\n\n';
  }
  if (doc.syntax) {
    desc += 'Syntax:\n    ' + doc.syntax.join('\n    ') + '\n\n';
  }
  if (doc.examples) {
    desc += 'Examples:\n';
    for (var i = 0; i &lt; doc.examples.length; i++) {
      var expr = doc.examples[i];
      desc += '    ' + expr + '\n';

      var res;
      try {
        res = parser.eval(expr);
      }
      catch (e) {
        res = e;
      }
      if (res &amp;&amp; !res.isHelp) {
        desc += '        ' + string.format(res, {precision: 14}) + '\n';
      }
    }
    desc += '\n';
  }
  if (doc.seealso) {
    desc += 'See also: ' + doc.seealso.join(', ') + '\n';
  }

  return desc;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    throw new TypeError('Cannot implicitly convert a Fraction to BigNumber or vice versa. ' +
        'Use function bignumber(x) to convert to BigNumber or fraction(x) to convert to Fraction.');
  }
}, {
  from: 'Fraction',
  to: 'Complex',
  convert: function (x) {
    return new type.Complex(x.<span class="apidocCodeKeywordSpan">valueOf</span>(), 0);
  }
}, {
  from: 'number',
  to: 'Fraction',
  convert: function (x) {
    if (digits(x) &gt; 15) {
      throw new TypeError('Cannot implicitly convert a number with &gt;15 significant digits to Fraction ' +
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.type.ImmutableDenseMatrix" id="apidoc.module.mathjs.type.ImmutableDenseMatrix">module mathjs.type.ImmutableDenseMatrix</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.type.ImmutableDenseMatrix.ImmutableDenseMatrix" id="apidoc.element.mathjs.type.ImmutableDenseMatrix.ImmutableDenseMatrix">
        function <span class="apidocSignatureSpan">mathjs.type.</span>ImmutableDenseMatrix
        <span class="apidocSignatureSpan">(data, datatype)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ImmutableDenseMatrix(data, datatype) {
  if (!(this instanceof ImmutableDenseMatrix))
    throw new SyntaxError('Constructor must be called with the new operator');
  if (datatype &amp;&amp; !isString(datatype))
    throw new Error('Invalid datatype: ' + datatype);

  if ((data &amp;&amp; data.isMatrix === true) || isArray(data)) {
    // use DenseMatrix implementation
    var matrix = new DenseMatrix(data, datatype);
    // internal structures
    this._data = matrix._data;
    this._size = matrix._size;
    this._datatype = matrix._datatype;
    this._min = null;
    this._max = null;
  }
  else if (data &amp;&amp; isArray(data.data) &amp;&amp; isArray(data.size)) {
    // initialize fields from JSON representation
    this._data = data.data;
    this._size = data.size;
    this._datatype = data.datatype;
    this._min = typeof data.min !== 'undefined' ? data.min : null;
    this._max = typeof data.max !== 'undefined' ? data.max : null;
  }
  else if (data) {
    // unsupported type
    throw new TypeError('Unsupported type of data (' + util.types.type(data) + ')');
  }
  else {
    // nothing provided
    this._data = [];
    this._size = [0];
    this._datatype = datatype;
    this._min = null;
    this._max = null;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // loop array elements
  for (var i = 0, l = arg.length; i &lt; l; i++) {
    if (typeof arg[i] !== 'number' || !isInteger(arg[i])) {
      throw new TypeError('Index parameters must be positive integer numbers');
    }
  }
  // create matrix
  return new type.<span class="apidocCodeKeywordSpan">ImmutableDenseMatrix</span>(arg);
}

/**
 * Create a clone of the index
 * @memberof Index
 * @return {Index} clone
 */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.ImmutableDenseMatrix.fromJSON" id="apidoc.element.mathjs.type.ImmutableDenseMatrix.fromJSON">
        function <span class="apidocSignatureSpan">mathjs.type.ImmutableDenseMatrix.</span>fromJSON
        <span class="apidocSignatureSpan">(json)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromJSON = function (json) {
  return new ImmutableDenseMatrix(json);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * @param {string} key
   * @param {*} value
   * @returns {*} Returns the revived object
   */
  return function reviver(key, value) {
    var constructor = type[value &amp;&amp; value.mathjs];
    if (constructor &amp;&amp; typeof constructor.fromJSON === 'function') {
      return constructor.<span class="apidocCodeKeywordSpan">fromJSON</span>(value);
    }

    return value;
  }
}

exports.name = 'reviver';
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.type.ImmutableDenseMatrix.prototype" id="apidoc.module.mathjs.type.ImmutableDenseMatrix.prototype">module mathjs.type.ImmutableDenseMatrix.prototype</a></h1>




    <h2>
        <a href="#apidoc.element.mathjs.type.ImmutableDenseMatrix.prototype.clone" id="apidoc.element.mathjs.type.ImmutableDenseMatrix.prototype.clone">
        function <span class="apidocSignatureSpan">mathjs.type.ImmutableDenseMatrix.prototype.</span>clone
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clone = function () {
  var m = new ImmutableDenseMatrix({
    data: object.clone(this._data),
    size: object.clone(this._size),
    datatype: this._datatype
  });
  return m;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return desc;
};

/**
 * Export the help object to JSON
 */
Help.prototype.toJSON = function () {
  var obj = object.<span class="apidocCodeKeywordSpan">clone</span>(this.doc);
  obj.mathjs = 'Help';
  return obj;
};

/**
 * Instantiate a Help object from a JSON object
 * @param {Object} json
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.ImmutableDenseMatrix.prototype.max" id="apidoc.element.mathjs.type.ImmutableDenseMatrix.prototype.max">
        function <span class="apidocSignatureSpan">mathjs.type.ImmutableDenseMatrix.prototype.</span>max
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">max = function () {
  // check max has been calculated before
  if (this._max === null) {
    // maximum
    var m = null;
    // compute max
    this.forEach(function (v) {
      if (m === null || smaller(m, v))
        m = v;
    });
    this._max = m !== null ? m : undefined;
  }
  return this._max;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @return {number} Returns the maximum number of expected arguments.
 *                  Returns -1 when no signatures where found on the function.
 */
exports.maxArgumentCount = function (fn) {
  return Object.keys(fn.signatures || {})
      .reduce(function (args, signature) {
        var count = (signature.match(/,/g) || []).length + 1;
        return Math.<span class="apidocCodeKeywordSpan">max</span>(args, count);
      }, -1);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.ImmutableDenseMatrix.prototype.min" id="apidoc.element.mathjs.type.ImmutableDenseMatrix.prototype.min">
        function <span class="apidocSignatureSpan">mathjs.type.ImmutableDenseMatrix.prototype.</span>min
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">min = function () {
  // check min has been calculated before
  if (this._min === null) {
    // minimum
    var m = null;
    // compute min
    this.forEach(function (v) {
      if (m === null || smaller(v, m))
        m = v;
    });
    this._min = m !== null ? m : undefined;
  }
  return this._min;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @private
 */
function _resize (array, size, dim, defaultValue) {
var i;
var elem;
var oldLen = array.length;
var newLen = size[dim];
var minLen = Math.<span class="apidocCodeKeywordSpan">min</span>(oldLen, newLen);

// apply new length
array.length = newLen;

if (dim &lt; size.length - 1) {
  // non-last dimension
  var dimNext = dim + 1;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.ImmutableDenseMatrix.prototype.reshape" id="apidoc.element.mathjs.type.ImmutableDenseMatrix.prototype.reshape">
        function <span class="apidocSignatureSpan">mathjs.type.ImmutableDenseMatrix.prototype.</span>reshape
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reshape = function () {
  throw new Error('Cannot invoke reshape on an Immutable Matrix instance');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var matrix = load(require('../../type/matrix/function/matrix'));

/**
 * Reshape a multi dimensional array to fit the specified dimensions
 *
 * Syntax:
 *
 *     math.<span class="apidocCodeKeywordSpan">reshape</span>(x, sizes)
 *
 * Examples:
 *
 *     math.reshape([1, 2, 3, 4, 5, 6], [2, 3]);
 *     // returns Array  [[1, 2, 3], [4, 5, 6]]
 *
 *     math.reshape([[1, 2], [3, 4]], [1, 4]);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.ImmutableDenseMatrix.prototype.resize" id="apidoc.element.mathjs.type.ImmutableDenseMatrix.prototype.resize">
        function <span class="apidocSignatureSpan">mathjs.type.ImmutableDenseMatrix.prototype.</span>resize
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resize = function () {
  throw new Error('Cannot invoke resize on an Immutable Matrix instance');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // get matrix storage constructor
  var F = type.Matrix.storage(format);
  // create diagonal matrix (use optimized implementation for storage format)
  return F.diagonal(size, one, 0, defaultValue);
}

// create and resize array
var res = array.<span class="apidocCodeKeywordSpan">resize</span>([], size, defaultValue);
// fill in ones on the diagonal
var minimum = rows &lt; cols ? rows : cols;
// fill diagonal
for (var d = 0; d &lt; minimum; d++) {
  res[d][d] = one;
}
return res;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.ImmutableDenseMatrix.prototype.set" id="apidoc.element.mathjs.type.ImmutableDenseMatrix.prototype.set">
        function <span class="apidocSignatureSpan">mathjs.type.ImmutableDenseMatrix.prototype.</span>set
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">set = function () {
  throw new Error('Cannot invoke set on an Immutable Matrix instance');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* keeps a scope containing variables in memory, which is used for all
* evaluations.
*
* Methods:
*    var result = parser.eval(expr);    // evaluate an expression
*    var value = parser.get(name);      // retrieve a variable from the parser
*    var values = parser.getAll();      // retrieve all defined variables
*    parser.<span class="apidocCodeKeywordSpan">set</span>(name, value);           // set a variable in the parser
*    parser.remove(name);               // clear a variable from the
*                                       // parsers scope
*    parser.clear();                    // clear the parsers scope
*
* Example usage:
*    var parser = new Parser();
*    // Note: there is a convenience method which can be used instead:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.ImmutableDenseMatrix.prototype.subset" id="apidoc.element.mathjs.type.ImmutableDenseMatrix.prototype.subset">
        function <span class="apidocSignatureSpan">mathjs.type.ImmutableDenseMatrix.prototype.</span>subset
        <span class="apidocSignatureSpan">(index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">subset = function (index) {
  switch (arguments.length) {
    case 1:
      // use base implementation
      var m = DenseMatrix.prototype.subset.call(this, index);
      // check result is a matrix
      if (m.isMatrix) {
        // return immutable matrix
        return new ImmutableDenseMatrix({
          data: m._data,
          size: m._size,
          datatype: m._datatype
        });
      }
      return m;

      // intentional fall through
    case 2:
    case 3:
      throw new Error('Cannot invoke set subset on an Immutable Matrix instance');

    default:
      throw new SyntaxError('Wrong number of arguments');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function factory (type, config, load, typed) {
var matrix = load(require('../../type/matrix/function/matrix'));

/**
 * Get or set a subset of a matrix or string.
 *
 * Syntax:
 *     math.<span class="apidocCodeKeywordSpan">subset</span>(value, index)                                // retrieve a subset
 *     math.subset(value, index, replacement [, defaultValue])  // replace a subset
 *
 * Examples:
 *
 *     // get a subset
 *     var d = [[1, 2], [3, 4]];
 *     math.subset(d, math.index(1, 0));        // returns 3
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.ImmutableDenseMatrix.prototype.swapRows" id="apidoc.element.mathjs.type.ImmutableDenseMatrix.prototype.swapRows">
        function <span class="apidocSignatureSpan">mathjs.type.ImmutableDenseMatrix.prototype.</span>swapRows
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">swapRows = function () {
  throw new Error('Cannot invoke swapRows on an Immutable Matrix instance');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.ImmutableDenseMatrix.prototype.toJSON" id="apidoc.element.mathjs.type.ImmutableDenseMatrix.prototype.toJSON">
        function <span class="apidocSignatureSpan">mathjs.type.ImmutableDenseMatrix.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function () {
  return {
    mathjs: 'ImmutableDenseMatrix',
    data: this._data,
    size: this._size,
    datatype: this._datatype
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.type.Index" id="apidoc.module.mathjs.type.Index">module mathjs.type.Index</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.type.Index.Index" id="apidoc.element.mathjs.type.Index.Index">
        function <span class="apidocSignatureSpan">mathjs.type.</span>Index
        <span class="apidocSignatureSpan">(ranges)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Index(ranges) {
  if (!(this instanceof Index)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  this._dimensions = [];
  this._isScalar = true;

  for (var i = 0, ii = arguments.length; i &lt; ii; i++) {
    var arg = arguments[i];

    if (arg &amp;&amp; (arg.isRange === true)) {
      this._dimensions.push(arg);
      this._isScalar = false;
    }
    else if (arg &amp;&amp; (Array.isArray(arg) || arg.isMatrix === true)) {
      // create matrix
      var m = _createImmutableMatrix(arg.valueOf());
      this._dimensions.push(m);
      // size
      var size = m.size();
      // scalar
      if (size.length !== 1 || size[0] !== 1) {
        this._isScalar = false;
      }
    }
    else if (typeof arg === 'number') {
      this._dimensions.push(_createImmutableMatrix([arg]));
    }
    else if (typeof arg === 'string') {
      // object property (arguments.count should be 1)
      this._dimensions.push(arg);
    }
    // TODO: implement support for wildcard '*'
    else {
      throw new TypeError('Dimension must be an Array, Matrix, number, string, or Range');
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      else {
        throw new TypeError('Dimension must be an Array, Matrix, number, string, or Range');
      }

      args[i] = arg;
    }

    var res = new type.<span class="apidocCodeKeywordSpan">Index</span>();
    type.Index.apply(res, args);
    return res;
  };
}

exports.name = 'index';
exports.path = 'expression.transform';
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Index.create" id="apidoc.element.mathjs.type.Index.create">
        function <span class="apidocSignatureSpan">mathjs.type.Index.</span>create
        <span class="apidocSignatureSpan">(ranges)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function (ranges) {
  var index = new Index();
  Index.apply(index, ranges);
  return index;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *                              false (default), output type can vary depending
 *                              on input values. For example `math.sqrt(-4)`
 *                              returns `complex('2i')` when predictable is false, and
 *                              returns `NaN` when true.
 */
function create (config) {
  // create a new math.js instance
  var math = core.<span class="apidocCodeKeywordSpan">create</span>(config);
  math.create = create;

  // import data types, functions, constants, expression parser, etc.
  math['import'](require('./lib'));

  return math;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Index.fromJSON" id="apidoc.element.mathjs.type.Index.fromJSON">
        function <span class="apidocSignatureSpan">mathjs.type.Index.</span>fromJSON
        <span class="apidocSignatureSpan">(json)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromJSON = function (json) {
  return Index.create(json.dimensions);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * @param {string} key
   * @param {*} value
   * @returns {*} Returns the revived object
   */
  return function reviver(key, value) {
    var constructor = type[value &amp;&amp; value.mathjs];
    if (constructor &amp;&amp; typeof constructor.fromJSON === 'function') {
      return constructor.<span class="apidocCodeKeywordSpan">fromJSON</span>(value);
    }

    return value;
  }
}

exports.name = 'reviver';
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.type.Index.prototype" id="apidoc.module.mathjs.type.Index.prototype">module mathjs.type.Index.prototype</a></h1>




    <h2>
        <a href="#apidoc.element.mathjs.type.Index.prototype.clone" id="apidoc.element.mathjs.type.Index.prototype.clone">
        function <span class="apidocSignatureSpan">mathjs.type.Index.prototype.</span>clone
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clone = function () {
  var index = new Index();
  index._dimensions = clone(this._dimensions);
  index._isScalar = this._isScalar;
  return index;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return desc;
};

/**
 * Export the help object to JSON
 */
Help.prototype.toJSON = function () {
  var obj = object.<span class="apidocCodeKeywordSpan">clone</span>(this.doc);
  obj.mathjs = 'Help';
  return obj;
};

/**
 * Instantiate a Help object from a JSON object
 * @param {Object} json
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Index.prototype.dimension" id="apidoc.element.mathjs.type.Index.prototype.dimension">
        function <span class="apidocSignatureSpan">mathjs.type.Index.prototype.</span>dimension
        <span class="apidocSignatureSpan">(dim)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dimension = function (dim) {
  return this._dimensions[dim] || null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

// validate whether the range is out of range
var strLen = str.length;
validateIndex(index.min()[0], strLen);
validateIndex(index.max()[0], strLen);

var range = index.<span class="apidocCodeKeywordSpan">dimension</span>(0);

var substr = '';
range.forEach(function (v) {
  substr += str.charAt(v);
});

return substr;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Index.prototype.forEach" id="apidoc.element.mathjs.type.Index.prototype.forEach">
        function <span class="apidocSignatureSpan">mathjs.type.Index.prototype.</span>forEach
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEach = function (callback) {
  for (var i = 0, ii = this._dimensions.length; i &lt; ii; i++) {
    callback(this._dimensions[i], i, this);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (def.indexOf(keyword) == 0) {
      matches.push(def);
    }
  }
}

// commandline keywords
['exit', 'quit', 'clear'].<span class="apidocCodeKeywordSpan">forEach</span>(function (cmd) {
  if (cmd.indexOf(keyword) == 0) {
    matches.push(cmd);
  }
});

// math functions and constants
var ignore = ['expr', 'type'];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Index.prototype.getObjectProperty" id="apidoc.element.mathjs.type.Index.prototype.getObjectProperty">
        function <span class="apidocSignatureSpan">mathjs.type.Index.prototype.</span>getObjectProperty
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getObjectProperty = function () {
  return this.isObjectProperty() ? this._dimensions[0] : null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.index = index;

// readonly property name
Object.defineProperty(this, 'name', {
  get: function () {
    if (this.index) {
      return (this.index.isObjectProperty())
          ? this.index.<span class="apidocCodeKeywordSpan">getObjectProperty</span>()
          : '';
    }
    else {
      return this.object.name || '';
    }
  }.bind(this),
  set: function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Index.prototype.isObjectProperty" id="apidoc.element.mathjs.type.Index.prototype.isObjectProperty">
        function <span class="apidocSignatureSpan">mathjs.type.Index.prototype.</span>isObjectProperty
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isObjectProperty = function () {
  return this._dimensions.length === 1 &amp;&amp; typeof this._dimensions[0] === 'string';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.object = object || null;
this.index = index;

// readonly property name
Object.defineProperty(this, 'name', {
  get: function () {
    if (this.index) {
      return (this.index.<span class="apidocCodeKeywordSpan">isObjectProperty</span>())
          ? this.index.getObjectProperty()
          : '';
    }
    else {
      return this.object.name || '';
    }
  }.bind(this),
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Index.prototype.isScalar" id="apidoc.element.mathjs.type.Index.prototype.isScalar">
        function <span class="apidocSignatureSpan">mathjs.type.Index.prototype.</span>isScalar
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isScalar = function () {
  return this._isScalar;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * @private
   */
  function _get (matrix, index) {
if (!index || index.isIndex !== true) {
  throw new TypeError('Invalid index');
}

var isScalar = index.<span class="apidocCodeKeywordSpan">isScalar</span>();
if (isScalar) {
  // return a scalar
  return matrix.get(index.min());
}
else {
  // validate dimensions
  var size = index.size();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Index.prototype.max" id="apidoc.element.mathjs.type.Index.prototype.max">
        function <span class="apidocSignatureSpan">mathjs.type.Index.prototype.</span>max
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">max = function () {
  var values = [];

  for (var i = 0, ii = this._dimensions.length; i &lt; ii; i++) {
    var range = this._dimensions[i];
    values[i] = (typeof range === 'string') ? range : range.max();
  }

  return values;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @return {number} Returns the maximum number of expected arguments.
 *                  Returns -1 when no signatures where found on the function.
 */
exports.maxArgumentCount = function (fn) {
  return Object.keys(fn.signatures || {})
      .reduce(function (args, signature) {
        var count = (signature.match(/,/g) || []).length + 1;
        return Math.<span class="apidocCodeKeywordSpan">max</span>(args, count);
      }, -1);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Index.prototype.min" id="apidoc.element.mathjs.type.Index.prototype.min">
        function <span class="apidocSignatureSpan">mathjs.type.Index.prototype.</span>min
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">min = function () {
  var values = [];

  for (var i = 0, ii = this._dimensions.length; i &lt; ii; i++) {
    var range = this._dimensions[i];
    values[i] = (typeof range === 'string') ? range : range.min();
  }

  return values;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @private
 */
function _resize (array, size, dim, defaultValue) {
var i;
var elem;
var oldLen = array.length;
var newLen = size[dim];
var minLen = Math.<span class="apidocCodeKeywordSpan">min</span>(oldLen, newLen);

// apply new length
array.length = newLen;

if (dim &lt; size.length - 1) {
  // non-last dimension
  var dimNext = dim + 1;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Index.prototype.size" id="apidoc.element.mathjs.type.Index.prototype.size">
        function <span class="apidocSignatureSpan">mathjs.type.Index.prototype.</span>size
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">size = function () {
  var size = [];

  for (var i = 0, ii = this._dimensions.length; i &lt; ii; i++) {
    var d = this._dimensions[i];
    size[i] = (typeof d === 'string') ? 1 : d.size()[0];
  }

  return size;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

if (!Array.isArray(array) || !Array.isArray(sizes)) {
  throw new TypeError('Array expected');
}

if (sizes.length === 0) {
  throw new DimensionError(0, product(exports.<span class="apidocCodeKeywordSpan">size</span>(array)), '!=');
}

try {
  newArray  = _reshape(flatArray, sizes);
} catch (e) {
  if (e instanceof DimensionError) {
    throw new DimensionError(
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Index.prototype.toArray" id="apidoc.element.mathjs.type.Index.prototype.toArray">
        function <span class="apidocSignatureSpan">mathjs.type.Index.prototype.</span>toArray
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toArray = function () {
  var array = [];
  for (var i = 0, ii = this._dimensions.length; i &lt; ii; i++) {
    var dimension = this._dimensions[i];
    array.push((typeof dimension === 'string') ? dimension : dimension.toArray());
  }
  return array;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  '... number | BigNumber': _hypot,

  'Array': function (x) {
    return hypot.apply(hypot, flatten(x));
  },

  'Matrix': function (x) {
    return hypot.apply(hypot, flatten(x.<span class="apidocCodeKeywordSpan">toArray</span>()));
  }
});

/**
 * Calculate the hypotenusa for an Array with values
 * @param {Array.&lt;number | BigNumber&gt;} args
 * @return {number | BigNumber} Returns the result
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Index.prototype.toJSON" id="apidoc.element.mathjs.type.Index.prototype.toJSON">
        function <span class="apidocSignatureSpan">mathjs.type.Index.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function () {
  return {
    mathjs: 'Index',
    dimensions: this._dimensions
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Index.prototype.toString" id="apidoc.element.mathjs.type.Index.prototype.toString">
        function <span class="apidocSignatureSpan">mathjs.type.Index.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
  var strings = [];

  for (var i = 0, ii = this._dimensions.length; i &lt; ii; i++) {
    var dimension = this._dimensions[i];
    if (typeof dimension === 'string') {
      strings.push(JSON.stringify(dimension));
    }
    else {
      strings.push(dimension.toString());
    }
  }

  return '[' + strings.join(', ') + ']';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      }
      else {
        scope.ans = res;
        console.log(format(res));
      }
    }
    else if (res instanceof math.type.Help) {
      console.log(res.<span class="apidocCodeKeywordSpan">toString</span>());
    }
    else {
      scope.ans = res;
      console.log(format(res));
    }
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Index.prototype.valueOf" id="apidoc.element.mathjs.type.Index.prototype.valueOf">
        function <span class="apidocSignatureSpan">mathjs.type.Index.prototype.</span>valueOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">valueOf = function () {
  var array = [];
  for (var i = 0, ii = this._dimensions.length; i &lt; ii; i++) {
    var dimension = this._dimensions[i];
    array.push((typeof dimension === 'string') ? dimension : dimension.toArray());
  }
  return array;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    throw new TypeError('Cannot implicitly convert a Fraction to BigNumber or vice versa. ' +
        'Use function bignumber(x) to convert to BigNumber or fraction(x) to convert to Fraction.');
  }
}, {
  from: 'Fraction',
  to: 'Complex',
  convert: function (x) {
    return new type.Complex(x.<span class="apidocCodeKeywordSpan">valueOf</span>(), 0);
  }
}, {
  from: 'number',
  to: 'Fraction',
  convert: function (x) {
    if (digits(x) &gt; 15) {
      throw new TypeError('Cannot implicitly convert a number with &gt;15 significant digits to Fraction ' +
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.type.Matrix" id="apidoc.module.mathjs.type.Matrix">module mathjs.type.Matrix</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.type.Matrix.Matrix" id="apidoc.element.mathjs.type.Matrix.Matrix">
        function <span class="apidocSignatureSpan">mathjs.type.</span>Matrix
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Matrix() {
  if (!(this instanceof Matrix)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Matrix.storage" id="apidoc.element.mathjs.type.Matrix.storage">
        function <span class="apidocSignatureSpan">mathjs.type.Matrix.</span>storage
        <span class="apidocSignatureSpan">(format)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">storage = function (format) {
  // check storage format is a string
  if (!isString(format)) {
    throw new TypeError('format must be a string value');
  }

  // get storage format constructor
  var constructor = Matrix._storage[format];
  if (!constructor) {
    throw new SyntaxError('Unsupported matrix storage format: ' + format);
  }

  // return storage constructor
  return constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// we extend the signatures of addScalar with signatures dealing with matrices

'Matrix, Matrix': function (x, y) {
  // result
  var c;

  // process matrix storage
  switch (x.<span class="apidocCodeKeywordSpan">storage</span>()) {
    case 'sparse':
      switch (y.storage()) {
        case 'sparse':
          // sparse + sparse
          c = algorithm04(x, y, addScalar);
          break;
        default:
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.type.Matrix.prototype" id="apidoc.module.mathjs.type.Matrix.prototype">module mathjs.type.Matrix.prototype</a></h1>




    <h2>
        <a href="#apidoc.element.mathjs.type.Matrix.prototype.clone" id="apidoc.element.mathjs.type.Matrix.prototype.clone">
        function <span class="apidocSignatureSpan">mathjs.type.Matrix.prototype.</span>clone
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clone = function () {
  // must be implemented by each of the Matrix implementations
  throw new Error('Cannot invoke clone on a Matrix interface');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return desc;
};

/**
 * Export the help object to JSON
 */
Help.prototype.toJSON = function () {
  var obj = object.<span class="apidocCodeKeywordSpan">clone</span>(this.doc);
  obj.mathjs = 'Help';
  return obj;
};

/**
 * Instantiate a Help object from a JSON object
 * @param {Object} json
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Matrix.prototype.create" id="apidoc.element.mathjs.type.Matrix.prototype.create">
        function <span class="apidocSignatureSpan">mathjs.type.Matrix.prototype.</span>create
        <span class="apidocSignatureSpan">(data, datatype)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function (data, datatype) {
  throw new Error('Cannot invoke create on a Matrix interface');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *                              false (default), output type can vary depending
 *                              on input values. For example `math.sqrt(-4)`
 *                              returns `complex('2i')` when predictable is false, and
 *                              returns `NaN` when true.
 */
function create (config) {
  // create a new math.js instance
  var math = core.<span class="apidocCodeKeywordSpan">create</span>(config);
  math.create = create;

  // import data types, functions, constants, expression parser, etc.
  math['import'](require('./lib'));

  return math;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Matrix.prototype.datatype" id="apidoc.element.mathjs.type.Matrix.prototype.datatype">
        function <span class="apidocSignatureSpan">mathjs.type.Matrix.prototype.</span>datatype
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">datatype = function () {
  // must be implemented by each of the Matrix implementations
  throw new Error('Cannot invoke datatype on a Matrix interface');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return 'dense';
};

/**
 * Get the datatype of the data stored in the matrix.
 *
 * Usage:
 *     var format = matrix.<span class="apidocCodeKeywordSpan">datatype</span>()                   // retrieve matrix datatype
 *
 * @memberof DenseMatrix
 * @return {string}           The datatype.
 */
DenseMatrix.prototype.datatype = function () {
  return this._datatype;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Matrix.prototype.forEach" id="apidoc.element.mathjs.type.Matrix.prototype.forEach">
        function <span class="apidocSignatureSpan">mathjs.type.Matrix.prototype.</span>forEach
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEach = function (callback) {
  // must be implemented by each of the Matrix implementations
  throw new Error('Cannot invoke forEach on a Matrix interface');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (def.indexOf(keyword) == 0) {
      matches.push(def);
    }
  }
}

// commandline keywords
['exit', 'quit', 'clear'].<span class="apidocCodeKeywordSpan">forEach</span>(function (cmd) {
  if (cmd.indexOf(keyword) == 0) {
    matches.push(cmd);
  }
});

// math functions and constants
var ignore = ['expr', 'type'];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Matrix.prototype.format" id="apidoc.element.mathjs.type.Matrix.prototype.format">
        function <span class="apidocSignatureSpan">mathjs.type.Matrix.prototype.</span>format
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">format = function (options) {
  // must be implemented by each of the Matrix implementations
  throw new Error('Cannot invoke format on a Matrix interface');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Helper function to format a value. Regular numbers will be rounded
 * to 14 digits to prevent round-off errors from showing up.
 * @param {*} value
 */
function format(value) {
var math = getMath();

return math.<span class="apidocCodeKeywordSpan">format</span>(value, {
  fn: function (value) {
    if (typeof value === 'number') {
      // round numbers
      return math.format(value, PRECISION);
    }
    else {
      return math.format(value);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Matrix.prototype.get" id="apidoc.element.mathjs.type.Matrix.prototype.get">
        function <span class="apidocSignatureSpan">mathjs.type.Matrix.prototype.</span>get
        <span class="apidocSignatureSpan">(index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get = function (index) {
  // must be implemented by each of the Matrix implementations
  throw new Error('Cannot invoke get on a Matrix interface');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Parser contains methods to evaluate or parse expressions, and has a number
* of convenience methods to get, set, and remove variables from memory. Parser
* keeps a scope containing variables in memory, which is used for all
* evaluations.
*
* Methods:
*    var result = parser.eval(expr);    // evaluate an expression
*    var value = parser.<span class="apidocCodeKeywordSpan">get</span>(name);      // retrieve a variable from the parser
*    var values = parser.getAll();      // retrieve all defined variables
*    parser.set(name, value);           // set a variable in the parser
*    parser.remove(name);               // clear a variable from the
*                                       // parsers scope
*    parser.clear();                    // clear the parsers scope
*
* Example usage:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Matrix.prototype.map" id="apidoc.element.mathjs.type.Matrix.prototype.map">
        function <span class="apidocSignatureSpan">mathjs.type.Matrix.prototype.</span>map
        <span class="apidocSignatureSpan">(callback, skipZeros)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">map = function (callback, skipZeros) {
  // must be implemented by each of the Matrix implementations
  throw new Error('Cannot invoke map on a Matrix interface');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (res &amp;&amp; res.isResultSet) {
  // we can have 0 or 1 results in the ResultSet, as the CLI
  // does not allow multiple expressions separated by a return
  res = res.entries[0];
  node = node.blocks
      .filter(function (entry) { return entry.visible; })
      .<span class="apidocCodeKeywordSpan">map</span>(function (entry) { return entry.node })[0];
}

if (node) {
  if (node.isAssignmentNode) {
    var name = findSymbolName(node);
    if (name != null) {
      scope.ans = scope[name];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Matrix.prototype.reshape" id="apidoc.element.mathjs.type.Matrix.prototype.reshape">
        function <span class="apidocSignatureSpan">mathjs.type.Matrix.prototype.</span>reshape
        <span class="apidocSignatureSpan">(size, defaultValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reshape = function (size, defaultValue) {
  // must be implemented by each of the Matrix implementations
  throw new Error('Cannot invoke reshape on a Matrix interface');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var matrix = load(require('../../type/matrix/function/matrix'));

/**
 * Reshape a multi dimensional array to fit the specified dimensions
 *
 * Syntax:
 *
 *     math.<span class="apidocCodeKeywordSpan">reshape</span>(x, sizes)
 *
 * Examples:
 *
 *     math.reshape([1, 2, 3, 4, 5, 6], [2, 3]);
 *     // returns Array  [[1, 2, 3], [4, 5, 6]]
 *
 *     math.reshape([[1, 2], [3, 4]], [1, 4]);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Matrix.prototype.resize" id="apidoc.element.mathjs.type.Matrix.prototype.resize">
        function <span class="apidocSignatureSpan">mathjs.type.Matrix.prototype.</span>resize
        <span class="apidocSignatureSpan">(size, defaultValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resize = function (size, defaultValue) {
  // must be implemented by each of the Matrix implementations
  throw new Error('Cannot invoke resize on a Matrix interface');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // get matrix storage constructor
  var F = type.Matrix.storage(format);
  // create diagonal matrix (use optimized implementation for storage format)
  return F.diagonal(size, one, 0, defaultValue);
}

// create and resize array
var res = array.<span class="apidocCodeKeywordSpan">resize</span>([], size, defaultValue);
// fill in ones on the diagonal
var minimum = rows &lt; cols ? rows : cols;
// fill diagonal
for (var d = 0; d &lt; minimum; d++) {
  res[d][d] = one;
}
return res;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Matrix.prototype.set" id="apidoc.element.mathjs.type.Matrix.prototype.set">
        function <span class="apidocSignatureSpan">mathjs.type.Matrix.prototype.</span>set
        <span class="apidocSignatureSpan">(index, value, defaultValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">set = function (index, value, defaultValue) {
  // must be implemented by each of the Matrix implementations
  throw new Error('Cannot invoke set on a Matrix interface');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* keeps a scope containing variables in memory, which is used for all
* evaluations.
*
* Methods:
*    var result = parser.eval(expr);    // evaluate an expression
*    var value = parser.get(name);      // retrieve a variable from the parser
*    var values = parser.getAll();      // retrieve all defined variables
*    parser.<span class="apidocCodeKeywordSpan">set</span>(name, value);           // set a variable in the parser
*    parser.remove(name);               // clear a variable from the
*                                       // parsers scope
*    parser.clear();                    // clear the parsers scope
*
* Example usage:
*    var parser = new Parser();
*    // Note: there is a convenience method which can be used instead:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Matrix.prototype.size" id="apidoc.element.mathjs.type.Matrix.prototype.size">
        function <span class="apidocSignatureSpan">mathjs.type.Matrix.prototype.</span>size
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">size = function () {
  // must be implemented by each of the Matrix implementations
  throw new Error('Cannot invoke size on a Matrix interface');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

if (!Array.isArray(array) || !Array.isArray(sizes)) {
  throw new TypeError('Array expected');
}

if (sizes.length === 0) {
  throw new DimensionError(0, product(exports.<span class="apidocCodeKeywordSpan">size</span>(array)), '!=');
}

try {
  newArray  = _reshape(flatArray, sizes);
} catch (e) {
  if (e instanceof DimensionError) {
    throw new DimensionError(
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Matrix.prototype.storage" id="apidoc.element.mathjs.type.Matrix.prototype.storage">
        function <span class="apidocSignatureSpan">mathjs.type.Matrix.prototype.</span>storage
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">storage = function () {
  // must be implemented by each of the Matrix implementations
  throw new Error('Cannot invoke storage on a Matrix interface');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// we extend the signatures of addScalar with signatures dealing with matrices

'Matrix, Matrix': function (x, y) {
  // result
  var c;

  // process matrix storage
  switch (x.<span class="apidocCodeKeywordSpan">storage</span>()) {
    case 'sparse':
      switch (y.storage()) {
        case 'sparse':
          // sparse + sparse
          c = algorithm04(x, y, addScalar);
          break;
        default:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Matrix.prototype.subset" id="apidoc.element.mathjs.type.Matrix.prototype.subset">
        function <span class="apidocSignatureSpan">mathjs.type.Matrix.prototype.</span>subset
        <span class="apidocSignatureSpan">(index, replacement, defaultValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">subset = function (index, replacement, defaultValue) {
  // must be implemented by each of the Matrix implementations
  throw new Error('Cannot invoke subset on a Matrix interface');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function factory (type, config, load, typed) {
var matrix = load(require('../../type/matrix/function/matrix'));

/**
 * Get or set a subset of a matrix or string.
 *
 * Syntax:
 *     math.<span class="apidocCodeKeywordSpan">subset</span>(value, index)                                // retrieve a subset
 *     math.subset(value, index, replacement [, defaultValue])  // replace a subset
 *
 * Examples:
 *
 *     // get a subset
 *     var d = [[1, 2], [3, 4]];
 *     math.subset(d, math.index(1, 0));        // returns 3
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Matrix.prototype.toArray" id="apidoc.element.mathjs.type.Matrix.prototype.toArray">
        function <span class="apidocSignatureSpan">mathjs.type.Matrix.prototype.</span>toArray
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toArray = function () {
  // must be implemented by each of the Matrix implementations
  throw new Error('Cannot invoke toArray on a Matrix interface');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  '... number | BigNumber': _hypot,

  'Array': function (x) {
    return hypot.apply(hypot, flatten(x));
  },

  'Matrix': function (x) {
    return hypot.apply(hypot, flatten(x.<span class="apidocCodeKeywordSpan">toArray</span>()));
  }
});

/**
 * Calculate the hypotenusa for an Array with values
 * @param {Array.&lt;number | BigNumber&gt;} args
 * @return {number | BigNumber} Returns the result
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Matrix.prototype.toString" id="apidoc.element.mathjs.type.Matrix.prototype.toString">
        function <span class="apidocSignatureSpan">mathjs.type.Matrix.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
  // must be implemented by each of the Matrix implementations
  throw new Error('Cannot invoke toString on a Matrix interface');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      }
      else {
        scope.ans = res;
        console.log(format(res));
      }
    }
    else if (res instanceof math.type.Help) {
      console.log(res.<span class="apidocCodeKeywordSpan">toString</span>());
    }
    else {
      scope.ans = res;
      console.log(format(res));
    }
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Matrix.prototype.valueOf" id="apidoc.element.mathjs.type.Matrix.prototype.valueOf">
        function <span class="apidocSignatureSpan">mathjs.type.Matrix.prototype.</span>valueOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">valueOf = function () {
  // must be implemented by each of the Matrix implementations
  throw new Error('Cannot invoke valueOf on a Matrix interface');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    throw new TypeError('Cannot implicitly convert a Fraction to BigNumber or vice versa. ' +
        'Use function bignumber(x) to convert to BigNumber or fraction(x) to convert to Fraction.');
  }
}, {
  from: 'Fraction',
  to: 'Complex',
  convert: function (x) {
    return new type.Complex(x.<span class="apidocCodeKeywordSpan">valueOf</span>(), 0);
  }
}, {
  from: 'number',
  to: 'Fraction',
  convert: function (x) {
    if (digits(x) &gt; 15) {
      throw new TypeError('Cannot implicitly convert a number with &gt;15 significant digits to Fraction ' +
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.type.Range" id="apidoc.module.mathjs.type.Range">module mathjs.type.Range</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.type.Range.Range" id="apidoc.element.mathjs.type.Range.Range">
        function <span class="apidocSignatureSpan">mathjs.type.</span>Range
        <span class="apidocSignatureSpan">(start, end, step)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Range(start, end, step) {
  if (!(this instanceof Range)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  if (start != null) {
    if (start.isBigNumber === true)
      start = start.toNumber();
    else if (typeof start !== 'number')
      throw new TypeError('Parameter start must be a number');
  }
  if (end != null) {
    if (end.isBigNumber === true)
      end = end.toNumber();
    else if (typeof end !== 'number')
      throw new TypeError('Parameter end must be a number');
  }
  if (step != null) {
    if (step.isBigNumber === true)
      step = step.toNumber();
    else if (typeof step !== 'number')
      throw new TypeError('Parameter step must be a number');
  }

  this.start = (start != null) ? parseFloat(start) : 0;
  this.end   = (end != null)   ? parseFloat(end)   : 0;
  this.step  = (step != null)  ? parseFloat(step)  : 1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Range.fromJSON" id="apidoc.element.mathjs.type.Range.fromJSON">
        function <span class="apidocSignatureSpan">mathjs.type.Range.</span>fromJSON
        <span class="apidocSignatureSpan">(json)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromJSON = function (json) {
  return new Range(json.start, json.end, json.step);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * @param {string} key
   * @param {*} value
   * @returns {*} Returns the revived object
   */
  return function reviver(key, value) {
    var constructor = type[value &amp;&amp; value.mathjs];
    if (constructor &amp;&amp; typeof constructor.fromJSON === 'function') {
      return constructor.<span class="apidocCodeKeywordSpan">fromJSON</span>(value);
    }

    return value;
  }
}

exports.name = 'reviver';
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Range.parse" id="apidoc.element.mathjs.type.Range.parse">
        function <span class="apidocSignatureSpan">mathjs.type.Range.</span>parse
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function (str) {
  if (typeof str !== 'string') {
    return null;
  }

  var args = str.split(':');
  var nums = args.map(function (arg) {
    return parseFloat(arg);
  });

  var invalid = nums.some(function (num) {
    return isNaN(num);
  });
  if (invalid) {
    return null;
  }

  switch (nums.length) {
    case 2:
      return new Range(nums[0], nums[1]);
    case 3:
      return new Range(nums[0], nums[2], nums[1]);
    default:
      return null;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        if (!expr) {
          break;
        }
        switch (mode) {
          case 'eval':
            // evaluate expression
            try {
var node = math.<span class="apidocCodeKeywordSpan">parse</span>(expr);
var res = node.eval(scope);

if (res &amp;&amp; res.isResultSet) {
  // we can have 0 or 1 results in the ResultSet, as the CLI
  // does not allow multiple expressions separated by a return
  res = res.entries[0];
  node = node.blocks
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.type.Range.prototype" id="apidoc.module.mathjs.type.Range.prototype">module mathjs.type.Range.prototype</a></h1>




    <h2>
        <a href="#apidoc.element.mathjs.type.Range.prototype.clone" id="apidoc.element.mathjs.type.Range.prototype.clone">
        function <span class="apidocSignatureSpan">mathjs.type.Range.prototype.</span>clone
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clone = function () {
  return new Range(this.start, this.end, this.step);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return desc;
};

/**
 * Export the help object to JSON
 */
Help.prototype.toJSON = function () {
  var obj = object.<span class="apidocCodeKeywordSpan">clone</span>(this.doc);
  obj.mathjs = 'Help';
  return obj;
};

/**
 * Instantiate a Help object from a JSON object
 * @param {Object} json
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Range.prototype.forEach" id="apidoc.element.mathjs.type.Range.prototype.forEach">
        function <span class="apidocSignatureSpan">mathjs.type.Range.prototype.</span>forEach
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEach = function (callback) {
  var x = this.start;
  var step = this.step;
  var end = this.end;
  var i = 0;

  if (step &gt; 0) {
    while (x &lt; end) {
      callback(x, [i], this);
      x += step;
      i++;
    }
  }
  else if (step &lt; 0) {
    while (x &gt; end) {
      callback(x, [i], this);
      x += step;
      i++;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (def.indexOf(keyword) == 0) {
      matches.push(def);
    }
  }
}

// commandline keywords
['exit', 'quit', 'clear'].<span class="apidocCodeKeywordSpan">forEach</span>(function (cmd) {
  if (cmd.indexOf(keyword) == 0) {
    matches.push(cmd);
  }
});

// math functions and constants
var ignore = ['expr', 'type'];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Range.prototype.format" id="apidoc.element.mathjs.type.Range.prototype.format">
        function <span class="apidocSignatureSpan">mathjs.type.Range.prototype.</span>format
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">format = function (options) {
  var str = number.format(this.start, options);

  if (this.step != 1) {
    str += ':' + number.format(this.step, options);
  }
  str += ':' + number.format(this.end, options);
  return str;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Helper function to format a value. Regular numbers will be rounded
 * to 14 digits to prevent round-off errors from showing up.
 * @param {*} value
 */
function format(value) {
var math = getMath();

return math.<span class="apidocCodeKeywordSpan">format</span>(value, {
  fn: function (value) {
    if (typeof value === 'number') {
      // round numbers
      return math.format(value, PRECISION);
    }
    else {
      return math.format(value);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Range.prototype.map" id="apidoc.element.mathjs.type.Range.prototype.map">
        function <span class="apidocSignatureSpan">mathjs.type.Range.prototype.</span>map
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">map = function (callback) {
  var array = [];
  this.forEach(function (value, index, obj) {
    array[index[0]] = callback(value, index, obj);
  });
  return array;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (res &amp;&amp; res.isResultSet) {
  // we can have 0 or 1 results in the ResultSet, as the CLI
  // does not allow multiple expressions separated by a return
  res = res.entries[0];
  node = node.blocks
      .filter(function (entry) { return entry.visible; })
      .<span class="apidocCodeKeywordSpan">map</span>(function (entry) { return entry.node })[0];
}

if (node) {
  if (node.isAssignmentNode) {
    var name = findSymbolName(node);
    if (name != null) {
      scope.ans = scope[name];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Range.prototype.max" id="apidoc.element.mathjs.type.Range.prototype.max">
        function <span class="apidocSignatureSpan">mathjs.type.Range.prototype.</span>max
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">max = function () {
  var size = this.size()[0];

  if (size &gt; 0) {
    if (this.step &gt; 0) {
      // positive step
      return this.start + (size - 1) * this.step;
    }
    else {
      // negative step
      return this.start;
    }
  }
  else {
    return undefined;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @return {number} Returns the maximum number of expected arguments.
 *                  Returns -1 when no signatures where found on the function.
 */
exports.maxArgumentCount = function (fn) {
  return Object.keys(fn.signatures || {})
      .reduce(function (args, signature) {
        var count = (signature.match(/,/g) || []).length + 1;
        return Math.<span class="apidocCodeKeywordSpan">max</span>(args, count);
      }, -1);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Range.prototype.min" id="apidoc.element.mathjs.type.Range.prototype.min">
        function <span class="apidocSignatureSpan">mathjs.type.Range.prototype.</span>min
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">min = function () {
  var size = this.size()[0];

  if (size &gt; 0) {
    if (this.step &gt; 0) {
      // positive step
      return this.start;
    }
    else {
      // negative step
      return this.start + (size - 1) * this.step;
    }
  }
  else {
    return undefined;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @private
 */
function _resize (array, size, dim, defaultValue) {
var i;
var elem;
var oldLen = array.length;
var newLen = size[dim];
var minLen = Math.<span class="apidocCodeKeywordSpan">min</span>(oldLen, newLen);

// apply new length
array.length = newLen;

if (dim &lt; size.length - 1) {
  // non-last dimension
  var dimNext = dim + 1;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Range.prototype.size" id="apidoc.element.mathjs.type.Range.prototype.size">
        function <span class="apidocSignatureSpan">mathjs.type.Range.prototype.</span>size
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">size = function () {
  var len = 0,
      start = this.start,
      step = this.step,
      end = this.end,
      diff = end - start;

  if (number.sign(step) == number.sign(diff)) {
    len = Math.ceil((diff) / step);
  }
  else if (diff == 0) {
    len = 0;
  }

  if (isNaN(len)) {
    len = 0;
  }
  return [len];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

if (!Array.isArray(array) || !Array.isArray(sizes)) {
  throw new TypeError('Array expected');
}

if (sizes.length === 0) {
  throw new DimensionError(0, product(exports.<span class="apidocCodeKeywordSpan">size</span>(array)), '!=');
}

try {
  newArray  = _reshape(flatArray, sizes);
} catch (e) {
  if (e instanceof DimensionError) {
    throw new DimensionError(
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Range.prototype.toArray" id="apidoc.element.mathjs.type.Range.prototype.toArray">
        function <span class="apidocSignatureSpan">mathjs.type.Range.prototype.</span>toArray
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toArray = function () {
  var array = [];
  this.forEach(function (value, index) {
    array[index[0]] = value;
  });
  return array;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  '... number | BigNumber': _hypot,

  'Array': function (x) {
    return hypot.apply(hypot, flatten(x));
  },

  'Matrix': function (x) {
    return hypot.apply(hypot, flatten(x.<span class="apidocCodeKeywordSpan">toArray</span>()));
  }
});

/**
 * Calculate the hypotenusa for an Array with values
 * @param {Array.&lt;number | BigNumber&gt;} args
 * @return {number | BigNumber} Returns the result
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Range.prototype.toJSON" id="apidoc.element.mathjs.type.Range.prototype.toJSON">
        function <span class="apidocSignatureSpan">mathjs.type.Range.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function () {
  return {
    mathjs: 'Range',
    start: this.start,
    end: this.end,
    step: this.step
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Range.prototype.toString" id="apidoc.element.mathjs.type.Range.prototype.toString">
        function <span class="apidocSignatureSpan">mathjs.type.Range.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
  return this.format();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      }
      else {
        scope.ans = res;
        console.log(format(res));
      }
    }
    else if (res instanceof math.type.Help) {
      console.log(res.<span class="apidocCodeKeywordSpan">toString</span>());
    }
    else {
      scope.ans = res;
      console.log(format(res));
    }
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Range.prototype.valueOf" id="apidoc.element.mathjs.type.Range.prototype.valueOf">
        function <span class="apidocSignatureSpan">mathjs.type.Range.prototype.</span>valueOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">valueOf = function () {
  // TODO: implement a caching mechanism for range.valueOf()
  return this.toArray();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    throw new TypeError('Cannot implicitly convert a Fraction to BigNumber or vice versa. ' +
        'Use function bignumber(x) to convert to BigNumber or fraction(x) to convert to Fraction.');
  }
}, {
  from: 'Fraction',
  to: 'Complex',
  convert: function (x) {
    return new type.Complex(x.<span class="apidocCodeKeywordSpan">valueOf</span>(), 0);
  }
}, {
  from: 'number',
  to: 'Fraction',
  convert: function (x) {
    if (digits(x) &gt; 15) {
      throw new TypeError('Cannot implicitly convert a number with &gt;15 significant digits to Fraction ' +
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.type.ResultSet" id="apidoc.module.mathjs.type.ResultSet">module mathjs.type.ResultSet</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.type.ResultSet.ResultSet" id="apidoc.element.mathjs.type.ResultSet.ResultSet">
        function <span class="apidocSignatureSpan">mathjs.type.</span>ResultSet
        <span class="apidocSignatureSpan">(entries)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ResultSet(entries) {
  if (!(this instanceof ResultSet)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  this.entries = entries || [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.ResultSet.fromJSON" id="apidoc.element.mathjs.type.ResultSet.fromJSON">
        function <span class="apidocSignatureSpan">mathjs.type.ResultSet.</span>fromJSON
        <span class="apidocSignatureSpan">(json)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromJSON = function (json) {
  return new ResultSet(json.entries);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * @param {string} key
   * @param {*} value
   * @returns {*} Returns the revived object
   */
  return function reviver(key, value) {
    var constructor = type[value &amp;&amp; value.mathjs];
    if (constructor &amp;&amp; typeof constructor.fromJSON === 'function') {
      return constructor.<span class="apidocCodeKeywordSpan">fromJSON</span>(value);
    }

    return value;
  }
}

exports.name = 'reviver';
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.type.ResultSet.prototype" id="apidoc.module.mathjs.type.ResultSet.prototype">module mathjs.type.ResultSet.prototype</a></h1>




    <h2>
        <a href="#apidoc.element.mathjs.type.ResultSet.prototype.toJSON" id="apidoc.element.mathjs.type.ResultSet.prototype.toJSON">
        function <span class="apidocSignatureSpan">mathjs.type.ResultSet.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function () {
  return {
    mathjs: 'ResultSet',
    entries: this.entries
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.ResultSet.prototype.toString" id="apidoc.element.mathjs.type.ResultSet.prototype.toString">
        function <span class="apidocSignatureSpan">mathjs.type.ResultSet.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
  return '[' + this.entries.join(', ') + ']';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      }
      else {
        scope.ans = res;
        console.log(format(res));
      }
    }
    else if (res instanceof math.type.Help) {
      console.log(res.<span class="apidocCodeKeywordSpan">toString</span>());
    }
    else {
      scope.ans = res;
      console.log(format(res));
    }
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.ResultSet.prototype.valueOf" id="apidoc.element.mathjs.type.ResultSet.prototype.valueOf">
        function <span class="apidocSignatureSpan">mathjs.type.ResultSet.prototype.</span>valueOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">valueOf = function () {
  return this.entries;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    throw new TypeError('Cannot implicitly convert a Fraction to BigNumber or vice versa. ' +
        'Use function bignumber(x) to convert to BigNumber or fraction(x) to convert to Fraction.');
  }
}, {
  from: 'Fraction',
  to: 'Complex',
  convert: function (x) {
    return new type.Complex(x.<span class="apidocCodeKeywordSpan">valueOf</span>(), 0);
  }
}, {
  from: 'number',
  to: 'Fraction',
  convert: function (x) {
    if (digits(x) &gt; 15) {
      throw new TypeError('Cannot implicitly convert a number with &gt;15 significant digits to Fraction ' +
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.type.Spa" id="apidoc.module.mathjs.type.Spa">module mathjs.type.Spa</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.type.Spa.Spa" id="apidoc.element.mathjs.type.Spa.Spa">
        function <span class="apidocSignatureSpan">mathjs.type.</span>Spa
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Spa() {
  if (!(this instanceof Spa))
    throw new SyntaxError('Constructor must be called with the new operator');

  // allocate vector, TODO use typed arrays
  this._values = [];
  this._heap = new type.FibonacciHeap();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.type.Spa.prototype" id="apidoc.module.mathjs.type.Spa.prototype">module mathjs.type.Spa.prototype</a></h1>




    <h2>
        <a href="#apidoc.element.mathjs.type.Spa.prototype.accumulate" id="apidoc.element.mathjs.type.Spa.prototype.accumulate">
        function <span class="apidocSignatureSpan">mathjs.type.Spa.prototype.</span>accumulate
        <span class="apidocSignatureSpan">(i, v)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">accumulate = function (i, v) {
  // node @ i
  var node = this._values[i];
  if (!node) {
    // insert in heap
    node = this._heap.insert(i, v);
    // initialize value
    this._values[i] = node;
  }
  else {
    // accumulate value
    node.value = add(node.value, v);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Spa.prototype.forEach" id="apidoc.element.mathjs.type.Spa.prototype.forEach">
        function <span class="apidocSignatureSpan">mathjs.type.Spa.prototype.</span>forEach
        <span class="apidocSignatureSpan">(from, to, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEach = function (from, to, callback) {
  // references
  var heap = this._heap;
  var values = this._values;
  // nodes
  var nodes = [];
  // node with minimum key, save it
  var node = heap.extractMinimum();
  if (node)
    nodes.push(node);
  // extract nodes from heap (ordered)
  while (node &amp;&amp; node.key &lt;= to) {
    // check it is in range
    if (node.key &gt;= from) {
      // check value is not zero
      if (!equalScalar(node.value, 0)) {
        // invoke callback
        callback(node.key, node.value, this);
      }
    }
    // extract next node, save it
    node = heap.extractMinimum();
    if (node)
      nodes.push(node);
  }
  // reinsert all nodes in heap
  for (var i = 0; i &lt; nodes.length; i++) {
    // current node
    var n = nodes[i];
    // insert node in heap
    node = heap.insert(n.key, n.value);
    // update values
    values[node.key] = node;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (def.indexOf(keyword) == 0) {
      matches.push(def);
    }
  }
}

// commandline keywords
['exit', 'quit', 'clear'].<span class="apidocCodeKeywordSpan">forEach</span>(function (cmd) {
  if (cmd.indexOf(keyword) == 0) {
    matches.push(cmd);
  }
});

// math functions and constants
var ignore = ['expr', 'type'];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Spa.prototype.get" id="apidoc.element.mathjs.type.Spa.prototype.get">
        function <span class="apidocSignatureSpan">mathjs.type.Spa.prototype.</span>get
        <span class="apidocSignatureSpan">(i)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get = function (i) {
  var node = this._values[i];
  if (node)
    return node.value;
  return 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Parser contains methods to evaluate or parse expressions, and has a number
* of convenience methods to get, set, and remove variables from memory. Parser
* keeps a scope containing variables in memory, which is used for all
* evaluations.
*
* Methods:
*    var result = parser.eval(expr);    // evaluate an expression
*    var value = parser.<span class="apidocCodeKeywordSpan">get</span>(name);      // retrieve a variable from the parser
*    var values = parser.getAll();      // retrieve all defined variables
*    parser.set(name, value);           // set a variable in the parser
*    parser.remove(name);               // clear a variable from the
*                                       // parsers scope
*    parser.clear();                    // clear the parsers scope
*
* Example usage:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Spa.prototype.set" id="apidoc.element.mathjs.type.Spa.prototype.set">
        function <span class="apidocSignatureSpan">mathjs.type.Spa.prototype.</span>set
        <span class="apidocSignatureSpan">(i, v)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">set = function (i, v) {
  // check we have a value @ i
  if (!this._values[i]) {
    // insert in heap
    var node = this._heap.insert(i, v);
    // set the value @ i
    this._values[i] = node;
  }
  else {
    // update the value @ i
    this._values[i].value = v;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* keeps a scope containing variables in memory, which is used for all
* evaluations.
*
* Methods:
*    var result = parser.eval(expr);    // evaluate an expression
*    var value = parser.get(name);      // retrieve a variable from the parser
*    var values = parser.getAll();      // retrieve all defined variables
*    parser.<span class="apidocCodeKeywordSpan">set</span>(name, value);           // set a variable in the parser
*    parser.remove(name);               // clear a variable from the
*                                       // parsers scope
*    parser.clear();                    // clear the parsers scope
*
* Example usage:
*    var parser = new Parser();
*    // Note: there is a convenience method which can be used instead:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Spa.prototype.swap" id="apidoc.element.mathjs.type.Spa.prototype.swap">
        function <span class="apidocSignatureSpan">mathjs.type.Spa.prototype.</span>swap
        <span class="apidocSignatureSpan">(i, j)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">swap = function (i, j) {
  // node @ i and j
  var nodei = this._values[i];
  var nodej = this._values[j];
  // check we need to insert indeces
  if (!nodei &amp;&amp; nodej) {
    // insert in heap
    nodei = this._heap.insert(i, nodej.value);
    // remove from heap
    this._heap.remove(nodej);
    // set values
    this._values[i] = nodei;
    this._values[j] = undefined;
  }
  else if (nodei &amp;&amp; !nodej) {
    // insert in heap
    nodej = this._heap.insert(j, nodei.value);
    // remove from heap
    this._heap.remove(nodei);
    // set values
    this._values[j] = nodej;
    this._values[i] = undefined;
  }
  else if (nodei &amp;&amp; nodej) {
    // swap values
    var v = nodei.value;
    nodei.value = nodej.value;
    nodej.value = v;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.type.SparseMatrix" id="apidoc.module.mathjs.type.SparseMatrix">module mathjs.type.SparseMatrix</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.type.SparseMatrix.SparseMatrix" id="apidoc.element.mathjs.type.SparseMatrix.SparseMatrix">
        function <span class="apidocSignatureSpan">mathjs.type.</span>SparseMatrix
        <span class="apidocSignatureSpan">(data, datatype)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SparseMatrix(data, datatype) {
  if (!(this instanceof SparseMatrix))
    throw new SyntaxError('Constructor must be called with the new operator');
  if (datatype &amp;&amp; !isString(datatype))
    throw new Error('Invalid datatype: ' + datatype);

  if (data &amp;&amp; data.isMatrix === true) {
    // create from matrix
    _createFromMatrix(this, data, datatype);
  }
  else if (data &amp;&amp; isArray(data.index) &amp;&amp; isArray(data.ptr) &amp;&amp; isArray(data.size)) {
    // initialize fields
    this._values = data.values;
    this._index = data.index;
    this._ptr = data.ptr;
    this._size = data.size;
    this._datatype = datatype || data.datatype;
  }
  else if (isArray(data)) {
    // create from array
    _createFromArray(this, data, datatype);
  }
  else if (data) {
    // unsupported type
    throw new TypeError('Unsupported type of data (' + util.types.type(data) + ')');
  }
  else {
    // nothing provided
    this._values = [];
    this._index = [];
    this._ptr = [0];
    this._size = [0, 0];
    this._datatype = datatype;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.SparseMatrix._forEachRow" id="apidoc.element.mathjs.type.SparseMatrix._forEachRow">
        function <span class="apidocSignatureSpan">mathjs.type.SparseMatrix.</span>_forEachRow
        <span class="apidocSignatureSpan">(j, values, index, ptr, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_forEachRow = function (j, values, index, ptr, callback) {
  // indeces for column j
  var k0 = ptr[j];
  var k1 = ptr[j + 1];
  // loop
  for (var k = k0; k &lt; k1; k++) {
    // invoke callback
    callback(index[k], values[k]);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.SparseMatrix._swapRows" id="apidoc.element.mathjs.type.SparseMatrix._swapRows">
        function <span class="apidocSignatureSpan">mathjs.type.SparseMatrix.</span>_swapRows
        <span class="apidocSignatureSpan">(x, y, columns, values, index, ptr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_swapRows = function (x, y, columns, values, index, ptr) {
  // loop columns
  for (var j = 0; j &lt; columns; j++) {
    // k0 &lt;= k &lt; k1 where k0 = _ptr[j] &amp;&amp; k1 = _ptr[j+1]
    var k0 = ptr[j];
    var k1 = ptr[j + 1];
    // find value index @ x
    var kx = _getValueIndex(x, k0, k1, index);
    // find value index @ x
    var ky = _getValueIndex(y, k0, k1, index);
    // check both rows exist in matrix
    if (kx &lt; k1 &amp;&amp; ky &lt; k1 &amp;&amp; index[kx] === x &amp;&amp; index[ky] === y) {
      // swap values (check for pattern matrix)
      if (values) {
        var v = values[kx];
        values[kx] = values[ky];
        values[ky] = v;
      }
      // next column
      continue;
    }
    // check x row exist &amp; no y row
    if (kx &lt; k1 &amp;&amp; index[kx] === x &amp;&amp; (ky &gt;= k1 || index[ky] !== y)) {
      // value @ x (check for pattern matrix)
      var vx = values ? values[kx] : undefined;
      // insert value @ y
      index.splice(ky, 0, y);
      if (values)
        values.splice(ky, 0, vx);
      // remove value @ x (adjust array index if needed)
      index.splice(ky &lt;= kx ? kx + 1 : kx, 1);
      if (values)
        values.splice(ky &lt;= kx ? kx + 1 : kx, 1);
      // next column
      continue;
    }
    // check y row exist &amp; no x row
    if (ky &lt; k1 &amp;&amp; index[ky] === y &amp;&amp; (kx &gt;= k1 || index[kx] !== x)) {
      // value @ y (check for pattern matrix)
      var vy = values ? values[ky] : undefined;
      // insert value @ x
      index.splice(kx, 0, x);
      if (values)
        values.splice(kx, 0, vy);
      // remove value @ y (adjust array index if needed)
      index.splice(kx &lt;= ky ? ky + 1 : ky, 1);
      if (values)
        values.splice(kx &lt;= ky ? ky + 1 : ky, 1);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    throw new Error('Only two dimensional matrix is supported');
  }
  // validate index
  validateIndex(i, this._size[0]);
  validateIndex(j, this._size[0]);

  // swap rows
  DenseMatrix.<span class="apidocCodeKeywordSpan">_swapRows</span>(i, j, this._data);
  // return current instance
  return this;
};

/**
 * Swap rows i and j in Dense Matrix data structure.
 *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.SparseMatrix.diagonal" id="apidoc.element.mathjs.type.SparseMatrix.diagonal">
        function <span class="apidocSignatureSpan">mathjs.type.SparseMatrix.</span>diagonal
        <span class="apidocSignatureSpan">(size, value, k, defaultValue, datatype)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">diagonal = function (size, value, k, defaultValue, datatype) {
  if (!isArray(size))
    throw new TypeError('Array expected, size parameter');
  if (size.length !== 2)
    throw new Error('Only two dimensions matrix are supported');

  // map size &amp; validate
  size = size.map(function (s) {
    // check it is a big number
    if (s &amp;&amp; s.isBigNumber === true) {
      // convert it
      s = s.toNumber();
    }
    // validate arguments
    if (!isNumber(s) || !isInteger(s) || s &lt; 1) {
      throw new Error('Size values must be positive integers');
    }
    return s;
  });

  // validate k if any
  if (k) {
    // convert BigNumber to a number
    if (k.isBigNumber === true)
      k = k.toNumber();
    // is must be an integer
    if (!isNumber(k) || !isInteger(k)) {
      throw new TypeError ('The parameter k must be an integer number');
    }
  }
  else {
    // default value
    k = 0;
  }

  // equal signature to use
  var eq = equalScalar;
  // zero value
  var zero = 0;

  if (isString(datatype)) {
    // find signature that matches (datatype, datatype)
    eq = typed.find(equalScalar, [datatype, datatype]) || equalScalar;
    // convert 0 to the same datatype
    zero = typed.convert(0, datatype);
  }

  var kSuper = k &gt; 0 ? k : 0;
  var kSub = k &lt; 0 ? -k : 0;

  // rows and columns
  var rows = size[0];
  var columns = size[1];

  // number of non-zero items
  var n = Math.min(rows - kSub, columns -  kSuper);

  // value extraction function
  var _value;

  // check value
  if (isArray(value)) {
    // validate array
    if (value.length !== n) {
      // number of values in array must be n
      throw new Error('Invalid value array length');
    }
    // define function
    _value = function (i) {
      // return value @ i
      return value[i];
    };
  }
  else if (value &amp;&amp; value.isMatrix === true) {
    // matrix size
    var ms = value.size();
    // validate matrix
    if (ms.length !== 1 || ms[0] !== n) {
      // number of values in array must be n
      throw new Error('Invalid matrix length');
    }
    // define function
    _value = function (i) {
      // return value @ i
      return value.get([i]);
    };
  }
  else {
    // define function
    _value = function () {
      // return value
      return value;
    };
  }

  // create arrays
  var values = [];
  var index = [];
  var ptr = [];

  // loop items
  for (var j = 0; j &lt; columns; j++) {
    // number of rows with value
    ptr.push(values.length);
    // diagonal index
    var i = j - kSuper;
    // check we need to set diagonal value
    if (i &gt;= 0 &amp;&amp; i &lt; n) {
      // get value @ i
      var v = _value(i);
      // check for zero
      if (!eq(v, zero)) {
        // column
        index.push(i + kSub);
        // add value
        values.push(v);
      }
    }
  }
  // last value should be number of values
  ptr.push(values.length);
  // create SparseMatrix
  return new SparseMatrix({
    values: values,
    index: index,
    ptr: ptr,
    size: [rows, columns]
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

function _createDiagonalMatrix(x, k, format, l, kSub, kSuper) {
  // matrix size
  var ms = [l + kSub, l + kSuper];
  // get matrix constructor
  var F = type.Matrix.storage(format || 'dense');
  // create diagonal matrix
  var m = F.<span class="apidocCodeKeywordSpan">diagonal</span>(ms, x, k);
  // check we need to return a matrix
  return format !== null ? m : m.valueOf();
}

function _getDiagonal(x, k, format, s, kSub, kSuper) {
  // check x is a Matrix
  if (x &amp;&amp; x.isMatrix === true) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.SparseMatrix.fromJSON" id="apidoc.element.mathjs.type.SparseMatrix.fromJSON">
        function <span class="apidocSignatureSpan">mathjs.type.SparseMatrix.</span>fromJSON
        <span class="apidocSignatureSpan">(json)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromJSON = function (json) {
  return new SparseMatrix(json);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * @param {string} key
   * @param {*} value
   * @returns {*} Returns the revived object
   */
  return function reviver(key, value) {
    var constructor = type[value &amp;&amp; value.mathjs];
    if (constructor &amp;&amp; typeof constructor.fromJSON === 'function') {
      return constructor.<span class="apidocCodeKeywordSpan">fromJSON</span>(value);
    }

    return value;
  }
}

exports.name = 'reviver';
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.type.SparseMatrix.prototype" id="apidoc.module.mathjs.type.SparseMatrix.prototype">module mathjs.type.SparseMatrix.prototype</a></h1>




    <h2>
        <a href="#apidoc.element.mathjs.type.SparseMatrix.prototype.clone" id="apidoc.element.mathjs.type.SparseMatrix.prototype.clone">
        function <span class="apidocSignatureSpan">mathjs.type.SparseMatrix.prototype.</span>clone
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clone = function () {
  var m = new SparseMatrix({
    values: this._values ? object.clone(this._values) : undefined,
    index: object.clone(this._index),
    ptr: object.clone(this._ptr),
    size: object.clone(this._size),
    datatype: this._datatype
  });
  return m;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return desc;
};

/**
 * Export the help object to JSON
 */
Help.prototype.toJSON = function () {
  var obj = object.<span class="apidocCodeKeywordSpan">clone</span>(this.doc);
  obj.mathjs = 'Help';
  return obj;
};

/**
 * Instantiate a Help object from a JSON object
 * @param {Object} json
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.SparseMatrix.prototype.create" id="apidoc.element.mathjs.type.SparseMatrix.prototype.create">
        function <span class="apidocSignatureSpan">mathjs.type.SparseMatrix.prototype.</span>create
        <span class="apidocSignatureSpan">(data, datatype)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function (data, datatype) {
  return new SparseMatrix(data, datatype);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *                              false (default), output type can vary depending
 *                              on input values. For example `math.sqrt(-4)`
 *                              returns `complex('2i')` when predictable is false, and
 *                              returns `NaN` when true.
 */
function create (config) {
  // create a new math.js instance
  var math = core.<span class="apidocCodeKeywordSpan">create</span>(config);
  math.create = create;

  // import data types, functions, constants, expression parser, etc.
  math['import'](require('./lib'));

  return math;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.SparseMatrix.prototype.datatype" id="apidoc.element.mathjs.type.SparseMatrix.prototype.datatype">
        function <span class="apidocSignatureSpan">mathjs.type.SparseMatrix.prototype.</span>datatype
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">datatype = function () {
  return this._datatype;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return 'dense';
};

/**
 * Get the datatype of the data stored in the matrix.
 *
 * Usage:
 *     var format = matrix.<span class="apidocCodeKeywordSpan">datatype</span>()                   // retrieve matrix datatype
 *
 * @memberof DenseMatrix
 * @return {string}           The datatype.
 */
DenseMatrix.prototype.datatype = function () {
  return this._datatype;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.SparseMatrix.prototype.density" id="apidoc.element.mathjs.type.SparseMatrix.prototype.density">
        function <span class="apidocSignatureSpan">mathjs.type.SparseMatrix.prototype.</span>density
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">density = function () {
  // rows &amp; columns
  var rows = this._size[0];
  var columns = this._size[1];
  // calculate density
  return rows !== 0 &amp;&amp; columns !== 0 ? (this._index.length / (rows * columns)) : 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// process matrix storage
switch (x.storage()) {
  case 'sparse':
    switch (y.storage()) {
      case 'sparse':
        // density must be one (no zeros in matrix)
        if (y.<span class="apidocCodeKeywordSpan">density</span>() === 1) {
          // sparse + sparse
          c = algorithm06(x, y, nthRoot);
        }
        else {
          // throw exception
          throw new Error('Root must be non-zero');
        }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.SparseMatrix.prototype.diagonal" id="apidoc.element.mathjs.type.SparseMatrix.prototype.diagonal">
        function <span class="apidocSignatureSpan">mathjs.type.SparseMatrix.prototype.</span>diagonal
        <span class="apidocSignatureSpan">(k)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">diagonal = function (k) {
  // validate k if any
  if (k) {
    // convert BigNumber to a number
    if (k.isBigNumber === true)
      k = k.toNumber();
    // is must be an integer
    if (!isNumber(k) || !isInteger(k)) {
      throw new TypeError ('The parameter k must be an integer number');
    }
  }
  else {
    // default value
    k = 0;
  }

  var kSuper = k &gt; 0 ? k : 0;
  var kSub = k &lt; 0 ? -k : 0;

  // rows &amp; columns
  var rows = this._size[0];
  var columns = this._size[1];

  // number diagonal values
  var n = Math.min(rows - kSub, columns -  kSuper);

  // diagonal arrays
  var values = [];
  var index = [];
  var ptr = [];
  // initial ptr value
  ptr[0] = 0;
  // loop columns
  for (var j = kSuper; j &lt; columns &amp;&amp; values.length &lt; n; j++) {
    // k0 &lt;= k &lt; k1 where k0 = _ptr[j] &amp;&amp; k1 = _ptr[j+1]
    var k0 = this._ptr[j];
    var k1 = this._ptr[j + 1];
    // loop x within [k0, k1[
    for (var x = k0; x &lt; k1; x++) {
      // row index
      var i = this._index[x];
      // check row
      if (i === j - kSuper + kSub) {
        // value on this column
        values.push(this._values[x]);
        // store row
        index[values.length - 1] = i - kSub;
        // exit loop
        break;
      }
    }
  }
  // close ptr
  ptr.push(values.length);
  // return matrix
  return new SparseMatrix({
    values: values,
    index: index,
    ptr: ptr,
    size: [n, 1]
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

function _createDiagonalMatrix(x, k, format, l, kSub, kSuper) {
  // matrix size
  var ms = [l + kSub, l + kSuper];
  // get matrix constructor
  var F = type.Matrix.storage(format || 'dense');
  // create diagonal matrix
  var m = F.<span class="apidocCodeKeywordSpan">diagonal</span>(ms, x, k);
  // check we need to return a matrix
  return format !== null ? m : m.valueOf();
}

function _getDiagonal(x, k, format, s, kSub, kSuper) {
  // check x is a Matrix
  if (x &amp;&amp; x.isMatrix === true) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.SparseMatrix.prototype.forEach" id="apidoc.element.mathjs.type.SparseMatrix.prototype.forEach">
        function <span class="apidocSignatureSpan">mathjs.type.SparseMatrix.prototype.</span>forEach
        <span class="apidocSignatureSpan">(callback, skipZeros)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEach = function (callback, skipZeros) {
  // check it is a pattern matrix
  if (!this._values)
    throw new Error('Cannot invoke forEach on a Pattern only matrix');
  // matrix instance
  var me = this;
  // rows and columns
  var rows = this._size[0];
  var columns = this._size[1];
  // loop columns
  for (var j = 0; j &lt; columns; j++) {
    // k0 &lt;= k &lt; k1 where k0 = _ptr[j] &amp;&amp; k1 = _ptr[j+1]
    var k0 = this._ptr[j];
    var k1 = this._ptr[j + 1];
    // column pointer
    var p = 0;
    // loop k within [k0, k1[
    for (var k = k0; k &lt; k1; k++) {
      // row index
      var i = this._index[k];
      // check we need to process zeros
      if (!skipZeros) {
        // zero values
        for (var x = p; x &lt; i; x++)
          callback(0, [x, j], me);
      }
      // value @ k
      callback(this._values[k], [i, j], me);
      // update pointer
      p = i + 1;
    }
    // check we need to process zeros
    if (!skipZeros) {
      // zero values
      for (var y = p; y &lt; rows; y++)
        callback(0, [y, j], me);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (def.indexOf(keyword) == 0) {
      matches.push(def);
    }
  }
}

// commandline keywords
['exit', 'quit', 'clear'].<span class="apidocCodeKeywordSpan">forEach</span>(function (cmd) {
  if (cmd.indexOf(keyword) == 0) {
    matches.push(cmd);
  }
});

// math functions and constants
var ignore = ['expr', 'type'];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.SparseMatrix.prototype.format" id="apidoc.element.mathjs.type.SparseMatrix.prototype.format">
        function <span class="apidocSignatureSpan">mathjs.type.SparseMatrix.prototype.</span>format
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">format = function (options) {
  // rows and columns
  var rows = this._size[0];
  var columns = this._size[1];
  // density
  var density = this.density();
  // rows &amp; columns
  var str = 'Sparse Matrix [' + string.format(rows, options) + ' x ' + string.format(columns, options) + '] density: ' + string.
format(density, options) + '\n';
  // loop columns
  for (var j = 0; j &lt; columns; j++) {
    // k0 &lt;= k &lt; k1 where k0 = _ptr[j] &amp;&amp; k1 = _ptr[j+1]
    var k0 = this._ptr[j];
    var k1 = this._ptr[j + 1];
    // loop k within [k0, k1[
    for (var k = k0; k &lt; k1; k++) {
      // row index
      var i = this._index[k];
      // append value
      str += '\n    (' + string.format(i, options) + ', ' + string.format(j, options) + ') ==&gt; ' + (this._values ? string.format
(this._values[k], options) : 'X');
    }
  }
  return str;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Helper function to format a value. Regular numbers will be rounded
 * to 14 digits to prevent round-off errors from showing up.
 * @param {*} value
 */
function format(value) {
var math = getMath();

return math.<span class="apidocCodeKeywordSpan">format</span>(value, {
  fn: function (value) {
    if (typeof value === 'number') {
      // round numbers
      return math.format(value, PRECISION);
    }
    else {
      return math.format(value);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.SparseMatrix.prototype.get" id="apidoc.element.mathjs.type.SparseMatrix.prototype.get">
        function <span class="apidocSignatureSpan">mathjs.type.SparseMatrix.prototype.</span>get
        <span class="apidocSignatureSpan">(index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get = function (index) {
  if (!isArray(index))
    throw new TypeError('Array expected');
  if (index.length != this._size.length)
    throw new DimensionError(index.length, this._size.length);

  // check it is a pattern matrix
  if (!this._values)
    throw new Error('Cannot invoke get on a Pattern only matrix');

  // row and column
  var i = index[0];
  var j = index[1];

  // check i, j are valid
  validateIndex(i, this._size[0]);
  validateIndex(j, this._size[1]);

  // find value index
  var k = _getValueIndex(i, this._ptr[j], this._ptr[j + 1], this._index);
  // check k is prior to next column k and it is in the correct row
  if (k &lt; this._ptr[j + 1] &amp;&amp; this._index[k] === i)
    return this._values[k];

  return 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Parser contains methods to evaluate or parse expressions, and has a number
* of convenience methods to get, set, and remove variables from memory. Parser
* keeps a scope containing variables in memory, which is used for all
* evaluations.
*
* Methods:
*    var result = parser.eval(expr);    // evaluate an expression
*    var value = parser.<span class="apidocCodeKeywordSpan">get</span>(name);      // retrieve a variable from the parser
*    var values = parser.getAll();      // retrieve all defined variables
*    parser.set(name, value);           // set a variable in the parser
*    parser.remove(name);               // clear a variable from the
*                                       // parsers scope
*    parser.clear();                    // clear the parsers scope
*
* Example usage:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.SparseMatrix.prototype.map" id="apidoc.element.mathjs.type.SparseMatrix.prototype.map">
        function <span class="apidocSignatureSpan">mathjs.type.SparseMatrix.prototype.</span>map
        <span class="apidocSignatureSpan">(callback, skipZeros)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">map = function (callback, skipZeros) {
  // check it is a pattern matrix
  if (!this._values)
    throw new Error('Cannot invoke map on a Pattern only matrix');
  // matrix instance
  var me = this;
  // rows and columns
  var rows = this._size[0];
  var columns = this._size[1];
  // invoke callback
  var invoke = function (v, i, j) {
    // invoke callback
    return callback(v, [i, j], me);
  };
  // invoke _map
  return _map(this, 0, rows - 1, 0, columns - 1, invoke, skipZeros);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (res &amp;&amp; res.isResultSet) {
  // we can have 0 or 1 results in the ResultSet, as the CLI
  // does not allow multiple expressions separated by a return
  res = res.entries[0];
  node = node.blocks
      .filter(function (entry) { return entry.visible; })
      .<span class="apidocCodeKeywordSpan">map</span>(function (entry) { return entry.node })[0];
}

if (node) {
  if (node.isAssignmentNode) {
    var name = findSymbolName(node);
    if (name != null) {
      scope.ans = scope[name];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.SparseMatrix.prototype.reshape" id="apidoc.element.mathjs.type.SparseMatrix.prototype.reshape">
        function <span class="apidocSignatureSpan">mathjs.type.SparseMatrix.prototype.</span>reshape
        <span class="apidocSignatureSpan">(size, copy)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reshape = function (size, copy) {

  // validate arguments
  if (!isArray(size))
    throw new TypeError('Array expected');
  if (size.length !== 2)
    throw new Error('Sparse matrices can only be reshaped in two dimensions');

  // check sizes
  size.forEach(function (value) {
    if (!number.isNumber(value) || !number.isInteger(value) || value &lt; 0) {
      throw new TypeError('Invalid size, must contain positive integers ' +
                          '(size: ' + string.format(size) + ')');
    }
  });

  // m * n must not change
  if(this._size[0] * this._size[1] !== size[0] * size[1]) {
    throw new Error('Reshaping sparse matrix will result in the wrong number of elements');
  }

  // matrix to reshape
  var m = copy ? this.clone() : this;

  // return unchanged if the same shape
  if(this._size[0] === size[0] &amp;&amp; this._size[1] === size[1]) {
    return m;
  }

  // Convert to COO format (generate a column index)
  var colIndex = [];
  for(var i=0; i&lt;m._ptr.length; i++) {
    for(var j=0; j&lt;m._ptr[i+1]-m._ptr[i]; j++) {
      colIndex.push(i);
    }
  }

  // Clone the values array
  var values = m._values.slice();

  // Clone the row index array
  var rowIndex = m._index.slice();

  // Transform the (row, column) indices
  for(var i=0; i&lt;m._index.length; i++) {
    var r1 = rowIndex[i];
    var c1 = colIndex[i];
    var flat = r1 * m._size[1] + c1;
    colIndex[i] = flat % size[1];
    rowIndex[i] = Math.floor(flat / size[1]);
  }

  // Now reshaping is supposed to preserve the row-major order, BUT these sparse matrices are stored
  // in column-major order, so we have to reorder the value array now. One option is to use a multisort,
  // sorting several arrays based on some other array.

  // OR, we could easily just:

  // 1. Remove all values from the matrix
  m._values.length = 0;
  m._index.length = 0;
  m._ptr.length = size[1] + 1;
  m._size = size.slice();
  for(var i=0; i&lt;m._ptr.length; i++) {
    m._ptr[i] = 0;
  }

  // 2. Re-insert all elements in the proper order (simplified code from SparseMatrix.prototype.set)
  // This step is probably the most time-consuming
  for(var h=0; h&lt;values.length; h++) {
    var i = rowIndex[h];
    var j = colIndex[h];
    var v = values[h];
    var k = _getValueIndex(i, m._ptr[j], m._ptr[j + 1], m._index);
    _insert(k, i, j, v, m._values, m._index, m._ptr);
  }

  // The value indices are inserted out of order, but apparently that's... still OK?

  return m;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var matrix = load(require('../../type/matrix/function/matrix'));

/**
 * Reshape a multi dimensional array to fit the specified dimensions
 *
 * Syntax:
 *
 *     math.<span class="apidocCodeKeywordSpan">reshape</span>(x, sizes)
 *
 * Examples:
 *
 *     math.reshape([1, 2, 3, 4, 5, 6], [2, 3]);
 *     // returns Array  [[1, 2, 3], [4, 5, 6]]
 *
 *     math.reshape([[1, 2], [3, 4]], [1, 4]);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.SparseMatrix.prototype.resize" id="apidoc.element.mathjs.type.SparseMatrix.prototype.resize">
        function <span class="apidocSignatureSpan">mathjs.type.SparseMatrix.prototype.</span>resize
        <span class="apidocSignatureSpan">(size, defaultValue, copy)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resize = function (size, defaultValue, copy) {
  // validate arguments
  if (!isArray(size))
    throw new TypeError('Array expected');
  if (size.length !== 2)
    throw new Error('Only two dimensions matrix are supported');

  // check sizes
  size.forEach(function (value) {
    if (!number.isNumber(value) || !number.isInteger(value) || value &lt; 0) {
      throw new TypeError('Invalid size, must contain positive integers ' +
                          '(size: ' + string.format(size) + ')');
    }
  });

  // matrix to resize
  var m = copy ? this.clone() : this;
  // resize matrix
  return _resize(m, size[0], size[1], defaultValue);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // get matrix storage constructor
  var F = type.Matrix.storage(format);
  // create diagonal matrix (use optimized implementation for storage format)
  return F.diagonal(size, one, 0, defaultValue);
}

// create and resize array
var res = array.<span class="apidocCodeKeywordSpan">resize</span>([], size, defaultValue);
// fill in ones on the diagonal
var minimum = rows &lt; cols ? rows : cols;
// fill diagonal
for (var d = 0; d &lt; minimum; d++) {
  res[d][d] = one;
}
return res;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.SparseMatrix.prototype.set" id="apidoc.element.mathjs.type.SparseMatrix.prototype.set">
        function <span class="apidocSignatureSpan">mathjs.type.SparseMatrix.prototype.</span>set
        <span class="apidocSignatureSpan">(index, v, defaultValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">set = function (index, v, defaultValue) {
  if (!isArray(index))
    throw new TypeError('Array expected');
  if (index.length != this._size.length)
    throw new DimensionError(index.length, this._size.length);

  // check it is a pattern matrix
  if (!this._values)
    throw new Error('Cannot invoke set on a Pattern only matrix');

  // row and column
  var i = index[0];
  var j = index[1];

  // rows &amp; columns
  var rows = this._size[0];
  var columns = this._size[1];

  // equal signature to use
  var eq = equalScalar;
  // zero value
  var zero = 0;

  if (isString(this._datatype)) {
    // find signature that matches (datatype, datatype)
    eq = typed.find(equalScalar, [this._datatype, this._datatype]) || equalScalar;
    // convert 0 to the same datatype
    zero = typed.convert(0, this._datatype);
  }

  // check we need to resize matrix
  if (i &gt; rows - 1 || j &gt; columns - 1) {
    // resize matrix
    _resize(this, Math.max(i + 1, rows), Math.max(j + 1, columns), defaultValue);
    // update rows &amp; columns
    rows = this._size[0];
    columns = this._size[1];
  }

  // check i, j are valid
  validateIndex(i, rows);
  validateIndex(j, columns);

  // find value index
  var k = _getValueIndex(i, this._ptr[j], this._ptr[j + 1], this._index);
  // check k is prior to next column k and it is in the correct row
  if (k &lt; this._ptr[j + 1] &amp;&amp; this._index[k] === i) {
    // check value != 0
    if (!eq(v, zero)) {
      // update value
      this._values[k] = v;
    }
    else {
      // remove value from matrix
      _remove(k, j, this._values, this._index, this._ptr);
    }
  }
  else {
    // insert value @ (i, j)
    _insert(k, i, j, v, this._values, this._index, this._ptr);
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* keeps a scope containing variables in memory, which is used for all
* evaluations.
*
* Methods:
*    var result = parser.eval(expr);    // evaluate an expression
*    var value = parser.get(name);      // retrieve a variable from the parser
*    var values = parser.getAll();      // retrieve all defined variables
*    parser.<span class="apidocCodeKeywordSpan">set</span>(name, value);           // set a variable in the parser
*    parser.remove(name);               // clear a variable from the
*                                       // parsers scope
*    parser.clear();                    // clear the parsers scope
*
* Example usage:
*    var parser = new Parser();
*    // Note: there is a convenience method which can be used instead:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.SparseMatrix.prototype.size" id="apidoc.element.mathjs.type.SparseMatrix.prototype.size">
        function <span class="apidocSignatureSpan">mathjs.type.SparseMatrix.prototype.</span>size
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">size = function () {
  return this._size.slice(0); // copy the Array
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

if (!Array.isArray(array) || !Array.isArray(sizes)) {
  throw new TypeError('Array expected');
}

if (sizes.length === 0) {
  throw new DimensionError(0, product(exports.<span class="apidocCodeKeywordSpan">size</span>(array)), '!=');
}

try {
  newArray  = _reshape(flatArray, sizes);
} catch (e) {
  if (e instanceof DimensionError) {
    throw new DimensionError(
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.SparseMatrix.prototype.storage" id="apidoc.element.mathjs.type.SparseMatrix.prototype.storage">
        function <span class="apidocSignatureSpan">mathjs.type.SparseMatrix.prototype.</span>storage
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">storage = function () {
  return 'sparse';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// we extend the signatures of addScalar with signatures dealing with matrices

'Matrix, Matrix': function (x, y) {
  // result
  var c;

  // process matrix storage
  switch (x.<span class="apidocCodeKeywordSpan">storage</span>()) {
    case 'sparse':
      switch (y.storage()) {
        case 'sparse':
          // sparse + sparse
          c = algorithm04(x, y, addScalar);
          break;
        default:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.SparseMatrix.prototype.subset" id="apidoc.element.mathjs.type.SparseMatrix.prototype.subset">
        function <span class="apidocSignatureSpan">mathjs.type.SparseMatrix.prototype.</span>subset
        <span class="apidocSignatureSpan">(index, replacement, defaultValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">subset = function (index, replacement, defaultValue) { // check it is a pattern matrix
  if (!this._values)
    throw new Error('Cannot invoke subset on a Pattern only matrix');

  // check arguments
  switch (arguments.length) {
    case 1:
      return _getsubset(this, index);

      // intentional fall through
    case 2:
    case 3:
      return _setsubset(this, index, replacement, defaultValue);

    default:
      throw new SyntaxError('Wrong number of arguments');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function factory (type, config, load, typed) {
var matrix = load(require('../../type/matrix/function/matrix'));

/**
 * Get or set a subset of a matrix or string.
 *
 * Syntax:
 *     math.<span class="apidocCodeKeywordSpan">subset</span>(value, index)                                // retrieve a subset
 *     math.subset(value, index, replacement [, defaultValue])  // replace a subset
 *
 * Examples:
 *
 *     // get a subset
 *     var d = [[1, 2], [3, 4]];
 *     math.subset(d, math.index(1, 0));        // returns 3
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.SparseMatrix.prototype.swapRows" id="apidoc.element.mathjs.type.SparseMatrix.prototype.swapRows">
        function <span class="apidocSignatureSpan">mathjs.type.SparseMatrix.prototype.</span>swapRows
        <span class="apidocSignatureSpan">(i, j)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">swapRows = function (i, j) {
  // check index
  if (!isNumber(i) || !isInteger(i) || !isNumber(j) || !isInteger(j)) {
    throw new Error('Row index must be positive integers');
  }
  // check dimensions
  if (this._size.length !== 2) {
    throw new Error('Only two dimensional matrix is supported');
  }
  // validate index
  validateIndex(i, this._size[0]);
  validateIndex(j, this._size[0]);

  // swap rows
  SparseMatrix._swapRows(i, j, this._size[1], this._values, this._index, this._ptr);
  // return current instance
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.SparseMatrix.prototype.toArray" id="apidoc.element.mathjs.type.SparseMatrix.prototype.toArray">
        function <span class="apidocSignatureSpan">mathjs.type.SparseMatrix.prototype.</span>toArray
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toArray = function () {
  return _toArray(this._values, this._index, this._ptr, this._size, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  '... number | BigNumber': _hypot,

  'Array': function (x) {
    return hypot.apply(hypot, flatten(x));
  },

  'Matrix': function (x) {
    return hypot.apply(hypot, flatten(x.<span class="apidocCodeKeywordSpan">toArray</span>()));
  }
});

/**
 * Calculate the hypotenusa for an Array with values
 * @param {Array.&lt;number | BigNumber&gt;} args
 * @return {number | BigNumber} Returns the result
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.SparseMatrix.prototype.toJSON" id="apidoc.element.mathjs.type.SparseMatrix.prototype.toJSON">
        function <span class="apidocSignatureSpan">mathjs.type.SparseMatrix.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function () {
  return {
    mathjs: 'SparseMatrix',
    values: this._values,
    index: this._index,
    ptr: this._ptr,
    size: this._size,
    datatype: this._datatype
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.SparseMatrix.prototype.toString" id="apidoc.element.mathjs.type.SparseMatrix.prototype.toString">
        function <span class="apidocSignatureSpan">mathjs.type.SparseMatrix.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
  return string.format(this.toArray());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      }
      else {
        scope.ans = res;
        console.log(format(res));
      }
    }
    else if (res instanceof math.type.Help) {
      console.log(res.<span class="apidocCodeKeywordSpan">toString</span>());
    }
    else {
      scope.ans = res;
      console.log(format(res));
    }
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.SparseMatrix.prototype.valueOf" id="apidoc.element.mathjs.type.SparseMatrix.prototype.valueOf">
        function <span class="apidocSignatureSpan">mathjs.type.SparseMatrix.prototype.</span>valueOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">valueOf = function () {
  return _toArray(this._values, this._index, this._ptr, this._size, false);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    throw new TypeError('Cannot implicitly convert a Fraction to BigNumber or vice versa. ' +
        'Use function bignumber(x) to convert to BigNumber or fraction(x) to convert to Fraction.');
  }
}, {
  from: 'Fraction',
  to: 'Complex',
  convert: function (x) {
    return new type.Complex(x.<span class="apidocCodeKeywordSpan">valueOf</span>(), 0);
  }
}, {
  from: 'number',
  to: 'Fraction',
  convert: function (x) {
    if (digits(x) &gt; 15) {
      throw new TypeError('Cannot implicitly convert a number with &gt;15 significant digits to Fraction ' +
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.type.Unit" id="apidoc.module.mathjs.type.Unit">module mathjs.type.Unit</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.type.Unit.Unit" id="apidoc.element.mathjs.type.Unit.Unit">
        function <span class="apidocSignatureSpan">mathjs.type.</span>Unit
        <span class="apidocSignatureSpan">(value, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Unit(value, name) {
  if (!(this instanceof Unit)) {
    throw new Error('Constructor must be called with the new operator');
  }

  if (!(value === undefined || isNumeric(value) || value.isComplex)) {
    throw new TypeError('First parameter in Unit constructor must be number, BigNumber, Fraction, Complex, or undefined');
  }
  if (name != undefined &amp;&amp; (typeof name !== 'string' || name == '')) {
    throw new TypeError('Second parameter in Unit constructor must be a string');
  }

  if (name != undefined) {
    var u = Unit.parse(name);
    this.units = u.units;
    this.dimensions = u.dimensions;
  }
  else {
    this.units = [
      {
        unit: UNIT_NONE,
        prefix: PREFIXES.NONE,  // link to a list with supported prefixes
        power: 0
      }
    ];
    this.dimensions = [];
    for(var i=0; i&lt;BASE_DIMENSIONS.length; i++) {
      this.dimensions[i] = 0;
    }
  }

  this.value = (value != undefined) ? this._normalize(value) : null;

  this.fixPrefix = false; // if true, function format will not search for the
                          // best prefix but leave it as initially provided.
                          // fixPrefix is set true by the method Unit.to

  // The justification behind this is that if the constructor is explicitly called,
  // the caller wishes the units to be returned exactly as he supplied.
  this.isUnitListSimplified = true;

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Unit._getNumberConverter" id="apidoc.element.mathjs.type.Unit._getNumberConverter">
        function <span class="apidocSignatureSpan">mathjs.type.Unit.</span>_getNumberConverter
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getNumberConverter = function (type) {
  if (!Unit.typeConverters[type]) {
    throw new TypeError('Unsupported type "' + type + '"');
  }

  return Unit.typeConverters[type];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (value == null || this.units.length === 0) {
return value;
    }
    else if (this._isDerived()) {
// This is a derived unit, so do not apply offsets.
// For example, with J kg^-1 degC^-1 you would NOT want to apply the offset.
var res = value;
convert = Unit.<span class="apidocCodeKeywordSpan">_getNumberConverter</span>(getTypeOf(value)); // convert to Fraction or BigNumber
 if needed

for(var i=0; i &lt; this.units.length; i++) {
  unitValue       = convert(this.units[i].unit.value);
  unitPrefixValue = convert(this.units[i].prefix.value);
  unitPower       = convert(this.units[i].power);
  res = multiply(res, pow(multiply(unitValue, unitPrefixValue), unitPower));
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Unit.createUnit" id="apidoc.element.mathjs.type.Unit.createUnit">
        function <span class="apidocSignatureSpan">mathjs.type.Unit.</span>createUnit
        <span class="apidocSignatureSpan">(obj, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createUnit = function (obj, options) {

  if(typeof(obj) !== 'object') {
    throw new TypeError("createUnit expects first parameter to be of type 'Object'");
  }

  // Remove all units and aliases we are overriding
  if(options &amp;&amp; options.override) {
    for(var key in obj) {
      if(obj.hasOwnProperty(key)) {
        Unit.deleteUnit(key);
      }
      if(obj[key].aliases) {
        for(var i=0; i&lt;obj[key].aliases.length; i++) {
          Unit.deleteUnit(obj[key].aliases[i]);
        }
      }
    }
  }

  // TODO: traverse multiple times until all units have been added
  var lastUnit;
  for(var key in obj) {
    if(obj.hasOwnProperty(key)) {
      lastUnit = Unit.createUnitSingle(key, obj[key]);
    }
  }
  return lastUnit;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Unit.createUnitSingle" id="apidoc.element.mathjs.type.Unit.createUnitSingle">
        function <span class="apidocSignatureSpan">mathjs.type.Unit.</span>createUnitSingle
        <span class="apidocSignatureSpan">(name, obj, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createUnitSingle = function (name, obj, options) {

  if(typeof(obj) === 'undefined' || obj === null) {
    obj = {};
  }

  if(typeof(name) !== 'string') {
    throw new TypeError("createUnitSingle expects first parameter to be of type 'string'");
  }

  // Check collisions with existing units
  if(UNITS.hasOwnProperty(name)) {
    throw new Error('Cannot create unit "' + name + '": a unit with that name already exists');
  }

  // TODO: Validate name for collisions with other built-in functions (like abs or cos, for example), and for acceptable variable
 names. For example, '42' is probably not a valid unit. Nor is '%', since it is also an operator.

  assertUnitNameIsValid(name);

  var defUnit = null;   // The Unit from which the new unit will be created.
  var aliases = [];
  var offset = 0;
  var definition;
  var prefixes;
  if(obj &amp;&amp; obj.type === 'Unit') {
    defUnit = obj.clone();
  }
  else if(typeof(obj) === 'string') {
    if(obj !== '') {
      definition = obj;
    }
  }
  else if(typeof(obj) === 'object') {
    definition = obj.definition;
    prefixes = obj.prefixes;
    offset = obj.offset;
    aliases = obj.aliases;
  }
  else {
    throw new TypeError('Cannot create unit "' + name + '" from "' + obj.toString() + '": expecting "string" or "Unit" or "Object
"');
  }

  if(aliases) {
    for (var i=0; i&lt;aliases.length; i++) {
      if(UNITS.hasOwnProperty(aliases[i])) {
        throw new Error('Cannot create alias "' + aliases[i] + '": a unit with that name already exists');
      }
    }
  }

  if(definition &amp;&amp; typeof(definition) === 'string' &amp;&amp; !defUnit) {
    try {
      defUnit = Unit.parse(definition, {allowNoUnits: true});
    }
    catch (ex) {
      ex.message = 'Could not create unit "' + name + '" from "' + definition + '": ' + ex.message;
      throw(ex);
    }
  }
  else if(definition &amp;&amp; definition.type === 'Unit') {
    defUnit = definition.clone();
  }

  aliases = aliases || [];
  offset = offset || 0;
  if(prefixes &amp;&amp; prefixes.toUpperCase)
    prefixes = PREFIXES[prefixes.toUpperCase()] || PREFIXES.NONE;
  else
    prefixes = PREFIXES.NONE;


  // If defUnit is null, it is because the user did not
  // specify a defintion. So create a new base dimension.
  var newUnit = {};
  if(!defUnit) {
    // Add a new base dimension
    var baseName = name + "_STUFF";   // foo --&gt; foo_STUFF, or the essence of foo
    if(BASE_DIMENSIONS.indexOf(baseName) &gt;= 0) {
      throw new Error('Cannot create new base unit "' + name + '": a base unit with that name already exists (and cannot be overridden
)');
    }
    BASE_DIMENSIONS.push(baseName);

    // Push 0 onto existing base units
    for(var b in BASE_UNITS) {
      if(BASE_UNITS.hasOwnProperty(b)) {
        BASE_UNITS[b].dimensions[BASE_DIMENSIONS.length-1] = 0;
      }
    }

    // Add the new base unit
    var newBaseUnit = { dimensions: [] };
    for(var i=0; i&lt;BASE_DIMENSIONS.length; i++) {
      newBaseUnit.dimensions[i] = 0;
    }
    newBaseUnit.dimensions[BASE_DIMENSIONS.length-1] = 1;
    newBaseUnit.key = baseName;
    BASE_UNITS[baseName] = newBaseUnit;

    newUnit = {
      name: name,
      value: 1,
      dimensions: BASE_UNITS[baseName].dimensions.slice(0),
      prefixes: prefixes,
      offset: offset,
      base: baseName
    };

    currentUnitSystem[baseName] = {
      unit: newUnit,
      prefix: PREFIXES.NONE['']
    };

  }
  else {

    newUnit = {
      name: name,
      value: defUnit.value,
      dimensions: defUnit.dimensions.slice(0),
      prefixes: prefixes,
      offset: offset,
    };

    // Create a new base if no matching base exists
    var anyMatch = false;
    for(var i in BASE_UNITS) {
      if(BASE_UNITS.hasOwnProperty(i)) {
        var match = true;
        for(var j=0; j&lt;BASE_DIMENSIONS.length; j++) {
          if (Math.abs((newUnit.dimensions[j] || 0) - (BASE_UNITS[i].dimensions[j] || 0)) &gt; 1e-12) {
            match = false;
            break;
          }
        }
        if(match) {
          anyMatch = true;
          break;
        }
      }
    }
    if(!anyMatch) {
      var baseName = name + "_STUFF"; ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
  }

  // TODO: traverse multiple times until all units have been added
  var lastUnit;
  for(var key in obj) {
    if(obj.hasOwnProperty(key)) {
      lastUnit = Unit.<span class="apidocCodeKeywordSpan">createUnitSingle</span>(key, obj[key]);
    }
  }
  return lastUnit;
};

/**
 * Create a user-defined unit and register it with the Unit type.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Unit.deleteUnit" id="apidoc.element.mathjs.type.Unit.deleteUnit">
        function <span class="apidocSignatureSpan">mathjs.type.Unit.</span>deleteUnit
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deleteUnit = function (name) {
  delete Unit.UNITS[name];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  throw new TypeError("createUnit expects first parameter to be of type 'Object'");
}

// Remove all units and aliases we are overriding
if(options &amp;&amp; options.override) {
  for(var key in obj) {
    if(obj.hasOwnProperty(key)) {
      Unit.<span class="apidocCodeKeywordSpan">deleteUnit</span>(key);
    }
    if(obj[key].aliases) {
      for(var i=0; i&lt;obj[key].aliases.length; i++) {
        Unit.deleteUnit(obj[key].aliases[i]);
      }
    }
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Unit.fromJSON" id="apidoc.element.mathjs.type.Unit.fromJSON">
        function <span class="apidocSignatureSpan">mathjs.type.Unit.</span>fromJSON
        <span class="apidocSignatureSpan">(json)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromJSON = function (json) {
  var unit = new Unit(json.value, json.unit);
  unit.fixPrefix = json.fixPrefix || false;
  return unit;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * @param {string} key
   * @param {*} value
   * @returns {*} Returns the revived object
   */
  return function reviver(key, value) {
    var constructor = type[value &amp;&amp; value.mathjs];
    if (constructor &amp;&amp; typeof constructor.fromJSON === 'function') {
      return constructor.<span class="apidocCodeKeywordSpan">fromJSON</span>(value);
    }

    return value;
  }
}

exports.name = 'reviver';
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Unit.getUnitSystem" id="apidoc.element.mathjs.type.Unit.getUnitSystem">
        function <span class="apidocSignatureSpan">mathjs.type.Unit.</span>getUnitSystem
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getUnitSystem = function () {
  for(var key in UNIT_SYSTEMS) {
    if(UNIT_SYSTEMS[key] === currentUnitSystem) {
      return key;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Unit.isValuelessUnit" id="apidoc.element.mathjs.type.Unit.isValuelessUnit">
        function <span class="apidocSignatureSpan">mathjs.type.Unit.</span>isValuelessUnit
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isValuelessUnit = function (name) {
  return (_findUnit(name) != null);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      matches.push(prefix);
    }
    else if (keyword.indexOf(prefix) == 0) {
      var unitKeyword = keyword.substring(prefix.length);
      for (var n in Unit.UNITS) {
        if (Unit.UNITS.hasOwnProperty(n)) {
          if (n.indexOf(unitKeyword) == 0 &amp;&amp;
              Unit.<span class="apidocCodeKeywordSpan">isValuelessUnit</span>(prefix + n)) {
            matches.push(prefix + n);
          }
        }
      }
    }
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Unit.parse" id="apidoc.element.mathjs.type.Unit.parse">
        function <span class="apidocSignatureSpan">mathjs.type.Unit.</span>parse
        <span class="apidocSignatureSpan">(str, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function (str, options) {
  options = options || {};
  text = str;
  index = -1;
  c = '';

  if (typeof text !== 'string') {
    throw new TypeError('Invalid argument in Unit.parse, string expected');
  }

  var unit = new Unit();
  unit.units = [];

  // A unit should follow this pattern:
  // [number]unit[^number] [unit[^number]]...[/unit[^number] [unit[^number]]]

  // Rules:
  // number is any floating point number.
  // unit is any alphanumeric string beginning with an alpha. Units with names like e3 should be avoided because they look like
the exponent of a floating point number!
  // The string may optionally begin with a number.
  // Each unit may optionally be followed by ^number.
  // Whitespace or a forward slash is recommended between consecutive units, although the following technically is parseable:
  //   2m^2kg/s^2
  // it is not good form. If a unit starts with e, then it could be confused as a floating point number:
  //   4erg

  next();
  skipWhitespace();
  // Optional number at the start of the string
  var valueStr = parseNumber();
  var value = null;
  if(valueStr) {
    if (config.number === 'BigNumber') {
      value = new type.BigNumber(valueStr);
    }
    else if (config.number === 'Fraction') {
      value = new type.Fraction(valueStr);
    }
    else { // number
      value = parseFloat(valueStr);
    }
  }
  skipWhitespace();    // Whitespace is not required here

  // Next, we read any number of unit[^number]
  var powerMultiplierCurrent = 1;
  var expectingUnit = false;

  // Stack to keep track of powerMultipliers applied to each parentheses group
  var powerMultiplierStack = [];

  // Running product of all elements in powerMultiplierStack
  var powerMultiplierStackProduct = 1;

  while (true) {
    skipWhitespace();

    // Check for and consume opening parentheses, pushing powerMultiplierCurrent to the stack
    // A '(' will always appear directly before a unit.
    while (c === '(') {
      powerMultiplierStack.push(powerMultiplierCurrent);
      powerMultiplierStackProduct *= powerMultiplierCurrent;
      powerMultiplierCurrent = 1;
      next();
      skipWhitespace();
    }

    // Is there something here?
    if(c) {
      var oldC = c;
      var uStr = parseUnit();
      if(uStr == null) {
        throw new SyntaxError('Unexpected "' + oldC + '" in "' + text + '" at index ' + index.toString());
      }
    }
    else {
      // End of input.
      break;
    }

    // Verify the unit exists and get the prefix (if any)
    var res = _findUnit(uStr);
    if(res == null) {
      // Unit not found.
      throw new SyntaxError('Unit "' + uStr + '" not found.');
    }

    var power = powerMultiplierCurrent * powerMultiplierStackProduct;
    // Is there a "^ number"?
    skipWhitespace();
    if (parseCharacter('^')) {
      skipWhitespace();
      var p = parseNumber();
      if(p == null) {
        // No valid number found for the power!
        throw new SyntaxError('In "' + str + '", "^" must be followed by a floating-point number');
      }
      power *= p;
    }

    // Add the unit to the list
    unit.units.push( {
      unit: res.unit,
      prefix: res.prefix,
      power: power
    });
    for(var i=0; i&lt;BASE_DIMENSIONS.length; i++) {
      unit.dimensions[i] += (res.unit.dimensions[i] || 0) * power;
    }

    // Check for and consume closing parentheses, popping from the stack.
    // A ')' will always follow a unit.
    skipWhitespace();
    while (c === ')') {
      if(powerMultiplierStack.length === 0) {
        throw new SyntaxError('Unmatched ")" in "' + text + '" at index ' + index.toString());
      }
      powerMultiplierStackProduct /= powerMultiplierStack.pop();
      next();
      skipWhitespace();
    }

    // "*" and "/" should mean we are expecting something to come next.
    // Is there a forward slash? If so, negate powerMultiplierCurrent. The next unit or paren group is in the denominator.
    expectingUnit = false;

    if (parseCharacter('*')) {
      // explicit multiplication
      powerMultiplierCurrent = 1;
      expectingUnit = true;
    } ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        if (!expr) {
          break;
        }
        switch (mode) {
          case 'eval':
            // evaluate expression
            try {
var node = math.<span class="apidocCodeKeywordSpan">parse</span>(expr);
var res = node.eval(scope);

if (res &amp;&amp; res.isResultSet) {
  // we can have 0 or 1 results in the ResultSet, as the CLI
  // does not allow multiple expressions separated by a return
  res = res.entries[0];
  node = node.blocks
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Unit.setUnitSystem" id="apidoc.element.mathjs.type.Unit.setUnitSystem">
        function <span class="apidocSignatureSpan">mathjs.type.Unit.</span>setUnitSystem
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setUnitSystem = function (name) {
  if(UNIT_SYSTEMS.hasOwnProperty(name)) {
    currentUnitSystem = UNIT_SYSTEMS[name];
  }
  else {
    throw new Error('Unit system ' + name + ' does not exist. Choices are: ' + Object.keys(UNIT_SYSTEMS).join(', '));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>












</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.type.Unit.prototype" id="apidoc.module.mathjs.type.Unit.prototype">module mathjs.type.Unit.prototype</a></h1>




    <h2>
        <a href="#apidoc.element.mathjs.type.Unit.prototype._bestPrefix" id="apidoc.element.mathjs.type.Unit.prototype._bestPrefix">
        function <span class="apidocSignatureSpan">mathjs.type.Unit.prototype.</span>_bestPrefix
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_bestPrefix = function () {
  if (this.units.length !== 1) {
    throw new Error("Can only compute the best prefix for single units with integer powers, like kg, s^2, N^-1, and so forth!");
  }
  if (Math.abs(this.units[0].power - Math.round(this.units[0].power)) &gt;= 1e-14) {
    throw new Error("Can only compute the best prefix for single units with integer powers, like kg, s^2, N^-1, and so forth!");
  }

  // find the best prefix value (resulting in the value of which
  // the absolute value of the log10 is closest to zero,
  // though with a little offset of 1.2 for nicer values: you get a
  // sequence 1mm 100mm 500mm 0.6m 1m 10m 100m 500m 0.6km 1km ...

  // Note: the units value can be any numeric type, but to find the best
  // prefix it's enough to work with limited precision of a regular number
  // Update: using mathjs abs since we also allow complex numbers
  var absValue = abs(this.value);
  var absUnitValue = abs(this.units[0].unit.value);
  var bestPrefix = this.units[0].prefix;
  if (absValue === 0) {
    return bestPrefix;
  }
  var power = this.units[0].power;
  var bestDiff = Math.log(absValue / Math.pow(bestPrefix.value * absUnitValue, power)) / Math.LN10 - 1.2;
  if(bestDiff &gt; -2.200001 &amp;&amp; bestDiff &lt; 1.800001) return bestPrefix;    // Allow the original prefix
  bestDiff = Math.abs(bestDiff);
  var prefixes = this.units[0].unit.prefixes;
  for (var p in prefixes) {
    if (prefixes.hasOwnProperty(p)) {
      var prefix = prefixes[p];
      if (prefix.scientific) {

        var diff = Math.abs(
            Math.log(absValue / Math.pow(prefix.value * absUnitValue, power)) / Math.LN10 - 1.2);

        if (diff &lt; bestDiff
            || (diff === bestDiff &amp;&amp; prefix.name.length &lt; bestPrefix.name.length)) {
              // choose the prefix with the smallest diff, or if equal, choose the one
              // with the shortest name (can happen with SHORTLONG for example)
              bestPrefix = prefix;
              bestDiff = diff;
        }
      }
    }
  }

  return bestPrefix;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Now apply the best prefix
// Units must have only one unit and not have the fixPrefix flag set
if (this.units.length === 1 &amp;&amp; !this.fixPrefix) {
  // Units must have integer powers, otherwise the prefix will change the
  // outputted value by not-an-integer-power-of-ten
  if (Math.abs(this.units[0].power - Math.round(this.units[0].power)) &lt; 1e-14) {
    // Apply the best prefix
    this.units[0].prefix = this.<span class="apidocCodeKeywordSpan">_bestPrefix</span>();
  }
}


var value = this._denormalize(this.value);
var str = (this.value !== null) ? format(value, options || {}) : '';
var unitStr = this.formatUnits();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Unit.prototype._denormalize" id="apidoc.element.mathjs.type.Unit.prototype._denormalize">
        function <span class="apidocSignatureSpan">mathjs.type.Unit.prototype.</span>_denormalize
        <span class="apidocSignatureSpan">(value, prefixValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_denormalize = function (value, prefixValue) {
  var unitValue, unitOffset, unitPower, unitPrefixValue;
  var convert;

  if (value == null || this.units.length === 0) {
    return value;
  }
  else if (this._isDerived()) {
    // This is a derived unit, so do not apply offsets.
    // For example, with J kg^-1 degC^-1 you would NOT want to apply the offset.
    // Also, prefixValue is ignored--but we will still use the prefix value stored in each unit, since kg is usually preferable
to g unless the user decides otherwise.
    var res = value;
    convert = Unit._getNumberConverter(getTypeOf(value)); // convert to Fraction or BigNumber if needed

    for (var i = 0; i &lt; this.units.length; i++) {
      unitValue       = convert(this.units[i].unit.value);
      unitPrefixValue = convert(this.units[i].prefix.value);
      unitPower       = convert(this.units[i].power);
      res = divide(res, pow(multiply(unitValue, unitPrefixValue), unitPower));
    }

    return res;
  }
  else {
    // This is a single unit of power 1, like kg or degC
    convert = Unit._getNumberConverter(getTypeOf(value)); // convert to Fraction or BigNumber if needed

    unitValue       = convert(this.units[0].unit.value);
    unitPrefixValue = convert(this.units[0].prefix.value);
    unitOffset      = convert(this.units[0].unit.offset);

    if (prefixValue == undefined) {
      return subtract(divide(divide(value, unitValue), unitPrefixValue), unitOffset);
    }
    else {
      return subtract(divide(divide(value, unitValue), prefixValue), unitOffset);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var other = this;
  if(valuelessUnit) {
    // Allow getting the numeric value without converting to a different unit
    other = this.to(valuelessUnit);
  }

  if(other._isDerived()) {
    return other.<span class="apidocCodeKeywordSpan">_denormalize</span>(other.value);
  }
  else {
    return other._denormalize(other.value, other.units[0].prefix.value);
  }
};

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Unit.prototype._isDerived" id="apidoc.element.mathjs.type.Unit.prototype._isDerived">
        function <span class="apidocSignatureSpan">mathjs.type.Unit.prototype.</span>_isDerived
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_isDerived = function () {
  if(this.units.length === 0) {
    return false;
  }
  return this.units.length &gt; 1 || Math.abs(this.units[0].power - 1.0) &gt; 1e-15;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  Unit.prototype._normalize = function (value) {
    var unitValue, unitOffset, unitPower, unitPrefixValue;
    var convert;

    if (value == null || this.units.length === 0) {
return value;
    }
    else if (this.<span class="apidocCodeKeywordSpan">_isDerived</span>()) {
// This is a derived unit, so do not apply offsets.
// For example, with J kg^-1 degC^-1 you would NOT want to apply the offset.
var res = value;
convert = Unit._getNumberConverter(getTypeOf(value)); // convert to Fraction or BigNumber if needed

for(var i=0; i &lt; this.units.length; i++) {
  unitValue       = convert(this.units[i].unit.value);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Unit.prototype._normalize" id="apidoc.element.mathjs.type.Unit.prototype._normalize">
        function <span class="apidocSignatureSpan">mathjs.type.Unit.prototype.</span>_normalize
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_normalize = function (value) {
  var unitValue, unitOffset, unitPower, unitPrefixValue;
  var convert;

  if (value == null || this.units.length === 0) {
    return value;
  }
  else if (this._isDerived()) {
    // This is a derived unit, so do not apply offsets.
    // For example, with J kg^-1 degC^-1 you would NOT want to apply the offset.
    var res = value;
    convert = Unit._getNumberConverter(getTypeOf(value)); // convert to Fraction or BigNumber if needed

    for(var i=0; i &lt; this.units.length; i++) {
      unitValue       = convert(this.units[i].unit.value);
      unitPrefixValue = convert(this.units[i].prefix.value);
      unitPower       = convert(this.units[i].power);
      res = multiply(res, pow(multiply(unitValue, unitPrefixValue), unitPower));
    }

    return res;
  }
  else {
    // This is a single unit of power 1, like kg or degC
    convert = Unit._getNumberConverter(getTypeOf(value)); // convert to Fraction or BigNumber if needed

    unitValue       = convert(this.units[0].unit.value);
    unitOffset      = convert(this.units[0].unit.offset);
    unitPrefixValue = convert(this.units[0].prefix.value);

    return multiply(add(value, unitOffset), multiply(unitValue, unitPrefixValue));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
'Fraction, Fraction': function (x, y) {
  return x.div(y);
},

'Unit, number | Fraction | BigNumber': function (x, y) {
  var res = x.clone();
  // TODO: move the divide function to Unit.js, it uses internals of Unit
  res.value = divideScalar(((res.value === null) ? res.<span class="apidocCodeKeywordSpan">_normalize</span>(1) : res.value), y);
  return res;
},

'number | Fraction | BigNumber, Unit': function (x, y) {
  var res = y.pow(-1);
  // TODO: move the divide function to Unit.js, it uses internals of Unit
  res.value = multiplyScalar(((res.value === null) ? res._normalize(1) : res.value), x);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Unit.prototype.abs" id="apidoc.element.mathjs.type.Unit.prototype.abs">
        function <span class="apidocSignatureSpan">mathjs.type.Unit.prototype.</span>abs
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">abs = function () {
  // This gives correct, but unexpected, results for units with an offset.
  // For example, abs(-283.15 degC) = -263.15 degC !!!
  var ret = this.clone();
  ret.value = abs(ret.value);

  for(var i in ret.units) {
    if(ret.units[i].unit.name === 'VA' || ret.units[i].unit.name === 'VAR') {
      ret.units[i].unit = UNITS["W"];
    }
  }

  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function factory (type, config, load, typed) {
/**
 * Calculate the absolute value of a number. For matrices, the function is
 * evaluated element wise.
 *
 * Syntax:
 *
 *    math.<span class="apidocCodeKeywordSpan">abs</span>(x)
 *
 * Examples:
 *
 *    math.abs(3.5);                // returns number 3.5
 *    math.abs(-4.2);               // returns number 4.2
 *
 *    math.abs([3, -5, -1, 0, 2]);  // returns Array [3, 5, 1, 0, 2]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Unit.prototype.clone" id="apidoc.element.mathjs.type.Unit.prototype.clone">
        function <span class="apidocSignatureSpan">mathjs.type.Unit.prototype.</span>clone
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clone = function () {
  var unit = new Unit();

  unit.fixPrefix = this.fixPrefix;
  unit.isUnitListSimplified = this.isUnitListSimplified;

  unit.value = clone(this.value);
  unit.dimensions = this.dimensions.slice(0);
  unit.units = [];
  for(var i = 0; i &lt; this.units.length; i++) {
    unit.units[i] = { };
    for (var p in this.units[i]) {
      if (this.units[i].hasOwnProperty(p)) {
        unit.units[i][p] = this.units[i][p];
      }
    }
  }

  return unit;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return desc;
};

/**
 * Export the help object to JSON
 */
Help.prototype.toJSON = function () {
  var obj = object.<span class="apidocCodeKeywordSpan">clone</span>(this.doc);
  obj.mathjs = 'Help';
  return obj;
};

/**
 * Instantiate a Help object from a JSON object
 * @param {Object} json
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Unit.prototype.divide" id="apidoc.element.mathjs.type.Unit.prototype.divide">
        function <span class="apidocSignatureSpan">mathjs.type.Unit.prototype.</span>divide
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">divide = function (other) {
  var res = this.clone();

  for(var i=0; i&lt;BASE_DIMENSIONS.length; i++) {
    // Dimensions arrays may be of different lengths. Default to 0.
    res.dimensions[i] = (this.dimensions[i] || 0) - (other.dimensions[i] || 0);
  }

  // Invert and append other's units list onto res (simplify later in Unit.prototype.format)
  for(var i=0; i&lt;other.units.length; i++) {
    // Make a deep copy
    var inverted = {};
    for(var key in other.units[i]) {
      inverted[key] = other.units[i][key];
    }
    inverted.power = -inverted.power;
    res.units.push(inverted);
  }

  // If at least one operand has a value, the result should have a value
  if (this.value != null || other.value != null) {
    var valThis = this.value == null ? this._normalize(1) : this.value;
    var valOther = other.value == null ? other._normalize(1) : other.value;
    res.value = divide(valThis, valOther);
  }
  else {
    res.value = null;
  }

  // Trigger simplification of the unit list at some future time
  res.isUnitListSimplified = false;

  return getNumericIfUnitless(res);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  /**
* Divide two values, `x / y`.
* To divide matrices, `x` is multiplied with the inverse of `y`: `x * inv(y)`.
*
* Syntax:
*
*    math.<span class="apidocCodeKeywordSpan">divide</span>(x, y)
*
* Examples:
*
*    math.divide(2, 3);            // returns number 0.6666666666666666
*
*    var a = math.complex(5, 14);
*    var b = math.complex(4, 1);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Unit.prototype.equalBase" id="apidoc.element.mathjs.type.Unit.prototype.equalBase">
        function <span class="apidocSignatureSpan">mathjs.type.Unit.prototype.</span>equalBase
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">equalBase = function (other) {
  // All dimensions must be the same
  for(var i=0; i&lt;BASE_DIMENSIONS.length; i++) {
    if (Math.abs((this.dimensions[i] || 0) - (other.dimensions[i] || 0)) &gt; 1e-12) {
      return false;
    }
  }
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  'Fraction, Fraction': function (x, y) {
    return x.add(y);
  },

  'Unit, Unit': function (x, y) {
    if (x.value == null) throw new Error('Parameter x contains a unit with undefined value');
    if (y.value == null) throw new Error('Parameter y contains a unit with undefined value');
    if (!x.<span class="apidocCodeKeywordSpan">equalBase</span>(y)) throw new Error('Units do not match');

    var res = x.clone();
    res.value = add(res.value, y.value);
    res.fixPrefix = false;
    return res;
  }
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Unit.prototype.equals" id="apidoc.element.mathjs.type.Unit.prototype.equals">
        function <span class="apidocSignatureSpan">mathjs.type.Unit.prototype.</span>equals
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">equals = function (other) {
  return (this.equalBase(other) &amp;&amp; equal(this.value, other.value));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (inv) {
  root = root.neg();
}

if (root.isZero()) {
  throw new Error('Root must be non-zero');
}
if (a.isNegative() &amp;&amp; !root.abs().mod(2).<span class="apidocCodeKeywordSpan">equals</span>(1)) {
  throw new Error('Root must be odd when a is negative.');
}

// edge cases zero and infinity
if (a.isZero()) {
  return inv ? new Big(Infinity) : 0;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Unit.prototype.format" id="apidoc.element.mathjs.type.Unit.prototype.format">
        function <span class="apidocSignatureSpan">mathjs.type.Unit.prototype.</span>format
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">format = function (options) {

  // Simplfy the unit list, if necessary
  this.simplifyUnitListLazy();

  // Apply some custom logic for handling VA and VAR. The goal is to express the value of the unit as a real value, if possible.
Otherwise, use a real-valued unit instead of a complex-valued one.
  var isImaginary = false;
  var isReal = true;
  if(typeof(this.value) !== 'undefined' &amp;&amp; this.value !== null &amp;&amp; this.value.isComplex) {
    // TODO: Make this better, for example, use relative magnitude of re and im rather than absolute
    isImaginary = Math.abs(this.value.re) &lt; 1e-14;
    isReal = Math.abs(this.value.im) &lt; 1e-14;
  }

  for(var i in this.units) {
    if(this.units[i].unit) {
      if(this.units[i].unit.name === 'VA' &amp;&amp; isImaginary) {
        this.units[i].unit = UNITS["VAR"];
      }
      else if(this.units[i].unit.name === 'VAR' &amp;&amp; !isImaginary) {
        this.units[i].unit = UNITS["VA"];
      }
    }
  }


  // Now apply the best prefix
  // Units must have only one unit and not have the fixPrefix flag set
  if (this.units.length === 1 &amp;&amp; !this.fixPrefix) {
    // Units must have integer powers, otherwise the prefix will change the
    // outputted value by not-an-integer-power-of-ten
    if (Math.abs(this.units[0].power - Math.round(this.units[0].power)) &lt; 1e-14) {
      // Apply the best prefix
      this.units[0].prefix = this._bestPrefix();
    }
  }


  var value = this._denormalize(this.value);
  var str = (this.value !== null) ? format(value, options || {}) : '';
  var unitStr = this.formatUnits();
  if(this.value &amp;&amp; this.value.isComplex) {
    str = "(" + str + ")";    // Surround complex values with ( ) to enable better parsing
  }
  if(unitStr.length &gt; 0 &amp;&amp; str.length &gt; 0) {
    str += " ";
  }
  str += unitStr;

  return str;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Helper function to format a value. Regular numbers will be rounded
 * to 14 digits to prevent round-off errors from showing up.
 * @param {*} value
 */
function format(value) {
var math = getMath();

return math.<span class="apidocCodeKeywordSpan">format</span>(value, {
  fn: function (value) {
    if (typeof value === 'number') {
      // round numbers
      return math.format(value, PRECISION);
    }
    else {
      return math.format(value);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Unit.prototype.formatUnits" id="apidoc.element.mathjs.type.Unit.prototype.formatUnits">
        function <span class="apidocSignatureSpan">mathjs.type.Unit.prototype.</span>formatUnits
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">formatUnits = function () {

  // Lazy evaluation of the unit list
  this.simplifyUnitListLazy();

  var strNum = "";
  var strDen = "";
  var nNum = 0;
  var nDen = 0;

  for(var i=0; i&lt;this.units.length; i++) {
    if(this.units[i].power &gt; 0) {
      nNum++;
      strNum += " " + this.units[i].prefix.name + this.units[i].unit.name;
      if(Math.abs(this.units[i].power - 1.0) &gt; 1e-15) {
        strNum += "^" + this.units[i].power;
      }
    }
    else if(this.units[i].power &lt; 0) {
      nDen++;
    }
  }

  if(nDen &gt; 0) {
    for(var i=0; i&lt;this.units.length; i++) {
      if(this.units[i].power &lt; 0) {
        if(nNum &gt; 0) {
          strDen += " " + this.units[i].prefix.name + this.units[i].unit.name;
          if(Math.abs(this.units[i].power + 1.0) &gt; 1e-15) {
            strDen += "^" + (-this.units[i].power);
          }
        }
        else {
          strDen += " " + this.units[i].prefix.name + this.units[i].unit.name;
          strDen += "^" + (this.units[i].power);
        }
      }
    }
  }
  // Remove leading " "
  strNum = strNum.substr(1);
  strDen = strDen.substr(1);

  // Add parans for better copy/paste back into the eval, for example, or for better pretty print formatting
  if(nNum &gt; 1 &amp;&amp; nDen &gt; 0) {
    strNum = "(" + strNum + ")";
  }
  if(nDen &gt; 1 &amp;&amp; nNum &gt; 0) {
    strDen = "(" + strDen + ")";
  }

  var str = strNum;
  if(nNum &gt; 0 &amp;&amp; nDen &gt; 0) {
    str += " / ";
  }
  str += strDen;

  return str;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @returns {Object} Returns a JSON object structured as:
 *                   `{"mathjs": "Unit", "value": 2, "unit": "cm", "fixPrefix
": false}`
 */
Unit.prototype.toJSON = function () {
  return {
    mathjs: 'Unit',
    value: this._denormalize(this.value),
    unit: this.<span class="apidocCodeKeywordSpan">formatUnits</span>(),
    fixPrefix: this.fixPrefix
  };
};

/**
 * Instantiate a Unit from a JSON object
 * @memberof Unit
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Unit.prototype.hasBase" id="apidoc.element.mathjs.type.Unit.prototype.hasBase">
        function <span class="apidocSignatureSpan">mathjs.type.Unit.prototype.</span>hasBase
        <span class="apidocSignatureSpan">(base)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasBase = function (base) {

  if(typeof(base) === "string") {
    base = BASE_UNITS[base];
  }

  if(!base)
    return false;


  // All dimensions must be the same
  for(var i=0; i&lt;BASE_DIMENSIONS.length; i++) {
    if (Math.abs((this.dimensions[i] || 0) - (base.dimensions[i] || 0)) &gt; 1e-12) {
      return false;
    }
  }
  return true;

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
},

'BigNumber': function (x) {
  return x.cosh();
},

'Unit': function (x) {
  if (!x.<span class="apidocCodeKeywordSpan">hasBase</span>(type.Unit.BASE_UNITS.ANGLE)) {
    throw new TypeError ('Unit in function cosh is no angle');
  }
  return cosh(x.value);
},

'Array | Matrix': function (x) {
  return deepMap(x, cosh);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Unit.prototype.multiply" id="apidoc.element.mathjs.type.Unit.prototype.multiply">
        function <span class="apidocSignatureSpan">mathjs.type.Unit.prototype.</span>multiply
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">multiply = function (other) {
  var res = this.clone();

  for(var i = 0; i&lt;BASE_DIMENSIONS.length; i++) {
    // Dimensions arrays may be of different lengths. Default to 0.
    res.dimensions[i] = (this.dimensions[i] || 0) + (other.dimensions[i] || 0);
  }

  // Append other's units list onto res (simplify later in Unit.prototype.format)
  for(var i=0; i&lt;other.units.length; i++) {
    // Make a deep copy
    var inverted = {};
    for(var key in other.units[i]) {
      inverted[key] = other.units[i][key];
    }
    res.units.push(inverted);
  }

  // If at least one operand has a value, then the result should also have a value
  if(this.value != null || other.value != null) {
    var valThis = this.value == null ? this._normalize(1) : this.value;
    var valOther = other.value == null ? other._normalize(1) : other.value;
    res.value = multiply(valThis, valOther);
  }
  else {
    res.value = null;
  }

  // Trigger simplification of the unit list at some future time
  res.isUnitListSimplified = false;

  return getNumericIfUnitless(res);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
math.eval('sin(45 deg) ^ 2');     // 0.5
math.eval('9 / 3 + 2i');          // 3 + 2i
math.eval('det([-1, 2; 3, 1])');  // -7

// chaining
math.chain(3)
    .add(4)
    .<span class="apidocCodeKeywordSpan">multiply</span>(2)
    .done(); // 14
```

## Browser support

Math.js works on any ES5 compatible JavaScript engine: node.js 0.10, and Internet Explorer 9 and newer, and all other browsers (
Chrome, Firefox, Safari). If support for old browsers like Internet Explorer 8 is required, the [es5-shim](https://github.com/kriskowal
/es5-shim) library has to be loaded.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Unit.prototype.pow" id="apidoc.element.mathjs.type.Unit.prototype.pow">
        function <span class="apidocSignatureSpan">mathjs.type.Unit.prototype.</span>pow
        <span class="apidocSignatureSpan">(p)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pow = function (p) {
  var res = this.clone();

  for(var i=0; i&lt;BASE_DIMENSIONS.length; i++) {
    // Dimensions arrays may be of different lengths. Default to 0.
    res.dimensions[i] = (this.dimensions[i] || 0) * p;
  }

  // Adjust the power of each unit in the list
  for(var i=0; i&lt;res.units.length; i++) {
    res.units[i].power *= p;
  }

  if(res.value != null) {
    res.value = pow(res.value, p);

    // only allow numeric output, we don't want to return a Complex number
    //if (!isNumeric(res.value)) {
    //  res.value = NaN;
    //}
    // Update: Complex supported now
  }
  else {
    res.value = null;
  }

  // Trigger lazy evaluation of the unit list
  res.isUnitListSimplified = false;

  return getNumericIfUnitless(res);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var math = require('mathjs');

// functions and constants
math.round(math.e, 3);            // 2.718
math.atan2(3, -3) / math.pi;      // 0.75
math.log(1000, 10);               // 3
math.sqrt(-4);                    // 2i
math.<span class="apidocCodeKeywordSpan">pow</span>([[-1, 2], [3, 1]], 2);   // [[7, 0], [0, 7]]
math.derivative('x^2 + x', 'x');  // 2 * x + 1

// expressions
math.eval('12 / (2.3 + 0.7)');    // 4
math.eval('5.08 cm to inch');     // 2 inch
math.eval('sin(45 deg) ^ 2');     // 0.5
math.eval('9 / 3 + 2i');          // 3 + 2i
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Unit.prototype.simplifyUnitListLazy" id="apidoc.element.mathjs.type.Unit.prototype.simplifyUnitListLazy">
        function <span class="apidocSignatureSpan">mathjs.type.Unit.prototype.</span>simplifyUnitListLazy
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">simplifyUnitListLazy = function () {

  if (this.isUnitListSimplified || this.value == null) {
    return;
  }

  var proposedUnitList = [];

  // Search for a matching base
  var matchingBase;
  for(var key in currentUnitSystem) {
    if(this.hasBase(BASE_UNITS[key])) {
      matchingBase = key;
      break;
    }
  }

  if(matchingBase === 'NONE')
  {
    this.units = [];
  }
  else {
    var matchingUnit;
    if(matchingBase) {
      // Does the unit system have a matching unit?
      if(currentUnitSystem.hasOwnProperty(matchingBase)) {
        matchingUnit = currentUnitSystem[matchingBase];
      }
    }
    var value;
    var str;
    if(matchingUnit) {
      this.units = [{
        unit: matchingUnit.unit,
        prefix: matchingUnit.prefix,
        power: 1.0
      }];
    }
    else {
      // Multiple units or units with powers are formatted like this:
      // 5 (kg m^2) / (s^3 mol)
      // Build an representation from the base units of the current unit system
      var missingBaseDim = false;
      for(var i=0; i&lt;BASE_DIMENSIONS.length; i++) {
        var baseDim = BASE_DIMENSIONS[i];
        if(Math.abs(this.dimensions[i] || 0) &gt; 1e-12) {
          if(currentUnitSystem.hasOwnProperty(baseDim)) {
            proposedUnitList.push({
              unit: currentUnitSystem[baseDim].unit,
              prefix: currentUnitSystem[baseDim].prefix,
              power: this.dimensions[i] || 0
            });
          }
          else {
            missingBaseDim = true;
          }
        }
      }

      // Is the proposed unit list "simpler" than the existing one?
      if(proposedUnitList.length &lt; this.units.length &amp;&amp; !missingBaseDim) {
        // Replace this unit list with the proposed list
        this.units = proposedUnitList;
      }
    }
  }

  this.isUnitListSimplified = true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * Get a string representation of the units of this Unit, without the value.
   * @memberof Unit
   * @return {string}
   */
  Unit.prototype.formatUnits = function () {

// Lazy evaluation of the unit list
this.<span class="apidocCodeKeywordSpan">simplifyUnitListLazy</span>();

var strNum = "";
var strDen = "";
var nNum = 0;
var nDen = 0;

for(var i=0; i&lt;this.units.length; i++) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Unit.prototype.splitUnit" id="apidoc.element.mathjs.type.Unit.prototype.splitUnit">
        function <span class="apidocSignatureSpan">mathjs.type.Unit.prototype.</span>splitUnit
        <span class="apidocSignatureSpan">(parts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">splitUnit = function (parts) {

  var x = this.clone();
  var ret = [];
  for(var i=0; i&lt;parts.length; i++) {
    x = x.to(parts[i]);
    if(i==parts.length-1) break;
    // fix rounds a number towards 0
    var fixedVal = fix(x.toNumeric());
    var y = new Unit(fixedVal, parts[i].toString());
    ret.push(y);
    x = subtract(x, y);
  }
  ret.push(x);

  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * Returns an array of units whose sum is equal to this unit
   * @memberof Unit
   * @param {Array} [parts] An array of strings or valueless units.
   *
   *   Example:
   *
   *   var u = new Unit(1, 'm');
   *   u.<span class="apidocCodeKeywordSpan">splitUnit</span>(['feet', 'inch']);
   *     [ 3 feet, 3.3700787401575 inch ]
   *
   * @return {Array} An array of units.
   */
  Unit.prototype.splitUnit = function(parts) {

var x = this.clone();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Unit.prototype.to" id="apidoc.element.mathjs.type.Unit.prototype.to">
        function <span class="apidocSignatureSpan">mathjs.type.Unit.prototype.</span>to
        <span class="apidocSignatureSpan">(valuelessUnit)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">to = function (valuelessUnit) {
  var other;
  var value = this.value == null ? this._normalize(1) : this.value;
  if (typeof valuelessUnit === 'string') {
    //other = new Unit(null, valuelessUnit);
    other = Unit.parse(valuelessUnit);
    if (!this.equalBase(other)) {
      throw new Error('Units do not match');
    }
    if (other.value !== null) {
      throw new Error('Cannot convert to a unit with a value');
    }

    other.value = clone(value);
    other.fixPrefix = true;
    other.isUnitListSimplified = true;
    return other;
  }
  else if (valuelessUnit &amp;&amp; valuelessUnit.isUnit) {
    if (!this.equalBase(valuelessUnit)) {
      throw new Error('Units do not match');
    }
    if (valuelessUnit.value !== null) {
      throw new Error('Cannot convert to a unit with a value');
    }
    other = valuelessUnit.clone();
    other.value = clone(value);
    other.fixPrefix = true;
    other.isUnitListSimplified = true;
    return other;
  }
  else {
    throw new Error('String or Unit expected as parameter');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* Examples:
*
*    math.string(4.2);               // returns string '4.2'
*    math.string(math.complex(3, 2); // returns string '3 + 2i'
*
*    var u = math.unit(5, 'km');
*    math.string(u.<span class="apidocCodeKeywordSpan">to</span>('m'));         // returns string '5000 m'
*
*    math.string([true, false]);     // returns ['true', 'false']
*
* See also:
*
*    bignumber, boolean, complex, index, matrix, number, unit
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Unit.prototype.toJSON" id="apidoc.element.mathjs.type.Unit.prototype.toJSON">
        function <span class="apidocSignatureSpan">mathjs.type.Unit.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function () {
  return {
    mathjs: 'Unit',
    value: this._denormalize(this.value),
    unit: this.formatUnits(),
    fixPrefix: this.fixPrefix
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Unit.prototype.toNumber" id="apidoc.element.mathjs.type.Unit.prototype.toNumber">
        function <span class="apidocSignatureSpan">mathjs.type.Unit.prototype.</span>toNumber
        <span class="apidocSignatureSpan">(valuelessUnit)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toNumber = function (valuelessUnit) {
  return toNumber(this.toNumeric(valuelessUnit));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  convert: function (x) {
    return x + '';
  }
}, {
  from: 'BigNumber',
  to: 'Complex',
  convert: function (x) {
    return new type.Complex(x.<span class="apidocCodeKeywordSpan">toNumber</span>(), 0);
  }
}, {
  from: 'Fraction',
  to: 'BigNumber',
  convert: function (x) {
    throw new TypeError('Cannot implicitly convert a Fraction to BigNumber or vice versa. ' +
        'Use function bignumber(x) to convert to BigNumber or fraction(x) to convert to Fraction.');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Unit.prototype.toNumeric" id="apidoc.element.mathjs.type.Unit.prototype.toNumeric">
        function <span class="apidocSignatureSpan">mathjs.type.Unit.prototype.</span>toNumeric
        <span class="apidocSignatureSpan">(valuelessUnit)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toNumeric = function (valuelessUnit) {
  var other = this;
  if(valuelessUnit) {
    // Allow getting the numeric value without converting to a different unit
    other = this.to(valuelessUnit);
  }

  if(other._isDerived()) {
    return other._denormalize(other.value);
  }
  else {
    return other._denormalize(other.value, other.units[0].prefix.value);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Return the value of the unit when represented with given valueless unit
 * @memberof Unit
 * @param {string | Unit} valuelessUnit    For example 'cm' or 'inch'
 * @return {number} Returns the unit value as number.
 */
// TODO: deprecate Unit.toNumber? It's always better to use toNumeric
Unit.prototype.toNumber = function (valuelessUnit) {
  return toNumber(this.<span class="apidocCodeKeywordSpan">toNumeric</span>(valuelessUnit));
};

/**
 * Return the value of the unit in the original numeric type
 * @memberof Unit
 * @param {string | Unit} valuelessUnit    For example 'cm' or 'inch'
 * @return {number | BigNumber | Fraction} Returns the unit value
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Unit.prototype.toSI" id="apidoc.element.mathjs.type.Unit.prototype.toSI">
        function <span class="apidocSignatureSpan">mathjs.type.Unit.prototype.</span>toSI
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toSI = function () {

  var ret = this.clone();

  var proposedUnitList = [];

  // Multiple units or units with powers are formatted like this:
  // 5 (kg m^2) / (s^3 mol)
  // Build an representation from the base units of the SI unit system
  var missingBaseDim = false;
  for(var i=0; i&lt;BASE_DIMENSIONS.length; i++) {
    var baseDim = BASE_DIMENSIONS[i];
    if(Math.abs(ret.dimensions[i] || 0) &gt; 1e-12) {
      if(UNIT_SYSTEMS["si"].hasOwnProperty(baseDim)) {
        proposedUnitList.push({
          unit: UNIT_SYSTEMS["si"][baseDim].unit,
          prefix: UNIT_SYSTEMS["si"][baseDim].prefix,
          power: ret.dimensions[i] || 0
        });
      }
      else {
        throw new Error("Cannot express custom unit " + baseDim + " in SI units");
      }
    }
  }

  // Replace this unit list with the proposed list
  ret.units = proposedUnitList;

  ret.isUnitListSimplified = true;

  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Unit.prototype.toString" id="apidoc.element.mathjs.type.Unit.prototype.toString">
        function <span class="apidocSignatureSpan">mathjs.type.Unit.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
  return this.format();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      }
      else {
        scope.ans = res;
        console.log(format(res));
      }
    }
    else if (res instanceof math.type.Help) {
      console.log(res.<span class="apidocCodeKeywordSpan">toString</span>());
    }
    else {
      scope.ans = res;
      console.log(format(res));
    }
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.type.Unit.prototype.valueOf" id="apidoc.element.mathjs.type.Unit.prototype.valueOf">
        function <span class="apidocSignatureSpan">mathjs.type.Unit.prototype.</span>valueOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">valueOf = function () {
  return this.format();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    throw new TypeError('Cannot implicitly convert a Fraction to BigNumber or vice versa. ' +
        'Use function bignumber(x) to convert to BigNumber or fraction(x) to convert to Fraction.');
  }
}, {
  from: 'Fraction',
  to: 'Complex',
  convert: function (x) {
    return new type.Complex(x.<span class="apidocCodeKeywordSpan">valueOf</span>(), 0);
  }
}, {
  from: 'number',
  to: 'Fraction',
  convert: function (x) {
    if (digits(x) &gt; 15) {
      throw new TypeError('Cannot implicitly convert a number with &gt;15 significant digits to Fraction ' +
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.typed" id="apidoc.module.mathjs.typed">module mathjs.typed</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.typed.typed" id="apidoc.element.mathjs.typed.typed">
        function <span class="apidocSignatureSpan">mathjs.</span>typed
        <span class="apidocSignatureSpan">(arg0, arg1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function typed(arg0, arg1) {
  "use strict";
  var name = 'typed';
  if (test0(arg0)) { // type: string
    if (test1(arg1)) { // type: Object
      if (arguments.length === 2) {
        return signature0(arg0, arg1); // signature: string, Object
      }
      if (arguments.length &gt; 2) {
        throw createError(name, arguments.length, 2, arguments[2]);
      }
    }
    throw createError(name, arguments.length, 1, arguments[1], 'Object');
  }
  if (test2(arg0)) { // type: ...Function
    var varArgs = [arg0];
    for (var i = 1; i &lt; arguments.length; i++) {
      if (test2(arguments[i])) {
        varArgs.push(arguments[i]);
      } else {
        throw createError(name, arguments.length, i, arguments[i], 'Function');
      }
    }
    return signature1(varArgs); // signature: ...Function
  }
  if (test1(arg0)) { // type: Object
    if (arguments.length === 1) {
      return signature2(arg0); // signature: Object
    }
    if (arguments.length &gt; 1) {
      throw createError(name, arguments.length, 1, arguments[1]);
    }
  }
  throw createError(name, arguments.length, 0, arguments[0], 'string,Function,Object');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.typed.addConversion" id="apidoc.element.mathjs.typed.addConversion">
        function <span class="apidocSignatureSpan">mathjs.typed.</span>addConversion
        <span class="apidocSignatureSpan">(conversion)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addConversion = function (conversion) {
  if (!conversion
      || typeof conversion.from !== 'string'
      || typeof conversion.to !== 'string'
      || typeof conversion.convert !== 'function') {
    throw new TypeError('Object with properties {from: string, to: string, convert: function} expected');
  }

  typed.conversions.push(conversion);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.typed.addType" id="apidoc.element.mathjs.typed.addType">
        function <span class="apidocSignatureSpan">mathjs.typed.</span>addType
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addType = function (type) {
  if (!type || typeof type.name !== 'string' || typeof type.test !== 'function') {
    throw new TypeError('Object with properties {name: string, test: function} expected');
  }

  typed.types.push(type);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.typed.convert" id="apidoc.element.mathjs.typed.convert">
        function <span class="apidocSignatureSpan">mathjs.typed.</span>convert
        <span class="apidocSignatureSpan">(value, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function convert(value, type) {
  var from = getTypeOf(value);

  // check conversion is needed
  if (type === from) {
    return value;
  }

  for (var i = 0; i &lt; typed.conversions.length; i++) {
    var conversion = typed.conversions[i];
    if (conversion.from === from &amp;&amp; conversion.to === type) {
      return conversion.convert(value);
    }
  }

  throw new Error('Cannot convert from ' + from + ' to ' + type);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // datatype
  dt = adt;
  // find signatures that matches (dt, dt)
  af = typed.find(addScalar, [dt, dt]);
  mf = typed.find(multiplyScalar, [dt, dt]);
  eq = typed.find(equalScalar, [dt, dt]);
  // convert 0 to the same datatype
  zero = typed.<span class="apidocCodeKeywordSpan">convert</span>(0, dt);
}

// result
var cvalues = [];
var cindex = [];
var cptr = [];
// c matrix
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.typed.create" id="apidoc.element.mathjs.typed.create">
        function <span class="apidocSignatureSpan">mathjs.typed.</span>create
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function create() {
<span class="apidocCodeCommentSpan">  /**
   * Get a type test function for a specific data type
   * @param {string} name                   Name of a data type like 'number' or 'string'
   * @returns {Function(obj: *) : boolean}  Returns a type testing function.
   *                                        Throws an error for an unknown type.
   */
</span>  function getTypeTest(name) {
    var test;
    for (var i = 0; i &lt; typed.types.length; i++) {
      var entry = typed.types[i];
      if (entry.name === name) {
        test = entry.test;
        break;
      }
    }

    if (!test) {
      var hint;
      for (i = 0; i &lt; typed.types.length; i++) {
        entry = typed.types[i];
        if (entry.name.toLowerCase() == name.toLowerCase()) {
          hint = entry.name;
          break;
        }
      }

      throw new Error('Unknown type "' + name + '"' +
          (hint ? ('. Did you mean "' + hint + '"?') : ''));
    }
    return test;
  }

  /**
   * Retrieve the function name from a set of functions, and check
   * whether the name of all functions match (if given)
   * @param {Array.&lt;function&gt;} fns
   */
  function getName (fns) {
    var name = '';

    for (var i = 0; i &lt; fns.length; i++) {
      var fn = fns[i];

      // merge function name when this is a typed function
      if (fn.signatures &amp;&amp; fn.name != '') {
        if (name == '') {
          name = fn.name;
        }
        else if (name != fn.name) {
          var err = new Error('Function names do not match (expected: ' + name + ', actual: ' + fn.name + ')');
          err.data = {
            actual: fn.name,
            expected: name
          };
          throw err;
        }
      }
    }

    return name;
  }

  /**
   * Create an ArgumentsError. Creates messages like:
   *
   *   Unexpected type of argument (expected: ..., actual: ..., index: ...)
   *   Too few arguments (expected: ..., index: ...)
   *   Too many arguments (expected: ..., actual: ...)
   *
   * @param {String} fn         Function name
   * @param {number} argCount   Number of arguments
   * @param {Number} index      Current argument index
   * @param {*} actual          Current argument
   * @param {string} [expected] An optional, comma separated string with
   *                            expected types on given index
   * @extends Error
   */
  function createError(fn, argCount, index, actual, expected) {
    var actualType = getTypeOf(actual);
    var _expected = expected ? expected.split(',') : null;
    var _fn = (fn || 'unnamed');
    var anyType = _expected &amp;&amp; contains(_expected, 'any');
    var message;
    var data = {
      fn: fn,
      index: index,
      actual: actual,
      expected: _expected
    };

    if (_expected) {
      if (argCount &gt; index &amp;&amp; !anyType) {
        // unexpected type
        message = 'Unexpected type of argument in function ' + _fn +
            ' (expected: ' + _expected.join(' or ') + ', actual: ' + actualType + ', index: ' + index + ')';
      }
      else {
        // too few arguments
        message = 'Too few arguments in function ' + _fn +
            ' (expected: ' + _expected.join(' or ') + ', index: ' + index + ')';
      }
    }
    else {
      // too many arguments
      message = 'Too many arguments in function ' + _fn +
          ' (expected: ' + index + ', actual: ' + argCount + ')'
    }

    var err = new TypeError(message);
    err.data = data;
    return err;
  }

  /**
   * Collection with function references (local shortcuts to functions)
   * @constructor
   * @param {string} [name='refs']  Optional name for the refs, used to generate
   *                                JavaScript code
   */
  function Refs(name) {
    this.name = name || 'refs';
    this.categories = {};
  }

  /**
   * Add a function reference.
   * @param {Function} fn
   * @param {string} [category='fn']    A function category, like 'fn' or 'signature'
   * @returns {string} Returns the function name, for example 'fn0' or 'signature2'
   */
  Refs.prototype.add = function (fn, category) {
    var cat = category || 'fn';
    if (!this.categories[cat]) this.categ ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *                              false (default), output type can vary depending
 *                              on input values. For example `math.sqrt(-4)`
 *                              returns `complex('2i')` when predictable is false, and
 *                              returns `NaN` when true.
 */
function create (config) {
  // create a new math.js instance
  var math = core.<span class="apidocCodeKeywordSpan">create</span>(config);
  math.create = create;

  // import data types, functions, constants, expression parser, etc.
  math['import'](require('./lib'));

  return math;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.typed.find" id="apidoc.element.mathjs.typed.find">
        function <span class="apidocSignatureSpan">mathjs.typed.</span>find
        <span class="apidocSignatureSpan">(fn, signature)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function find(fn, signature) {
  if (!fn.signatures) {
    throw new TypeError('Function is no typed-function');
  }

  // normalize input
  var arr;
  if (typeof signature === 'string') {
    arr = signature.split(',');
    for (var i = 0; i &lt; arr.length; i++) {
      arr[i] = arr[i].trim();
    }
  }
  else if (Array.isArray(signature)) {
    arr = signature;
  }
  else {
    throw new TypeError('String array or a comma separated string expected');
  }

  var str = arr.join(',');

  // find an exact match
  var match = fn.signatures[str];
  if (match) {
    return match;
  }

  // TODO: extend find to match non-exact signatures

  throw new TypeError('Signature not found (signature: ' + (fn.name || 'unnamed') + '(' + arr.join(', ') + '))');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var mf = multiplyScalar;

// process data types
if (adt &amp;&amp; bdt &amp;&amp; adt === bdt &amp;&amp; typeof adt === 'string') {
  // datatype
  dt = adt;
  // find signatures that matches (dt, dt)
  af = typed.<span class="apidocCodeKeywordSpan">find</span>(addScalar, [dt, dt]);
  mf = typed.find(multiplyScalar, [dt, dt]);
}

// result (do not initialize it with zero)
var c = mf(adata[0], bdata[0]);
// loop data
for (var i = 1; i &lt; n; i++) {
...</pre></li>
    </ul>












</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.typed.signatures" id="apidoc.module.mathjs.typed.signatures">module mathjs.typed.signatures</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.typed.signatures.Object" id="apidoc.element.mathjs.typed.signatures.Object">
        function <span class="apidocSignatureSpan">mathjs.typed.signatures.</span>Object
        <span class="apidocSignatureSpan">(signatures)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Object = function (signatures) {
  var fns = [];
  for (var signature in signatures) {
    if (signatures.hasOwnProperty(signature)) {
      fns.push(signatures[signature]);
    }
  }
  var name = getName(fns);

  return _typed(name, signatures);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.typeof" id="apidoc.module.mathjs.typeof">module mathjs.typeof</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.typeof.factory" id="apidoc.element.mathjs.typeof.factory">
        function <span class="apidocSignatureSpan">mathjs.typeof.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
<span class="apidocCodeCommentSpan">  /**
   * Determine the type of a variable.
   *
   * Function `typeof` recognizes the following types of objects:
   *
   * Object                 | Returns       | Example
   * ---------------------- | ------------- | ------------------------------------------
   * null                   | `'null'`      | `math.typeof(null)`
   * number                 | `'number'`    | `math.typeof(3.5)`
   * boolean                | `'boolean'`   | `math.typeof (true)`
   * string                 | `'string'`    | `math.typeof ('hello world')`
   * Array                  | `'Array'`     | `math.typeof ([1, 2, 3])`
   * Date                   | `'Date'`      | `math.typeof (new Date())`
   * Function               | `'Function'`  | `math.typeof (function () {})`
   * Object                 | `'Object'`    | `math.typeof ({a: 2, b: 3})`
   * RegExp                 | `'RegExp'`    | `math.typeof (/a regexp/)`
   * undefined              | `'undefined'` | `math.typeof(undefined)`
   * math.type.BigNumber    | `'BigNumber'` | `math.typeof (math.bignumber('2.3e500'))`
   * math.type.Chain        | `'Chain'`     | `math.typeof (math.chain(2))`
   * math.type.Complex      | `'Complex'`   | `math.typeof (math.complex(2, 3))`
   * math.type.Fraction     | `'Fraction'`  | `math.typeof (math.fraction(1, 3))`
   * math.type.Help         | `'Help'`      | `math.typeof (math.help('sqrt'))`
   * math.type.Index        | `'Index'`     | `math.typeof (math.index(1, 3))`
   * math.type.Matrix       | `'Matrix'`    | `math.typeof (math.matrix([[1,2], [3, 4]]))`
   * math.type.Range        | `'Range'`     | `math.typeof (math.range(0, 10))`
   * math.type.Unit         | `'Unit'`      | `math.typeof (math.unit('45 deg'))`
   *
   * Syntax:
   *
   *    math.typeof(x)
   *
   * Examples:
   *
   *    math.typeof(3.5);                     // returns 'number'
   *    math.typeof(math.complex('2-4i'));    // returns 'Complex'
   *    math.typeof(math.unit('45 deg'));     // returns 'Unit'
   *    math.typeof('hello world');           // returns 'string'
   *
   * @param {*} x     The variable for which to test the type.
   * @return {string} Returns the name of the type. Primitive types are lower case,
   *                  non-primitive types are upper-camel-case.
   *                  For example 'number', 'string', 'Array', 'Date'.
   */
</span>  var _typeof = typed('_typeof', {
    'any': function (x) {
      // JavaScript types
      var t = types.type(x);

      // math.js types
      if (t === 'Object') {
        if (x.isBigNumber === true) return 'BigNumber';
        if (x.isComplex === true)   return 'Complex';
        if (x.isFraction === true)  return 'Fraction';
        if (x.isMatrix === true)    return 'Matrix';
        if (x.isUnit === true)      return 'Unit';
        if (x.isIndex === true)     return 'Index';
        if (x.isRange === true)     return 'Range';
        if (x.isChain === true)     return 'Chain';
        if (x.isHelp === true)      return 'Help';
      }

      return t;
    }
  });

  _typeof.toTex = undefined; // use default template

  return _typeof;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.types" id="apidoc.module.mathjs.types">module mathjs.types</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.types.isScalar" id="apidoc.element.mathjs.types.isScalar">
        function <span class="apidocSignatureSpan">mathjs.types.</span>isScalar
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isScalar = function (x) {
  return !((x &amp;&amp; x.isMatrix) || Array.isArray(x));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * @private
   */
  function _get (matrix, index) {
if (!index || index.isIndex !== true) {
  throw new TypeError('Invalid index');
}

var isScalar = index.<span class="apidocCodeKeywordSpan">isScalar</span>();
if (isScalar) {
  // return a scalar
  return matrix.get(index.min());
}
else {
  // validate dimensions
  var size = index.size();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mathjs.types.type" id="apidoc.element.mathjs.types.type">
        function <span class="apidocSignatureSpan">mathjs.types.</span>type
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">type = function (x) {
  var type = typeof x;

  if (type === 'object') {
    if (x === null)           return 'null';
    if (x instanceof Boolean) return 'boolean';
    if (x instanceof Number)  return 'number';
    if (x instanceof String)  return 'string';
    if (Array.isArray(x))     return 'Array';
    if (x instanceof Date)    return 'Date';
    if (x instanceof RegExp)  return 'RegExp';

    return 'Object';
  }

  if (type === 'function')    return 'Function';

  return type;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   * @return {string} Returns the name of the type. Primitive types are lower case,
   *                  non-primitive types are upper-camel-case.
   *                  For example 'number', 'string', 'Array', 'Date'.
   */
  var _typeof = typed('_typeof', {
    'any': function (x) {
// JavaScript types
var t = types.<span class="apidocCodeKeywordSpan">type</span>(x);

// math.js types
if (t === 'Object') {
  if (x.isBigNumber === true) return 'BigNumber';
  if (x.isComplex === true)   return 'Complex';
  if (x.isFraction === true)  return 'Fraction';
  if (x.isMatrix === true)    return 'Matrix';
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.unaryMinus" id="apidoc.module.mathjs.unaryMinus">module mathjs.unaryMinus</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.unaryMinus.factory" id="apidoc.element.mathjs.unaryMinus.factory">
        function <span class="apidocSignatureSpan">mathjs.unaryMinus.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var latex = require('../../utils/latex');

<span class="apidocCodeCommentSpan">  /**
   * Inverse the sign of a value, apply a unary minus operation.
   *
   * For matrices, the function is evaluated element wise. Boolean values and
   * strings will be converted to a number. For complex numbers, both real and
   * complex value are inverted.
   *
   * Syntax:
   *
   *    math.unaryMinus(x)
   *
   * Examples:
   *
   *    math.unaryMinus(3.5);      // returns -3.5
   *    math.unaryMinus(-4.2);     // returns 4.2
   *
   * See also:
   *
   *    add, subtract, unaryPlus
   *
   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x Number to be inverted.
   * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} Returns the value with inverted sign.
   */
</span>  var unaryMinus = typed('unaryMinus', {
    'number': function (x) {
      return -x;
    },

    'Complex': function (x) {
      return x.neg();
    },

    'BigNumber': function (x) {
      return x.neg();
    },

    'Fraction': function (x) {
      return x.neg();
    },

    'Unit': function (x) {
      var res = x.clone();
      res.value = unaryMinus(x.value);
      return res;
    },

    'Array | Matrix': function (x) {
      // deep map collection, skip zeros since unaryMinus(0) = 0
      return deepMap(x, unaryMinus, true);
    }

    // TODO: add support for string
  });

  unaryMinus.toTex = {
    1: latex.operators['unaryMinus'] + '\\left(${args[0]}\\right)'
  };

  return unaryMinus;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.unaryPlus" id="apidoc.module.mathjs.unaryPlus">module mathjs.unaryPlus</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.unaryPlus.factory" id="apidoc.element.mathjs.unaryPlus.factory">
        function <span class="apidocSignatureSpan">mathjs.unaryPlus.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var latex = require('../../utils/latex');

<span class="apidocCodeCommentSpan">  /**
   * Unary plus operation.
   * Boolean values and strings will be converted to a number, numeric values will be returned as is.
   *
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.unaryPlus(x)
   *
   * Examples:
   *
   *    math.unaryPlus(3.5);      // returns 3.5
   *    math.unaryPlus(1);     // returns 1
   *
   * See also:
   *
   *    unaryMinus, add, subtract
   *
   * @param  {number | BigNumber | Fraction | string | Complex | Unit | Array | Matrix} x
   *            Input value
   * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix}
   *            Returns the input value when numeric, converts to a number when input is non-numeric.
   */
</span>  var unaryPlus = typed('unaryPlus', {
    'number': function (x) {
      return x;
    },

    'Complex': function (x) {
      return x; // complex numbers are immutable
    },

    'BigNumber': function (x) {
      return x; // bignumbers are immutable
    },

    'Fraction': function (x) {
      return x; // fractions are immutable
    },

    'Unit': function (x) {
      return x.clone();
    },

    'Array | Matrix': function (x) {
      // deep map collection, skip zeros since unaryPlus(0) = 0
      return deepMap(x, unaryPlus, true);
    },

    'boolean | string | null': function (x) {
      // convert to a number or bignumber
      return (config.number == 'BigNumber') ? new type.BigNumber(+x): +x;
    }
  });

  unaryPlus.toTex = {
    1: latex.operators['unaryPlus'] + '\\left(${args[0]}\\right)'
  };

  return unaryPlus;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.unequal" id="apidoc.module.mathjs.unequal">module mathjs.unequal</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.unequal.factory" id="apidoc.element.mathjs.unequal.factory">
        function <span class="apidocSignatureSpan">mathjs.unequal.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {

  var matrix = load(require('../../type/matrix/function/matrix'));

  var algorithm03 = load(require('../../type/matrix/utils/algorithm03'));
  var algorithm07 = load(require('../../type/matrix/utils/algorithm07'));
  var algorithm12 = load(require('../../type/matrix/utils/algorithm12'));
  var algorithm13 = load(require('../../type/matrix/utils/algorithm13'));
  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));

  var latex = require('../../utils/latex');

<span class="apidocCodeCommentSpan">  /**
   * Test whether two values are unequal.
   *
   * The function tests whether the relative difference between x and y is
   * larger than the configured epsilon. The function cannot be used to compare
   * values smaller than approximately 2.22e-16.
   *
   * For matrices, the function is evaluated element wise.
   * In case of complex numbers, x.re must unequal y.re, or x.im must unequal y.im.
   *
   * Values `null` and `undefined` are compared strictly, thus `null` is unequal
   * with everything except `null`, and `undefined` is unequal with everying
   * except. `undefined`.
   *
   * Syntax:
   *
   *    math.unequal(x, y)
   *
   * Examples:
   *
   *    math.unequal(2 + 2, 3);       // returns true
   *    math.unequal(2 + 2, 4);       // returns false
   *
   *    var a = math.unit('50 cm');
   *    var b = math.unit('5 m');
   *    math.unequal(a, b);           // returns false
   *
   *    var c = [2, 5, 1];
   *    var d = [2, 7, 1];
   *
   *    math.unequal(c, d);           // returns [false, true, false]
   *    math.deepEqual(c, d);         // returns false
   *
   *    math.unequal(0, null);        // returns true
   * See also:
   *
   *    equal, deepEqual, smaller, smallerEq, larger, largerEq, compare
   *
   * @param  {number | BigNumber | Fraction | boolean | Complex | Unit | string | Array | Matrix | undefined} x First value to compare
   * @param  {number | BigNumber | Fraction | boolean | Complex | Unit | string | Array | Matrix | undefined} y Second value to
compare
   * @return {boolean | Array | Matrix} Returns true when the compared values are unequal, else returns false
   */
</span>  var unequal = typed('unequal', {

    'any, any': function (x, y) {
      // strict equality for null and undefined?
      if (x === null) { return y !== null; }
      if (y === null) { return x !== null; }
      if (x === undefined) { return y !== undefined; }
      if (y === undefined) { return x !== undefined; }

      return _unequal(x, y);
    },

    'Matrix, Matrix': function (x, y) {
      // result
      var c;

      // process matrix storage
      switch (x.storage()) {
        case 'sparse':
          switch (y.storage()) {
            case 'sparse':
              // sparse + sparse
              c = algorithm07(x, y, _unequal);
              break;
            default:
              // sparse + dense
              c = algorithm03(y, x, _unequal, true);
              break;
          }
          break;
        default:
          switch (y.storage()) {
            case 'sparse':
              // dense + sparse
              c = algorithm03(x, y, _unequal, false);
              break;
            default:
              // dense + dense
              c = algorithm13(x, y, _unequal);
              break;
          }
          break;
      }
      return c;
    },

    'Array, Array': function (x, y) {
      // use matrix implementation
      return unequal(matrix(x), matrix(y)).valueOf();
    },

    'Array, Matrix': function (x, y) {
      // use matrix implementation
      return unequal(matrix(x), y);
    },

    'Matrix, Array': function (x, y) {
      // use matrix implementation
      return unequal(x, matrix(y));
    },

    'Matrix, any': function (x, y) {
      // result
      var c;
      // check storage format
      switch (x.storage()) {
        case 'sparse':
          c = algorithm12(x, y, _unequal, false);
          break;
        default:
          c = algorithm14(x, y, _unequal, false);
          break;
      }
      return c;
    },

    'any, Matrix': functi ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.var" id="apidoc.module.mathjs.var">module mathjs.var</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.var.factory" id="apidoc.element.mathjs.var.factory">
        function <span class="apidocSignatureSpan">mathjs.var.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var add = load(require('../arithmetic/addScalar'));
  var subtract = load(require('../arithmetic/subtract'));
  var multiply = load(require('../arithmetic/multiplyScalar'));
  var divide = load(require('../arithmetic/divideScalar'));

<span class="apidocCodeCommentSpan">  /**
   * Compute the variance of a matrix or a  list with values.
   * In case of a (multi dimensional) array or matrix, the variance over all
   * elements will be calculated.
   *
   * Optionally, the type of normalization can be specified as second
   * parameter. The parameter `normalization` can be one of the following values:
   *
   * - 'unbiased' (default) The sum of squared errors is divided by (n - 1)
   * - 'uncorrected'        The sum of squared errors is divided by n
   * - 'biased'             The sum of squared errors is divided by (n + 1)
   *
   * Note that older browser may not like the variable name `var`. In that
   * case, the function can be called as `math['var'](...)` instead of
   * `math.var(...)`.
   *
   * Syntax:
   *
   *     math.var(a, b, c, ...)
   *     math.var(A)
   *     math.var(A, normalization)
   *
   * Examples:
   *
   *     math.var(2, 4, 6);                     // returns 4
   *     math.var([2, 4, 6, 8]);                // returns 6.666666666666667
   *     math.var([2, 4, 6, 8], 'uncorrected'); // returns 5
   *     math.var([2, 4, 6, 8], 'biased');      // returns 4
   *
   *     math.var([[1, 2, 3], [4, 5, 6]]);      // returns 3.5
   *
   * See also:
   *
   *    mean, median, max, min, prod, std, sum
   *
   * @param {Array | Matrix} array
   *                        A single matrix or or multiple scalar values
   * @param {string} [normalization='unbiased']
   *                        Determines how to normalize the variance.
   *                        Choose 'unbiased' (default), 'uncorrected', or 'biased'.
   * @return {*} The variance
   */
</span>  var variance = typed('variance', {
    // var([a, b, c, d, ...])
    'Array | Matrix': function (array) {
      return _var(array, DEFAULT_NORMALIZATION);
    },

    // var([a, b, c, d, ...], normalization)
    'Array | Matrix, string': _var,

    // var(a, b, c, d, ...)
    '...': function (args) {
      return _var(args, DEFAULT_NORMALIZATION);
    }
  });

  variance.toTex = '\\mathrm{Var}\\left(${args}\\right)';

  return variance;

  /**
   * Recursively calculate the variance of an n-dimensional array
   * @param {Array} array
   * @param {string} normalization
   *                        Determines how to normalize the variance:
   *                        - 'unbiased'    The sum of squared errors is divided by (n - 1)
   *                        - 'uncorrected' The sum of squared errors is divided by n
   *                        - 'biased'      The sum of squared errors is divided by (n + 1)
   * @return {number | BigNumber} variance
   * @private
   */
  function _var(array, normalization) {
    var sum = 0;
    var num = 0;

    if (array.length == 0) {
      throw new SyntaxError('Function var requires one or more parameters (0 provided)');
    }

    // calculate the mean and number of elements
    deepForEach(array, function (value) {
      sum = add(sum, value);
      num++;
    });
    if (num === 0) throw new Error('Cannot calculate var of an empty array');

    var mean = divide(sum, num);

    // calculate the variance
    sum = 0;
    deepForEach(array, function (value) {
      var diff = subtract(value, mean);
      sum = add(sum, multiply(diff, diff));
    });

    switch (normalization) {
      case 'uncorrected':
        return divide(sum, num);

      case 'biased':
        return divide(sum, num + 1);

      case 'unbiased':
        var zero = (sum &amp;&amp; sum.isBigNumber === true) ? new type.BigNumber(0) : 0;
        return (num == 1) ? zero : divide(sum, num - 1);

      default:
        throw new Error('Unknown normalization "' + normalization + '". ' +
        'Choose "unbiased" (default), "uncorrected", or "biased".');
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.xgcd" id="apidoc.module.mathjs.xgcd">module mathjs.xgcd</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.xgcd.factory" id="apidoc.element.mathjs.xgcd.factory">
        function <span class="apidocSignatureSpan">mathjs.xgcd.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var matrix = load(require('../../type/matrix/function/matrix'));

<span class="apidocCodeCommentSpan">  /**
   * Calculate the extended greatest common divisor for two values.
   * See http://en.wikipedia.org/wiki/Extended_Euclidean_algorithm.
   *
   * Syntax:
   *
   *    math.xgcd(a, b)
   *
   * Examples:
   *
   *    math.xgcd(8, 12);             // returns [4, -1, 1]
   *    math.gcd(8, 12);              // returns 4
   *    math.xgcd(36163, 21199);      // returns [1247, -7, 12]
   *
   * See also:
   *
   *    gcd, lcm
   *
   * @param {number | BigNumber} a  An integer number
   * @param {number | BigNumber} b  An integer number
   * @return {Array}              Returns an array containing 3 integers `[div, m, n]`
   *                              where `div = gcd(a, b)` and `a*m + b*n = div`
   */
</span>  var xgcd = typed('xgcd', {
    'number, number': _xgcd,
    'BigNumber, BigNumber': _xgcdBigNumber
    // TODO: implement support for Fraction
  });

  xgcd.toTex = undefined; // use default template

  return xgcd;

  /**
   * Calculate xgcd for two numbers
   * @param {number} a
   * @param {number} b
   * @return {number} result
   * @private
   */
  function _xgcd (a, b) {
    // source: http://en.wikipedia.org/wiki/Extended_Euclidean_algorithm
    var t, // used to swap two variables
        q, // quotient
        r, // remainder
        x = 0, lastx = 1,
        y = 1, lasty = 0;

    if (!isInteger(a) || !isInteger(b)) {
      throw new Error('Parameters in function xgcd must be integer numbers');
    }

    while (b) {
      q = Math.floor(a / b);
      r = a - q*b;

      t = x;
      x = lastx - q * x;
      lastx = t;

      t = y;
      y = lasty - q * y;
      lasty = t;

      a = b;
      b = r;
    }

    var res;
    if (a &lt; 0) {
      res = [-a, -lastx, -lasty];
    }
    else {
      res = [a, a ? lastx : 0, lasty];
    }
    return (config.matrix === 'Array') ? res : matrix(res);
  }

  /**
   * Calculate xgcd for two BigNumbers
   * @param {BigNumber} a
   * @param {BigNumber} b
   * @return {BigNumber[]} result
   * @private
   */
  function _xgcdBigNumber(a, b) {
    // source: http://en.wikipedia.org/wiki/Extended_Euclidean_algorithm
    var t, // used to swap two variables
        q, // quotient
        r, // remainder
        zero = new type.BigNumber(0),
        one = new type.BigNumber(1),
        x = zero,
        lastx = one,
        y = one,
        lasty = zero;

    if (!a.isInt() || !b.isInt()) {
      throw new Error('Parameters in function xgcd must be integer numbers');
    }

    while (!b.isZero()) {
      q = a.div(b).floor();
      r = a.mod(b);

      t = x;
      x = lastx.minus(q.times(x));
      lastx = t;

      t = y;
      y = lasty.minus(q.times(y));
      lasty = t;

      a = b;
      b = r;
    }

    var res;
    if (a.lt(zero)) {
      res = [a.neg(), lastx.neg(), lasty.neg()];
    }
    else {
      res = [a, !a.isZero() ? lastx : 0, lasty];
    }
    return (config.matrix === 'Array') ? res : matrix(res);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.xor" id="apidoc.module.mathjs.xor">module mathjs.xor</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.xor.factory" id="apidoc.element.mathjs.xor.factory">
        function <span class="apidocSignatureSpan">mathjs.xor.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var latex = require('../../utils/latex');

  var matrix = load(require('../../type/matrix/function/matrix'));

  var algorithm03 = load(require('../../type/matrix/utils/algorithm03'));
  var algorithm07 = load(require('../../type/matrix/utils/algorithm07'));
  var algorithm12 = load(require('../../type/matrix/utils/algorithm12'));
  var algorithm13 = load(require('../../type/matrix/utils/algorithm13'));
  var algorithm14 = load(require('../../type/matrix/utils/algorithm14'));

<span class="apidocCodeCommentSpan">  /**
   * Logical `xor`. Test whether one and only one value is defined with a nonzero/nonempty value.
   * For matrices, the function is evaluated element wise.
   *
   * Syntax:
   *
   *    math.xor(x, y)
   *
   * Examples:
   *
   *    math.xor(2, 4);   // returns false
   *
   *    a = [2, 0, 0];
   *    b = [2, 7, 0];
   *    c = 0;
   *
   *    math.xor(a, b);   // returns [false, true, false]
   *    math.xor(a, c);   // returns [true, false, false]
   *
   * See also:
   *
   *    and, not, or
   *
   * @param  {number | BigNumber | Complex | Unit | Array | Matrix} x First value to check
   * @param  {number | BigNumber | Complex | Unit | Array | Matrix} y Second value to check
   * @return {boolean | Array | Matrix}
   *            Returns true when one and only one input is defined with a nonzero/nonempty value.
   */
</span>  var xor = typed('xor', {

    'number, number': function (x, y) {
      return !!(!!x ^ !!y);
    },

    'Complex, Complex': function (x, y) {
      return ((x.re !== 0 || x.im !== 0) !== (y.re !== 0 || y.im !== 0));
    },

    'BigNumber, BigNumber': function (x, y) {
      return ((!x.isZero() &amp;&amp; !x.isNaN()) !== (!y.isZero() &amp;&amp; !y.isNaN()));
    },

    'Unit, Unit': function (x, y) {
      return xor(x.value, y.value);
    },

    'Matrix, Matrix': function (x, y) {
      // result
      var c;

      // process matrix storage
      switch (x.storage()) {
        case 'sparse':
          switch (y.storage()) {
            case 'sparse':
              // sparse + sparse
              c = algorithm07(x, y, xor);
              break;
            default:
              // sparse + dense
              c = algorithm03(y, x, xor, true);
              break;
          }
          break;
        default:
          switch (y.storage()) {
            case 'sparse':
              // dense + sparse
              c = algorithm03(x, y, xor, false);
              break;
            default:
              // dense + dense
              c = algorithm13(x, y, xor);
              break;
          }
          break;
      }
      return c;
    },

    'Array, Array': function (x, y) {
      // use matrix implementation
      return xor(matrix(x), matrix(y)).valueOf();
    },

    'Array, Matrix': function (x, y) {
      // use matrix implementation
      return xor(matrix(x), y);
    },

    'Matrix, Array': function (x, y) {
      // use matrix implementation
      return xor(x, matrix(y));
    },

    'Matrix, any': function (x, y) {
      // result
      var c;
      // check storage format
      switch (x.storage()) {
        case 'sparse':
          c = algorithm12(x, y, xor, false);
          break;
        default:
          c = algorithm14(x, y, xor, false);
          break;
      }
      return c;
    },

    'any, Matrix': function (x, y) {
      // result
      var c;
      // check storage format
      switch (y.storage()) {
        case 'sparse':
          c = algorithm12(y, x, xor, true);
          break;
        default:
          c = algorithm14(y, x, xor, true);
          break;
      }
      return c;
    },

    'Array, any': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(x), y, xor, false).valueOf();
    },

    'any, Array': function (x, y) {
      // use matrix implementation
      return algorithm14(matrix(y), x, xor, true).valueOf();
    }
  });

  xor.toTex = {
    2: '\\left(${args[0]}' + latex.operators['xor'] + '${args[1]}\\right)'
  };

  return xor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mathjs.zeros" id="apidoc.module.mathjs.zeros">module mathjs.zeros</a></h1>


    <h2>
        <a href="#apidoc.element.mathjs.zeros.factory" id="apidoc.element.mathjs.zeros.factory">
        function <span class="apidocSignatureSpan">mathjs.zeros.</span>factory
        <span class="apidocSignatureSpan">(type, config, load, typed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(type, config, load, typed) {
  var matrix = load(require('../../type/matrix/function/matrix'));

<span class="apidocCodeCommentSpan">  /**
   * Create a matrix filled with zeros. The created matrix can have one or
   * multiple dimensions.
   *
   * Syntax:
   *
   *    math.zeros(m)
   *    math.zeros(m, format)
   *    math.zeros(m, n)
   *    math.zeros(m, n, format)
   *    math.zeros([m, n])
   *    math.zeros([m, n], format)
   *
   * Examples:
   *
   *    math.zeros(3);                  // returns [0, 0, 0]
   *    math.zeros(3, 2);               // returns [[0, 0], [0, 0], [0, 0]]
   *    math.zeros(3, 'dense');         // returns [0, 0, 0]
   *
   *    var A = [[1, 2, 3], [4, 5, 6]];
   *    math.zeros(math.size(A));       // returns [[0, 0, 0], [0, 0, 0]]
   *
   * See also:
   *
   *    ones, eye, size, range
   *
   * @param {...number | Array} size    The size of each dimension of the matrix
   * @param {string} [format]           The Matrix storage format
   *
   * @return {Array | Matrix}           A matrix filled with zeros
   */
</span>  var zeros = typed('zeros', {
    '': function () {
      return (config.matrix === 'Array')
          ? _zeros([])
          : _zeros([], 'default');
    },

    // math.zeros(m, n, p, ..., format)
    // TODO: more accurate signature '...number | BigNumber, string' as soon as typed-function supports this
    '...number | BigNumber | string': function (size) {
      var last = size[size.length - 1];
      if (typeof last === 'string') {
        var format = size.pop();
        return _zeros(size, format);
      }
      else if (config.matrix === 'Array') {
        return _zeros(size);
      }
      else {
        return _zeros(size, 'default');
      }
    },

    'Array': _zeros,

    'Matrix': function (size) {
      var format = size.storage();
      return _zeros(size.valueOf(), format);
    },

    'Array | Matrix, string': function (size, format) {
      return _zeros (size.valueOf(), format);
    }
  });

  zeros.toTex = undefined; // use default template

  return zeros;

  /**
   * Create an Array or Matrix with zeros
   * @param {Array} size
   * @param {string} [format='default']
   * @return {Array | Matrix}
   * @private
   */
  function _zeros(size, format) {
    var hasBigNumbers = _normalize(size);
    var defaultValue = hasBigNumbers ? new type.BigNumber(0) : 0;
    _validate(size);

    if (format) {
      // return a matrix
      var m = matrix(format);
      if (size.length &gt; 0) {
        return m.resize(size, defaultValue);
      }
      return m;
    }
    else {
      // return an Array
      var arr = [];
      if (size.length &gt; 0) {
        return resize(arr, size, defaultValue);
      }
      return arr;
    }
  }

  // replace BigNumbers with numbers, returns true if size contained BigNumbers
  function _normalize(size) {
    var hasBigNumbers = false;
    size.forEach(function (value, index, arr) {
      if (value &amp;&amp; value.isBigNumber === true) {
        hasBigNumbers = true;
        arr[index] = value.toNumber();
      }
    });
    return hasBigNumbers;
  }

  // validate arguments
  function _validate (size) {
    size.forEach(function (value) {
      if (typeof value !== 'number' || !isInteger(value) || value &lt; 0) {
        throw new Error('Parameters in function zeros must be positive integers');
      }
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>